
bin/app.elf:     file format elf32-littlearm


Disassembly of section .text:

c0de0000 <main>:
        }
        END_TRY;
    }
}

__attribute__((section(".boot"))) int main(int arg0) {
c0de0000:	b510      	push	{r4, lr}
c0de0002:	4604      	mov	r4, r0
    }
    END_TRY;
    // no return
#else
    // exit critical section
    __asm volatile("cpsie i");
c0de0004:	b662      	cpsie	i

    // ensure exception will work as planned
    os_boot();
c0de0006:	f007 fa09 	bl	c0de741c <os_boot>

    if (!arg0) {
c0de000a:	2c00      	cmp	r4, #0
c0de000c:	d009      	beq.n	c0de0022 <main+0x22>
c0de000e:	2001      	movs	r0, #1
c0de0010:	0200      	lsls	r0, r0, #8
        coin_main(NULL);
        return 0;
    }

    struct libargs_s *args = (struct libargs_s *) arg0;
    if (args->id != 0x100) {
c0de0012:	6821      	ldr	r1, [r4, #0]
c0de0014:	4281      	cmp	r1, r0
c0de0016:	d108      	bne.n	c0de002a <main+0x2a>
        app_exit();
        return 0;
    }
    switch (args->command) {
c0de0018:	6860      	ldr	r0, [r4, #4]
c0de001a:	2801      	cmp	r0, #1
c0de001c:	d109      	bne.n	c0de0032 <main+0x32>
        case RUN_APPLICATION:
            // called as ethereum from altcoin or plugin
            coin_main(args->chain_config);
c0de001e:	68a0      	ldr	r0, [r4, #8]
c0de0020:	e000      	b.n	c0de0024 <main+0x24>
c0de0022:	2000      	movs	r0, #0
c0de0024:	f007 f8c6 	bl	c0de71b4 <coin_main>
c0de0028:	e001      	b.n	c0de002e <main+0x2e>
        app_exit();
c0de002a:	f007 f8a3 	bl	c0de7174 <app_exit>
c0de002e:	2000      	movs	r0, #0
            // called as ethereum or altcoin library
            library_main(args);
    }
#endif
    return 0;
}
c0de0030:	bd10      	pop	{r4, pc}
            library_main(args);
c0de0032:	4620      	mov	r0, r4
c0de0034:	f007 f940 	bl	c0de72b8 <library_main>

c0de0038 <bagl_draw_with_context>:
}
#endif // HAVE_BAGL_GLYPH_ARRAY

// --------------------------------------------------------------------------------------

void bagl_draw_with_context(const bagl_component_t* component, const void* context, unsigned short context_length, unsigned char context_encoding) {
c0de0038:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de003a:	b097      	sub	sp, #92	; 0x5c
c0de003c:	9314      	str	r3, [sp, #80]	; 0x50
c0de003e:	4615      	mov	r5, r2
c0de0040:	460e      	mov	r6, r1
c0de0042:	4604      	mov	r4, r0

idx_ok:
  */

  // strip the flags to match kinds
  unsigned int type = component->type&~(BAGL_TYPE_FLAGS_MASK);
c0de0044:	7801      	ldrb	r1, [r0, #0]
c0de0046:	207f      	movs	r0, #127	; 0x7f
c0de0048:	910d      	str	r1, [sp, #52]	; 0x34
c0de004a:	4008      	ands	r0, r1
c0de004c:	2100      	movs	r1, #0
c0de004e:	9013      	str	r0, [sp, #76]	; 0x4c

  // compute alignment if text provided and requiring special alignment
  if (type != BAGL_ICON) {
c0de0050:	2805      	cmp	r0, #5
c0de0052:	4608      	mov	r0, r1
c0de0054:	460f      	mov	r7, r1
c0de0056:	460a      	mov	r2, r1
c0de0058:	460b      	mov	r3, r1
c0de005a:	9112      	str	r1, [sp, #72]	; 0x48
c0de005c:	950c      	str	r5, [sp, #48]	; 0x30
c0de005e:	9616      	str	r6, [sp, #88]	; 0x58
c0de0060:	d100      	bne.n	c0de0064 <bagl_draw_with_context+0x2c>
c0de0062:	e0a6      	b.n	c0de01b2 <bagl_draw_with_context+0x17a>
    const bagl_font_t* font = bagl_get_font(component->font_id);
c0de0064:	8b20      	ldrh	r0, [r4, #24]
c0de0066:	f000 faad 	bl	c0de05c4 <bagl_get_font>
    if (font) {
c0de006a:	2800      	cmp	r0, #0
c0de006c:	d061      	beq.n	c0de0132 <bagl_draw_with_context+0xfa>
      baseline = font->baseline_height;
      height_to_draw = component->height;
c0de006e:	8927      	ldrh	r7, [r4, #8]
      baseline = font->baseline_height;
c0de0070:	7982      	ldrb	r2, [r0, #6]

      if (context && context_length) {
c0de0072:	2e00      	cmp	r6, #0
c0de0074:	d05a      	beq.n	c0de012c <bagl_draw_with_context+0xf4>
c0de0076:	2d00      	cmp	r5, #0
c0de0078:	d058      	beq.n	c0de012c <bagl_draw_with_context+0xf4>
c0de007a:	9710      	str	r7, [sp, #64]	; 0x40
c0de007c:	920e      	str	r2, [sp, #56]	; 0x38
        // compute with some margin to fit other characters and check if ellipsis algorithm is required
        strwidth = bagl_compute_line_width(component->font_id, component->width+100, context, context_length, context_encoding);
c0de007e:	8b20      	ldrh	r0, [r4, #24]
c0de0080:	88e1      	ldrh	r1, [r4, #6]
c0de0082:	9a14      	ldr	r2, [sp, #80]	; 0x50
c0de0084:	9200      	str	r2, [sp, #0]
c0de0086:	b2eb      	uxtb	r3, r5
c0de0088:	3164      	adds	r1, #100	; 0x64
c0de008a:	b289      	uxth	r1, r1
c0de008c:	4632      	mov	r2, r6
c0de008e:	f000 fabd 	bl	c0de060c <bagl_compute_line_width>
c0de0092:	4607      	mov	r7, r0
        ellipsis_1_len = context_length;

#ifdef HAVE_BAGL_ELLIPSIS
        // ellipsis mode (ensure something is to be splitted!)
        if (strwidth > component->width && context_length>4) {
c0de0094:	88e0      	ldrh	r0, [r4, #6]
c0de0096:	2100      	movs	r1, #0
c0de0098:	2d05      	cmp	r5, #5
c0de009a:	910f      	str	r1, [sp, #60]	; 0x3c
c0de009c:	d350      	bcc.n	c0de0140 <bagl_draw_with_context+0x108>
c0de009e:	4287      	cmp	r7, r0
c0de00a0:	d94e      	bls.n	c0de0140 <bagl_draw_with_context+0x108>
          unsigned int robin = 0; // remove char by char either on the left or right side
          unsigned int dots_len = bagl_compute_line_width(component->font_id, 100 /*probably larger than ... whatever the font*/, "...", 3, context_encoding);
c0de00a2:	8b20      	ldrh	r0, [r4, #24]
c0de00a4:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de00a6:	9100      	str	r1, [sp, #0]
c0de00a8:	2164      	movs	r1, #100	; 0x64
c0de00aa:	4acf      	ldr	r2, [pc, #828]	; (c0de03e8 <bagl_draw_with_context+0x3b0>)
c0de00ac:	447a      	add	r2, pc
c0de00ae:	2303      	movs	r3, #3
c0de00b0:	f000 faac 	bl	c0de060c <bagl_compute_line_width>
c0de00b4:	9011      	str	r0, [sp, #68]	; 0x44
          ellipsis_1_len = context_length/2;
c0de00b6:	086b      	lsrs	r3, r5, #1
          ellipsis_2_start = ((char*)context) + context_length/2;
c0de00b8:	18f2      	adds	r2, r6, r3
          // split line in 2 halves, strip a char from end of left part, and from start of right part, reassemble with ... , repeat until it fits.
          // NOTE: algorithm is wrong if special blank chars are inserted, they should be removed first
          while (strwidth > component->width && ellipsis_1_len && (context_length - ((unsigned int)ellipsis_2_start-(unsigned int)context) )) {
c0de00ba:	88e0      	ldrh	r0, [r4, #6]
c0de00bc:	2100      	movs	r1, #0
c0de00be:	910b      	str	r1, [sp, #44]	; 0x2c
c0de00c0:	9215      	str	r2, [sp, #84]	; 0x54
c0de00c2:	1ab1      	subs	r1, r6, r2
c0de00c4:	194d      	adds	r5, r1, r5
c0de00c6:	9512      	str	r5, [sp, #72]	; 0x48
c0de00c8:	2b00      	cmp	r3, #0
c0de00ca:	d03c      	beq.n	c0de0146 <bagl_draw_with_context+0x10e>
c0de00cc:	b281      	uxth	r1, r0
c0de00ce:	428f      	cmp	r7, r1
c0de00d0:	d939      	bls.n	c0de0146 <bagl_draw_with_context+0x10e>
c0de00d2:	2d00      	cmp	r5, #0
c0de00d4:	d037      	beq.n	c0de0146 <bagl_draw_with_context+0x10e>
            unsigned int left_part = bagl_compute_line_width(component->font_id, component->width, context, ellipsis_1_len, context_encoding);
c0de00d6:	8b20      	ldrh	r0, [r4, #24]
c0de00d8:	9d14      	ldr	r5, [sp, #80]	; 0x50
c0de00da:	9500      	str	r5, [sp, #0]
c0de00dc:	461e      	mov	r6, r3
c0de00de:	b2db      	uxtb	r3, r3
c0de00e0:	9a16      	ldr	r2, [sp, #88]	; 0x58
c0de00e2:	f000 fa93 	bl	c0de060c <bagl_compute_line_width>
c0de00e6:	4607      	mov	r7, r0
            unsigned int right_part = bagl_compute_line_width(component->font_id, component->width, ellipsis_2_start, (context_length - ((unsigned int)ellipsis_2_start-(unsigned int)context) ), context_encoding);
c0de00e8:	88e1      	ldrh	r1, [r4, #6]
c0de00ea:	8b20      	ldrh	r0, [r4, #24]
c0de00ec:	9500      	str	r5, [sp, #0]
c0de00ee:	9d12      	ldr	r5, [sp, #72]	; 0x48
c0de00f0:	b2eb      	uxtb	r3, r5
c0de00f2:	9a15      	ldr	r2, [sp, #84]	; 0x54
c0de00f4:	f000 fa8a 	bl	c0de060c <bagl_compute_line_width>
c0de00f8:	4633      	mov	r3, r6
            // update to check and to compute alignement if needed
            strwidth = left_part + dots_len + right_part;
c0de00fa:	9911      	ldr	r1, [sp, #68]	; 0x44
c0de00fc:	1879      	adds	r1, r7, r1
c0de00fe:	180f      	adds	r7, r1, r0
            // only start to split if the middle char if odd context_length removal is not sufficient
            if (strwidth > component->width) {
c0de0100:	88e0      	ldrh	r0, [r4, #6]
c0de0102:	4287      	cmp	r7, r0
c0de0104:	d9e0      	bls.n	c0de00c8 <bagl_draw_with_context+0x90>
c0de0106:	990b      	ldr	r1, [sp, #44]	; 0x2c
              // either remove a left char, OR remove a right char
              switch(robin) {
c0de0108:	2901      	cmp	r1, #1
c0de010a:	d005      	beq.n	c0de0118 <bagl_draw_with_context+0xe0>
c0de010c:	2900      	cmp	r1, #0
c0de010e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0de0110:	9e16      	ldr	r6, [sp, #88]	; 0x58
c0de0112:	d106      	bne.n	c0de0122 <bagl_draw_with_context+0xea>
                case 0:
                  // remove a left char
                  ellipsis_1_len--;
c0de0114:	1e5b      	subs	r3, r3, #1
c0de0116:	e004      	b.n	c0de0122 <bagl_draw_with_context+0xea>
                  break;
                case 1:
                  // remove a right char
                  ellipsis_2_start++;
c0de0118:	9915      	ldr	r1, [sp, #84]	; 0x54
c0de011a:	1c49      	adds	r1, r1, #1
c0de011c:	9115      	str	r1, [sp, #84]	; 0x54
c0de011e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0de0120:	9e16      	ldr	r6, [sp, #88]	; 0x58
c0de0122:	2101      	movs	r1, #1
                  break;
              }
              robin = (robin+1)%2;
c0de0124:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
c0de0126:	4391      	bics	r1, r2
c0de0128:	9a15      	ldr	r2, [sp, #84]	; 0x54
c0de012a:	e7c8      	b.n	c0de00be <bagl_draw_with_context+0x86>
c0de012c:	2100      	movs	r1, #0
c0de012e:	4608      	mov	r0, r1
c0de0130:	e003      	b.n	c0de013a <bagl_draw_with_context+0x102>
c0de0132:	2100      	movs	r1, #0
c0de0134:	4608      	mov	r0, r1
c0de0136:	460f      	mov	r7, r1
c0de0138:	460a      	mov	r2, r1
c0de013a:	460b      	mov	r3, r1
c0de013c:	9112      	str	r1, [sp, #72]	; 0x48
c0de013e:	e038      	b.n	c0de01b2 <bagl_draw_with_context+0x17a>
c0de0140:	9512      	str	r5, [sp, #72]	; 0x48
c0de0142:	9115      	str	r1, [sp, #84]	; 0x54
c0de0144:	e000      	b.n	c0de0148 <bagl_draw_with_context+0x110>
c0de0146:	9312      	str	r3, [sp, #72]	; 0x48
c0de0148:	2503      	movs	r5, #3
c0de014a:	03ae      	lsls	r6, r5, #14
          }
          // we've computed split positions
        }
#endif // HAVE_BAGL_ELLIPSIS

        switch (component->font_id & BAGL_FONT_ALIGNMENT_HORIZONTAL_MASK ) {
c0de014c:	8b21      	ldrh	r1, [r4, #24]
c0de014e:	400e      	ands	r6, r1
c0de0150:	2201      	movs	r2, #1
c0de0152:	03d3      	lsls	r3, r2, #15
c0de0154:	429e      	cmp	r6, r3
c0de0156:	9511      	str	r5, [sp, #68]	; 0x44
c0de0158:	d009      	beq.n	c0de016e <bagl_draw_with_context+0x136>
c0de015a:	0393      	lsls	r3, r2, #14
c0de015c:	429e      	cmp	r6, r3
c0de015e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0de0160:	461d      	mov	r5, r3
c0de0162:	d10d      	bne.n	c0de0180 <bagl_draw_with_context+0x148>
          default:
          case BAGL_FONT_ALIGNMENT_LEFT:
            halignment = 0;
            break;
          case BAGL_FONT_ALIGNMENT_RIGHT:
            halignment = MAX(0,component->width - strwidth);
c0de0164:	b280      	uxth	r0, r0
c0de0166:	1bc5      	subs	r5, r0, r7
c0de0168:	17e8      	asrs	r0, r5, #31
c0de016a:	4385      	bics	r5, r0
c0de016c:	e008      	b.n	c0de0180 <bagl_draw_with_context+0x148>
          case BAGL_FONT_ALIGNMENT_CENTER:
            // x   xalign      strwidth width
            // '     '            '     '
            //       ^
            // xalign = x+ (width/2) - (strwidth/2) => align -x
            halignment = MAX(0,component->width/2 - strwidth/2);
c0de016e:	0ffb      	lsrs	r3, r7, #31
c0de0170:	18fb      	adds	r3, r7, r3
c0de0172:	105b      	asrs	r3, r3, #1
c0de0174:	b280      	uxth	r0, r0
c0de0176:	0840      	lsrs	r0, r0, #1
c0de0178:	1ac5      	subs	r5, r0, r3
c0de017a:	17e8      	asrs	r0, r5, #31
c0de017c:	4385      	bics	r5, r0
c0de017e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0de0180:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0182:	0300      	lsls	r0, r0, #12
            break;
        }

        switch (component->font_id & BAGL_FONT_ALIGNMENT_VERTICAL_MASK ) {
c0de0184:	4001      	ands	r1, r0
c0de0186:	0350      	lsls	r0, r2, #13
c0de0188:	4281      	cmp	r1, r0
c0de018a:	d006      	beq.n	c0de019a <bagl_draw_with_context+0x162>
c0de018c:	0310      	lsls	r0, r2, #12
c0de018e:	4281      	cmp	r1, r0
c0de0190:	d10b      	bne.n	c0de01aa <bagl_draw_with_context+0x172>
          default:
          case BAGL_FONT_ALIGNMENT_TOP:
            valignment = 0;
            break;
          case BAGL_FONT_ALIGNMENT_BOTTOM:
            valignment = component->height - baseline;
c0de0192:	8920      	ldrh	r0, [r4, #8]
c0de0194:	9a0e      	ldr	r2, [sp, #56]	; 0x38
c0de0196:	1a83      	subs	r3, r0, r2
c0de0198:	e005      	b.n	c0de01a6 <bagl_draw_with_context+0x16e>
c0de019a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
          case BAGL_FONT_ALIGNMENT_MIDDLE:
            // y                 yalign           charheight        height
            // '                    '          v  '                 '
            //                           baseline
            // yalign = y+ (height/2) - (baseline/2) => align - y
            valignment = component->height/2 - baseline/2 - 1;
c0de019c:	0850      	lsrs	r0, r2, #1
c0de019e:	43c0      	mvns	r0, r0
c0de01a0:	8921      	ldrh	r1, [r4, #8]
c0de01a2:	0849      	lsrs	r1, r1, #1
c0de01a4:	180b      	adds	r3, r1, r0
c0de01a6:	9815      	ldr	r0, [sp, #84]	; 0x54
c0de01a8:	e001      	b.n	c0de01ae <bagl_draw_with_context+0x176>
c0de01aa:	9815      	ldr	r0, [sp, #84]	; 0x54
c0de01ac:	9a0e      	ldr	r2, [sp, #56]	; 0x38
c0de01ae:	4629      	mov	r1, r5
c0de01b0:	9f10      	ldr	r7, [sp, #64]	; 0x40
c0de01b2:	9111      	str	r1, [sp, #68]	; 0x44
c0de01b4:	9015      	str	r0, [sp, #84]	; 0x54
c0de01b6:	a80e      	add	r0, sp, #56	; 0x38
c0de01b8:	c08c      	stmia	r0!, {r2, r3, r7}
      }
    }
  }

  unsigned int radius = component->radius;
  radius = MIN(radius, MIN(component->width/2, component->height/2));
c0de01ba:	88e3      	ldrh	r3, [r4, #6]
c0de01bc:	0858      	lsrs	r0, r3, #1
c0de01be:	8927      	ldrh	r7, [r4, #8]
c0de01c0:	0879      	lsrs	r1, r7, #1
c0de01c2:	4288      	cmp	r0, r1
c0de01c4:	4602      	mov	r2, r0
c0de01c6:	d300      	bcc.n	c0de01ca <bagl_draw_with_context+0x192>
c0de01c8:	460a      	mov	r2, r1
  unsigned int radius = component->radius;
c0de01ca:	7ae6      	ldrb	r6, [r4, #11]
  radius = MIN(radius, MIN(component->width/2, component->height/2));
c0de01cc:	42b2      	cmp	r2, r6
c0de01ce:	4632      	mov	r2, r6
c0de01d0:	9d13      	ldr	r5, [sp, #76]	; 0x4c
c0de01d2:	d804      	bhi.n	c0de01de <bagl_draw_with_context+0x1a6>
c0de01d4:	4288      	cmp	r0, r1
c0de01d6:	d201      	bcs.n	c0de01dc <bagl_draw_with_context+0x1a4>
c0de01d8:	4602      	mov	r2, r0
c0de01da:	e000      	b.n	c0de01de <bagl_draw_with_context+0x1a6>
c0de01dc:	460a      	mov	r2, r1

  // Check the type only, ignore the touchable flag
  switch (type) {
c0de01de:	1e68      	subs	r0, r5, #1
c0de01e0:	2804      	cmp	r0, #4
c0de01e2:	d304      	bcc.n	c0de01ee <bagl_draw_with_context+0x1b6>
c0de01e4:	2d06      	cmp	r5, #6
c0de01e6:	d046      	beq.n	c0de0276 <bagl_draw_with_context+0x23e>
c0de01e8:	2d07      	cmp	r5, #7
c0de01ea:	d000      	beq.n	c0de01ee <bagl_draw_with_context+0x1b6>
c0de01ec:	e0fa      	b.n	c0de03e4 <bagl_draw_with_context+0x3ac>
    case BAGL_BUTTON:
    case BAGL_LABEL:
    case BAGL_RECTANGLE:
    case BAGL_LINE:
    case BAGL_LABELINE:
      if((type == BAGL_LINE) && (component->radius == 0)) {
c0de01ee:	2d04      	cmp	r5, #4
c0de01f0:	d10a      	bne.n	c0de0208 <bagl_draw_with_context+0x1d0>
c0de01f2:	2e00      	cmp	r6, #0
c0de01f4:	d108      	bne.n	c0de0208 <bagl_draw_with_context+0x1d0>
c0de01f6:	2004      	movs	r0, #4
        bagl_hal_draw_rect(component->fgcolor,
                           component->x, component->y,
c0de01f8:	5e22      	ldrsh	r2, [r4, r0]
c0de01fa:	2002      	movs	r0, #2
c0de01fc:	5e21      	ldrsh	r1, [r4, r0]
        bagl_hal_draw_rect(component->fgcolor,
c0de01fe:	6920      	ldr	r0, [r4, #16]
c0de0200:	9700      	str	r7, [sp, #0]
c0de0202:	f009 f8e1 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0206:	e0ed      	b.n	c0de03e4 <bagl_draw_with_context+0x3ac>
c0de0208:	980d      	ldr	r0, [sp, #52]	; 0x34
                           component->width, component->height);
        break;
      }

      if ((type == BAGL_LABEL) || (type == BAGL_LABELINE)) {
c0de020a:	2802      	cmp	r0, #2
c0de020c:	d005      	beq.n	c0de021a <bagl_draw_with_context+0x1e2>
c0de020e:	2807      	cmp	r0, #7
c0de0210:	d003      	beq.n	c0de021a <bagl_draw_with_context+0x1e2>
c0de0212:	2887      	cmp	r0, #135	; 0x87
c0de0214:	d001      	beq.n	c0de021a <bagl_draw_with_context+0x1e2>
c0de0216:	2882      	cmp	r0, #130	; 0x82
c0de0218:	d145      	bne.n	c0de02a6 <bagl_draw_with_context+0x26e>
        /*if (component->fill == BAGL_FILL)*/ {
          bagl_hal_draw_rect(component->bgcolor,
                             component->x, component->y-(type==BAGL_LABELINE?(baseline):0),
                             component->width, (type==BAGL_LABELINE? height_to_draw : component->height));
c0de021a:	2d07      	cmp	r5, #7
c0de021c:	d000      	beq.n	c0de0220 <bagl_draw_with_context+0x1e8>
c0de021e:	9710      	str	r7, [sp, #64]	; 0x40
c0de0220:	2002      	movs	r0, #2
                             component->x, component->y-(type==BAGL_LABELINE?(baseline):0),
c0de0222:	5e21      	ldrsh	r1, [r4, r0]
c0de0224:	2004      	movs	r0, #4
c0de0226:	5e22      	ldrsh	r2, [r4, r0]
          bagl_hal_draw_rect(component->bgcolor,
c0de0228:	6960      	ldr	r0, [r4, #20]
c0de022a:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0de022c:	9600      	str	r6, [sp, #0]
                             component->x, component->y-(type==BAGL_LABELINE?(baseline):0),
c0de022e:	2d07      	cmp	r5, #7
c0de0230:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0232:	d101      	bne.n	c0de0238 <bagl_draw_with_context+0x200>
c0de0234:	9e0e      	ldr	r6, [sp, #56]	; 0x38
c0de0236:	1b92      	subs	r2, r2, r6
          bagl_hal_draw_rect(component->bgcolor,
c0de0238:	f009 f8c6 	bl	c0de93c8 <bagl_hal_draw_rect>
                                  radius, BAGL_FILL_CIRCLE_3PI2_2PI, radiusint,
                                  component->bgcolor);
        }
      }

      if (type == BAGL_LINE) {
c0de023c:	2d00      	cmp	r5, #0
c0de023e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
c0de0240:	d100      	bne.n	c0de0244 <bagl_draw_with_context+0x20c>
c0de0242:	e0cf      	b.n	c0de03e4 <bagl_draw_with_context+0x3ac>
c0de0244:	2a04      	cmp	r2, #4
c0de0246:	d100      	bne.n	c0de024a <bagl_draw_with_context+0x212>
c0de0248:	e0cc      	b.n	c0de03e4 <bagl_draw_with_context+0x3ac>
        // No text for this type
        break;
      }

      // Text display
      if (context && context_length) {
c0de024a:	980c      	ldr	r0, [sp, #48]	; 0x30
c0de024c:	2800      	cmp	r0, #0
c0de024e:	d100      	bne.n	c0de0252 <bagl_draw_with_context+0x21a>
c0de0250:	e0c8      	b.n	c0de03e4 <bagl_draw_with_context+0x3ac>
c0de0252:	2002      	movs	r0, #2
        unsigned int pos = 0;
        unsigned int fgcolor = component->fgcolor;
        unsigned int bgcolor = component->bgcolor;

          // Invert colors of text when rectangle/button is filled
        if (   ((type == BAGL_BUTTON) || (type == BAGL_RECTANGLE))
c0de0254:	4302      	orrs	r2, r0
        unsigned int fgcolor = component->fgcolor;
c0de0256:	6923      	ldr	r3, [r4, #16]
        unsigned int bgcolor = component->bgcolor;
c0de0258:	6961      	ldr	r1, [r4, #20]
        if (   ((type == BAGL_BUTTON) || (type == BAGL_RECTANGLE))
c0de025a:	2a03      	cmp	r2, #3
c0de025c:	d154      	bne.n	c0de0308 <bagl_draw_with_context+0x2d0>
            && (component->fill == BAGL_FILL)) {
c0de025e:	7b22      	ldrb	r2, [r4, #12]
        if (   ((type == BAGL_BUTTON) || (type == BAGL_RECTANGLE))
c0de0260:	2a01      	cmp	r2, #1
c0de0262:	461e      	mov	r6, r3
c0de0264:	d000      	beq.n	c0de0268 <bagl_draw_with_context+0x230>
c0de0266:	460e      	mov	r6, r1
c0de0268:	2a01      	cmp	r2, #1
c0de026a:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de026c:	d000      	beq.n	c0de0270 <bagl_draw_with_context+0x238>
c0de026e:	4619      	mov	r1, r3
c0de0270:	960d      	str	r6, [sp, #52]	; 0x34
c0de0272:	9110      	str	r1, [sp, #64]	; 0x40
c0de0274:	e04b      	b.n	c0de030e <bagl_draw_with_context+0x2d6>
c0de0276:	2004      	movs	r0, #4
#endif // HAVE_BAGL_GLYPH_ARRAY

    case BAGL_CIRCLE:
      // draw the circle (all 8 octants)
      bagl_draw_circle_helper(component->fgcolor,
                              component->x+component->radius, component->y+component->radius,
c0de0278:	5e20      	ldrsh	r0, [r4, r0]
c0de027a:	1982      	adds	r2, r0, r6
c0de027c:	2002      	movs	r0, #2
c0de027e:	5e20      	ldrsh	r0, [r4, r0]
c0de0280:	1981      	adds	r1, r0, r6
      bagl_draw_circle_helper(component->fgcolor,
c0de0282:	6920      	ldr	r0, [r4, #16]
                              component->radius, 0xFF,
                              ((component->fill != BAGL_FILL && component->stroke < component->radius)?component->radius-component->stroke:0),
c0de0284:	7b25      	ldrb	r5, [r4, #12]
c0de0286:	2300      	movs	r3, #0
c0de0288:	2d01      	cmp	r5, #1
c0de028a:	d003      	beq.n	c0de0294 <bagl_draw_with_context+0x25c>
c0de028c:	7aa5      	ldrb	r5, [r4, #10]
c0de028e:	42ae      	cmp	r6, r5
c0de0290:	d900      	bls.n	c0de0294 <bagl_draw_with_context+0x25c>
c0de0292:	1b73      	subs	r3, r6, r5
                              component->bgcolor);
c0de0294:	6964      	ldr	r4, [r4, #20]
c0de0296:	25ff      	movs	r5, #255	; 0xff
      bagl_draw_circle_helper(component->fgcolor,
c0de0298:	9500      	str	r5, [sp, #0]
c0de029a:	9301      	str	r3, [sp, #4]
c0de029c:	9402      	str	r4, [sp, #8]
c0de029e:	4633      	mov	r3, r6
c0de02a0:	f000 faf8 	bl	c0de0894 <bagl_draw_circle_helper>
c0de02a4:	e09e      	b.n	c0de03e4 <bagl_draw_with_context+0x3ac>
        if (component->fill != BAGL_FILL) {
c0de02a6:	7b20      	ldrb	r0, [r4, #12]
c0de02a8:	2801      	cmp	r0, #1
c0de02aa:	d000      	beq.n	c0de02ae <bagl_draw_with_context+0x276>
c0de02ac:	e09e      	b.n	c0de03ec <bagl_draw_with_context+0x3b4>
c0de02ae:	2004      	movs	r0, #4
c0de02b0:	900d      	str	r0, [sp, #52]	; 0x34
c0de02b2:	4615      	mov	r5, r2
                             component->x+radius, component->y,
c0de02b4:	5e22      	ldrsh	r2, [r4, r0]
c0de02b6:	2002      	movs	r0, #2
c0de02b8:	900b      	str	r0, [sp, #44]	; 0x2c
c0de02ba:	5e21      	ldrsh	r1, [r4, r0]
          bagl_hal_draw_rect(component->fgcolor,
c0de02bc:	6920      	ldr	r0, [r4, #16]
c0de02be:	9700      	str	r7, [sp, #0]
                             component->x+radius, component->y,
c0de02c0:	1869      	adds	r1, r5, r1
                             component->width-2*radius, component->height);
c0de02c2:	006e      	lsls	r6, r5, #1
c0de02c4:	1b9b      	subs	r3, r3, r6
          bagl_hal_draw_rect(component->fgcolor,
c0de02c6:	4fbc      	ldr	r7, [pc, #752]	; (c0de05b8 <bagl_draw_with_context+0x580>)
c0de02c8:	447f      	add	r7, pc
c0de02ca:	9710      	str	r7, [sp, #64]	; 0x40
c0de02cc:	47b8      	blx	r7
                             component->x, component->y+radius,
c0de02ce:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de02d0:	5e21      	ldrsh	r1, [r4, r0]
c0de02d2:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de02d4:	5e22      	ldrsh	r2, [r4, r0]
                             radius,  component->height-2*radius);
c0de02d6:	8920      	ldrh	r0, [r4, #8]
c0de02d8:	1b83      	subs	r3, r0, r6
          bagl_hal_draw_rect(component->fgcolor,
c0de02da:	6920      	ldr	r0, [r4, #16]
c0de02dc:	9300      	str	r3, [sp, #0]
                             component->x, component->y+radius,
c0de02de:	18aa      	adds	r2, r5, r2
          bagl_hal_draw_rect(component->fgcolor,
c0de02e0:	462b      	mov	r3, r5
c0de02e2:	9f10      	ldr	r7, [sp, #64]	; 0x40
c0de02e4:	47b8      	blx	r7
                             component->x+component->width-radius, component->y+radius,
c0de02e6:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de02e8:	5e21      	ldrsh	r1, [r4, r0]
c0de02ea:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de02ec:	5e22      	ldrsh	r2, [r4, r0]
                             radius, component->height-2*radius);
c0de02ee:	8920      	ldrh	r0, [r4, #8]
c0de02f0:	1b83      	subs	r3, r0, r6
          bagl_hal_draw_rect(component->fgcolor,
c0de02f2:	6920      	ldr	r0, [r4, #16]
                             component->x+component->width-radius, component->y+radius,
c0de02f4:	88e6      	ldrh	r6, [r4, #6]
          bagl_hal_draw_rect(component->fgcolor,
c0de02f6:	9300      	str	r3, [sp, #0]
                             component->x+component->width-radius, component->y+radius,
c0de02f8:	18aa      	adds	r2, r5, r2
c0de02fa:	1b49      	subs	r1, r1, r5
c0de02fc:	1989      	adds	r1, r1, r6
          bagl_hal_draw_rect(component->fgcolor,
c0de02fe:	462b      	mov	r3, r5
c0de0300:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0de0302:	47b0      	blx	r6
c0de0304:	4629      	mov	r1, r5
c0de0306:	e0e4      	b.n	c0de04d2 <bagl_draw_with_context+0x49a>
c0de0308:	9310      	str	r3, [sp, #64]	; 0x40
c0de030a:	910d      	str	r1, [sp, #52]	; 0x34
c0de030c:	9d16      	ldr	r5, [sp, #88]	; 0x58
                               component->x + halignment,
c0de030e:	5e21      	ldrsh	r1, [r4, r0]
c0de0310:	2004      	movs	r0, #4
c0de0312:	900b      	str	r0, [sp, #44]	; 0x2c
                               component->y + ((type==BAGL_LABELINE)?-(baseline):valignment),
c0de0314:	5e22      	ldrsh	r2, [r4, r0]
        pos = bagl_draw_string(component->font_id,
c0de0316:	8b20      	ldrh	r0, [r4, #24]
                               component->width - halignment,
c0de0318:	88e3      	ldrh	r3, [r4, #6]
c0de031a:	4626      	mov	r6, r4
                               component->height - ((type==BAGL_LABELINE)?0:valignment),
c0de031c:	8927      	ldrh	r7, [r4, #8]
        pos = bagl_draw_string(component->font_id,
c0de031e:	9503      	str	r5, [sp, #12]
c0de0320:	9c12      	ldr	r4, [sp, #72]	; 0x48
c0de0322:	9404      	str	r4, [sp, #16]
c0de0324:	9d14      	ldr	r5, [sp, #80]	; 0x50
c0de0326:	9505      	str	r5, [sp, #20]
c0de0328:	9d13      	ldr	r5, [sp, #76]	; 0x4c
                               component->height - ((type==BAGL_LABELINE)?0:valignment),
c0de032a:	2d07      	cmp	r5, #7
c0de032c:	d001      	beq.n	c0de0332 <bagl_draw_with_context+0x2fa>
c0de032e:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
c0de0330:	e000      	b.n	c0de0334 <bagl_draw_with_context+0x2fc>
c0de0332:	2400      	movs	r4, #0
c0de0334:	9412      	str	r4, [sp, #72]	; 0x48
c0de0336:	1b3f      	subs	r7, r7, r4
                               component->width - halignment,
c0de0338:	9c11      	ldr	r4, [sp, #68]	; 0x44
c0de033a:	1b1b      	subs	r3, r3, r4
        pos = bagl_draw_string(component->font_id,
c0de033c:	9301      	str	r3, [sp, #4]
c0de033e:	9702      	str	r7, [sp, #8]
                               component->y + ((type==BAGL_LABELINE)?-(baseline):valignment),
c0de0340:	2d07      	cmp	r5, #7
c0de0342:	4634      	mov	r4, r6
c0de0344:	d001      	beq.n	c0de034a <bagl_draw_with_context+0x312>
c0de0346:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0de0348:	e001      	b.n	c0de034e <bagl_draw_with_context+0x316>
c0de034a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0de034c:	425b      	negs	r3, r3
c0de034e:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0de0350:	9e0d      	ldr	r6, [sp, #52]	; 0x34
c0de0352:	930f      	str	r3, [sp, #60]	; 0x3c
c0de0354:	189a      	adds	r2, r3, r2
        pos = bagl_draw_string(component->font_id,
c0de0356:	9200      	str	r2, [sp, #0]
                               component->x + halignment,
c0de0358:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0de035a:	1853      	adds	r3, r2, r1
        pos = bagl_draw_string(component->font_id,
c0de035c:	4629      	mov	r1, r5
c0de035e:	4632      	mov	r2, r6
c0de0360:	f000 f9a4 	bl	c0de06ac <bagl_draw_string>
        if (ellipsis_2_start) {
c0de0364:	9915      	ldr	r1, [sp, #84]	; 0x54
c0de0366:	2900      	cmp	r1, #0
c0de0368:	d03c      	beq.n	c0de03e4 <bagl_draw_with_context+0x3ac>
c0de036a:	4995      	ldr	r1, [pc, #596]	; (c0de05c0 <bagl_draw_with_context+0x588>)
c0de036c:	4479      	add	r1, pc
c0de036e:	910a      	str	r1, [sp, #40]	; 0x28
c0de0370:	9013      	str	r0, [sp, #76]	; 0x4c
                                 component->y + ((type==BAGL_LABELINE)?-(baseline):valignment),
c0de0372:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de0374:	5e23      	ldrsh	r3, [r4, r0]
          pos = bagl_draw_string(component->font_id,
c0de0376:	8b20      	ldrh	r0, [r4, #24]
                                 component->width - halignment,
c0de0378:	900e      	str	r0, [sp, #56]	; 0x38
c0de037a:	88e7      	ldrh	r7, [r4, #6]
c0de037c:	4629      	mov	r1, r5
c0de037e:	9510      	str	r5, [sp, #64]	; 0x40
c0de0380:	4632      	mov	r2, r6
                                 component->height - (type==BAGL_LABELINE?0:valignment),
c0de0382:	960d      	str	r6, [sp, #52]	; 0x34
c0de0384:	8926      	ldrh	r6, [r4, #8]
c0de0386:	2503      	movs	r5, #3
c0de0388:	9812      	ldr	r0, [sp, #72]	; 0x48
c0de038a:	1a36      	subs	r6, r6, r0
                                 component->width - halignment,
c0de038c:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de038e:	1a3f      	subs	r7, r7, r0
                                 component->y + ((type==BAGL_LABELINE)?-(baseline):valignment),
c0de0390:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0de0392:	18c3      	adds	r3, r0, r3
          pos = bagl_draw_string(component->font_id,
c0de0394:	9300      	str	r3, [sp, #0]
c0de0396:	9701      	str	r7, [sp, #4]
c0de0398:	9602      	str	r6, [sp, #8]
c0de039a:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de039c:	9003      	str	r0, [sp, #12]
c0de039e:	9504      	str	r5, [sp, #16]
c0de03a0:	9e14      	ldr	r6, [sp, #80]	; 0x50
c0de03a2:	9605      	str	r6, [sp, #20]
                                 (pos & 0xFFFF),
c0de03a4:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de03a6:	b283      	uxth	r3, r0
          pos = bagl_draw_string(component->font_id,
c0de03a8:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de03aa:	f000 f97f 	bl	c0de06ac <bagl_draw_string>
c0de03ae:	9013      	str	r0, [sp, #76]	; 0x4c
                                 component->y + ((type==BAGL_LABELINE)?-(baseline):valignment),
c0de03b0:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de03b2:	5e22      	ldrsh	r2, [r4, r0]
          pos = bagl_draw_string(component->font_id,
c0de03b4:	8b20      	ldrh	r0, [r4, #24]
                                 component->width - halignment,
c0de03b6:	88e3      	ldrh	r3, [r4, #6]
                                 component->height - ((type==BAGL_LABELINE)?0:valignment),
c0de03b8:	8924      	ldrh	r4, [r4, #8]
                                 (context_length - ((unsigned int)ellipsis_2_start-(unsigned int)context) ),
c0de03ba:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0de03bc:	9f16      	ldr	r7, [sp, #88]	; 0x58
c0de03be:	19ed      	adds	r5, r5, r7
c0de03c0:	9f15      	ldr	r7, [sp, #84]	; 0x54
c0de03c2:	1bed      	subs	r5, r5, r7
                                 component->height - ((type==BAGL_LABELINE)?0:valignment),
c0de03c4:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de03c6:	1a64      	subs	r4, r4, r1
                                 component->width - halignment,
c0de03c8:	9911      	ldr	r1, [sp, #68]	; 0x44
c0de03ca:	1a5b      	subs	r3, r3, r1
                                 component->y + ((type==BAGL_LABELINE)?-(baseline):valignment),
c0de03cc:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0de03ce:	188a      	adds	r2, r1, r2
          pos = bagl_draw_string(component->font_id,
c0de03d0:	a900      	add	r1, sp, #0
c0de03d2:	c19c      	stmia	r1!, {r2, r3, r4, r7}
c0de03d4:	9504      	str	r5, [sp, #16]
c0de03d6:	9605      	str	r6, [sp, #20]
                                 (pos & 0xFFFF),
c0de03d8:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0de03da:	b28b      	uxth	r3, r1
          pos = bagl_draw_string(component->font_id,
c0de03dc:	9910      	ldr	r1, [sp, #64]	; 0x40
c0de03de:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0de03e0:	f000 f964 	bl	c0de06ac <bagl_draw_string>
      break;

    default:
      break;
  }
}
c0de03e4:	b017      	add	sp, #92	; 0x5c
c0de03e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de03e8:	0000e064 	.word	0x0000e064
c0de03ec:	2004      	movs	r0, #4
c0de03ee:	9009      	str	r0, [sp, #36]	; 0x24
c0de03f0:	9210      	str	r2, [sp, #64]	; 0x40
                             component->x+radius, component->y,
c0de03f2:	5e22      	ldrsh	r2, [r4, r0]
c0de03f4:	2002      	movs	r0, #2
c0de03f6:	5e21      	ldrsh	r1, [r4, r0]
c0de03f8:	4606      	mov	r6, r0
          bagl_hal_draw_rect(component->bgcolor,
c0de03fa:	900d      	str	r0, [sp, #52]	; 0x34
c0de03fc:	6960      	ldr	r0, [r4, #20]
c0de03fe:	9700      	str	r7, [sp, #0]
                             component->x+radius, component->y,
c0de0400:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0de0402:	1869      	adds	r1, r5, r1
                             component->width-2*radius, component->height);
c0de0404:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0de0406:	006d      	lsls	r5, r5, #1
c0de0408:	1b5b      	subs	r3, r3, r5
c0de040a:	462f      	mov	r7, r5
          bagl_hal_draw_rect(component->bgcolor,
c0de040c:	4d69      	ldr	r5, [pc, #420]	; (c0de05b4 <bagl_draw_with_context+0x57c>)
c0de040e:	447d      	add	r5, pc
c0de0410:	950a      	str	r5, [sp, #40]	; 0x28
c0de0412:	47a8      	blx	r5
                             component->x, component->y+radius,
c0de0414:	5fa1      	ldrsh	r1, [r4, r6]
c0de0416:	9d09      	ldr	r5, [sp, #36]	; 0x24
c0de0418:	5f62      	ldrsh	r2, [r4, r5]
                             radius, component->height-2*radius);
c0de041a:	8920      	ldrh	r0, [r4, #8]
c0de041c:	1bc3      	subs	r3, r0, r7
          bagl_hal_draw_rect(component->bgcolor,
c0de041e:	970b      	str	r7, [sp, #44]	; 0x2c
c0de0420:	6960      	ldr	r0, [r4, #20]
c0de0422:	9300      	str	r3, [sp, #0]
                             component->x, component->y+radius,
c0de0424:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0de0426:	189a      	adds	r2, r3, r2
          bagl_hal_draw_rect(component->bgcolor,
c0de0428:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0de042a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
c0de042c:	47b0      	blx	r6
                             component->x+component->width-radius-1, component->y+radius,
c0de042e:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de0430:	5e21      	ldrsh	r1, [r4, r0]
c0de0432:	5f62      	ldrsh	r2, [r4, r5]
                             radius, component->height-2*radius);
c0de0434:	8920      	ldrh	r0, [r4, #8]
c0de0436:	1bc3      	subs	r3, r0, r7
          bagl_hal_draw_rect(component->bgcolor,
c0de0438:	6966      	ldr	r6, [r4, #20]
                             component->x+component->width-radius-1, component->y+radius,
c0de043a:	88e0      	ldrh	r0, [r4, #6]
          bagl_hal_draw_rect(component->bgcolor,
c0de043c:	9300      	str	r3, [sp, #0]
                             component->x+component->width-radius-1, component->y+radius,
c0de043e:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0de0440:	189a      	adds	r2, r3, r2
c0de0442:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0de0444:	43db      	mvns	r3, r3
c0de0446:	18c9      	adds	r1, r1, r3
c0de0448:	1809      	adds	r1, r1, r0
          bagl_hal_draw_rect(component->bgcolor,
c0de044a:	4630      	mov	r0, r6
c0de044c:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0de044e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
c0de0450:	47b0      	blx	r6
                             component->x+radius, component->y,
c0de0452:	5f60      	ldrsh	r0, [r4, r5]
c0de0454:	9008      	str	r0, [sp, #32]
c0de0456:	9f0d      	ldr	r7, [sp, #52]	; 0x34
c0de0458:	5fe1      	ldrsh	r1, [r4, r7]
          bagl_hal_draw_rect(component->fgcolor,
c0de045a:	6922      	ldr	r2, [r4, #16]
                             component->width-2*radius, component->stroke); // top
c0de045c:	88e3      	ldrh	r3, [r4, #6]
c0de045e:	7aa0      	ldrb	r0, [r4, #10]
          bagl_hal_draw_rect(component->fgcolor,
c0de0460:	9000      	str	r0, [sp, #0]
                             component->x+radius, component->y,
c0de0462:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de0464:	1841      	adds	r1, r0, r1
                             component->width-2*radius, component->stroke); // top
c0de0466:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de0468:	1a1b      	subs	r3, r3, r0
          bagl_hal_draw_rect(component->fgcolor,
c0de046a:	4610      	mov	r0, r2
c0de046c:	9a08      	ldr	r2, [sp, #32]
c0de046e:	47b0      	blx	r6
                             component->x+radius, component->y+component->height-1,
c0de0470:	5f60      	ldrsh	r0, [r4, r5]
c0de0472:	9008      	str	r0, [sp, #32]
c0de0474:	463d      	mov	r5, r7
c0de0476:	5fe1      	ldrsh	r1, [r4, r7]
          bagl_hal_draw_rect(component->fgcolor,
c0de0478:	6920      	ldr	r0, [r4, #16]
                             component->x+radius, component->y+component->height-1,
c0de047a:	9007      	str	r0, [sp, #28]
c0de047c:	8922      	ldrh	r2, [r4, #8]
                             component->width-2*radius, component->stroke); // bottom
c0de047e:	88e3      	ldrh	r3, [r4, #6]
c0de0480:	7aa0      	ldrb	r0, [r4, #10]
          bagl_hal_draw_rect(component->fgcolor,
c0de0482:	9000      	str	r0, [sp, #0]
                             component->x+radius, component->y+component->height-1,
c0de0484:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de0486:	1841      	adds	r1, r0, r1
c0de0488:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
                             component->width-2*radius, component->stroke); // bottom
c0de048a:	1bdb      	subs	r3, r3, r7
                             component->x+radius, component->y+component->height-1,
c0de048c:	9808      	ldr	r0, [sp, #32]
c0de048e:	1880      	adds	r0, r0, r2
c0de0490:	1e42      	subs	r2, r0, #1
          bagl_hal_draw_rect(component->fgcolor,
c0de0492:	9807      	ldr	r0, [sp, #28]
c0de0494:	47b0      	blx	r6
                             component->x, component->y+radius,
c0de0496:	5f60      	ldrsh	r0, [r4, r5]
c0de0498:	9008      	str	r0, [sp, #32]
c0de049a:	9d09      	ldr	r5, [sp, #36]	; 0x24
c0de049c:	5f62      	ldrsh	r2, [r4, r5]
                             component->stroke, component->height-2*radius); // left
c0de049e:	8920      	ldrh	r0, [r4, #8]
c0de04a0:	1bc1      	subs	r1, r0, r7
c0de04a2:	7aa3      	ldrb	r3, [r4, #10]
          bagl_hal_draw_rect(component->fgcolor,
c0de04a4:	6920      	ldr	r0, [r4, #16]
c0de04a6:	9100      	str	r1, [sp, #0]
                             component->x, component->y+radius,
c0de04a8:	9910      	ldr	r1, [sp, #64]	; 0x40
c0de04aa:	188a      	adds	r2, r1, r2
          bagl_hal_draw_rect(component->fgcolor,
c0de04ac:	9908      	ldr	r1, [sp, #32]
c0de04ae:	47b0      	blx	r6
                             component->x+component->width-1, component->y+radius,
c0de04b0:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de04b2:	5e21      	ldrsh	r1, [r4, r0]
c0de04b4:	5f62      	ldrsh	r2, [r4, r5]
                             component->stroke, component->height-2*radius); // right
c0de04b6:	8920      	ldrh	r0, [r4, #8]
c0de04b8:	1bc5      	subs	r5, r0, r7
c0de04ba:	7aa7      	ldrb	r7, [r4, #10]
          bagl_hal_draw_rect(component->fgcolor,
c0de04bc:	6923      	ldr	r3, [r4, #16]
                             component->x+component->width-1, component->y+radius,
c0de04be:	88e0      	ldrh	r0, [r4, #6]
          bagl_hal_draw_rect(component->fgcolor,
c0de04c0:	9500      	str	r5, [sp, #0]
                             component->x+component->width-1, component->y+radius,
c0de04c2:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0de04c4:	18aa      	adds	r2, r5, r2
c0de04c6:	1808      	adds	r0, r1, r0
c0de04c8:	1e41      	subs	r1, r0, #1
          bagl_hal_draw_rect(component->fgcolor,
c0de04ca:	4618      	mov	r0, r3
c0de04cc:	463b      	mov	r3, r7
c0de04ce:	47b0      	blx	r6
c0de04d0:	9910      	ldr	r1, [sp, #64]	; 0x40
c0de04d2:	9d16      	ldr	r5, [sp, #88]	; 0x58
        if (radius > 1) {
c0de04d4:	2902      	cmp	r1, #2
c0de04d6:	d200      	bcs.n	c0de04da <bagl_draw_with_context+0x4a2>
c0de04d8:	e6b0      	b.n	c0de023c <bagl_draw_with_context+0x204>
          if ((component->fill != BAGL_FILL) && (component->stroke < radius)) {
c0de04da:	7b20      	ldrb	r0, [r4, #12]
c0de04dc:	2801      	cmp	r0, #1
c0de04de:	d101      	bne.n	c0de04e4 <bagl_draw_with_context+0x4ac>
c0de04e0:	460d      	mov	r5, r1
c0de04e2:	e003      	b.n	c0de04ec <bagl_draw_with_context+0x4b4>
c0de04e4:	7aa0      	ldrb	r0, [r4, #10]
c0de04e6:	460d      	mov	r5, r1
c0de04e8:	1a0f      	subs	r7, r1, r0
c0de04ea:	d200      	bcs.n	c0de04ee <bagl_draw_with_context+0x4b6>
c0de04ec:	2700      	movs	r7, #0
c0de04ee:	2004      	movs	r0, #4
                                  component->y+radius,
c0de04f0:	9010      	str	r0, [sp, #64]	; 0x40
c0de04f2:	5e20      	ldrsh	r0, [r4, r0]
c0de04f4:	900a      	str	r0, [sp, #40]	; 0x28
c0de04f6:	2002      	movs	r0, #2
                                  component->x+radius,
c0de04f8:	900b      	str	r0, [sp, #44]	; 0x2c
c0de04fa:	5e21      	ldrsh	r1, [r4, r0]
          bagl_draw_circle_helper(component->fgcolor,
c0de04fc:	6920      	ldr	r0, [r4, #16]
                                  component->bgcolor);
c0de04fe:	6963      	ldr	r3, [r4, #20]
c0de0500:	22c0      	movs	r2, #192	; 0xc0
          bagl_draw_circle_helper(component->fgcolor,
c0de0502:	9200      	str	r2, [sp, #0]
c0de0504:	9701      	str	r7, [sp, #4]
c0de0506:	9302      	str	r3, [sp, #8]
                                  component->x+radius,
c0de0508:	1869      	adds	r1, r5, r1
                                  component->y+radius,
c0de050a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
c0de050c:	18aa      	adds	r2, r5, r2
          bagl_draw_circle_helper(component->fgcolor,
c0de050e:	4e2b      	ldr	r6, [pc, #172]	; (c0de05bc <bagl_draw_with_context+0x584>)
c0de0510:	447e      	add	r6, pc
c0de0512:	960a      	str	r6, [sp, #40]	; 0x28
c0de0514:	462b      	mov	r3, r5
c0de0516:	47b0      	blx	r6
                                  component->x+component->width-radius-component->stroke,
c0de0518:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de051a:	5e20      	ldrsh	r0, [r4, r0]
                                  component->y+radius,
c0de051c:	9008      	str	r0, [sp, #32]
c0de051e:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de0520:	5e22      	ldrsh	r2, [r4, r0]
          bagl_draw_circle_helper(component->fgcolor,
c0de0522:	6920      	ldr	r0, [r4, #16]
                                  component->bgcolor);
c0de0524:	9009      	str	r0, [sp, #36]	; 0x24
c0de0526:	6963      	ldr	r3, [r4, #20]
                                  component->x+component->width-radius-component->stroke,
c0de0528:	7aa1      	ldrb	r1, [r4, #10]
c0de052a:	88e0      	ldrh	r0, [r4, #6]
c0de052c:	970d      	str	r7, [sp, #52]	; 0x34
c0de052e:	2630      	movs	r6, #48	; 0x30
          bagl_draw_circle_helper(component->fgcolor,
c0de0530:	9600      	str	r6, [sp, #0]
c0de0532:	9701      	str	r7, [sp, #4]
c0de0534:	9302      	str	r3, [sp, #8]
                                  component->y+radius,
c0de0536:	18aa      	adds	r2, r5, r2
                                  component->x+component->width-radius-component->stroke,
c0de0538:	9b08      	ldr	r3, [sp, #32]
c0de053a:	1b5b      	subs	r3, r3, r5
c0de053c:	1818      	adds	r0, r3, r0
c0de053e:	1a41      	subs	r1, r0, r1
          bagl_draw_circle_helper(component->fgcolor,
c0de0540:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de0542:	462b      	mov	r3, r5
c0de0544:	9f0a      	ldr	r7, [sp, #40]	; 0x28
c0de0546:	47b8      	blx	r7
                                  component->y+component->height-radius-component->stroke,
c0de0548:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de054a:	5e20      	ldrsh	r0, [r4, r0]
c0de054c:	9008      	str	r0, [sp, #32]
c0de054e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
                                  component->x+radius,
c0de0550:	5fa1      	ldrsh	r1, [r4, r6]
          bagl_draw_circle_helper(component->fgcolor,
c0de0552:	6920      	ldr	r0, [r4, #16]
                                  component->bgcolor);
c0de0554:	9009      	str	r0, [sp, #36]	; 0x24
c0de0556:	6963      	ldr	r3, [r4, #20]
                                  component->y+component->height-radius-component->stroke,
c0de0558:	7aa0      	ldrb	r0, [r4, #10]
c0de055a:	9007      	str	r0, [sp, #28]
c0de055c:	8920      	ldrh	r0, [r4, #8]
c0de055e:	220c      	movs	r2, #12
          bagl_draw_circle_helper(component->fgcolor,
c0de0560:	9200      	str	r2, [sp, #0]
c0de0562:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0de0564:	9201      	str	r2, [sp, #4]
c0de0566:	9302      	str	r3, [sp, #8]
                                  component->x+radius,
c0de0568:	1869      	adds	r1, r5, r1
                                  component->y+component->height-radius-component->stroke,
c0de056a:	9a08      	ldr	r2, [sp, #32]
c0de056c:	1b52      	subs	r2, r2, r5
c0de056e:	1810      	adds	r0, r2, r0
c0de0570:	9a07      	ldr	r2, [sp, #28]
c0de0572:	1a82      	subs	r2, r0, r2
          bagl_draw_circle_helper(component->fgcolor,
c0de0574:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de0576:	462b      	mov	r3, r5
c0de0578:	47b8      	blx	r7
                                  component->x+component->width-radius-component->stroke,
c0de057a:	5fa0      	ldrsh	r0, [r4, r6]
                                  component->y+component->height-radius-component->stroke,
c0de057c:	900b      	str	r0, [sp, #44]	; 0x2c
c0de057e:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de0580:	5e22      	ldrsh	r2, [r4, r0]
          bagl_draw_circle_helper(component->fgcolor,
c0de0582:	6920      	ldr	r0, [r4, #16]
                                  component->bgcolor);
c0de0584:	9010      	str	r0, [sp, #64]	; 0x40
c0de0586:	6963      	ldr	r3, [r4, #20]
                                  component->x+component->width-radius-component->stroke,
c0de0588:	88e6      	ldrh	r6, [r4, #6]
                                  component->y+component->height-radius-component->stroke,
c0de058a:	8927      	ldrh	r7, [r4, #8]
                                  component->x+component->width-radius-component->stroke,
c0de058c:	7aa0      	ldrb	r0, [r4, #10]
c0de058e:	2103      	movs	r1, #3
          bagl_draw_circle_helper(component->fgcolor,
c0de0590:	9100      	str	r1, [sp, #0]
c0de0592:	990d      	ldr	r1, [sp, #52]	; 0x34
c0de0594:	9101      	str	r1, [sp, #4]
c0de0596:	9302      	str	r3, [sp, #8]
                                  component->y+component->height-radius-component->stroke,
c0de0598:	1829      	adds	r1, r5, r0
c0de059a:	1a51      	subs	r1, r2, r1
c0de059c:	19ca      	adds	r2, r1, r7
                                  component->x+component->width-radius-component->stroke,
c0de059e:	990b      	ldr	r1, [sp, #44]	; 0x2c
c0de05a0:	1b49      	subs	r1, r1, r5
c0de05a2:	1989      	adds	r1, r1, r6
c0de05a4:	1a09      	subs	r1, r1, r0
          bagl_draw_circle_helper(component->fgcolor,
c0de05a6:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de05a8:	462b      	mov	r3, r5
c0de05aa:	9d0a      	ldr	r5, [sp, #40]	; 0x28
c0de05ac:	47a8      	blx	r5
c0de05ae:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de05b0:	e644      	b.n	c0de023c <bagl_draw_with_context+0x204>
c0de05b2:	46c0      	nop			; (mov r8, r8)
c0de05b4:	00008fb7 	.word	0x00008fb7
c0de05b8:	000090fd 	.word	0x000090fd
c0de05bc:	00000381 	.word	0x00000381
c0de05c0:	0000dda4 	.word	0x0000dda4

c0de05c4 <bagl_get_font>:
const bagl_font_t* bagl_get_font(unsigned int font_id) {
c0de05c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de05c6:	4d0e      	ldr	r5, [pc, #56]	; (c0de0600 <bagl_get_font+0x3c>)
  font_id &= BAGL_FONT_ID_MASK;
c0de05c8:	4005      	ands	r5, r0
  unsigned int i=C_bagl_fonts_count; 
c0de05ca:	480e      	ldr	r0, [pc, #56]	; (c0de0604 <bagl_get_font+0x40>)
c0de05cc:	4478      	add	r0, pc
c0de05ce:	6801      	ldr	r1, [r0, #0]
  while(i--) {
c0de05d0:	0088      	lsls	r0, r1, #2
c0de05d2:	4a0d      	ldr	r2, [pc, #52]	; (c0de0608 <bagl_get_font+0x44>)
c0de05d4:	447a      	add	r2, pc
c0de05d6:	1880      	adds	r0, r0, r2
c0de05d8:	1f00      	subs	r0, r0, #4
c0de05da:	1c4e      	adds	r6, r1, #1
c0de05dc:	1e76      	subs	r6, r6, #1
c0de05de:	d00c      	beq.n	c0de05fa <bagl_get_font+0x36>
c0de05e0:	1f07      	subs	r7, r0, #4
    if (PIC_FONT(C_bagl_fonts[i])->font_id == font_id) {
c0de05e2:	6804      	ldr	r4, [r0, #0]
c0de05e4:	4620      	mov	r0, r4
c0de05e6:	f007 fe2d 	bl	c0de8244 <pic>
c0de05ea:	6800      	ldr	r0, [r0, #0]
c0de05ec:	42a8      	cmp	r0, r5
c0de05ee:	4638      	mov	r0, r7
c0de05f0:	d1f4      	bne.n	c0de05dc <bagl_get_font+0x18>
      return PIC_FONT(C_bagl_fonts[i]);
c0de05f2:	4620      	mov	r0, r4
c0de05f4:	f007 fe26 	bl	c0de8244 <pic>
}
c0de05f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de05fa:	2000      	movs	r0, #0
c0de05fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de05fe:	46c0      	nop			; (mov r8, r8)
c0de0600:	00000fff 	.word	0x00000fff
c0de0604:	0000f038 	.word	0x0000f038
c0de0608:	0000f024 	.word	0x0000f024

c0de060c <bagl_compute_line_width>:
unsigned short bagl_compute_line_width(unsigned short font_id, unsigned short width, const void * text, unsigned char text_length, unsigned char text_encoding) {
c0de060c:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de060e:	461c      	mov	r4, r3
c0de0610:	4615      	mov	r5, r2
c0de0612:	9101      	str	r1, [sp, #4]
  const bagl_font_t *font = bagl_get_font(font_id);
c0de0614:	f7ff ffd6 	bl	c0de05c4 <bagl_get_font>
c0de0618:	2200      	movs	r2, #0
  if (font == NULL) {
c0de061a:	2800      	cmp	r0, #0
c0de061c:	d043      	beq.n	c0de06a6 <bagl_compute_line_width+0x9a>
c0de061e:	9b01      	ldr	r3, [sp, #4]
c0de0620:	9002      	str	r0, [sp, #8]
  while (text_length--) {
c0de0622:	0621      	lsls	r1, r4, #24
c0de0624:	d03f      	beq.n	c0de06a6 <bagl_compute_line_width+0x9a>
    if (ch < font->first_char || ch > font->last_char) {
c0de0626:	8906      	ldrh	r6, [r0, #8]
        ch = *((unsigned char*)text);
c0de0628:	782f      	ldrb	r7, [r5, #0]
    if (ch < font->first_char || ch > font->last_char) {
c0de062a:	42b7      	cmp	r7, r6
c0de062c:	d302      	bcc.n	c0de0634 <bagl_compute_line_width+0x28>
c0de062e:	8941      	ldrh	r1, [r0, #10]
c0de0630:	42b9      	cmp	r1, r7
c0de0632:	d213      	bcs.n	c0de065c <bagl_compute_line_width+0x50>
      if (ch == '\n' || ch == '\r') {
c0de0634:	2f0a      	cmp	r7, #10
c0de0636:	d036      	beq.n	c0de06a6 <bagl_compute_line_width+0x9a>
c0de0638:	2f0d      	cmp	r7, #13
c0de063a:	d034      	beq.n	c0de06a6 <bagl_compute_line_width+0x9a>
      if (ch >= 0xC0) {
c0de063c:	09b8      	lsrs	r0, r7, #6
c0de063e:	2803      	cmp	r0, #3
c0de0640:	d303      	bcc.n	c0de064a <bagl_compute_line_width+0x3e>
c0de0642:	203f      	movs	r0, #63	; 0x3f
        ch_width = ch&0x3F;
c0de0644:	4007      	ands	r7, r0
c0de0646:	463e      	mov	r6, r7
c0de0648:	e022      	b.n	c0de0690 <bagl_compute_line_width+0x84>
      else if (ch >= 0x80) {
c0de064a:	b278      	sxtb	r0, r7
c0de064c:	2600      	movs	r6, #0
c0de064e:	2800      	cmp	r0, #0
c0de0650:	d51e      	bpl.n	c0de0690 <bagl_compute_line_width+0x84>
        const bagl_font_t *font_symbols = bagl_get_font((ch&0x20)?BAGL_FONT_SYMBOLS_1:BAGL_FONT_SYMBOLS_0);
c0de0652:	06b8      	lsls	r0, r7, #26
c0de0654:	9200      	str	r2, [sp, #0]
c0de0656:	d50b      	bpl.n	c0de0670 <bagl_compute_line_width+0x64>
c0de0658:	200f      	movs	r0, #15
c0de065a:	e00a      	b.n	c0de0672 <bagl_compute_line_width+0x66>
      ch -= font->first_char;
c0de065c:	1bb9      	subs	r1, r7, r6
      ch_width = PIC_CHAR(font->characters)[ch].char_width;
c0de065e:	008e      	lsls	r6, r1, #2
c0de0660:	68c0      	ldr	r0, [r0, #12]
c0de0662:	4617      	mov	r7, r2
c0de0664:	f007 fdee 	bl	c0de8244 <pic>
c0de0668:	9b01      	ldr	r3, [sp, #4]
c0de066a:	463a      	mov	r2, r7
c0de066c:	5d86      	ldrb	r6, [r0, r6]
c0de066e:	e00f      	b.n	c0de0690 <bagl_compute_line_width+0x84>
c0de0670:	200e      	movs	r0, #14
        const bagl_font_t *font_symbols = bagl_get_font((ch&0x20)?BAGL_FONT_SYMBOLS_1:BAGL_FONT_SYMBOLS_0);
c0de0672:	f7ff ffa7 	bl	c0de05c4 <bagl_get_font>
        if (font_symbols != NULL) {
c0de0676:	2800      	cmp	r0, #0
c0de0678:	9a00      	ldr	r2, [sp, #0]
c0de067a:	9b01      	ldr	r3, [sp, #4]
c0de067c:	d008      	beq.n	c0de0690 <bagl_compute_line_width+0x84>
          ch_width = PIC_CHAR(font_symbols->characters)[ch & 0x1F].char_width;
c0de067e:	68c0      	ldr	r0, [r0, #12]
c0de0680:	4616      	mov	r6, r2
c0de0682:	f007 fddf 	bl	c0de8244 <pic>
c0de0686:	9b01      	ldr	r3, [sp, #4]
c0de0688:	4632      	mov	r2, r6
c0de068a:	06f9      	lsls	r1, r7, #27
c0de068c:	0e49      	lsrs	r1, r1, #25
c0de068e:	5c46      	ldrb	r6, [r0, r1]
    if (width > 0 && xx + ch_width > width) {
c0de0690:	2b00      	cmp	r3, #0
c0de0692:	d003      	beq.n	c0de069c <bagl_compute_line_width+0x90>
c0de0694:	b290      	uxth	r0, r2
c0de0696:	1830      	adds	r0, r6, r0
c0de0698:	4298      	cmp	r0, r3
c0de069a:	d804      	bhi.n	c0de06a6 <bagl_compute_line_width+0x9a>
c0de069c:	1e64      	subs	r4, r4, #1
c0de069e:	1c6d      	adds	r5, r5, #1
    xx += ch_width;
c0de06a0:	1992      	adds	r2, r2, r6
c0de06a2:	9802      	ldr	r0, [sp, #8]
c0de06a4:	e7bd      	b.n	c0de0622 <bagl_compute_line_width+0x16>
}
c0de06a6:	b290      	uxth	r0, r2
c0de06a8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de06aa:	d4d4      	bmi.n	c0de0656 <bagl_compute_line_width+0x4a>

c0de06ac <bagl_draw_string>:
int bagl_draw_string(unsigned short font_id, unsigned int fgcolor, unsigned int bgcolor, int x, int y, unsigned int width, unsigned int height, const void* text, unsigned int text_length, unsigned char text_encoding) {
c0de06ac:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de06ae:	b0a3      	sub	sp, #140	; 0x8c
c0de06b0:	461c      	mov	r4, r3
c0de06b2:	4615      	mov	r5, r2
  colors[1] = fgcolor;
c0de06b4:	9114      	str	r1, [sp, #80]	; 0x50
  colors[0] = bgcolor;
c0de06b6:	9213      	str	r2, [sp, #76]	; 0x4c
  const bagl_font_t *font = bagl_get_font(font_id);
c0de06b8:	f7ff ff84 	bl	c0de05c4 <bagl_get_font>
  if (font == NULL) {
c0de06bc:	2800      	cmp	r0, #0
c0de06be:	d100      	bne.n	c0de06c2 <bagl_draw_string+0x16>
c0de06c0:	e0dc      	b.n	c0de087c <bagl_draw_string+0x1d0>
c0de06c2:	4603      	mov	r3, r0
c0de06c4:	950a      	str	r5, [sp, #40]	; 0x28
c0de06c6:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
c0de06c8:	982b      	ldr	r0, [sp, #172]	; 0xac
c0de06ca:	992a      	ldr	r1, [sp, #168]	; 0xa8
c0de06cc:	9a29      	ldr	r2, [sp, #164]	; 0xa4
c0de06ce:	9e28      	ldr	r6, [sp, #160]	; 0xa0
c0de06d0:	9612      	str	r6, [sp, #72]	; 0x48
  height += y;
c0de06d2:	1989      	adds	r1, r1, r6
  width += x;
c0de06d4:	910e      	str	r1, [sp, #56]	; 0x38
c0de06d6:	1911      	adds	r1, r2, r4
c0de06d8:	910c      	str	r1, [sp, #48]	; 0x30
c0de06da:	2700      	movs	r7, #0
c0de06dc:	43fa      	mvns	r2, r7
c0de06de:	940d      	str	r4, [sp, #52]	; 0x34
c0de06e0:	4621      	mov	r1, r4
  while (text_length--) {
c0de06e2:	4355      	muls	r5, r2
c0de06e4:	1c6d      	adds	r5, r5, #1
c0de06e6:	2d01      	cmp	r5, #1
c0de06e8:	d100      	bne.n	c0de06ec <bagl_draw_string+0x40>
c0de06ea:	e0c2      	b.n	c0de0872 <bagl_draw_string+0x1c6>
c0de06ec:	1c44      	adds	r4, r0, #1
c0de06ee:	7806      	ldrb	r6, [r0, #0]
        if (ch == '\r') {
c0de06f0:	2f0d      	cmp	r7, #13
c0de06f2:	d103      	bne.n	c0de06fc <bagl_draw_string+0x50>
c0de06f4:	270a      	movs	r7, #10
c0de06f6:	2e0a      	cmp	r6, #10
c0de06f8:	4620      	mov	r0, r4
c0de06fa:	d0f3      	beq.n	c0de06e4 <bagl_draw_string+0x38>
    if (ch < font->first_char || ch > font->last_char) {
c0de06fc:	4355      	muls	r5, r2
c0de06fe:	8918      	ldrh	r0, [r3, #8]
    unsigned char ch_height = font->char_height;
c0de0700:	795f      	ldrb	r7, [r3, #5]
    if (ch < font->first_char || ch > font->last_char) {
c0de0702:	9710      	str	r7, [sp, #64]	; 0x40
c0de0704:	4286      	cmp	r6, r0
          ch_bitmap = &PIC_BMP(font_symbols->bitmap)[PIC_CHAR(font_symbols->characters)[ch & 0x1F].bitmap_offset];
c0de0706:	4f62      	ldr	r7, [pc, #392]	; (c0de0890 <bagl_draw_string+0x1e4>)
c0de0708:	447f      	add	r7, pc
c0de070a:	970b      	str	r7, [sp, #44]	; 0x2c
c0de070c:	9111      	str	r1, [sp, #68]	; 0x44
    if (ch < font->first_char || ch > font->last_char) {
c0de070e:	d302      	bcc.n	c0de0716 <bagl_draw_string+0x6a>
c0de0710:	8959      	ldrh	r1, [r3, #10]
c0de0712:	42b1      	cmp	r1, r6
c0de0714:	d20f      	bcs.n	c0de0736 <bagl_draw_string+0x8a>
      if (ch == '\n' || ch == '\r') {
c0de0716:	2e0d      	cmp	r6, #13
c0de0718:	d001      	beq.n	c0de071e <bagl_draw_string+0x72>
c0de071a:	2e0a      	cmp	r6, #10
c0de071c:	d125      	bne.n	c0de076a <bagl_draw_string+0xbe>
c0de071e:	9812      	ldr	r0, [sp, #72]	; 0x48
c0de0720:	9910      	ldr	r1, [sp, #64]	; 0x40
        y += ch_height; // no interleave
c0de0722:	1840      	adds	r0, r0, r1
c0de0724:	9012      	str	r0, [sp, #72]	; 0x48
        if (y + ch_height > (int)height) {
c0de0726:	1840      	adds	r0, r0, r1
c0de0728:	990e      	ldr	r1, [sp, #56]	; 0x38
c0de072a:	4288      	cmp	r0, r1
c0de072c:	4620      	mov	r0, r4
c0de072e:	990d      	ldr	r1, [sp, #52]	; 0x34
c0de0730:	4637      	mov	r7, r6
c0de0732:	ddd6      	ble.n	c0de06e2 <bagl_draw_string+0x36>
c0de0734:	e0a5      	b.n	c0de0882 <bagl_draw_string+0x1d6>
c0de0736:	9209      	str	r2, [sp, #36]	; 0x24
      ch -= font->first_char;
c0de0738:	1a37      	subs	r7, r6, r0
      ch_bitmap = &PIC_BMP(font->bitmap)[PIC_CHAR(font->characters)[ch].bitmap_offset];
c0de073a:	6918      	ldr	r0, [r3, #16]
c0de073c:	930f      	str	r3, [sp, #60]	; 0x3c
c0de073e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
c0de0740:	47b0      	blx	r6
c0de0742:	9008      	str	r0, [sp, #32]
c0de0744:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0de0746:	68c0      	ldr	r0, [r0, #12]
c0de0748:	47b0      	blx	r6
c0de074a:	00b9      	lsls	r1, r7, #2
c0de074c:	9106      	str	r1, [sp, #24]
c0de074e:	1840      	adds	r0, r0, r1
c0de0750:	8840      	ldrh	r0, [r0, #2]
c0de0752:	9908      	ldr	r1, [sp, #32]
c0de0754:	1808      	adds	r0, r1, r0
      ch_width = PIC_CHAR(font->characters)[ch].char_width;
c0de0756:	9007      	str	r0, [sp, #28]
c0de0758:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0de075a:	68c0      	ldr	r0, [r0, #12]
c0de075c:	47b0      	blx	r6
c0de075e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0de0760:	9906      	ldr	r1, [sp, #24]
c0de0762:	5c46      	ldrb	r6, [r0, r1]
      ch_kerning = font->char_kerning;
c0de0764:	79d8      	ldrb	r0, [r3, #7]
c0de0766:	9008      	str	r0, [sp, #32]
c0de0768:	e010      	b.n	c0de078c <bagl_draw_string+0xe0>
      if (ch >= 0xC0) {
c0de076a:	2ec0      	cmp	r6, #192	; 0xc0
c0de076c:	9209      	str	r2, [sp, #36]	; 0x24
c0de076e:	d305      	bcc.n	c0de077c <bagl_draw_string+0xd0>
c0de0770:	213f      	movs	r1, #63	; 0x3f
        ch_width = ch & 0x3F;
c0de0772:	4031      	ands	r1, r6
c0de0774:	2000      	movs	r0, #0
c0de0776:	4637      	mov	r7, r6
c0de0778:	460e      	mov	r6, r1
c0de077a:	e005      	b.n	c0de0788 <bagl_draw_string+0xdc>
c0de077c:	b270      	sxtb	r0, r6
      else if (ch >= 0x80) {
c0de077e:	2800      	cmp	r0, #0
c0de0780:	d43f      	bmi.n	c0de0802 <bagl_draw_string+0x156>
c0de0782:	2000      	movs	r0, #0
c0de0784:	4637      	mov	r7, r6
c0de0786:	4606      	mov	r6, r0
c0de0788:	9008      	str	r0, [sp, #32]
c0de078a:	9007      	str	r0, [sp, #28]
c0de078c:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de078e:	460a      	mov	r2, r1
    if (xx + ch_width > (int)width) {
c0de0790:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0792:	960b      	str	r6, [sp, #44]	; 0x2c
c0de0794:	1980      	adds	r0, r0, r6
c0de0796:	9e0c      	ldr	r6, [sp, #48]	; 0x30
c0de0798:	42b0      	cmp	r0, r6
c0de079a:	dd08      	ble.n	c0de07ae <bagl_draw_string+0x102>
c0de079c:	9810      	ldr	r0, [sp, #64]	; 0x40
      y += ch_height; // no interleave
c0de079e:	1809      	adds	r1, r1, r0
      if (y + ch_height > (int)height) {
c0de07a0:	1808      	adds	r0, r1, r0
c0de07a2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
c0de07a4:	4290      	cmp	r0, r2
c0de07a6:	dc6f      	bgt.n	c0de0888 <bagl_draw_string+0x1dc>
c0de07a8:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de07aa:	9011      	str	r0, [sp, #68]	; 0x44
c0de07ac:	460a      	mov	r2, r1
c0de07ae:	9112      	str	r1, [sp, #72]	; 0x48
c0de07b0:	9807      	ldr	r0, [sp, #28]
    if (ch_bitmap) {
c0de07b2:	2800      	cmp	r0, #0
c0de07b4:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
c0de07b6:	930f      	str	r3, [sp, #60]	; 0x3c
c0de07b8:	d014      	beq.n	c0de07e4 <bagl_draw_string+0x138>
c0de07ba:	9206      	str	r2, [sp, #24]
c0de07bc:	4602      	mov	r2, r0
      bagl_hal_draw_bitmap_within_rect(xx, ch_y, ch_width, ch_height, (1<<font->bpp), colors, font->bpp, ch_bitmap, font->bpp*ch_width*ch_height); // note, last parameter is computable could be avoided
c0de07be:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de07c0:	4370      	muls	r0, r6
c0de07c2:	7919      	ldrb	r1, [r3, #4]
c0de07c4:	4348      	muls	r0, r1
c0de07c6:	9004      	str	r0, [sp, #16]
c0de07c8:	9203      	str	r2, [sp, #12]
c0de07ca:	9102      	str	r1, [sp, #8]
c0de07cc:	a813      	add	r0, sp, #76	; 0x4c
c0de07ce:	9001      	str	r0, [sp, #4]
c0de07d0:	2001      	movs	r0, #1
c0de07d2:	4088      	lsls	r0, r1
c0de07d4:	9000      	str	r0, [sp, #0]
c0de07d6:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de07d8:	9906      	ldr	r1, [sp, #24]
c0de07da:	4632      	mov	r2, r6
c0de07dc:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0de07de:	f008 fddb 	bl	c0de9398 <bagl_hal_draw_bitmap_within_rect>
c0de07e2:	e006      	b.n	c0de07f2 <bagl_draw_string+0x146>
      bagl_hal_draw_rect(bgcolor, xx, ch_y, ch_width, ch_height);
c0de07e4:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de07e6:	9000      	str	r0, [sp, #0]
c0de07e8:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de07ea:	9911      	ldr	r1, [sp, #68]	; 0x44
c0de07ec:	4633      	mov	r3, r6
c0de07ee:	f008 fdeb 	bl	c0de93c8 <bagl_hal_draw_rect>
    xx += ch_width + ch_kerning;
c0de07f2:	9808      	ldr	r0, [sp, #32]
c0de07f4:	1830      	adds	r0, r6, r0
c0de07f6:	9911      	ldr	r1, [sp, #68]	; 0x44
c0de07f8:	1841      	adds	r1, r0, r1
c0de07fa:	4620      	mov	r0, r4
c0de07fc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0de07fe:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0de0800:	e76f      	b.n	c0de06e2 <bagl_draw_string+0x36>
        const bagl_font_t *font_symbols = bagl_get_font((ch&0x20)?BAGL_FONT_SYMBOLS_1:BAGL_FONT_SYMBOLS_0);
c0de0802:	06b0      	lsls	r0, r6, #26
c0de0804:	930f      	str	r3, [sp, #60]	; 0x3c
c0de0806:	d501      	bpl.n	c0de080c <bagl_draw_string+0x160>
c0de0808:	200f      	movs	r0, #15
c0de080a:	e000      	b.n	c0de080e <bagl_draw_string+0x162>
c0de080c:	200e      	movs	r0, #14
c0de080e:	f7ff fed9 	bl	c0de05c4 <bagl_get_font>
        if (font_symbols != NULL) {
c0de0812:	2800      	cmp	r0, #0
c0de0814:	d024      	beq.n	c0de0860 <bagl_draw_string+0x1b4>
          ch_bitmap = &PIC_BMP(font_symbols->bitmap)[PIC_CHAR(font_symbols->characters)[ch & 0x1F].bitmap_offset];
c0de0816:	9008      	str	r0, [sp, #32]
c0de0818:	6900      	ldr	r0, [r0, #16]
c0de081a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
c0de081c:	47b8      	blx	r7
c0de081e:	9010      	str	r0, [sp, #64]	; 0x40
c0de0820:	9808      	ldr	r0, [sp, #32]
c0de0822:	68c0      	ldr	r0, [r0, #12]
c0de0824:	47b8      	blx	r7
c0de0826:	463a      	mov	r2, r7
c0de0828:	06f1      	lsls	r1, r6, #27
c0de082a:	0e49      	lsrs	r1, r1, #25
c0de082c:	9106      	str	r1, [sp, #24]
c0de082e:	1840      	adds	r0, r0, r1
c0de0830:	8840      	ldrh	r0, [r0, #2]
c0de0832:	9910      	ldr	r1, [sp, #64]	; 0x40
c0de0834:	1808      	adds	r0, r1, r0
          ch_width = PIC_CHAR(font_symbols->characters)[ch & 0x1F].char_width;
c0de0836:	9007      	str	r0, [sp, #28]
c0de0838:	9f08      	ldr	r7, [sp, #32]
c0de083a:	68f8      	ldr	r0, [r7, #12]
c0de083c:	4790      	blx	r2
c0de083e:	9906      	ldr	r1, [sp, #24]
c0de0840:	5c40      	ldrb	r0, [r0, r1]
c0de0842:	900b      	str	r0, [sp, #44]	; 0x2c
c0de0844:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
          ch_y = y + font->baseline_height - font_symbols->baseline_height;
c0de0846:	7998      	ldrb	r0, [r3, #6]
c0de0848:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de084a:	1808      	adds	r0, r1, r0
c0de084c:	79b9      	ldrb	r1, [r7, #6]
c0de084e:	1a42      	subs	r2, r0, r1
          ch_height = font_symbols->char_height;
c0de0850:	7978      	ldrb	r0, [r7, #5]
c0de0852:	9010      	str	r0, [sp, #64]	; 0x40
c0de0854:	2000      	movs	r0, #0
c0de0856:	9008      	str	r0, [sp, #32]
c0de0858:	4637      	mov	r7, r6
c0de085a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
c0de085c:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de085e:	e797      	b.n	c0de0790 <bagl_draw_string+0xe4>
c0de0860:	2000      	movs	r0, #0
c0de0862:	4637      	mov	r7, r6
c0de0864:	4606      	mov	r6, r0
c0de0866:	9008      	str	r0, [sp, #32]
c0de0868:	9007      	str	r0, [sp, #28]
c0de086a:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de086c:	460a      	mov	r2, r1
c0de086e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0de0870:	e78e      	b.n	c0de0790 <bagl_draw_string+0xe4>
  return (y<<16)|(xx&0xFFFF);
c0de0872:	b288      	uxth	r0, r1
c0de0874:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de0876:	0409      	lsls	r1, r1, #16
c0de0878:	1808      	adds	r0, r1, r0
c0de087a:	e000      	b.n	c0de087e <bagl_draw_string+0x1d2>
c0de087c:	2000      	movs	r0, #0
}
c0de087e:	b023      	add	sp, #140	; 0x8c
c0de0880:	bdf0      	pop	{r4, r5, r6, r7, pc}
          return (y<<16)|(xx&0xFFFF);
c0de0882:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0884:	b280      	uxth	r0, r0
c0de0886:	e7f5      	b.n	c0de0874 <bagl_draw_string+0x1c8>
        return (y<<16)|(xx&0xFFFF);
c0de0888:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de088a:	b280      	uxth	r0, r0
c0de088c:	e7f3      	b.n	c0de0876 <bagl_draw_string+0x1ca>
c0de088e:	46c0      	nop			; (mov r8, r8)
c0de0890:	00007b39 	.word	0x00007b39

c0de0894 <bagl_draw_circle_helper>:
void bagl_draw_circle_helper(unsigned int color, int x_center, int y_center, unsigned int radius, unsigned char octants, unsigned int radiusint, unsigned int colorint) {
c0de0894:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0896:	b09b      	sub	sp, #108	; 0x6c
c0de0898:	9218      	str	r2, [sp, #96]	; 0x60
c0de089a:	9117      	str	r1, [sp, #92]	; 0x5c
c0de089c:	4607      	mov	r7, r0
c0de089e:	9821      	ldr	r0, [sp, #132]	; 0x84
  unsigned int drawint = (radiusint > 0 && dradius > 0 /*&& xint <= yint*/);
c0de08a0:	1e41      	subs	r1, r0, #1
c0de08a2:	4602      	mov	r2, r0
c0de08a4:	418a      	sbcs	r2, r1
c0de08a6:	9219      	str	r2, [sp, #100]	; 0x64
  int dradius = radius-radiusint;
c0de08a8:	1a1a      	subs	r2, r3, r0
c0de08aa:	2101      	movs	r1, #1
c0de08ac:	2600      	movs	r6, #0
c0de08ae:	9214      	str	r2, [sp, #80]	; 0x50
  unsigned int drawint = (radiusint > 0 && dradius > 0 /*&& xint <= yint*/);
c0de08b0:	2a00      	cmp	r2, #0
c0de08b2:	460a      	mov	r2, r1
c0de08b4:	dc00      	bgt.n	c0de08b8 <bagl_draw_circle_helper+0x24>
c0de08b6:	4632      	mov	r2, r6
c0de08b8:	9c19      	ldr	r4, [sp, #100]	; 0x64
c0de08ba:	4014      	ands	r4, r2
c0de08bc:	9419      	str	r4, [sp, #100]	; 0x64
c0de08be:	2280      	movs	r2, #128	; 0x80
c0de08c0:	9c20      	ldr	r4, [sp, #128]	; 0x80
c0de08c2:	4022      	ands	r2, r4
c0de08c4:	9210      	str	r2, [sp, #64]	; 0x40
c0de08c6:	2240      	movs	r2, #64	; 0x40
c0de08c8:	4022      	ands	r2, r4
c0de08ca:	920e      	str	r2, [sp, #56]	; 0x38
c0de08cc:	2220      	movs	r2, #32
c0de08ce:	4022      	ands	r2, r4
c0de08d0:	920d      	str	r2, [sp, #52]	; 0x34
c0de08d2:	2210      	movs	r2, #16
c0de08d4:	4022      	ands	r2, r4
c0de08d6:	920c      	str	r2, [sp, #48]	; 0x30
c0de08d8:	2208      	movs	r2, #8
c0de08da:	4022      	ands	r2, r4
c0de08dc:	920b      	str	r2, [sp, #44]	; 0x2c
c0de08de:	2204      	movs	r2, #4
c0de08e0:	4022      	ands	r2, r4
c0de08e2:	920a      	str	r2, [sp, #40]	; 0x28
c0de08e4:	2202      	movs	r2, #2
c0de08e6:	4022      	ands	r2, r4
c0de08e8:	9209      	str	r2, [sp, #36]	; 0x24
c0de08ea:	400c      	ands	r4, r1
c0de08ec:	940f      	str	r4, [sp, #60]	; 0x3c
  int decisionOver2 = 1 - x;   // Decision criterion divided by 2 evaluated at x=r, y=0
c0de08ee:	1acd      	subs	r5, r1, r3
c0de08f0:	9a14      	ldr	r2, [sp, #80]	; 0x50
c0de08f2:	1a89      	subs	r1, r1, r2
  while( y <= x )
c0de08f4:	9105      	str	r1, [sp, #20]
c0de08f6:	1ac0      	subs	r0, r0, r3
c0de08f8:	1c40      	adds	r0, r0, #1
c0de08fa:	9003      	str	r0, [sp, #12]
c0de08fc:	1e50      	subs	r0, r2, #1
c0de08fe:	9007      	str	r0, [sp, #28]
c0de0900:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de0902:	1a80      	subs	r0, r0, r2
c0de0904:	1c40      	adds	r0, r0, #1
c0de0906:	9006      	str	r0, [sp, #24]
c0de0908:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de090a:	1e40      	subs	r0, r0, #1
c0de090c:	9004      	str	r0, [sp, #16]
c0de090e:	2003      	movs	r0, #3
c0de0910:	9922      	ldr	r1, [sp, #136]	; 0x88
c0de0912:	9111      	str	r1, [sp, #68]	; 0x44
c0de0914:	4632      	mov	r2, r6
c0de0916:	9313      	str	r3, [sp, #76]	; 0x4c
c0de0918:	9708      	str	r7, [sp, #32]
c0de091a:	429a      	cmp	r2, r3
c0de091c:	dd00      	ble.n	c0de0920 <bagl_draw_circle_helper+0x8c>
c0de091e:	e166      	b.n	c0de0bee <bagl_draw_circle_helper+0x35a>
c0de0920:	461c      	mov	r4, r3
c0de0922:	9012      	str	r0, [sp, #72]	; 0x48
    if (octants & 1) { // 
c0de0924:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0de0926:	2800      	cmp	r0, #0
c0de0928:	9615      	str	r6, [sp, #84]	; 0x54
c0de092a:	9516      	str	r5, [sp, #88]	; 0x58
c0de092c:	921a      	str	r2, [sp, #104]	; 0x68
c0de092e:	d024      	beq.n	c0de097a <bagl_draw_circle_helper+0xe6>
      if (drawint) {
c0de0930:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0932:	2800      	cmp	r0, #0
c0de0934:	d016      	beq.n	c0de0964 <bagl_draw_circle_helper+0xd0>
c0de0936:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0938:	1885      	adds	r5, r0, r2
c0de093a:	2601      	movs	r6, #1
        bagl_hal_draw_rect(colorint, x_center,   y+y_center, x-(dradius-1), 1);
c0de093c:	9600      	str	r6, [sp, #0]
c0de093e:	9807      	ldr	r0, [sp, #28]
c0de0940:	1a23      	subs	r3, r4, r0
c0de0942:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0944:	9f17      	ldr	r7, [sp, #92]	; 0x5c
c0de0946:	4639      	mov	r1, r7
c0de0948:	462a      	mov	r2, r5
c0de094a:	f008 fd3d 	bl	c0de93c8 <bagl_hal_draw_rect>
        bagl_hal_draw_rect(color, x_center+x-(dradius-1), y+y_center, dradius, 1);
c0de094e:	9600      	str	r6, [sp, #0]
c0de0950:	9e15      	ldr	r6, [sp, #84]	; 0x54
c0de0952:	19e2      	adds	r2, r4, r7
c0de0954:	9808      	ldr	r0, [sp, #32]
c0de0956:	9905      	ldr	r1, [sp, #20]
c0de0958:	1851      	adds	r1, r2, r1
c0de095a:	4607      	mov	r7, r0
c0de095c:	462a      	mov	r2, r5
c0de095e:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0960:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0962:	e007      	b.n	c0de0974 <bagl_draw_circle_helper+0xe0>
c0de0964:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center,   y+y_center-1, x, 1);
c0de0966:	9000      	str	r0, [sp, #0]
c0de0968:	9804      	ldr	r0, [sp, #16]
c0de096a:	991a      	ldr	r1, [sp, #104]	; 0x68
c0de096c:	1842      	adds	r2, r0, r1
c0de096e:	4638      	mov	r0, r7
c0de0970:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de0972:	4623      	mov	r3, r4
c0de0974:	f008 fd28 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0978:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    if (octants & 2) { // 
c0de097a:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de097c:	2800      	cmp	r0, #0
c0de097e:	d028      	beq.n	c0de09d2 <bagl_draw_circle_helper+0x13e>
      if (drawint) {
c0de0980:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0982:	2800      	cmp	r0, #0
c0de0984:	d01a      	beq.n	c0de09bc <bagl_draw_circle_helper+0x128>
c0de0986:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0988:	1825      	adds	r5, r4, r0
        if (last_x != x) {
c0de098a:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de098c:	42a0      	cmp	r0, r4
c0de098e:	d009      	beq.n	c0de09a4 <bagl_draw_circle_helper+0x110>
c0de0990:	2001      	movs	r0, #1
          bagl_hal_draw_rect(colorint, x_center,   x+y_center, y-(dradius-1), 1);
c0de0992:	9000      	str	r0, [sp, #0]
c0de0994:	9803      	ldr	r0, [sp, #12]
c0de0996:	1883      	adds	r3, r0, r2
c0de0998:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de099a:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de099c:	462a      	mov	r2, r5
c0de099e:	f008 fd13 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de09a2:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de09a4:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center+y-(dradius-1), x+y_center, dradius, 1);
c0de09a6:	9000      	str	r0, [sp, #0]
c0de09a8:	9806      	ldr	r0, [sp, #24]
c0de09aa:	1881      	adds	r1, r0, r2
c0de09ac:	4638      	mov	r0, r7
c0de09ae:	462a      	mov	r2, r5
c0de09b0:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de09b2:	f008 fd09 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de09b6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de09b8:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de09ba:	e00a      	b.n	c0de09d2 <bagl_draw_circle_helper+0x13e>
c0de09bc:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center,   x+y_center-1, y, 1);
c0de09be:	9000      	str	r0, [sp, #0]
c0de09c0:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de09c2:	1820      	adds	r0, r4, r0
c0de09c4:	1e42      	subs	r2, r0, #1
c0de09c6:	4638      	mov	r0, r7
c0de09c8:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de09ca:	9b1a      	ldr	r3, [sp, #104]	; 0x68
c0de09cc:	f008 fcfc 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de09d0:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    if (octants & 4) { // 
c0de09d2:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de09d4:	2800      	cmp	r0, #0
c0de09d6:	d023      	beq.n	c0de0a20 <bagl_draw_circle_helper+0x18c>
c0de09d8:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de09da:	1b06      	subs	r6, r0, r4
      if (drawint) {
c0de09dc:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de09de:	2800      	cmp	r0, #0
c0de09e0:	d012      	beq.n	c0de0a08 <bagl_draw_circle_helper+0x174>
c0de09e2:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de09e4:	1882      	adds	r2, r0, r2
        bagl_hal_draw_rect(colorint, x_center-x, y+y_center, x-(dradius-1), 1);
c0de09e6:	9202      	str	r2, [sp, #8]
c0de09e8:	2701      	movs	r7, #1
c0de09ea:	9700      	str	r7, [sp, #0]
c0de09ec:	9d07      	ldr	r5, [sp, #28]
c0de09ee:	1b63      	subs	r3, r4, r5
c0de09f0:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de09f2:	4631      	mov	r1, r6
c0de09f4:	f008 fce8 	bl	c0de93c8 <bagl_hal_draw_rect>
        bagl_hal_draw_rect(color, x_center-x-(dradius-1), y+y_center, dradius, 1);
c0de09f8:	9700      	str	r7, [sp, #0]
c0de09fa:	9808      	ldr	r0, [sp, #32]
c0de09fc:	1b71      	subs	r1, r6, r5
c0de09fe:	4607      	mov	r7, r0
c0de0a00:	9a02      	ldr	r2, [sp, #8]
c0de0a02:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0a04:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0a06:	e007      	b.n	c0de0a18 <bagl_draw_circle_helper+0x184>
c0de0a08:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center-x, y+y_center-1, x, 1);
c0de0a0a:	9000      	str	r0, [sp, #0]
c0de0a0c:	9804      	ldr	r0, [sp, #16]
c0de0a0e:	991a      	ldr	r1, [sp, #104]	; 0x68
c0de0a10:	1842      	adds	r2, r0, r1
c0de0a12:	4638      	mov	r0, r7
c0de0a14:	4631      	mov	r1, r6
c0de0a16:	4623      	mov	r3, r4
c0de0a18:	f008 fcd6 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0a1c:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de0a1e:	9e15      	ldr	r6, [sp, #84]	; 0x54
    if (octants & 8) { // 
c0de0a20:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de0a22:	2800      	cmp	r0, #0
c0de0a24:	d02b      	beq.n	c0de0a7e <bagl_draw_circle_helper+0x1ea>
      if (drawint) {
c0de0a26:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0a28:	2800      	cmp	r0, #0
c0de0a2a:	d005      	beq.n	c0de0a38 <bagl_draw_circle_helper+0x1a4>
        if (last_x != x) {
c0de0a2c:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de0a2e:	42a0      	cmp	r0, r4
c0de0a30:	d10e      	bne.n	c0de0a50 <bagl_draw_circle_helper+0x1bc>
        bagl_hal_draw_rect(color, x_center-y-(dradius-1), x+y_center, dradius, 1);
c0de0a32:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0a34:	1825      	adds	r5, r4, r0
c0de0a36:	e017      	b.n	c0de0a68 <bagl_draw_circle_helper+0x1d4>
c0de0a38:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center-y, x+y_center-1, y, 1);
c0de0a3a:	9000      	str	r0, [sp, #0]
c0de0a3c:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de0a3e:	1981      	adds	r1, r0, r6
c0de0a40:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0a42:	1820      	adds	r0, r4, r0
c0de0a44:	1e42      	subs	r2, r0, #1
c0de0a46:	4638      	mov	r0, r7
c0de0a48:	9b1a      	ldr	r3, [sp, #104]	; 0x68
c0de0a4a:	f008 fcbd 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0a4e:	e015      	b.n	c0de0a7c <bagl_draw_circle_helper+0x1e8>
c0de0a50:	2001      	movs	r0, #1
          bagl_hal_draw_rect(colorint, x_center-y, x+y_center, y-(dradius-1), 1);
c0de0a52:	9000      	str	r0, [sp, #0]
c0de0a54:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de0a56:	1981      	adds	r1, r0, r6
c0de0a58:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0a5a:	1825      	adds	r5, r4, r0
c0de0a5c:	9803      	ldr	r0, [sp, #12]
c0de0a5e:	1883      	adds	r3, r0, r2
c0de0a60:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0a62:	462a      	mov	r2, r5
c0de0a64:	f008 fcb0 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0a68:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center-y-(dradius-1), x+y_center, dradius, 1);
c0de0a6a:	9000      	str	r0, [sp, #0]
c0de0a6c:	9806      	ldr	r0, [sp, #24]
c0de0a6e:	1981      	adds	r1, r0, r6
c0de0a70:	4638      	mov	r0, r7
c0de0a72:	462a      	mov	r2, r5
c0de0a74:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0a76:	f008 fca7 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0a7a:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0a7c:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    if (octants & 16) { //
c0de0a7e:	980c      	ldr	r0, [sp, #48]	; 0x30
c0de0a80:	2800      	cmp	r0, #0
c0de0a82:	d022      	beq.n	c0de0aca <bagl_draw_circle_helper+0x236>
      if (drawint) {
c0de0a84:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0a86:	1986      	adds	r6, r0, r6
c0de0a88:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0a8a:	2800      	cmp	r0, #0
c0de0a8c:	d013      	beq.n	c0de0ab6 <bagl_draw_circle_helper+0x222>
c0de0a8e:	2501      	movs	r5, #1
        bagl_hal_draw_rect(colorint, x_center,   y_center-y, x-(dradius-1), 1);
c0de0a90:	9500      	str	r5, [sp, #0]
c0de0a92:	9807      	ldr	r0, [sp, #28]
c0de0a94:	1a23      	subs	r3, r4, r0
c0de0a96:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0a98:	9f17      	ldr	r7, [sp, #92]	; 0x5c
c0de0a9a:	4639      	mov	r1, r7
c0de0a9c:	4632      	mov	r2, r6
c0de0a9e:	f008 fc93 	bl	c0de93c8 <bagl_hal_draw_rect>
        bagl_hal_draw_rect(color, x_center+x-(dradius-1), y_center-y, dradius, 1);
c0de0aa2:	9500      	str	r5, [sp, #0]
c0de0aa4:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0aa6:	19e2      	adds	r2, r4, r7
c0de0aa8:	9808      	ldr	r0, [sp, #32]
c0de0aaa:	9905      	ldr	r1, [sp, #20]
c0de0aac:	1851      	adds	r1, r2, r1
c0de0aae:	4607      	mov	r7, r0
c0de0ab0:	4632      	mov	r2, r6
c0de0ab2:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0ab4:	e005      	b.n	c0de0ac2 <bagl_draw_circle_helper+0x22e>
c0de0ab6:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center,   y_center-y, x, 1);
c0de0ab8:	9000      	str	r0, [sp, #0]
c0de0aba:	4638      	mov	r0, r7
c0de0abc:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de0abe:	4632      	mov	r2, r6
c0de0ac0:	4623      	mov	r3, r4
c0de0ac2:	f008 fc81 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0ac6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de0ac8:	9e15      	ldr	r6, [sp, #84]	; 0x54
    if (octants & 32) { // 
c0de0aca:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de0acc:	2800      	cmp	r0, #0
c0de0ace:	d027      	beq.n	c0de0b20 <bagl_draw_circle_helper+0x28c>
      if (drawint) {
c0de0ad0:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0ad2:	2800      	cmp	r0, #0
c0de0ad4:	d01a      	beq.n	c0de0b0c <bagl_draw_circle_helper+0x278>
c0de0ad6:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0ad8:	1b05      	subs	r5, r0, r4
        if (last_x != x) {
c0de0ada:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de0adc:	42a0      	cmp	r0, r4
c0de0ade:	d009      	beq.n	c0de0af4 <bagl_draw_circle_helper+0x260>
c0de0ae0:	2001      	movs	r0, #1
          bagl_hal_draw_rect(colorint, x_center,   y_center-x, y-(dradius-1), 1);
c0de0ae2:	9000      	str	r0, [sp, #0]
c0de0ae4:	9803      	ldr	r0, [sp, #12]
c0de0ae6:	1883      	adds	r3, r0, r2
c0de0ae8:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0aea:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de0aec:	462a      	mov	r2, r5
c0de0aee:	f008 fc6b 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0af2:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de0af4:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center+y-(dradius-1), y_center-x, dradius, 1);
c0de0af6:	9000      	str	r0, [sp, #0]
c0de0af8:	9806      	ldr	r0, [sp, #24]
c0de0afa:	1881      	adds	r1, r0, r2
c0de0afc:	4638      	mov	r0, r7
c0de0afe:	462a      	mov	r2, r5
c0de0b00:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0b02:	f008 fc61 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0b06:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de0b08:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0b0a:	e009      	b.n	c0de0b20 <bagl_draw_circle_helper+0x28c>
c0de0b0c:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center,   y_center-x, y, 1);
c0de0b0e:	9000      	str	r0, [sp, #0]
c0de0b10:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0b12:	1b02      	subs	r2, r0, r4
c0de0b14:	4638      	mov	r0, r7
c0de0b16:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de0b18:	9b1a      	ldr	r3, [sp, #104]	; 0x68
c0de0b1a:	f008 fc55 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0b1e:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    if (octants & 64) { // 
c0de0b20:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de0b22:	2800      	cmp	r0, #0
c0de0b24:	d023      	beq.n	c0de0b6e <bagl_draw_circle_helper+0x2da>
      if (drawint) {
c0de0b26:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0b28:	1986      	adds	r6, r0, r6
c0de0b2a:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de0b2c:	1b05      	subs	r5, r0, r4
c0de0b2e:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0b30:	2800      	cmp	r0, #0
c0de0b32:	d011      	beq.n	c0de0b58 <bagl_draw_circle_helper+0x2c4>
c0de0b34:	2001      	movs	r0, #1
        bagl_hal_draw_rect(colorint, x_center-x, y_center-y, x-(dradius-1), 1);
c0de0b36:	9002      	str	r0, [sp, #8]
c0de0b38:	9000      	str	r0, [sp, #0]
c0de0b3a:	9f07      	ldr	r7, [sp, #28]
c0de0b3c:	1be3      	subs	r3, r4, r7
c0de0b3e:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0b40:	4629      	mov	r1, r5
c0de0b42:	4632      	mov	r2, r6
c0de0b44:	f008 fc40 	bl	c0de93c8 <bagl_hal_draw_rect>
        bagl_hal_draw_rect(color, x_center-x-(dradius-1), y_center-y, dradius, 1);
c0de0b48:	9802      	ldr	r0, [sp, #8]
c0de0b4a:	9000      	str	r0, [sp, #0]
c0de0b4c:	9808      	ldr	r0, [sp, #32]
c0de0b4e:	1be9      	subs	r1, r5, r7
c0de0b50:	4607      	mov	r7, r0
c0de0b52:	4632      	mov	r2, r6
c0de0b54:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0b56:	e005      	b.n	c0de0b64 <bagl_draw_circle_helper+0x2d0>
c0de0b58:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center-x, y_center-y, x, 1);
c0de0b5a:	9000      	str	r0, [sp, #0]
c0de0b5c:	4638      	mov	r0, r7
c0de0b5e:	4629      	mov	r1, r5
c0de0b60:	4632      	mov	r2, r6
c0de0b62:	4623      	mov	r3, r4
c0de0b64:	f008 fc30 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0b68:	9a1a      	ldr	r2, [sp, #104]	; 0x68
c0de0b6a:	9e15      	ldr	r6, [sp, #84]	; 0x54
c0de0b6c:	9d16      	ldr	r5, [sp, #88]	; 0x58
    if (octants & 128) { //
c0de0b6e:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de0b70:	2800      	cmp	r0, #0
c0de0b72:	d02a      	beq.n	c0de0bca <bagl_draw_circle_helper+0x336>
      if (drawint) {
c0de0b74:	9819      	ldr	r0, [sp, #100]	; 0x64
c0de0b76:	2800      	cmp	r0, #0
c0de0b78:	d005      	beq.n	c0de0b86 <bagl_draw_circle_helper+0x2f2>
        if (last_x != x) {
c0de0b7a:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de0b7c:	42a0      	cmp	r0, r4
c0de0b7e:	d10d      	bne.n	c0de0b9c <bagl_draw_circle_helper+0x308>
        bagl_hal_draw_rect(color, x_center-y-(dradius-1), y_center-x, dradius, 1);
c0de0b80:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0b82:	1b05      	subs	r5, r0, r4
c0de0b84:	e016      	b.n	c0de0bb4 <bagl_draw_circle_helper+0x320>
c0de0b86:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center-y, y_center-x, y, 1);
c0de0b88:	9000      	str	r0, [sp, #0]
c0de0b8a:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de0b8c:	1981      	adds	r1, r0, r6
c0de0b8e:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0b90:	1b02      	subs	r2, r0, r4
c0de0b92:	4638      	mov	r0, r7
c0de0b94:	9b1a      	ldr	r3, [sp, #104]	; 0x68
c0de0b96:	f008 fc17 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0b9a:	e015      	b.n	c0de0bc8 <bagl_draw_circle_helper+0x334>
c0de0b9c:	2001      	movs	r0, #1
          bagl_hal_draw_rect(colorint, x_center-y, y_center-x, y-(dradius-1), 1);
c0de0b9e:	9000      	str	r0, [sp, #0]
c0de0ba0:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0de0ba2:	1981      	adds	r1, r0, r6
c0de0ba4:	9818      	ldr	r0, [sp, #96]	; 0x60
c0de0ba6:	1b05      	subs	r5, r0, r4
c0de0ba8:	9803      	ldr	r0, [sp, #12]
c0de0baa:	1883      	adds	r3, r0, r2
c0de0bac:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de0bae:	462a      	mov	r2, r5
c0de0bb0:	f008 fc0a 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0bb4:	2001      	movs	r0, #1
        bagl_hal_draw_rect(color, x_center-y-(dradius-1), y_center-x, dradius, 1);
c0de0bb6:	9000      	str	r0, [sp, #0]
c0de0bb8:	9806      	ldr	r0, [sp, #24]
c0de0bba:	1981      	adds	r1, r0, r6
c0de0bbc:	4638      	mov	r0, r7
c0de0bbe:	462a      	mov	r2, r5
c0de0bc0:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0de0bc2:	f008 fc01 	bl	c0de93c8 <bagl_hal_draw_rect>
c0de0bc6:	9d16      	ldr	r5, [sp, #88]	; 0x58
c0de0bc8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    if (decisionOver2<=0)
c0de0bca:	1e60      	subs	r0, r4, #1
c0de0bcc:	2d01      	cmp	r5, #1
c0de0bce:	4623      	mov	r3, r4
c0de0bd0:	db00      	blt.n	c0de0bd4 <bagl_draw_circle_helper+0x340>
c0de0bd2:	4603      	mov	r3, r0
c0de0bd4:	2d01      	cmp	r5, #1
c0de0bd6:	da00      	bge.n	c0de0bda <bagl_draw_circle_helper+0x346>
c0de0bd8:	2000      	movs	r0, #0
  while( y <= x )
c0de0bda:	0040      	lsls	r0, r0, #1
c0de0bdc:	1a28      	subs	r0, r5, r0
c0de0bde:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de0be0:	180d      	adds	r5, r1, r0
c0de0be2:	4608      	mov	r0, r1
c0de0be4:	1c88      	adds	r0, r1, #2
c0de0be6:	1e76      	subs	r6, r6, #1
    y++;
c0de0be8:	1c52      	adds	r2, r2, #1
c0de0bea:	9413      	str	r4, [sp, #76]	; 0x4c
c0de0bec:	e695      	b.n	c0de091a <bagl_draw_circle_helper+0x86>
}
c0de0bee:	b01b      	add	sp, #108	; 0x6c
c0de0bf0:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0de0bf2 <bagl_draw_glyph>:

// --------------------------------------------------------------------------------------
void bagl_draw_glyph(const bagl_component_t* component, const bagl_icon_details_t* icon_details) {
c0de0bf2:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0bf4:	b089      	sub	sp, #36	; 0x24
  // no space to display that
  if (icon_details->bpp > 2) {
c0de0bf6:	688e      	ldr	r6, [r1, #8]
c0de0bf8:	2e02      	cmp	r6, #2
c0de0bfa:	d820      	bhi.n	c0de0c3e <bagl_draw_glyph+0x4c>
c0de0bfc:	460c      	mov	r4, r1
c0de0bfe:	2104      	movs	r1, #4
  }
  */
 
  // draw the glyph from the bitmap using the context for colors
  bagl_hal_draw_bitmap_within_rect(component->x, 
                                   component->y, 
c0de0c00:	5e41      	ldrsh	r1, [r0, r1]
c0de0c02:	9108      	str	r1, [sp, #32]
c0de0c04:	2102      	movs	r1, #2
  bagl_hal_draw_bitmap_within_rect(component->x, 
c0de0c06:	5e40      	ldrsh	r0, [r0, r1]
                                   icon_details->width, 
c0de0c08:	9005      	str	r0, [sp, #20]
c0de0c0a:	6820      	ldr	r0, [r4, #0]
                                   icon_details->height, 
c0de0c0c:	9006      	str	r0, [sp, #24]
c0de0c0e:	6860      	ldr	r0, [r4, #4]
                                   1<<(icon_details->bpp),
                                   (unsigned int*)PIC((unsigned int)icon_details->colors),
c0de0c10:	9007      	str	r0, [sp, #28]
c0de0c12:	68e0      	ldr	r0, [r4, #12]
c0de0c14:	f007 fb16 	bl	c0de8244 <pic>
c0de0c18:	4605      	mov	r5, r0
                                   icon_details->bpp, 
c0de0c1a:	68a7      	ldr	r7, [r4, #8]
                                   (unsigned char*)PIC((unsigned int)icon_details->bitmap), 
c0de0c1c:	6920      	ldr	r0, [r4, #16]
c0de0c1e:	f007 fb11 	bl	c0de8244 <pic>
                                   icon_details->bpp*(icon_details->width*icon_details->height));
c0de0c22:	cc0e      	ldmia	r4!, {r1, r2, r3}
c0de0c24:	2401      	movs	r4, #1
                                   1<<(icon_details->bpp),
c0de0c26:	40b4      	lsls	r4, r6
                                   icon_details->bpp*(icon_details->width*icon_details->height));
c0de0c28:	434b      	muls	r3, r1
c0de0c2a:	4353      	muls	r3, r2
  bagl_hal_draw_bitmap_within_rect(component->x, 
c0de0c2c:	a900      	add	r1, sp, #0
c0de0c2e:	c1b0      	stmia	r1!, {r4, r5, r7}
c0de0c30:	9003      	str	r0, [sp, #12]
c0de0c32:	9304      	str	r3, [sp, #16]
c0de0c34:	9908      	ldr	r1, [sp, #32]
c0de0c36:	ab05      	add	r3, sp, #20
c0de0c38:	cb0d      	ldmia	r3, {r0, r2, r3}
c0de0c3a:	f008 fbad 	bl	c0de9398 <bagl_hal_draw_bitmap_within_rect>
}
c0de0c3e:	b009      	add	sp, #36	; 0x24
c0de0c40:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0c42:	d4d4      	bmi.n	c0de0bee <bagl_draw_circle_helper+0x35a>

c0de0c44 <aci_gap_set_io_capability>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gap_set_io_capability( uint8_t IO_Capability )
{
c0de0c44:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0c46:	b0c7      	sub	sp, #284	; 0x11c
c0de0c48:	ae01      	add	r6, sp, #4
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->IO_Capability = IO_Capability;
c0de0c4a:	7030      	strb	r0, [r6, #0]
c0de0c4c:	466f      	mov	r7, sp
c0de0c4e:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de0c50:	703c      	strb	r4, [r7, #0]
c0de0c52:	ad41      	add	r5, sp, #260	; 0x104
c0de0c54:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0c56:	4628      	mov	r0, r5
c0de0c58:	4621      	mov	r1, r4
c0de0c5a:	f007 fae1 	bl	c0de8220 <Osal_MemSet>
c0de0c5e:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x085;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de0c60:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de0c62:	9745      	str	r7, [sp, #276]	; 0x114
  rq.clen = index_input;
c0de0c64:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de0c66:	9643      	str	r6, [sp, #268]	; 0x10c
c0de0c68:	4806      	ldr	r0, [pc, #24]	; (c0de0c84 <aci_gap_set_io_capability+0x40>)
  rq.ogf = 0x3f;
c0de0c6a:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0c6c:	4628      	mov	r0, r5
c0de0c6e:	4621      	mov	r1, r4
c0de0c70:	f004 fe92 	bl	c0de5998 <hci_send_req>
c0de0c74:	2800      	cmp	r0, #0
c0de0c76:	d401      	bmi.n	c0de0c7c <aci_gap_set_io_capability+0x38>
c0de0c78:	9800      	ldr	r0, [sp, #0]
c0de0c7a:	e000      	b.n	c0de0c7e <aci_gap_set_io_capability+0x3a>
c0de0c7c:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de0c7e:	b2c0      	uxtb	r0, r0
c0de0c80:	b047      	add	sp, #284	; 0x11c
c0de0c82:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0c84:	0085003f 	.word	0x0085003f

c0de0c88 <aci_gap_set_authentication_requirement>:
                                                   uint8_t Min_Encryption_Key_Size,
                                                   uint8_t Max_Encryption_Key_Size,
                                                   uint8_t Use_Fixed_Pin,
                                                   uint32_t Fixed_Pin,
                                                   uint8_t Identity_Address_Type )
{
c0de0c88:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0c8a:	b0c7      	sub	sp, #284	; 0x11c
c0de0c8c:	9c4f      	ldr	r4, [sp, #316]	; 0x13c
  index_input += 1;
  cp0->Max_Encryption_Key_Size = Max_Encryption_Key_Size;
  index_input += 1;
  cp0->Use_Fixed_Pin = Use_Fixed_Pin;
  index_input += 1;
  cp0->Fixed_Pin = Fixed_Pin;
c0de0c8e:	0e25      	lsrs	r5, r4, #24
c0de0c90:	ae01      	add	r6, sp, #4
c0de0c92:	72b5      	strb	r5, [r6, #10]
c0de0c94:	0c25      	lsrs	r5, r4, #16
c0de0c96:	7275      	strb	r5, [r6, #9]
c0de0c98:	0a25      	lsrs	r5, r4, #8
c0de0c9a:	7235      	strb	r5, [r6, #8]
c0de0c9c:	71f4      	strb	r4, [r6, #7]
c0de0c9e:	9c50      	ldr	r4, [sp, #320]	; 0x140
  index_input += 4;
  cp0->Identity_Address_Type = Identity_Address_Type;
c0de0ca0:	72f4      	strb	r4, [r6, #11]
c0de0ca2:	9c4e      	ldr	r4, [sp, #312]	; 0x138
  cp0->Use_Fixed_Pin = Use_Fixed_Pin;
c0de0ca4:	71b4      	strb	r4, [r6, #6]
c0de0ca6:	9c4d      	ldr	r4, [sp, #308]	; 0x134
  cp0->Max_Encryption_Key_Size = Max_Encryption_Key_Size;
c0de0ca8:	7174      	strb	r4, [r6, #5]
c0de0caa:	9c4c      	ldr	r4, [sp, #304]	; 0x130
  cp0->Min_Encryption_Key_Size = Min_Encryption_Key_Size;
c0de0cac:	7134      	strb	r4, [r6, #4]
  cp0->KeyPress_Notification_Support = KeyPress_Notification_Support;
c0de0cae:	70f3      	strb	r3, [r6, #3]
  cp0->SC_Support = SC_Support;
c0de0cb0:	70b2      	strb	r2, [r6, #2]
  cp0->MITM_Mode = MITM_Mode;
c0de0cb2:	7071      	strb	r1, [r6, #1]
  cp0->Bonding_Mode = Bonding_Mode;
c0de0cb4:	7030      	strb	r0, [r6, #0]
c0de0cb6:	466f      	mov	r7, sp
c0de0cb8:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de0cba:	703c      	strb	r4, [r7, #0]
c0de0cbc:	ad41      	add	r5, sp, #260	; 0x104
c0de0cbe:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0cc0:	4628      	mov	r0, r5
c0de0cc2:	4621      	mov	r1, r4
c0de0cc4:	f007 faac 	bl	c0de8220 <Osal_MemSet>
c0de0cc8:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x086;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de0cca:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de0ccc:	9745      	str	r7, [sp, #276]	; 0x114
c0de0cce:	200c      	movs	r0, #12
  rq.clen = index_input;
c0de0cd0:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de0cd2:	9643      	str	r6, [sp, #268]	; 0x10c
c0de0cd4:	4806      	ldr	r0, [pc, #24]	; (c0de0cf0 <aci_gap_set_authentication_requirement+0x68>)
  rq.ogf = 0x3f;
c0de0cd6:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0cd8:	4628      	mov	r0, r5
c0de0cda:	4621      	mov	r1, r4
c0de0cdc:	f004 fe5c 	bl	c0de5998 <hci_send_req>
c0de0ce0:	2800      	cmp	r0, #0
c0de0ce2:	d401      	bmi.n	c0de0ce8 <aci_gap_set_authentication_requirement+0x60>
c0de0ce4:	9800      	ldr	r0, [sp, #0]
c0de0ce6:	e000      	b.n	c0de0cea <aci_gap_set_authentication_requirement+0x62>
c0de0ce8:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de0cea:	b2c0      	uxtb	r0, r0
c0de0cec:	b047      	add	sp, #284	; 0x11c
c0de0cee:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0cf0:	0086003f 	.word	0x0086003f

c0de0cf4 <aci_gap_pass_key_resp>:
  return status;
}

tBleStatus aci_gap_pass_key_resp( uint16_t Connection_Handle,
                                  uint32_t Pass_Key )
{
c0de0cf4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0cf6:	b0c7      	sub	sp, #284	; 0x11c
  aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Connection_Handle = Connection_Handle;
  index_input += 2;
  cp0->Pass_Key = Pass_Key;
c0de0cf8:	0c0a      	lsrs	r2, r1, #16
c0de0cfa:	ae01      	add	r6, sp, #4
c0de0cfc:	80b2      	strh	r2, [r6, #4]
c0de0cfe:	8071      	strh	r1, [r6, #2]
  cp0->Connection_Handle = Connection_Handle;
c0de0d00:	8030      	strh	r0, [r6, #0]
c0de0d02:	466f      	mov	r7, sp
c0de0d04:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de0d06:	703c      	strb	r4, [r7, #0]
c0de0d08:	ad41      	add	r5, sp, #260	; 0x104
c0de0d0a:	2218      	movs	r2, #24
  index_input += 4;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0d0c:	4628      	mov	r0, r5
c0de0d0e:	4621      	mov	r1, r4
c0de0d10:	f007 fa86 	bl	c0de8220 <Osal_MemSet>
c0de0d14:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x088;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de0d16:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de0d18:	9745      	str	r7, [sp, #276]	; 0x114
c0de0d1a:	2006      	movs	r0, #6
  rq.clen = index_input;
c0de0d1c:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de0d1e:	9643      	str	r6, [sp, #268]	; 0x10c
c0de0d20:	4806      	ldr	r0, [pc, #24]	; (c0de0d3c <aci_gap_pass_key_resp+0x48>)
  rq.ogf = 0x3f;
c0de0d22:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0d24:	4628      	mov	r0, r5
c0de0d26:	4621      	mov	r1, r4
c0de0d28:	f004 fe36 	bl	c0de5998 <hci_send_req>
c0de0d2c:	2800      	cmp	r0, #0
c0de0d2e:	d401      	bmi.n	c0de0d34 <aci_gap_pass_key_resp+0x40>
c0de0d30:	9800      	ldr	r0, [sp, #0]
c0de0d32:	e000      	b.n	c0de0d36 <aci_gap_pass_key_resp+0x42>
c0de0d34:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de0d36:	b2c0      	uxtb	r0, r0
c0de0d38:	b047      	add	sp, #284	; 0x11c
c0de0d3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0d3c:	0088003f 	.word	0x0088003f

c0de0d40 <aci_gap_init>:
                         uint8_t privacy_enabled,
                         uint8_t device_name_char_len,
                         uint16_t* Service_Handle,
                         uint16_t* Dev_Name_Char_Handle,
                         uint16_t* Appearance_Char_Handle )
{
c0de0d40:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0d42:	b0cd      	sub	sp, #308	; 0x134
c0de0d44:	9301      	str	r3, [sp, #4]
c0de0d46:	9202      	str	r2, [sp, #8]
c0de0d48:	9103      	str	r1, [sp, #12]
c0de0d4a:	4604      	mov	r4, r0
c0de0d4c:	a805      	add	r0, sp, #20
c0de0d4e:	9004      	str	r0, [sp, #16]
c0de0d50:	2600      	movs	r6, #0
c0de0d52:	2707      	movs	r7, #7
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0*)(cmd_buffer);
  aci_gap_init_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
c0de0d54:	4631      	mov	r1, r6
c0de0d56:	463a      	mov	r2, r7
c0de0d58:	f007 fa62 	bl	c0de8220 <Osal_MemSet>
c0de0d5c:	ad07      	add	r5, sp, #28
  int index_input = 0;
  cp0->Role = Role;
  index_input += 1;
  cp0->privacy_enabled = privacy_enabled;
  index_input += 1;
  cp0->device_name_char_len = device_name_char_len;
c0de0d5e:	9802      	ldr	r0, [sp, #8]
c0de0d60:	70a8      	strb	r0, [r5, #2]
  cp0->privacy_enabled = privacy_enabled;
c0de0d62:	9803      	ldr	r0, [sp, #12]
c0de0d64:	7068      	strb	r0, [r5, #1]
  cp0->Role = Role;
c0de0d66:	702c      	strb	r4, [r5, #0]
c0de0d68:	ac47      	add	r4, sp, #284	; 0x11c
c0de0d6a:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0d6c:	4620      	mov	r0, r4
c0de0d6e:	4631      	mov	r1, r6
c0de0d70:	f007 fa56 	bl	c0de8220 <Osal_MemSet>
  rq.ogf = 0x3f;
  rq.ocf = 0x08a;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &resp;
  rq.rlen = sizeof(resp);
c0de0d74:	974c      	str	r7, [sp, #304]	; 0x130
c0de0d76:	9f04      	ldr	r7, [sp, #16]
  rq.rparam = &resp;
c0de0d78:	974b      	str	r7, [sp, #300]	; 0x12c
c0de0d7a:	2003      	movs	r0, #3
  rq.clen = index_input;
c0de0d7c:	904a      	str	r0, [sp, #296]	; 0x128
  rq.cparam = cmd_buffer;
c0de0d7e:	9549      	str	r5, [sp, #292]	; 0x124
c0de0d80:	4811      	ldr	r0, [pc, #68]	; (c0de0dc8 <aci_gap_init+0x88>)
  rq.ogf = 0x3f;
c0de0d82:	9047      	str	r0, [sp, #284]	; 0x11c
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0d84:	4620      	mov	r0, r4
c0de0d86:	4631      	mov	r1, r6
c0de0d88:	f004 fe06 	bl	c0de5998 <hci_send_req>
c0de0d8c:	2800      	cmp	r0, #0
c0de0d8e:	d418      	bmi.n	c0de0dc2 <aci_gap_init+0x82>
c0de0d90:	a805      	add	r0, sp, #20
    return BLE_STATUS_TIMEOUT;
  if ( resp.Status )
c0de0d92:	7800      	ldrb	r0, [r0, #0]
c0de0d94:	2800      	cmp	r0, #0
c0de0d96:	d115      	bne.n	c0de0dc4 <aci_gap_init+0x84>
c0de0d98:	1c78      	adds	r0, r7, #1
c0de0d9a:	9953      	ldr	r1, [sp, #332]	; 0x14c
c0de0d9c:	9a52      	ldr	r2, [sp, #328]	; 0x148
    return resp.Status;
  *Service_Handle = resp.Service_Handle;
c0de0d9e:	7803      	ldrb	r3, [r0, #0]
c0de0da0:	7844      	ldrb	r4, [r0, #1]
c0de0da2:	0224      	lsls	r4, r4, #8
c0de0da4:	18e3      	adds	r3, r4, r3
c0de0da6:	9c01      	ldr	r4, [sp, #4]
c0de0da8:	8023      	strh	r3, [r4, #0]
  *Dev_Name_Char_Handle = resp.Dev_Name_Char_Handle;
c0de0daa:	7883      	ldrb	r3, [r0, #2]
c0de0dac:	78c4      	ldrb	r4, [r0, #3]
c0de0dae:	0224      	lsls	r4, r4, #8
c0de0db0:	18e3      	adds	r3, r4, r3
c0de0db2:	8013      	strh	r3, [r2, #0]
  *Appearance_Char_Handle = resp.Appearance_Char_Handle;
c0de0db4:	7902      	ldrb	r2, [r0, #4]
c0de0db6:	7940      	ldrb	r0, [r0, #5]
c0de0db8:	0200      	lsls	r0, r0, #8
c0de0dba:	1880      	adds	r0, r0, r2
c0de0dbc:	8008      	strh	r0, [r1, #0]
c0de0dbe:	4630      	mov	r0, r6
c0de0dc0:	e000      	b.n	c0de0dc4 <aci_gap_init+0x84>
c0de0dc2:	20ff      	movs	r0, #255	; 0xff
  return BLE_STATUS_SUCCESS;
}
c0de0dc4:	b04d      	add	sp, #308	; 0x134
c0de0dc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0dc8:	008a003f 	.word	0x008a003f

c0de0dcc <aci_gap_terminate>:
  return status;
}

tBleStatus aci_gap_terminate( uint16_t Connection_Handle,
                              uint8_t Reason )
{
c0de0dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0dce:	b0c7      	sub	sp, #284	; 0x11c
c0de0dd0:	ae01      	add	r6, sp, #4
  aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Connection_Handle = Connection_Handle;
  index_input += 2;
  cp0->Reason = Reason;
c0de0dd2:	70b1      	strb	r1, [r6, #2]
  cp0->Connection_Handle = Connection_Handle;
c0de0dd4:	8030      	strh	r0, [r6, #0]
c0de0dd6:	466f      	mov	r7, sp
c0de0dd8:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de0dda:	703c      	strb	r4, [r7, #0]
c0de0ddc:	ad41      	add	r5, sp, #260	; 0x104
c0de0dde:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0de0:	4628      	mov	r0, r5
c0de0de2:	4621      	mov	r1, r4
c0de0de4:	f007 fa1c 	bl	c0de8220 <Osal_MemSet>
c0de0de8:	2001      	movs	r0, #1
  rq.ocf = 0x093;
  rq.event = 0x0F;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de0dea:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de0dec:	9745      	str	r7, [sp, #276]	; 0x114
c0de0dee:	2003      	movs	r0, #3
  rq.clen = index_input;
c0de0df0:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de0df2:	9643      	str	r6, [sp, #268]	; 0x10c
c0de0df4:	200f      	movs	r0, #15
  rq.event = 0x0F;
c0de0df6:	9042      	str	r0, [sp, #264]	; 0x108
c0de0df8:	4806      	ldr	r0, [pc, #24]	; (c0de0e14 <aci_gap_terminate+0x48>)
  rq.ogf = 0x3f;
c0de0dfa:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0dfc:	4628      	mov	r0, r5
c0de0dfe:	4621      	mov	r1, r4
c0de0e00:	f004 fdca 	bl	c0de5998 <hci_send_req>
c0de0e04:	2800      	cmp	r0, #0
c0de0e06:	d401      	bmi.n	c0de0e0c <aci_gap_terminate+0x40>
c0de0e08:	9800      	ldr	r0, [sp, #0]
c0de0e0a:	e000      	b.n	c0de0e0e <aci_gap_terminate+0x42>
c0de0e0c:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de0e0e:	b2c0      	uxtb	r0, r0
c0de0e10:	b047      	add	sp, #284	; 0x11c
c0de0e12:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0e14:	0093003f 	.word	0x0093003f

c0de0e18 <aci_gap_numeric_comparison_value_confirm_yesno>:
  return status;
}

tBleStatus aci_gap_numeric_comparison_value_confirm_yesno( uint16_t Connection_Handle,
                                                           uint8_t Confirm_Yes_No )
{
c0de0e18:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0e1a:	b0c7      	sub	sp, #284	; 0x11c
c0de0e1c:	ae01      	add	r6, sp, #4
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 = (aci_gap_numeric_comparison_value_confirm_yesno_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Connection_Handle = Connection_Handle;
  index_input += 2;
  cp0->Confirm_Yes_No = Confirm_Yes_No;
c0de0e1e:	70b1      	strb	r1, [r6, #2]
  cp0->Connection_Handle = Connection_Handle;
c0de0e20:	8030      	strh	r0, [r6, #0]
c0de0e22:	466f      	mov	r7, sp
c0de0e24:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de0e26:	703c      	strb	r4, [r7, #0]
c0de0e28:	ad41      	add	r5, sp, #260	; 0x104
c0de0e2a:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0e2c:	4628      	mov	r0, r5
c0de0e2e:	4621      	mov	r1, r4
c0de0e30:	f007 f9f6 	bl	c0de8220 <Osal_MemSet>
c0de0e34:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x0a5;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de0e36:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de0e38:	9745      	str	r7, [sp, #276]	; 0x114
c0de0e3a:	2003      	movs	r0, #3
  rq.clen = index_input;
c0de0e3c:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de0e3e:	9643      	str	r6, [sp, #268]	; 0x10c
c0de0e40:	4806      	ldr	r0, [pc, #24]	; (c0de0e5c <aci_gap_numeric_comparison_value_confirm_yesno+0x44>)
  rq.ogf = 0x3f;
c0de0e42:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0e44:	4628      	mov	r0, r5
c0de0e46:	4621      	mov	r1, r4
c0de0e48:	f004 fda6 	bl	c0de5998 <hci_send_req>
c0de0e4c:	2800      	cmp	r0, #0
c0de0e4e:	d401      	bmi.n	c0de0e54 <aci_gap_numeric_comparison_value_confirm_yesno+0x3c>
c0de0e50:	9800      	ldr	r0, [sp, #0]
c0de0e52:	e000      	b.n	c0de0e56 <aci_gap_numeric_comparison_value_confirm_yesno+0x3e>
c0de0e54:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de0e56:	b2c0      	uxtb	r0, r0
c0de0e58:	b047      	add	sp, #284	; 0x11c
c0de0e5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0e5c:	00a5003f 	.word	0x00a5003f

c0de0e60 <aci_gatt_init>:
 */

#include "ble_gatt_aci.h"

tBleStatus aci_gatt_init( void )
{
c0de0e60:	b570      	push	{r4, r5, r6, lr}
c0de0e62:	b088      	sub	sp, #32
c0de0e64:	ae01      	add	r6, sp, #4
c0de0e66:	2400      	movs	r4, #0
  struct hci_request rq;
  tBleStatus status = 0;
c0de0e68:	7034      	strb	r4, [r6, #0]
c0de0e6a:	ad02      	add	r5, sp, #8
c0de0e6c:	2218      	movs	r2, #24
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0e6e:	4628      	mov	r0, r5
c0de0e70:	4621      	mov	r1, r4
c0de0e72:	f007 f9d5 	bl	c0de8220 <Osal_MemSet>
c0de0e76:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x101;
  rq.rparam = &status;
  rq.rlen = 1;
c0de0e78:	9007      	str	r0, [sp, #28]
  rq.rparam = &status;
c0de0e7a:	9606      	str	r6, [sp, #24]
c0de0e7c:	4806      	ldr	r0, [pc, #24]	; (c0de0e98 <aci_gatt_init+0x38>)
  rq.ogf = 0x3f;
c0de0e7e:	9002      	str	r0, [sp, #8]
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0e80:	4628      	mov	r0, r5
c0de0e82:	4621      	mov	r1, r4
c0de0e84:	f004 fd88 	bl	c0de5998 <hci_send_req>
c0de0e88:	2800      	cmp	r0, #0
c0de0e8a:	d401      	bmi.n	c0de0e90 <aci_gatt_init+0x30>
c0de0e8c:	9801      	ldr	r0, [sp, #4]
c0de0e8e:	e000      	b.n	c0de0e92 <aci_gatt_init+0x32>
c0de0e90:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de0e92:	b2c0      	uxtb	r0, r0
c0de0e94:	b008      	add	sp, #32
c0de0e96:	bd70      	pop	{r4, r5, r6, pc}
c0de0e98:	0101003f 	.word	0x0101003f

c0de0e9c <aci_gatt_add_service>:
tBleStatus aci_gatt_add_service( uint8_t Service_UUID_Type,
                                 const Service_UUID_t* Service_UUID,
                                 uint8_t Service_Type,
                                 uint8_t Max_Attribute_Records,
                                 uint16_t* Service_Handle )
{
c0de0e9c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0e9e:	b0c9      	sub	sp, #292	; 0x124
c0de0ea0:	9300      	str	r3, [sp, #0]
c0de0ea2:	9201      	str	r2, [sp, #4]
c0de0ea4:	460f      	mov	r7, r1
c0de0ea6:	4606      	mov	r6, r0
c0de0ea8:	a802      	add	r0, sp, #8
c0de0eaa:	2100      	movs	r1, #0
c0de0eac:	2403      	movs	r4, #3
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_add_service_cp0 *cp0 = (aci_gatt_add_service_cp0*)(cmd_buffer);
  aci_gatt_add_service_cp1 *cp1 = (aci_gatt_add_service_cp1*)(cmd_buffer + 1 + (Service_UUID_Type == 1 ? 2 : (Service_UUID_Type == 2 ? 16 : 0)));
  aci_gatt_add_service_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
c0de0eae:	4622      	mov	r2, r4
c0de0eb0:	f007 f9b6 	bl	c0de8220 <Osal_MemSet>
c0de0eb4:	a803      	add	r0, sp, #12
  int index_input = 0;
  cp0->Service_UUID_Type = Service_UUID_Type;
c0de0eb6:	7006      	strb	r6, [r0, #0]
c0de0eb8:	1eb1      	subs	r1, r6, #2
c0de0eba:	424a      	negs	r2, r1
c0de0ebc:	414a      	adcs	r2, r1
c0de0ebe:	2502      	movs	r5, #2
  aci_gatt_add_service_cp1 *cp1 = (aci_gatt_add_service_cp1*)(cmd_buffer + 1 + (Service_UUID_Type == 1 ? 2 : (Service_UUID_Type == 2 ? 16 : 0)));
c0de0ec0:	2e01      	cmp	r6, #1
c0de0ec2:	4629      	mov	r1, r5
c0de0ec4:	d000      	beq.n	c0de0ec8 <aci_gatt_add_service+0x2c>
c0de0ec6:	0111      	lsls	r1, r2, #4
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch ( Service_UUID_Type )
c0de0ec8:	2e01      	cmp	r6, #1
c0de0eca:	d002      	beq.n	c0de0ed2 <aci_gatt_add_service+0x36>
c0de0ecc:	2e02      	cmp	r6, #2
c0de0ece:	d12f      	bne.n	c0de0f30 <aci_gatt_add_service+0x94>
c0de0ed0:	2510      	movs	r5, #16
c0de0ed2:	1c40      	adds	r0, r0, #1
c0de0ed4:	1846      	adds	r6, r0, r1
    {
      case 1: size = 2; break;
      case 2: size = 16; break;
      default: return BLE_STATUS_ERROR;
    }
    Osal_MemCpy( (void*)&cp0->Service_UUID, (const void*)Service_UUID, size );
c0de0ed6:	4639      	mov	r1, r7
c0de0ed8:	462a      	mov	r2, r5
c0de0eda:	f007 f99b 	bl	c0de8214 <Osal_MemCpy>
    {
      cp1->Service_Type = Service_Type;
    }
    index_input += 1;
    {
      cp1->Max_Attribute_Records = Max_Attribute_Records;
c0de0ede:	9800      	ldr	r0, [sp, #0]
c0de0ee0:	7070      	strb	r0, [r6, #1]
      cp1->Service_Type = Service_Type;
c0de0ee2:	9801      	ldr	r0, [sp, #4]
c0de0ee4:	7030      	strb	r0, [r6, #0]
c0de0ee6:	af43      	add	r7, sp, #268	; 0x10c
c0de0ee8:	2600      	movs	r6, #0
c0de0eea:	2218      	movs	r2, #24
    }
    index_input += 1;
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0eec:	4638      	mov	r0, r7
c0de0eee:	4631      	mov	r1, r6
c0de0ef0:	f007 f996 	bl	c0de8220 <Osal_MemSet>
  rq.ogf = 0x3f;
  rq.ocf = 0x102;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &resp;
  rq.rlen = sizeof(resp);
c0de0ef4:	9448      	str	r4, [sp, #288]	; 0x120
c0de0ef6:	a802      	add	r0, sp, #8
  rq.rparam = &resp;
c0de0ef8:	9047      	str	r0, [sp, #284]	; 0x11c
c0de0efa:	2001      	movs	r0, #1
    index_input += size;
c0de0efc:	4328      	orrs	r0, r5
    index_input += 1;
c0de0efe:	1c80      	adds	r0, r0, #2
  rq.clen = index_input;
c0de0f00:	9046      	str	r0, [sp, #280]	; 0x118
c0de0f02:	a803      	add	r0, sp, #12
  rq.cparam = cmd_buffer;
c0de0f04:	9045      	str	r0, [sp, #276]	; 0x114
c0de0f06:	480d      	ldr	r0, [pc, #52]	; (c0de0f3c <aci_gatt_add_service+0xa0>)
  rq.ogf = 0x3f;
c0de0f08:	9043      	str	r0, [sp, #268]	; 0x10c
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0f0a:	4638      	mov	r0, r7
c0de0f0c:	4631      	mov	r1, r6
c0de0f0e:	f004 fd43 	bl	c0de5998 <hci_send_req>
c0de0f12:	2800      	cmp	r0, #0
c0de0f14:	d40e      	bmi.n	c0de0f34 <aci_gatt_add_service+0x98>
c0de0f16:	a802      	add	r0, sp, #8
    return BLE_STATUS_TIMEOUT;
  if ( resp.Status )
c0de0f18:	7800      	ldrb	r0, [r0, #0]
c0de0f1a:	2800      	cmp	r0, #0
c0de0f1c:	d10b      	bne.n	c0de0f36 <aci_gatt_add_service+0x9a>
c0de0f1e:	984e      	ldr	r0, [sp, #312]	; 0x138
c0de0f20:	a902      	add	r1, sp, #8
    return resp.Status;
  *Service_Handle = resp.Service_Handle;
c0de0f22:	784a      	ldrb	r2, [r1, #1]
c0de0f24:	7889      	ldrb	r1, [r1, #2]
c0de0f26:	0209      	lsls	r1, r1, #8
c0de0f28:	1889      	adds	r1, r1, r2
c0de0f2a:	8001      	strh	r1, [r0, #0]
c0de0f2c:	4630      	mov	r0, r6
c0de0f2e:	e002      	b.n	c0de0f36 <aci_gatt_add_service+0x9a>
c0de0f30:	2047      	movs	r0, #71	; 0x47
c0de0f32:	e000      	b.n	c0de0f36 <aci_gatt_add_service+0x9a>
c0de0f34:	20ff      	movs	r0, #255	; 0xff
  return BLE_STATUS_SUCCESS;
}
c0de0f36:	b049      	add	sp, #292	; 0x124
c0de0f38:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de0f3a:	46c0      	nop			; (mov r8, r8)
c0de0f3c:	0102003f 	.word	0x0102003f

c0de0f40 <aci_gatt_add_char>:
                              uint8_t Security_Permissions,
                              uint8_t GATT_Evt_Mask,
                              uint8_t Enc_Key_Size,
                              uint8_t Is_Variable,
                              uint16_t* Char_Handle )
{
c0de0f40:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de0f42:	b0cd      	sub	sp, #308	; 0x134
c0de0f44:	461d      	mov	r5, r3
c0de0f46:	9205      	str	r2, [sp, #20]
c0de0f48:	460f      	mov	r7, r1
c0de0f4a:	4606      	mov	r6, r0
c0de0f4c:	a806      	add	r0, sp, #24
c0de0f4e:	2100      	movs	r1, #0
c0de0f50:	2403      	movs	r4, #3
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_add_char_cp0 *cp0 = (aci_gatt_add_char_cp0*)(cmd_buffer);
  aci_gatt_add_char_cp1 *cp1 = (aci_gatt_add_char_cp1*)(cmd_buffer + 2 + 1 + (Char_UUID_Type == 1 ? 2 : (Char_UUID_Type == 2 ? 16 : 0)));
  aci_gatt_add_char_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
c0de0f52:	4622      	mov	r2, r4
c0de0f54:	f007 f964 	bl	c0de8220 <Osal_MemSet>
c0de0f58:	a807      	add	r0, sp, #28
  int index_input = 0;
  cp0->Service_Handle = Service_Handle;
  index_input += 2;
  cp0->Char_UUID_Type = Char_UUID_Type;
c0de0f5a:	7087      	strb	r7, [r0, #2]
  cp0->Service_Handle = Service_Handle;
c0de0f5c:	8006      	strh	r6, [r0, #0]
c0de0f5e:	1eb9      	subs	r1, r7, #2
c0de0f60:	424a      	negs	r2, r1
c0de0f62:	414a      	adcs	r2, r1
c0de0f64:	2602      	movs	r6, #2
  aci_gatt_add_char_cp1 *cp1 = (aci_gatt_add_char_cp1*)(cmd_buffer + 2 + 1 + (Char_UUID_Type == 1 ? 2 : (Char_UUID_Type == 2 ? 16 : 0)));
c0de0f66:	2f01      	cmp	r7, #1
c0de0f68:	4631      	mov	r1, r6
c0de0f6a:	d000      	beq.n	c0de0f6e <aci_gatt_add_char+0x2e>
c0de0f6c:	0111      	lsls	r1, r2, #4
  index_input += 1;
  /* var_len_data input */
  {
    uint8_t size;
    switch ( Char_UUID_Type )
c0de0f6e:	2f01      	cmp	r7, #1
c0de0f70:	d002      	beq.n	c0de0f78 <aci_gatt_add_char+0x38>
c0de0f72:	2f02      	cmp	r7, #2
c0de0f74:	d142      	bne.n	c0de0ffc <aci_gatt_add_char+0xbc>
c0de0f76:	2610      	movs	r6, #16
c0de0f78:	1cc0      	adds	r0, r0, #3
c0de0f7a:	1847      	adds	r7, r0, r1
c0de0f7c:	9956      	ldr	r1, [sp, #344]	; 0x158
c0de0f7e:	9100      	str	r1, [sp, #0]
c0de0f80:	9404      	str	r4, [sp, #16]
c0de0f82:	9c55      	ldr	r4, [sp, #340]	; 0x154
c0de0f84:	9954      	ldr	r1, [sp, #336]	; 0x150
c0de0f86:	9101      	str	r1, [sp, #4]
c0de0f88:	9953      	ldr	r1, [sp, #332]	; 0x14c
c0de0f8a:	9102      	str	r1, [sp, #8]
c0de0f8c:	9952      	ldr	r1, [sp, #328]	; 0x148
    {
      case 1: size = 2; break;
      case 2: size = 16; break;
      default: return BLE_STATUS_ERROR;
    }
    Osal_MemCpy( (void*)&cp0->Char_UUID, (const void*)Char_UUID, size );
c0de0f8e:	9103      	str	r1, [sp, #12]
c0de0f90:	9905      	ldr	r1, [sp, #20]
c0de0f92:	4632      	mov	r2, r6
c0de0f94:	f007 f93e 	bl	c0de8214 <Osal_MemCpy>
    index_input += size;
    {
      cp1->Char_Value_Length = Char_Value_Length;
c0de0f98:	0a28      	lsrs	r0, r5, #8
c0de0f9a:	7078      	strb	r0, [r7, #1]
c0de0f9c:	703d      	strb	r5, [r7, #0]
    {
      cp1->Enc_Key_Size = Enc_Key_Size;
    }
    index_input += 1;
    {
      cp1->Is_Variable = Is_Variable;
c0de0f9e:	9800      	ldr	r0, [sp, #0]
c0de0fa0:	71b8      	strb	r0, [r7, #6]
      cp1->Enc_Key_Size = Enc_Key_Size;
c0de0fa2:	717c      	strb	r4, [r7, #5]
      cp1->GATT_Evt_Mask = GATT_Evt_Mask;
c0de0fa4:	9801      	ldr	r0, [sp, #4]
c0de0fa6:	7138      	strb	r0, [r7, #4]
      cp1->Security_Permissions = Security_Permissions;
c0de0fa8:	9802      	ldr	r0, [sp, #8]
c0de0faa:	70f8      	strb	r0, [r7, #3]
      cp1->Char_Properties = Char_Properties;
c0de0fac:	9803      	ldr	r0, [sp, #12]
c0de0fae:	70b8      	strb	r0, [r7, #2]
c0de0fb0:	af47      	add	r7, sp, #284	; 0x11c
c0de0fb2:	2500      	movs	r5, #0
c0de0fb4:	2218      	movs	r2, #24
    }
    index_input += 1;
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de0fb6:	4638      	mov	r0, r7
c0de0fb8:	4629      	mov	r1, r5
c0de0fba:	f007 f931 	bl	c0de8220 <Osal_MemSet>
  rq.ogf = 0x3f;
  rq.ocf = 0x104;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &resp;
  rq.rlen = sizeof(resp);
c0de0fbe:	9804      	ldr	r0, [sp, #16]
c0de0fc0:	904c      	str	r0, [sp, #304]	; 0x130
c0de0fc2:	a806      	add	r0, sp, #24
  rq.rparam = &resp;
c0de0fc4:	904b      	str	r0, [sp, #300]	; 0x12c
c0de0fc6:	2005      	movs	r0, #5
    index_input += 2;
c0de0fc8:	4330      	orrs	r0, r6
    index_input += 1;
c0de0fca:	1d40      	adds	r0, r0, #5
  rq.clen = index_input;
c0de0fcc:	904a      	str	r0, [sp, #296]	; 0x128
c0de0fce:	a807      	add	r0, sp, #28
  rq.cparam = cmd_buffer;
c0de0fd0:	9049      	str	r0, [sp, #292]	; 0x124
c0de0fd2:	480d      	ldr	r0, [pc, #52]	; (c0de1008 <aci_gatt_add_char+0xc8>)
  rq.ogf = 0x3f;
c0de0fd4:	9047      	str	r0, [sp, #284]	; 0x11c
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de0fd6:	4638      	mov	r0, r7
c0de0fd8:	4629      	mov	r1, r5
c0de0fda:	f004 fcdd 	bl	c0de5998 <hci_send_req>
c0de0fde:	2800      	cmp	r0, #0
c0de0fe0:	d40e      	bmi.n	c0de1000 <aci_gatt_add_char+0xc0>
c0de0fe2:	a806      	add	r0, sp, #24
    return BLE_STATUS_TIMEOUT;
  if ( resp.Status )
c0de0fe4:	7800      	ldrb	r0, [r0, #0]
c0de0fe6:	2800      	cmp	r0, #0
c0de0fe8:	d10b      	bne.n	c0de1002 <aci_gatt_add_char+0xc2>
c0de0fea:	9857      	ldr	r0, [sp, #348]	; 0x15c
c0de0fec:	a906      	add	r1, sp, #24
    return resp.Status;
  *Char_Handle = resp.Char_Handle;
c0de0fee:	784a      	ldrb	r2, [r1, #1]
c0de0ff0:	7889      	ldrb	r1, [r1, #2]
c0de0ff2:	0209      	lsls	r1, r1, #8
c0de0ff4:	1889      	adds	r1, r1, r2
c0de0ff6:	8001      	strh	r1, [r0, #0]
c0de0ff8:	4628      	mov	r0, r5
c0de0ffa:	e002      	b.n	c0de1002 <aci_gatt_add_char+0xc2>
c0de0ffc:	2047      	movs	r0, #71	; 0x47
c0de0ffe:	e000      	b.n	c0de1002 <aci_gatt_add_char+0xc2>
c0de1000:	20ff      	movs	r0, #255	; 0xff
  return BLE_STATUS_SUCCESS;
}
c0de1002:	b04d      	add	sp, #308	; 0x134
c0de1004:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1006:	46c0      	nop			; (mov r8, r8)
c0de1008:	0104003f 	.word	0x0104003f

c0de100c <aci_gatt_update_char_value>:
tBleStatus aci_gatt_update_char_value( uint16_t Service_Handle,
                                       uint16_t Char_Handle,
                                       uint8_t Val_Offset,
                                       uint8_t Char_Value_Length,
                                       const uint8_t* Char_Value )
{
c0de100c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de100e:	b0c9      	sub	sp, #292	; 0x124
c0de1010:	461d      	mov	r5, r3
c0de1012:	af03      	add	r7, sp, #12
  index_input += 2;
  cp0->Char_Handle = Char_Handle;
  index_input += 2;
  cp0->Val_Offset = Val_Offset;
  index_input += 1;
  cp0->Char_Value_Length = Char_Value_Length;
c0de1014:	717b      	strb	r3, [r7, #5]
  cp0->Val_Offset = Val_Offset;
c0de1016:	713a      	strb	r2, [r7, #4]
  cp0->Char_Handle = Char_Handle;
c0de1018:	8079      	strh	r1, [r7, #2]
  cp0->Service_Handle = Service_Handle;
c0de101a:	8038      	strh	r0, [r7, #0]
c0de101c:	a802      	add	r0, sp, #8
c0de101e:	9001      	str	r0, [sp, #4]
c0de1020:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de1022:	7004      	strb	r4, [r0, #0]
  index_input += 1;
  Osal_MemCpy( (void*)&cp0->Char_Value, (const void*)Char_Value, Char_Value_Length );
c0de1024:	1db8      	adds	r0, r7, #6
c0de1026:	994e      	ldr	r1, [sp, #312]	; 0x138
c0de1028:	461a      	mov	r2, r3
c0de102a:	f007 f8f3 	bl	c0de8214 <Osal_MemCpy>
c0de102e:	ae43      	add	r6, sp, #268	; 0x10c
c0de1030:	2218      	movs	r2, #24
  index_input += Char_Value_Length;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de1032:	4630      	mov	r0, r6
c0de1034:	4621      	mov	r1, r4
c0de1036:	f007 f8f3 	bl	c0de8220 <Osal_MemSet>
c0de103a:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x106;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de103c:	9048      	str	r0, [sp, #288]	; 0x120
  rq.rparam = &status;
c0de103e:	9801      	ldr	r0, [sp, #4]
c0de1040:	9047      	str	r0, [sp, #284]	; 0x11c
  index_input += Char_Value_Length;
c0de1042:	1da8      	adds	r0, r5, #6
  rq.clen = index_input;
c0de1044:	9046      	str	r0, [sp, #280]	; 0x118
  rq.cparam = cmd_buffer;
c0de1046:	9745      	str	r7, [sp, #276]	; 0x114
c0de1048:	4806      	ldr	r0, [pc, #24]	; (c0de1064 <aci_gatt_update_char_value+0x58>)
  rq.ogf = 0x3f;
c0de104a:	9043      	str	r0, [sp, #268]	; 0x10c
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de104c:	4630      	mov	r0, r6
c0de104e:	4621      	mov	r1, r4
c0de1050:	f004 fca2 	bl	c0de5998 <hci_send_req>
c0de1054:	2800      	cmp	r0, #0
c0de1056:	d401      	bmi.n	c0de105c <aci_gatt_update_char_value+0x50>
c0de1058:	9802      	ldr	r0, [sp, #8]
c0de105a:	e000      	b.n	c0de105e <aci_gatt_update_char_value+0x52>
c0de105c:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de105e:	b2c0      	uxtb	r0, r0
c0de1060:	b049      	add	sp, #292	; 0x124
c0de1062:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1064:	0106003f 	.word	0x0106003f

c0de1068 <aci_gatt_exchange_config>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gatt_exchange_config( uint16_t Connection_Handle )
{
c0de1068:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de106a:	b0c7      	sub	sp, #284	; 0x11c
c0de106c:	ae01      	add	r6, sp, #4
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_exchange_config_cp0 *cp0 = (aci_gatt_exchange_config_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Connection_Handle = Connection_Handle;
c0de106e:	8030      	strh	r0, [r6, #0]
c0de1070:	466f      	mov	r7, sp
c0de1072:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de1074:	703c      	strb	r4, [r7, #0]
c0de1076:	ad41      	add	r5, sp, #260	; 0x104
c0de1078:	2218      	movs	r2, #24
  index_input += 2;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de107a:	4628      	mov	r0, r5
c0de107c:	4621      	mov	r1, r4
c0de107e:	f007 f8cf 	bl	c0de8220 <Osal_MemSet>
c0de1082:	2001      	movs	r0, #1
  rq.ocf = 0x10b;
  rq.event = 0x0F;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de1084:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de1086:	9745      	str	r7, [sp, #276]	; 0x114
c0de1088:	2002      	movs	r0, #2
  rq.clen = index_input;
c0de108a:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de108c:	9643      	str	r6, [sp, #268]	; 0x10c
c0de108e:	200f      	movs	r0, #15
  rq.event = 0x0F;
c0de1090:	9042      	str	r0, [sp, #264]	; 0x108
c0de1092:	4807      	ldr	r0, [pc, #28]	; (c0de10b0 <aci_gatt_exchange_config+0x48>)
  rq.ogf = 0x3f;
c0de1094:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de1096:	4628      	mov	r0, r5
c0de1098:	4621      	mov	r1, r4
c0de109a:	f004 fc7d 	bl	c0de5998 <hci_send_req>
c0de109e:	2800      	cmp	r0, #0
c0de10a0:	d401      	bmi.n	c0de10a6 <aci_gatt_exchange_config+0x3e>
c0de10a2:	9800      	ldr	r0, [sp, #0]
c0de10a4:	e000      	b.n	c0de10a8 <aci_gatt_exchange_config+0x40>
c0de10a6:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de10a8:	b2c0      	uxtb	r0, r0
c0de10aa:	b047      	add	sp, #284	; 0x11c
c0de10ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de10ae:	46c0      	nop			; (mov r8, r8)
c0de10b0:	010b003f 	.word	0x010b003f

c0de10b4 <aci_gatt_confirm_indication>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gatt_confirm_indication( uint16_t Connection_Handle )
{
c0de10b4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de10b6:	b0c7      	sub	sp, #284	; 0x11c
c0de10b8:	ae01      	add	r6, sp, #4
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_confirm_indication_cp0 *cp0 = (aci_gatt_confirm_indication_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Connection_Handle = Connection_Handle;
c0de10ba:	8030      	strh	r0, [r6, #0]
c0de10bc:	466f      	mov	r7, sp
c0de10be:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de10c0:	703c      	strb	r4, [r7, #0]
c0de10c2:	ad41      	add	r5, sp, #260	; 0x104
c0de10c4:	2218      	movs	r2, #24
  index_input += 2;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de10c6:	4628      	mov	r0, r5
c0de10c8:	4621      	mov	r1, r4
c0de10ca:	f007 f8a9 	bl	c0de8220 <Osal_MemSet>
c0de10ce:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x125;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de10d0:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de10d2:	9745      	str	r7, [sp, #276]	; 0x114
c0de10d4:	2002      	movs	r0, #2
  rq.clen = index_input;
c0de10d6:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de10d8:	9643      	str	r6, [sp, #268]	; 0x10c
c0de10da:	4807      	ldr	r0, [pc, #28]	; (c0de10f8 <aci_gatt_confirm_indication+0x44>)
  rq.ogf = 0x3f;
c0de10dc:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de10de:	4628      	mov	r0, r5
c0de10e0:	4621      	mov	r1, r4
c0de10e2:	f004 fc59 	bl	c0de5998 <hci_send_req>
c0de10e6:	2800      	cmp	r0, #0
c0de10e8:	d401      	bmi.n	c0de10ee <aci_gatt_confirm_indication+0x3a>
c0de10ea:	9800      	ldr	r0, [sp, #0]
c0de10ec:	e000      	b.n	c0de10f0 <aci_gatt_confirm_indication+0x3c>
c0de10ee:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de10f0:	b2c0      	uxtb	r0, r0
c0de10f2:	b047      	add	sp, #284	; 0x11c
c0de10f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de10f6:	46c0      	nop			; (mov r8, r8)
c0de10f8:	0125003f 	.word	0x0125003f

c0de10fc <aci_gatt_write_resp>:
                                uint16_t Attr_Handle,
                                uint8_t Write_status,
                                uint8_t Error_Code,
                                uint8_t Attribute_Val_Length,
                                const uint8_t* Attribute_Val )
{
c0de10fc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de10fe:	b0c9      	sub	sp, #292	; 0x124
c0de1100:	af03      	add	r7, sp, #12
c0de1102:	9d4e      	ldr	r5, [sp, #312]	; 0x138
  index_input += 2;
  cp0->Write_status = Write_status;
  index_input += 1;
  cp0->Error_Code = Error_Code;
  index_input += 1;
  cp0->Attribute_Val_Length = Attribute_Val_Length;
c0de1104:	71bd      	strb	r5, [r7, #6]
  cp0->Error_Code = Error_Code;
c0de1106:	717b      	strb	r3, [r7, #5]
  cp0->Write_status = Write_status;
c0de1108:	713a      	strb	r2, [r7, #4]
  cp0->Attr_Handle = Attr_Handle;
c0de110a:	8079      	strh	r1, [r7, #2]
  cp0->Connection_Handle = Connection_Handle;
c0de110c:	8038      	strh	r0, [r7, #0]
c0de110e:	a802      	add	r0, sp, #8
c0de1110:	9001      	str	r0, [sp, #4]
c0de1112:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de1114:	7004      	strb	r4, [r0, #0]
  index_input += 1;
  Osal_MemCpy( (void*)&cp0->Attribute_Val, (const void*)Attribute_Val, Attribute_Val_Length );
c0de1116:	1df8      	adds	r0, r7, #7
c0de1118:	994f      	ldr	r1, [sp, #316]	; 0x13c
c0de111a:	462a      	mov	r2, r5
c0de111c:	f007 f87a 	bl	c0de8214 <Osal_MemCpy>
c0de1120:	ae43      	add	r6, sp, #268	; 0x10c
c0de1122:	2218      	movs	r2, #24
  index_input += Attribute_Val_Length;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de1124:	4630      	mov	r0, r6
c0de1126:	4621      	mov	r1, r4
c0de1128:	f007 f87a 	bl	c0de8220 <Osal_MemSet>
c0de112c:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x126;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de112e:	9048      	str	r0, [sp, #288]	; 0x120
  rq.rparam = &status;
c0de1130:	9801      	ldr	r0, [sp, #4]
c0de1132:	9047      	str	r0, [sp, #284]	; 0x11c
  index_input += Attribute_Val_Length;
c0de1134:	1de8      	adds	r0, r5, #7
  rq.clen = index_input;
c0de1136:	9046      	str	r0, [sp, #280]	; 0x118
  rq.cparam = cmd_buffer;
c0de1138:	9745      	str	r7, [sp, #276]	; 0x114
c0de113a:	4807      	ldr	r0, [pc, #28]	; (c0de1158 <aci_gatt_write_resp+0x5c>)
  rq.ogf = 0x3f;
c0de113c:	9043      	str	r0, [sp, #268]	; 0x10c
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de113e:	4630      	mov	r0, r6
c0de1140:	4621      	mov	r1, r4
c0de1142:	f004 fc29 	bl	c0de5998 <hci_send_req>
c0de1146:	2800      	cmp	r0, #0
c0de1148:	d401      	bmi.n	c0de114e <aci_gatt_write_resp+0x52>
c0de114a:	9802      	ldr	r0, [sp, #8]
c0de114c:	e000      	b.n	c0de1150 <aci_gatt_write_resp+0x54>
c0de114e:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de1150:	b2c0      	uxtb	r0, r0
c0de1152:	b049      	add	sp, #292	; 0x124
c0de1154:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1156:	46c0      	nop			; (mov r8, r8)
c0de1158:	0126003f 	.word	0x0126003f

c0de115c <aci_hal_write_config_data>:
}

tBleStatus aci_hal_write_config_data( uint8_t Offset,
                                      uint8_t Length,
                                      const uint8_t* Value )
{
c0de115c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de115e:	b0c9      	sub	sp, #292	; 0x124
c0de1160:	460d      	mov	r5, r1
c0de1162:	af03      	add	r7, sp, #12
  aci_hal_write_config_data_cp0 *cp0 = (aci_hal_write_config_data_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Offset = Offset;
  index_input += 1;
  cp0->Length = Length;
c0de1164:	7079      	strb	r1, [r7, #1]
  cp0->Offset = Offset;
c0de1166:	7038      	strb	r0, [r7, #0]
c0de1168:	a802      	add	r0, sp, #8
c0de116a:	9001      	str	r0, [sp, #4]
c0de116c:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de116e:	7004      	strb	r4, [r0, #0]
  index_input += 1;
  Osal_MemCpy( (void*)&cp0->Value, (const void*)Value, Length );
c0de1170:	1cb8      	adds	r0, r7, #2
c0de1172:	4611      	mov	r1, r2
c0de1174:	462a      	mov	r2, r5
c0de1176:	f007 f84d 	bl	c0de8214 <Osal_MemCpy>
c0de117a:	ae43      	add	r6, sp, #268	; 0x10c
c0de117c:	2218      	movs	r2, #24
  index_input += Length;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de117e:	4630      	mov	r0, r6
c0de1180:	4621      	mov	r1, r4
c0de1182:	f007 f84d 	bl	c0de8220 <Osal_MemSet>
c0de1186:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x00c;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de1188:	9048      	str	r0, [sp, #288]	; 0x120
  rq.rparam = &status;
c0de118a:	9801      	ldr	r0, [sp, #4]
c0de118c:	9047      	str	r0, [sp, #284]	; 0x11c
  index_input += Length;
c0de118e:	1ca8      	adds	r0, r5, #2
  rq.clen = index_input;
c0de1190:	9046      	str	r0, [sp, #280]	; 0x118
  rq.cparam = cmd_buffer;
c0de1192:	9745      	str	r7, [sp, #276]	; 0x114
c0de1194:	4806      	ldr	r0, [pc, #24]	; (c0de11b0 <aci_hal_write_config_data+0x54>)
  rq.ogf = 0x3f;
c0de1196:	9043      	str	r0, [sp, #268]	; 0x10c
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de1198:	4630      	mov	r0, r6
c0de119a:	4621      	mov	r1, r4
c0de119c:	f004 fbfc 	bl	c0de5998 <hci_send_req>
c0de11a0:	2800      	cmp	r0, #0
c0de11a2:	d401      	bmi.n	c0de11a8 <aci_hal_write_config_data+0x4c>
c0de11a4:	9802      	ldr	r0, [sp, #8]
c0de11a6:	e000      	b.n	c0de11aa <aci_hal_write_config_data+0x4e>
c0de11a8:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de11aa:	b2c0      	uxtb	r0, r0
c0de11ac:	b049      	add	sp, #292	; 0x124
c0de11ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de11b0:	000c003f 	.word	0x000c003f

c0de11b4 <aci_hal_set_tx_power_level>:
  return BLE_STATUS_SUCCESS;
}

tBleStatus aci_hal_set_tx_power_level( uint8_t En_High_Power,
                                       uint8_t PA_Level )
{
c0de11b4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de11b6:	b0c7      	sub	sp, #284	; 0x11c
c0de11b8:	ae01      	add	r6, sp, #4
  aci_hal_set_tx_power_level_cp0 *cp0 = (aci_hal_set_tx_power_level_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->En_High_Power = En_High_Power;
  index_input += 1;
  cp0->PA_Level = PA_Level;
c0de11ba:	7071      	strb	r1, [r6, #1]
  cp0->En_High_Power = En_High_Power;
c0de11bc:	7030      	strb	r0, [r6, #0]
c0de11be:	466f      	mov	r7, sp
c0de11c0:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de11c2:	703c      	strb	r4, [r7, #0]
c0de11c4:	ad41      	add	r5, sp, #260	; 0x104
c0de11c6:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de11c8:	4628      	mov	r0, r5
c0de11ca:	4621      	mov	r1, r4
c0de11cc:	f007 f828 	bl	c0de8220 <Osal_MemSet>
c0de11d0:	2001      	movs	r0, #1
  rq.ogf = 0x3f;
  rq.ocf = 0x00f;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de11d2:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de11d4:	9745      	str	r7, [sp, #276]	; 0x114
c0de11d6:	2002      	movs	r0, #2
  rq.clen = index_input;
c0de11d8:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de11da:	9643      	str	r6, [sp, #268]	; 0x10c
c0de11dc:	4806      	ldr	r0, [pc, #24]	; (c0de11f8 <aci_hal_set_tx_power_level+0x44>)
  rq.ogf = 0x3f;
c0de11de:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de11e0:	4628      	mov	r0, r5
c0de11e2:	4621      	mov	r1, r4
c0de11e4:	f004 fbd8 	bl	c0de5998 <hci_send_req>
c0de11e8:	2800      	cmp	r0, #0
c0de11ea:	d401      	bmi.n	c0de11f0 <aci_hal_set_tx_power_level+0x3c>
c0de11ec:	9800      	ldr	r0, [sp, #0]
c0de11ee:	e000      	b.n	c0de11f2 <aci_hal_set_tx_power_level+0x3e>
c0de11f0:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de11f2:	b2c0      	uxtb	r0, r0
c0de11f4:	b047      	add	sp, #284	; 0x11c
c0de11f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de11f8:	000f003f 	.word	0x000f003f

c0de11fc <hci_reset>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus hci_reset( void )
{
c0de11fc:	b570      	push	{r4, r5, r6, lr}
c0de11fe:	b088      	sub	sp, #32
c0de1200:	ae01      	add	r6, sp, #4
c0de1202:	2400      	movs	r4, #0
  struct hci_request rq;
  tBleStatus status = 0;
c0de1204:	7034      	strb	r4, [r6, #0]
c0de1206:	ad02      	add	r5, sp, #8
c0de1208:	2218      	movs	r2, #24
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de120a:	4628      	mov	r0, r5
c0de120c:	4621      	mov	r1, r4
c0de120e:	f007 f807 	bl	c0de8220 <Osal_MemSet>
c0de1212:	2001      	movs	r0, #1
  rq.ogf = 0x03;
  rq.ocf = 0x003;
  rq.rparam = &status;
  rq.rlen = 1;
c0de1214:	9007      	str	r0, [sp, #28]
  rq.rparam = &status;
c0de1216:	9606      	str	r6, [sp, #24]
c0de1218:	4806      	ldr	r0, [pc, #24]	; (c0de1234 <hci_reset+0x38>)
  rq.ogf = 0x03;
c0de121a:	9002      	str	r0, [sp, #8]
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de121c:	4628      	mov	r0, r5
c0de121e:	4621      	mov	r1, r4
c0de1220:	f004 fbba 	bl	c0de5998 <hci_send_req>
c0de1224:	2800      	cmp	r0, #0
c0de1226:	d401      	bmi.n	c0de122c <hci_reset+0x30>
c0de1228:	9801      	ldr	r0, [sp, #4]
c0de122a:	e000      	b.n	c0de122e <hci_reset+0x32>
c0de122c:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de122e:	b2c0      	uxtb	r0, r0
c0de1230:	b008      	add	sp, #32
c0de1232:	bd70      	pop	{r4, r5, r6, pc}
c0de1234:	00030003 	.word	0x00030003

c0de1238 <hci_le_set_advertising_parameters>:
                                              uint8_t Own_Address_Type,
                                              uint8_t Peer_Address_Type,
                                              const uint8_t* Peer_Address,
                                              uint8_t Advertising_Channel_Map,
                                              uint8_t Advertising_Filter_Policy )
{
c0de1238:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de123a:	b0c7      	sub	sp, #284	; 0x11c
c0de123c:	ae01      	add	r6, sp, #4
c0de123e:	9c4c      	ldr	r4, [sp, #304]	; 0x130
  index_input += 2;
  cp0->Advertising_Type = Advertising_Type;
  index_input += 1;
  cp0->Own_Address_Type = Own_Address_Type;
  index_input += 1;
  cp0->Peer_Address_Type = Peer_Address_Type;
c0de1240:	71b4      	strb	r4, [r6, #6]
  cp0->Own_Address_Type = Own_Address_Type;
c0de1242:	7173      	strb	r3, [r6, #5]
  cp0->Advertising_Type = Advertising_Type;
c0de1244:	7132      	strb	r2, [r6, #4]
  cp0->Advertising_Interval_Max = Advertising_Interval_Max;
c0de1246:	8071      	strh	r1, [r6, #2]
  cp0->Advertising_Interval_Min = Advertising_Interval_Min;
c0de1248:	8030      	strh	r0, [r6, #0]
c0de124a:	466f      	mov	r7, sp
c0de124c:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de124e:	703c      	strb	r4, [r7, #0]
  index_input += 1;
  Osal_MemCpy( (void*)&cp0->Peer_Address, (const void*)Peer_Address, 6 );
c0de1250:	1df0      	adds	r0, r6, #7
c0de1252:	994d      	ldr	r1, [sp, #308]	; 0x134
c0de1254:	2206      	movs	r2, #6
c0de1256:	f006 ffdd 	bl	c0de8214 <Osal_MemCpy>
c0de125a:	984f      	ldr	r0, [sp, #316]	; 0x13c
  index_input += 6;
  cp0->Advertising_Channel_Map = Advertising_Channel_Map;
  index_input += 1;
  cp0->Advertising_Filter_Policy = Advertising_Filter_Policy;
c0de125c:	73b0      	strb	r0, [r6, #14]
c0de125e:	984e      	ldr	r0, [sp, #312]	; 0x138
  cp0->Advertising_Channel_Map = Advertising_Channel_Map;
c0de1260:	7370      	strb	r0, [r6, #13]
c0de1262:	ad41      	add	r5, sp, #260	; 0x104
c0de1264:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de1266:	4628      	mov	r0, r5
c0de1268:	4621      	mov	r1, r4
c0de126a:	f006 ffd9 	bl	c0de8220 <Osal_MemSet>
c0de126e:	2001      	movs	r0, #1
  rq.ogf = 0x08;
  rq.ocf = 0x006;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de1270:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de1272:	9745      	str	r7, [sp, #276]	; 0x114
c0de1274:	200f      	movs	r0, #15
  rq.clen = index_input;
c0de1276:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de1278:	9643      	str	r6, [sp, #268]	; 0x10c
c0de127a:	4807      	ldr	r0, [pc, #28]	; (c0de1298 <hci_le_set_advertising_parameters+0x60>)
  rq.ogf = 0x08;
c0de127c:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de127e:	4628      	mov	r0, r5
c0de1280:	4621      	mov	r1, r4
c0de1282:	f004 fb89 	bl	c0de5998 <hci_send_req>
c0de1286:	2800      	cmp	r0, #0
c0de1288:	d401      	bmi.n	c0de128e <hci_le_set_advertising_parameters+0x56>
c0de128a:	9800      	ldr	r0, [sp, #0]
c0de128c:	e000      	b.n	c0de1290 <hci_le_set_advertising_parameters+0x58>
c0de128e:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de1290:	b2c0      	uxtb	r0, r0
c0de1292:	b047      	add	sp, #284	; 0x11c
c0de1294:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1296:	46c0      	nop			; (mov r8, r8)
c0de1298:	00060008 	.word	0x00060008

c0de129c <hci_le_set_advertising_data>:
  return BLE_STATUS_SUCCESS;
}

tBleStatus hci_le_set_advertising_data( uint8_t Advertising_Data_Length,
                                        const uint8_t* Advertising_Data )
{
c0de129c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de129e:	b0c7      	sub	sp, #284	; 0x11c
c0de12a0:	ae01      	add	r6, sp, #4
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  hci_le_set_advertising_data_cp0 *cp0 = (hci_le_set_advertising_data_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Advertising_Data_Length = Advertising_Data_Length;
c0de12a2:	7030      	strb	r0, [r6, #0]
c0de12a4:	466f      	mov	r7, sp
c0de12a6:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de12a8:	703c      	strb	r4, [r7, #0]
  index_input += 1;
  Osal_MemCpy( (void*)&cp0->Advertising_Data, (const void*)Advertising_Data, 31 );
c0de12aa:	1c70      	adds	r0, r6, #1
c0de12ac:	221f      	movs	r2, #31
c0de12ae:	f006 ffb1 	bl	c0de8214 <Osal_MemCpy>
c0de12b2:	ad41      	add	r5, sp, #260	; 0x104
c0de12b4:	2218      	movs	r2, #24
  index_input += 31;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de12b6:	4628      	mov	r0, r5
c0de12b8:	4621      	mov	r1, r4
c0de12ba:	f006 ffb1 	bl	c0de8220 <Osal_MemSet>
c0de12be:	2001      	movs	r0, #1
  rq.ogf = 0x08;
  rq.ocf = 0x008;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de12c0:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de12c2:	9745      	str	r7, [sp, #276]	; 0x114
c0de12c4:	2020      	movs	r0, #32
  rq.clen = index_input;
c0de12c6:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de12c8:	9643      	str	r6, [sp, #268]	; 0x10c
c0de12ca:	4807      	ldr	r0, [pc, #28]	; (c0de12e8 <hci_le_set_advertising_data+0x4c>)
  rq.ogf = 0x08;
c0de12cc:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de12ce:	4628      	mov	r0, r5
c0de12d0:	4621      	mov	r1, r4
c0de12d2:	f004 fb61 	bl	c0de5998 <hci_send_req>
c0de12d6:	2800      	cmp	r0, #0
c0de12d8:	d401      	bmi.n	c0de12de <hci_le_set_advertising_data+0x42>
c0de12da:	9800      	ldr	r0, [sp, #0]
c0de12dc:	e000      	b.n	c0de12e0 <hci_le_set_advertising_data+0x44>
c0de12de:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de12e0:	b2c0      	uxtb	r0, r0
c0de12e2:	b047      	add	sp, #284	; 0x11c
c0de12e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de12e6:	46c0      	nop			; (mov r8, r8)
c0de12e8:	00080008 	.word	0x00080008

c0de12ec <hci_le_set_scan_response_data>:

tBleStatus hci_le_set_scan_response_data( uint8_t Scan_Response_Data_Length,
                                          const uint8_t* Scan_Response_Data )
{
c0de12ec:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de12ee:	b0c7      	sub	sp, #284	; 0x11c
c0de12f0:	ae01      	add	r6, sp, #4
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  hci_le_set_scan_response_data_cp0 *cp0 = (hci_le_set_scan_response_data_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Scan_Response_Data_Length = Scan_Response_Data_Length;
c0de12f2:	7030      	strb	r0, [r6, #0]
c0de12f4:	466f      	mov	r7, sp
c0de12f6:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de12f8:	703c      	strb	r4, [r7, #0]
  index_input += 1;
  Osal_MemCpy( (void*)&cp0->Scan_Response_Data, (const void*)Scan_Response_Data, 31 );
c0de12fa:	1c70      	adds	r0, r6, #1
c0de12fc:	221f      	movs	r2, #31
c0de12fe:	f006 ff89 	bl	c0de8214 <Osal_MemCpy>
c0de1302:	ad41      	add	r5, sp, #260	; 0x104
c0de1304:	2218      	movs	r2, #24
  index_input += 31;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de1306:	4628      	mov	r0, r5
c0de1308:	4621      	mov	r1, r4
c0de130a:	f006 ff89 	bl	c0de8220 <Osal_MemSet>
c0de130e:	2001      	movs	r0, #1
  rq.ogf = 0x08;
  rq.ocf = 0x009;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de1310:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de1312:	9745      	str	r7, [sp, #276]	; 0x114
c0de1314:	2020      	movs	r0, #32
  rq.clen = index_input;
c0de1316:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de1318:	9643      	str	r6, [sp, #268]	; 0x10c
c0de131a:	4807      	ldr	r0, [pc, #28]	; (c0de1338 <hci_le_set_scan_response_data+0x4c>)
  rq.ogf = 0x08;
c0de131c:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de131e:	4628      	mov	r0, r5
c0de1320:	4621      	mov	r1, r4
c0de1322:	f004 fb39 	bl	c0de5998 <hci_send_req>
c0de1326:	2800      	cmp	r0, #0
c0de1328:	d401      	bmi.n	c0de132e <hci_le_set_scan_response_data+0x42>
c0de132a:	9800      	ldr	r0, [sp, #0]
c0de132c:	e000      	b.n	c0de1330 <hci_le_set_scan_response_data+0x44>
c0de132e:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de1330:	b2c0      	uxtb	r0, r0
c0de1332:	b047      	add	sp, #284	; 0x11c
c0de1334:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1336:	46c0      	nop			; (mov r8, r8)
c0de1338:	00090008 	.word	0x00090008

c0de133c <hci_le_set_advertise_enable>:

tBleStatus hci_le_set_advertise_enable( uint8_t Advertising_Enable )
{
c0de133c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de133e:	b0c7      	sub	sp, #284	; 0x11c
c0de1340:	ae01      	add	r6, sp, #4
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  hci_le_set_advertise_enable_cp0 *cp0 = (hci_le_set_advertise_enable_cp0*)(cmd_buffer);
  tBleStatus status = 0;
  int index_input = 0;
  cp0->Advertising_Enable = Advertising_Enable;
c0de1342:	7030      	strb	r0, [r6, #0]
c0de1344:	466f      	mov	r7, sp
c0de1346:	2400      	movs	r4, #0
  tBleStatus status = 0;
c0de1348:	703c      	strb	r4, [r7, #0]
c0de134a:	ad41      	add	r5, sp, #260	; 0x104
c0de134c:	2218      	movs	r2, #24
  index_input += 1;
  Osal_MemSet( &rq, 0, sizeof(rq) );
c0de134e:	4628      	mov	r0, r5
c0de1350:	4621      	mov	r1, r4
c0de1352:	f006 ff65 	bl	c0de8220 <Osal_MemSet>
c0de1356:	2001      	movs	r0, #1
  rq.ogf = 0x08;
  rq.ocf = 0x00a;
  rq.cparam = cmd_buffer;
  rq.clen = index_input;
  rq.rparam = &status;
  rq.rlen = 1;
c0de1358:	9046      	str	r0, [sp, #280]	; 0x118
  rq.rparam = &status;
c0de135a:	9745      	str	r7, [sp, #276]	; 0x114
  rq.clen = index_input;
c0de135c:	9044      	str	r0, [sp, #272]	; 0x110
  rq.cparam = cmd_buffer;
c0de135e:	9643      	str	r6, [sp, #268]	; 0x10c
c0de1360:	4806      	ldr	r0, [pc, #24]	; (c0de137c <hci_le_set_advertise_enable+0x40>)
  rq.ogf = 0x08;
c0de1362:	9041      	str	r0, [sp, #260]	; 0x104
  if ( hci_send_req(&rq, FALSE) < 0 )
c0de1364:	4628      	mov	r0, r5
c0de1366:	4621      	mov	r1, r4
c0de1368:	f004 fb16 	bl	c0de5998 <hci_send_req>
c0de136c:	2800      	cmp	r0, #0
c0de136e:	d401      	bmi.n	c0de1374 <hci_le_set_advertise_enable+0x38>
c0de1370:	9800      	ldr	r0, [sp, #0]
c0de1372:	e000      	b.n	c0de1376 <hci_le_set_advertise_enable+0x3a>
c0de1374:	43e0      	mvns	r0, r4
    return BLE_STATUS_TIMEOUT;
  return status;
}
c0de1376:	b2c0      	uxtb	r0, r0
c0de1378:	b047      	add	sp, #284	; 0x11c
c0de137a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de137c:	000a0008 	.word	0x000a0008

c0de1380 <handleGetAppConfiguration>:
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(workBuffer);
    UNUSED(dataLength);
    UNUSED(flags);
    G_io_apdu_buffer[0] = (N_storage.dataAllowed ? APP_FLAG_DATA_ALLOWED : 0x00);
c0de1380:	480c      	ldr	r0, [pc, #48]	; (c0de13b4 <handleGetAppConfiguration+0x34>)
c0de1382:	4478      	add	r0, pc
c0de1384:	f006 ff5e 	bl	c0de8244 <pic>
c0de1388:	7800      	ldrb	r0, [r0, #0]
c0de138a:	1e41      	subs	r1, r0, #1
c0de138c:	4188      	sbcs	r0, r1
#ifndef HAVE_TOKENS_LIST
    G_io_apdu_buffer[0] |= APP_FLAG_EXTERNAL_TOKEN_NEEDED;
#endif
#ifdef HAVE_STARKWARE
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE;
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE_V2;
c0de138e:	300e      	adds	r0, #14
c0de1390:	4907      	ldr	r1, [pc, #28]	; (c0de13b0 <handleGetAppConfiguration+0x30>)
c0de1392:	464a      	mov	r2, r9
c0de1394:	5450      	strb	r0, [r2, r1]
c0de1396:	1850      	adds	r0, r2, r1
c0de1398:	2101      	movs	r1, #1
#endif
    G_io_apdu_buffer[1] = LEDGER_MAJOR_VERSION;
c0de139a:	7041      	strb	r1, [r0, #1]
c0de139c:	2109      	movs	r1, #9
    G_io_apdu_buffer[2] = LEDGER_MINOR_VERSION;
c0de139e:	7081      	strb	r1, [r0, #2]
c0de13a0:	2213      	movs	r2, #19
    G_io_apdu_buffer[3] = LEDGER_PATCH_VERSION;
c0de13a2:	70c2      	strb	r2, [r0, #3]
c0de13a4:	9801      	ldr	r0, [sp, #4]
c0de13a6:	2204      	movs	r2, #4
    *tx = 4;
c0de13a8:	6002      	str	r2, [r0, #0]
c0de13aa:	0308      	lsls	r0, r1, #12
    THROW(0x9000);
c0de13ac:	f006 f83b 	bl	c0de7426 <os_longjmp>
c0de13b0:	00000990 	.word	0x00000990
c0de13b4:	0001037a 	.word	0x0001037a

c0de13b8 <getEth2PublicKey>:
static const uint8_t BLS12_381_FIELD_MODULUS[] = {
    0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6, 0x43, 0x4b, 0xac, 0xd7,
    0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf, 0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24,
    0x1e, 0xab, 0xff, 0xfe, 0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xab};

void getEth2PublicKey(uint32_t *bip32Path, uint8_t bip32PathLength, uint8_t *out) {
c0de13b8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de13ba:	b0cf      	sub	sp, #316	; 0x13c
c0de13bc:	9200      	str	r2, [sp, #0]
c0de13be:	460f      	mov	r7, r1
c0de13c0:	4604      	mov	r4, r0
    cx_ecfp_256_extended_private_key_t privateKey;
    cx_ecfp_384_public_key_t publicKey;
    uint8_t yFlag = 0;
    uint8_t tmp[96];

    io_seproxyhal_io_heartbeat();
c0de13c2:	f006 fbed 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de13c6:	2539      	movs	r5, #57	; 0x39
c0de13c8:	ae46      	add	r6, sp, #280	; 0x118
    os_perso_derive_eip2333(CX_CURVE_BLS12_381_G1, bip32Path, bip32PathLength, privateKeyData);
c0de13ca:	4628      	mov	r0, r5
c0de13cc:	4621      	mov	r1, r4
c0de13ce:	463a      	mov	r2, r7
c0de13d0:	4633      	mov	r3, r6
c0de13d2:	f007 ff1f 	bl	c0de9214 <os_perso_derive_eip2333>
    io_seproxyhal_io_heartbeat();
c0de13d6:	f006 fbe3 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de13da:	2000      	movs	r0, #0
    memset(tmp, 0, 48);
c0de13dc:	9004      	str	r0, [sp, #16]
c0de13de:	9003      	str	r0, [sp, #12]
c0de13e0:	9002      	str	r0, [sp, #8]
c0de13e2:	9001      	str	r0, [sp, #4]
c0de13e4:	ac01      	add	r4, sp, #4
    memmove(tmp + 16, privateKeyData, 32);
c0de13e6:	4620      	mov	r0, r4
c0de13e8:	3010      	adds	r0, #16
c0de13ea:	2220      	movs	r2, #32
c0de13ec:	4631      	mov	r1, r6
c0de13ee:	f00c fa17 	bl	c0ded820 <__aeabi_memcpy>
c0de13f2:	2230      	movs	r2, #48	; 0x30
c0de13f4:	ab34      	add	r3, sp, #208	; 0xd0
 * @throws             CX_EC_INVALID_CURVE
 * @throws             CX_INVALID_PARAMETER
 */
static inline int cx_ecfp_init_private_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_private_key_t * pvkey )
{
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de13f6:	4628      	mov	r0, r5
c0de13f8:	4621      	mov	r1, r4
c0de13fa:	f001 fe27 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de13fe:	2800      	cmp	r0, #0
c0de1400:	d13c      	bne.n	c0de147c <getEth2PublicKey+0xc4>
c0de1402:	2039      	movs	r0, #57	; 0x39
c0de1404:	a919      	add	r1, sp, #100	; 0x64
c0de1406:	aa34      	add	r2, sp, #208	; 0xd0
c0de1408:	2301      	movs	r3, #1
 * @throws                 CX_EC_INVALID_POINT
 * @throws                 CX_EC_INFINITE_POINT
 */
static inline int cx_ecfp_generate_pair ( cx_curve_t curve, cx_ecfp_public_key_t * pubkey, cx_ecfp_private_key_t * privkey, int keepprivate )
{
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de140a:	f001 fe19 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de140e:	2800      	cmp	r0, #0
c0de1410:	d134      	bne.n	c0de147c <getEth2PublicKey+0xc4>
c0de1412:	ae01      	add	r6, sp, #4
c0de1414:	2160      	movs	r1, #96	; 0x60
    cx_ecfp_init_private_key(CX_CURVE_BLS12_381_G1, tmp, 48, (cx_ecfp_private_key_t *) &privateKey);
    cx_ecfp_generate_pair(CX_CURVE_BLS12_381_G1,
                          (cx_ecfp_public_key_t *) &publicKey,
                          (cx_ecfp_private_key_t *) &privateKey,
                          1);
    explicit_bzero(tmp, 96);
c0de1416:	4630      	mov	r0, r6
c0de1418:	f00c fa12 	bl	c0ded840 <explicit_bzero>
c0de141c:	a834      	add	r0, sp, #208	; 0xd0
c0de141e:	2148      	movs	r1, #72	; 0x48
    explicit_bzero((void *) &privateKey, sizeof(cx_ecfp_256_extended_private_key_t));
c0de1420:	f00c fa0e 	bl	c0ded840 <explicit_bzero>
c0de1424:	202f      	movs	r0, #47	; 0x2f
c0de1426:	2102      	movs	r1, #2
    tmp[47] = 2;
c0de1428:	5431      	strb	r1, [r6, r0]
c0de142a:	ad19      	add	r5, sp, #100	; 0x64
    cx_math_mult(tmp, publicKey.W + 1 + 48, tmp, 48);
c0de142c:	4629      	mov	r1, r5
c0de142e:	3139      	adds	r1, #57	; 0x39
c0de1430:	2330      	movs	r3, #48	; 0x30
 * @throws         CX_NOT_LOCKED
 * @throws         CX_MEMORY_FULL
 * @throws         CX_INVALID_PARAMETER
 */
static inline void cx_math_mult(uint8_t *r, const uint8_t *a, const uint8_t *b, size_t len) {
  CX_THROW(cx_math_mult_no_throw(r, a, b, len));
c0de1432:	4630      	mov	r0, r6
c0de1434:	4632      	mov	r2, r6
c0de1436:	f001 fe45 	bl	c0de30c4 <cx_math_mult_no_throw>
c0de143a:	2800      	cmp	r0, #0
c0de143c:	d11e      	bne.n	c0de147c <getEth2PublicKey+0xc4>
c0de143e:	a801      	add	r0, sp, #4
    if (cx_math_cmp(tmp + 48, BLS12_381_FIELD_MODULUS, 48) > 0) {
c0de1440:	3030      	adds	r0, #48	; 0x30
  CX_THROW(cx_math_cmp_no_throw(a, b, length, &diff));
c0de1442:	490f      	ldr	r1, [pc, #60]	; (c0de1480 <getEth2PublicKey+0xc8>)
c0de1444:	4479      	add	r1, pc
c0de1446:	2230      	movs	r2, #48	; 0x30
c0de1448:	ab4e      	add	r3, sp, #312	; 0x138
c0de144a:	f001 fe2f 	bl	c0de30ac <cx_math_cmp_no_throw>
c0de144e:	2800      	cmp	r0, #0
c0de1450:	d114      	bne.n	c0de147c <getEth2PublicKey+0xc4>
c0de1452:	3509      	adds	r5, #9
  return diff;
c0de1454:	984e      	ldr	r0, [sp, #312]	; 0x138
c0de1456:	2800      	cmp	r0, #0
c0de1458:	dc01      	bgt.n	c0de145e <getEth2PublicKey+0xa6>
c0de145a:	207f      	movs	r0, #127	; 0x7f
c0de145c:	e000      	b.n	c0de1460 <getEth2PublicKey+0xa8>
c0de145e:	205f      	movs	r0, #95	; 0x5f
c0de1460:	43c0      	mvns	r0, r0
c0de1462:	a919      	add	r1, sp, #100	; 0x64
        yFlag = 0x20;
    }
    publicKey.W[1] &= 0x1f;
c0de1464:	7a4a      	ldrb	r2, [r1, #9]
c0de1466:	231f      	movs	r3, #31
c0de1468:	4013      	ands	r3, r2
    publicKey.W[1] |= 0x80 | yFlag;
c0de146a:	1818      	adds	r0, r3, r0
c0de146c:	7248      	strb	r0, [r1, #9]
c0de146e:	2230      	movs	r2, #48	; 0x30
    memmove(out, publicKey.W + 1, 48);
c0de1470:	9800      	ldr	r0, [sp, #0]
c0de1472:	4629      	mov	r1, r5
c0de1474:	f00c f9d4 	bl	c0ded820 <__aeabi_memcpy>
}
c0de1478:	b04f      	add	sp, #316	; 0x13c
c0de147a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de147c:	f005 ffd3 	bl	c0de7426 <os_longjmp>
c0de1480:	0000e1c4 	.word	0x0000e1c4

c0de1484 <handleGetEth2PublicKey>:
void handleGetEth2PublicKey(uint8_t p1,
                            uint8_t p2,
                            uint8_t *dataBuffer,
                            uint16_t dataLength,
                            unsigned int *flags,
                            unsigned int *tx) {
c0de1484:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de1486:	b08b      	sub	sp, #44	; 0x2c
c0de1488:	4616      	mov	r6, r2
c0de148a:	460f      	mov	r7, r1
c0de148c:	4604      	mov	r4, r0
    UNUSED(dataLength);
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);

    if (!called_from_swap) {
c0de148e:	4826      	ldr	r0, [pc, #152]	; (c0de1528 <handleGetEth2PublicKey+0xa4>)
c0de1490:	4649      	mov	r1, r9
c0de1492:	5c08      	ldrb	r0, [r1, r0]
    uint8_t bip32PathLength = *(dataBuffer++);
c0de1494:	7815      	ldrb	r5, [r2, #0]
    if (!called_from_swap) {
c0de1496:	2800      	cmp	r0, #0
c0de1498:	d101      	bne.n	c0de149e <handleGetEth2PublicKey+0x1a>
        reset_app_context();
c0de149a:	f005 f8e3 	bl	c0de6664 <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0de149e:	1e68      	subs	r0, r5, #1
c0de14a0:	b2c0      	uxtb	r0, r0
c0de14a2:	280a      	cmp	r0, #10
c0de14a4:	d234      	bcs.n	c0de1510 <handleGetEth2PublicKey+0x8c>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0de14a6:	2c02      	cmp	r4, #2
c0de14a8:	d22d      	bcs.n	c0de1506 <handleGetEth2PublicKey+0x82>
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0de14aa:	2f00      	cmp	r7, #0
c0de14ac:	d12b      	bne.n	c0de1506 <handleGetEth2PublicKey+0x82>
c0de14ae:	1c70      	adds	r0, r6, #1
c0de14b0:	9911      	ldr	r1, [sp, #68]	; 0x44
c0de14b2:	9100      	str	r1, [sp, #0]
c0de14b4:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0de14b6:	a901      	add	r1, sp, #4
c0de14b8:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
c0de14ba:	2a00      	cmp	r2, #0
c0de14bc:	d00d      	beq.n	c0de14da <handleGetEth2PublicKey+0x56>
   ((lo0)&0xFFu))
static inline uint16_t U2BE(const uint8_t *buf, size_t off) {
  return (buf[off] << 8) | buf[off + 1];
}
static inline uint32_t U4BE(const uint8_t *buf, size_t off) {
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de14be:	7803      	ldrb	r3, [r0, #0]
c0de14c0:	061b      	lsls	r3, r3, #24
c0de14c2:	7847      	ldrb	r7, [r0, #1]
c0de14c4:	043f      	lsls	r7, r7, #16
c0de14c6:	18fb      	adds	r3, r7, r3
         (buf[off + 2] << 8) | buf[off + 3];
c0de14c8:	7887      	ldrb	r7, [r0, #2]
c0de14ca:	023f      	lsls	r7, r7, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de14cc:	19db      	adds	r3, r3, r7
         (buf[off + 2] << 8) | buf[off + 3];
c0de14ce:	78c7      	ldrb	r7, [r0, #3]
c0de14d0:	19db      	adds	r3, r3, r7
        bip32Path[i] = U4BE(dataBuffer, 0);
c0de14d2:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0de14d4:	1d00      	adds	r0, r0, #4
c0de14d6:	1e52      	subs	r2, r2, #1
c0de14d8:	e7ef      	b.n	c0de14ba <handleGetEth2PublicKey+0x36>
        dataBuffer += 4;
    }
    getEth2PublicKey(bip32Path, bip32PathLength, tmpCtx.publicKeyContext.publicKey.W);
c0de14da:	4814      	ldr	r0, [pc, #80]	; (c0de152c <handleGetEth2PublicKey+0xa8>)
c0de14dc:	4649      	mov	r1, r9
c0de14de:	180a      	adds	r2, r1, r0
c0de14e0:	3208      	adds	r2, #8
c0de14e2:	a801      	add	r0, sp, #4
c0de14e4:	4629      	mov	r1, r5
c0de14e6:	f7ff ff67 	bl	c0de13b8 <getEth2PublicKey>

#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0de14ea:	2c00      	cmp	r4, #0
c0de14ec:	d014      	beq.n	c0de1518 <handleGetEth2PublicKey+0x94>
        *tx = set_result_get_eth2_publicKey();
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        ux_flow_init(0, ux_display_public_eth2_flow, NULL);
c0de14ee:	4910      	ldr	r1, [pc, #64]	; (c0de1530 <handleGetEth2PublicKey+0xac>)
c0de14f0:	4479      	add	r1, pc
c0de14f2:	2000      	movs	r0, #0
c0de14f4:	4602      	mov	r2, r0
c0de14f6:	f00b fa45 	bl	c0dec984 <ux_flow_init>

        *flags |= IO_ASYNCH_REPLY;
c0de14fa:	6830      	ldr	r0, [r6, #0]
c0de14fc:	2110      	movs	r1, #16
c0de14fe:	4301      	orrs	r1, r0
c0de1500:	6031      	str	r1, [r6, #0]
    }
#endif  // NO_CONSENT
}
c0de1502:	b00b      	add	sp, #44	; 0x2c
c0de1504:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1506:	20d5      	movs	r0, #213	; 0xd5
c0de1508:	01c0      	lsls	r0, r0, #7
c0de150a:	3080      	adds	r0, #128	; 0x80
c0de150c:	f005 ff8b 	bl	c0de7426 <os_longjmp>
c0de1510:	20d5      	movs	r0, #213	; 0xd5
c0de1512:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0de1514:	f005 ff87 	bl	c0de7426 <os_longjmp>
        *tx = set_result_get_eth2_publicKey();
c0de1518:	f004 fc62 	bl	c0de5de0 <set_result_get_eth2_publicKey>
c0de151c:	9900      	ldr	r1, [sp, #0]
c0de151e:	6008      	str	r0, [r1, #0]
c0de1520:	2009      	movs	r0, #9
c0de1522:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0de1524:	f005 ff7f 	bl	c0de7426 <os_longjmp>
c0de1528:	0000011d 	.word	0x0000011d
c0de152c:	00000124 	.word	0x00000124
c0de1530:	0000ed78 	.word	0x0000ed78

c0de1534 <handleGetPublicKey>:
void handleGetPublicKey(uint8_t p1,
                        uint8_t p2,
                        uint8_t *dataBuffer,
                        uint16_t dataLength,
                        unsigned int *flags,
                        unsigned int *tx) {
c0de1534:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de1536:	b0a1      	sub	sp, #132	; 0x84
c0de1538:	4617      	mov	r7, r2
c0de153a:	460e      	mov	r6, r1
c0de153c:	4604      	mov	r4, r0
    uint8_t privateKeyData[INT256_LENGTH];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);
    cx_ecfp_private_key_t privateKey;
    if (!called_from_swap) {
c0de153e:	484c      	ldr	r0, [pc, #304]	; (c0de1670 <handleGetPublicKey+0x13c>)
c0de1540:	4649      	mov	r1, r9
c0de1542:	5c08      	ldrb	r0, [r1, r0]
    uint8_t bip32PathLength = *(dataBuffer++);
c0de1544:	7815      	ldrb	r5, [r2, #0]
    if (!called_from_swap) {
c0de1546:	2800      	cmp	r0, #0
c0de1548:	d101      	bne.n	c0de154e <handleGetPublicKey+0x1a>
        reset_app_context();
c0de154a:	f005 f88b 	bl	c0de6664 <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0de154e:	1e68      	subs	r0, r5, #1
c0de1550:	280a      	cmp	r0, #10
c0de1552:	d300      	bcc.n	c0de1556 <handleGetPublicKey+0x22>
c0de1554:	e080      	b.n	c0de1658 <handleGetPublicKey+0x124>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0de1556:	2c02      	cmp	r4, #2
c0de1558:	d279      	bcs.n	c0de164e <handleGetPublicKey+0x11a>
c0de155a:	9403      	str	r4, [sp, #12]
        THROW(0x6B00);
    }
    if ((p2 != P2_CHAINCODE) && (p2 != P2_NO_CHAINCODE)) {
c0de155c:	2e01      	cmp	r6, #1
c0de155e:	d876      	bhi.n	c0de164e <handleGetPublicKey+0x11a>
c0de1560:	1c78      	adds	r0, r7, #1
c0de1562:	9927      	ldr	r1, [sp, #156]	; 0x9c
c0de1564:	9102      	str	r1, [sp, #8]
c0de1566:	9926      	ldr	r1, [sp, #152]	; 0x98
c0de1568:	9104      	str	r1, [sp, #16]
c0de156a:	a90f      	add	r1, sp, #60	; 0x3c
c0de156c:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
c0de156e:	2a00      	cmp	r2, #0
c0de1570:	d00d      	beq.n	c0de158e <handleGetPublicKey+0x5a>
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1572:	7803      	ldrb	r3, [r0, #0]
c0de1574:	061b      	lsls	r3, r3, #24
c0de1576:	7844      	ldrb	r4, [r0, #1]
c0de1578:	0424      	lsls	r4, r4, #16
c0de157a:	18e3      	adds	r3, r4, r3
         (buf[off + 2] << 8) | buf[off + 3];
c0de157c:	7884      	ldrb	r4, [r0, #2]
c0de157e:	0224      	lsls	r4, r4, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1580:	191b      	adds	r3, r3, r4
         (buf[off + 2] << 8) | buf[off + 3];
c0de1582:	78c4      	ldrb	r4, [r0, #3]
c0de1584:	191b      	adds	r3, r3, r4
        bip32Path[i] = U4BE(dataBuffer, 0);
c0de1586:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0de1588:	1d00      	adds	r0, r0, #4
c0de158a:	1e52      	subs	r2, r2, #1
c0de158c:	e7ef      	b.n	c0de156e <handleGetPublicKey+0x3a>
        dataBuffer += 4;
    }
    tmpCtx.publicKeyContext.getChaincode = (p2 == P2_CHAINCODE);
c0de158e:	1e70      	subs	r0, r6, #1
c0de1590:	4241      	negs	r1, r0
c0de1592:	4141      	adcs	r1, r0
c0de1594:	4c37      	ldr	r4, [pc, #220]	; (c0de1674 <handleGetPublicKey+0x140>)
c0de1596:	4648      	mov	r0, r9
c0de1598:	1906      	adds	r6, r0, r4
c0de159a:	2795      	movs	r7, #149	; 0x95
c0de159c:	55f1      	strb	r1, [r6, r7]
    io_seproxyhal_io_heartbeat();
c0de159e:	f006 faff 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(
        CX_CURVE_256K1,
        bip32Path,
        bip32PathLength,
        privateKeyData,
        (tmpCtx.publicKeyContext.getChaincode ? tmpCtx.publicKeyContext.chainCode : NULL));
c0de15a2:	5df0      	ldrb	r0, [r6, r7]
c0de15a4:	2800      	cmp	r0, #0
c0de15a6:	d101      	bne.n	c0de15ac <handleGetPublicKey+0x78>
c0de15a8:	4606      	mov	r6, r0
c0de15aa:	e000      	b.n	c0de15ae <handleGetPublicKey+0x7a>
c0de15ac:	3675      	adds	r6, #117	; 0x75
    os_perso_derive_node_bip32(
c0de15ae:	9600      	str	r6, [sp, #0]
c0de15b0:	2621      	movs	r6, #33	; 0x21
c0de15b2:	a90f      	add	r1, sp, #60	; 0x3c
c0de15b4:	af19      	add	r7, sp, #100	; 0x64
c0de15b6:	4630      	mov	r0, r6
c0de15b8:	462a      	mov	r2, r5
c0de15ba:	463b      	mov	r3, r7
c0de15bc:	f007 fe1a 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0de15c0:	2220      	movs	r2, #32
c0de15c2:	ab05      	add	r3, sp, #20
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de15c4:	4630      	mov	r0, r6
c0de15c6:	4639      	mov	r1, r7
c0de15c8:	f001 fd40 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de15cc:	2800      	cmp	r0, #0
c0de15ce:	d141      	bne.n	c0de1654 <handleGetPublicKey+0x120>
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
    io_seproxyhal_io_heartbeat();
c0de15d0:	f006 fae6 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de15d4:	4648      	mov	r0, r9
c0de15d6:	1901      	adds	r1, r0, r4
c0de15d8:	2021      	movs	r0, #33	; 0x21
c0de15da:	aa05      	add	r2, sp, #20
c0de15dc:	2301      	movs	r3, #1
c0de15de:	f001 fd2f 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de15e2:	2800      	cmp	r0, #0
c0de15e4:	d136      	bne.n	c0de1654 <handleGetPublicKey+0x120>
c0de15e6:	a805      	add	r0, sp, #20
c0de15e8:	2128      	movs	r1, #40	; 0x28
    cx_ecfp_generate_pair(CX_CURVE_256K1, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de15ea:	f00c f929 	bl	c0ded840 <explicit_bzero>
c0de15ee:	a819      	add	r0, sp, #100	; 0x64
c0de15f0:	2120      	movs	r1, #32
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de15f2:	f00c f925 	bl	c0ded840 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0de15f6:	f006 fad3 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
                               tmpCtx.publicKeyContext.address,
                               &global_sha3,
                               chainConfig->chainId);
c0de15fa:	481f      	ldr	r0, [pc, #124]	; (c0de1678 <handleGetPublicKey+0x144>)
c0de15fc:	4649      	mov	r1, r9
c0de15fe:	5808      	ldr	r0, [r1, r0]
c0de1600:	6902      	ldr	r2, [r0, #16]
c0de1602:	6940      	ldr	r0, [r0, #20]
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
c0de1604:	9200      	str	r2, [sp, #0]
c0de1606:	9001      	str	r0, [sp, #4]
c0de1608:	481c      	ldr	r0, [pc, #112]	; (c0de167c <handleGetPublicKey+0x148>)
c0de160a:	180a      	adds	r2, r1, r0
c0de160c:	1908      	adds	r0, r1, r4
c0de160e:	4601      	mov	r1, r0
c0de1610:	314c      	adds	r1, #76	; 0x4c
c0de1612:	f003 f84d 	bl	c0de46b0 <getEthAddressStringFromKey>
#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0de1616:	9803      	ldr	r0, [sp, #12]
c0de1618:	2800      	cmp	r0, #0
c0de161a:	d021      	beq.n	c0de1660 <handleGetPublicKey+0x12c>
        *tx = set_result_get_publicKey();
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        snprintf(strings.common.fullAddress,
c0de161c:	4648      	mov	r0, r9
c0de161e:	1901      	adds	r1, r0, r4
c0de1620:	314c      	adds	r1, #76	; 0x4c
c0de1622:	9100      	str	r1, [sp, #0]
c0de1624:	4916      	ldr	r1, [pc, #88]	; (c0de1680 <handleGetPublicKey+0x14c>)
c0de1626:	1840      	adds	r0, r0, r1
c0de1628:	2135      	movs	r1, #53	; 0x35
c0de162a:	4a16      	ldr	r2, [pc, #88]	; (c0de1684 <handleGetPublicKey+0x150>)
c0de162c:	447a      	add	r2, pc
c0de162e:	2328      	movs	r3, #40	; 0x28
c0de1630:	f006 fc2c 	bl	c0de7e8c <snprintf>
                 sizeof(strings.common.fullAddress),
                 "0x%.*s",
                 40,
                 tmpCtx.publicKeyContext.address);
        ux_flow_init(0, ux_display_public_flow, NULL);
c0de1634:	4914      	ldr	r1, [pc, #80]	; (c0de1688 <handleGetPublicKey+0x154>)
c0de1636:	4479      	add	r1, pc
c0de1638:	2000      	movs	r0, #0
c0de163a:	4602      	mov	r2, r0
c0de163c:	f00b f9a2 	bl	c0dec984 <ux_flow_init>
c0de1640:	9a04      	ldr	r2, [sp, #16]

        *flags |= IO_ASYNCH_REPLY;
c0de1642:	6810      	ldr	r0, [r2, #0]
c0de1644:	2110      	movs	r1, #16
c0de1646:	4301      	orrs	r1, r0
c0de1648:	6011      	str	r1, [r2, #0]
    }
#endif  // NO_CONSENT
}
c0de164a:	b021      	add	sp, #132	; 0x84
c0de164c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de164e:	20d5      	movs	r0, #213	; 0xd5
c0de1650:	01c0      	lsls	r0, r0, #7
c0de1652:	3080      	adds	r0, #128	; 0x80
c0de1654:	f005 fee7 	bl	c0de7426 <os_longjmp>
c0de1658:	20d5      	movs	r0, #213	; 0xd5
c0de165a:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0de165c:	f005 fee3 	bl	c0de7426 <os_longjmp>
        *tx = set_result_get_publicKey();
c0de1660:	f004 fbd0 	bl	c0de5e04 <set_result_get_publicKey>
c0de1664:	9902      	ldr	r1, [sp, #8]
c0de1666:	6008      	str	r0, [r1, #0]
c0de1668:	2009      	movs	r0, #9
c0de166a:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0de166c:	f005 fedb 	bl	c0de7426 <os_longjmp>
c0de1670:	0000011d 	.word	0x0000011d
c0de1674:	00000124 	.word	0x00000124
c0de1678:	00000590 	.word	0x00000590
c0de167c:	000007e8 	.word	0x000007e8
c0de1680:	000006ba 	.word	0x000006ba
c0de1684:	0000ccaf 	.word	0x0000ccaf
c0de1688:	0000ecda 	.word	0x0000ecda

c0de168c <decodeScalar>:
#include "feature_performPrivacyOperation.h"

#define P2_PUBLIC_ENCRYPTION_KEY 0x00
#define P2_SHARED_SECRET         0x01

void decodeScalar(const uint8_t *scalarIn, uint8_t *scalarOut) {
c0de168c:	b570      	push	{r4, r5, r6, lr}
    for (uint8_t i = 0; i < 32; i++) {
c0de168e:	4602      	mov	r2, r0
c0de1690:	321f      	adds	r2, #31
c0de1692:	2300      	movs	r3, #0
c0de1694:	461c      	mov	r4, r3
c0de1696:	2b20      	cmp	r3, #32
c0de1698:	d016      	beq.n	c0de16c8 <decodeScalar+0x3c>
c0de169a:	257f      	movs	r5, #127	; 0x7f
        switch (i) {
c0de169c:	4025      	ands	r5, r4
c0de169e:	2d1f      	cmp	r5, #31
c0de16a0:	d007      	beq.n	c0de16b2 <decodeScalar+0x26>
c0de16a2:	2d00      	cmp	r5, #0
c0de16a4:	d10a      	bne.n	c0de16bc <decodeScalar+0x30>
            case 0:
                scalarOut[0] = (scalarIn[31] & 0x7f) | 0x40;
c0de16a6:	7fc5      	ldrb	r5, [r0, #31]
c0de16a8:	263f      	movs	r6, #63	; 0x3f
c0de16aa:	402e      	ands	r6, r5
c0de16ac:	3640      	adds	r6, #64	; 0x40
c0de16ae:	700e      	strb	r6, [r1, #0]
c0de16b0:	e006      	b.n	c0de16c0 <decodeScalar+0x34>
                break;
            case 31:
                scalarOut[31] = scalarIn[0] & 0xf8;
c0de16b2:	7805      	ldrb	r5, [r0, #0]
c0de16b4:	26f8      	movs	r6, #248	; 0xf8
c0de16b6:	402e      	ands	r6, r5
c0de16b8:	77ce      	strb	r6, [r1, #31]
c0de16ba:	e001      	b.n	c0de16c0 <decodeScalar+0x34>
                break;
            default:
                scalarOut[i] = scalarIn[31 - i];
c0de16bc:	7815      	ldrb	r5, [r2, #0]
c0de16be:	54cd      	strb	r5, [r1, r3]
    for (uint8_t i = 0; i < 32; i++) {
c0de16c0:	1e52      	subs	r2, r2, #1
c0de16c2:	1c64      	adds	r4, r4, #1
c0de16c4:	1c5b      	adds	r3, r3, #1
c0de16c6:	e7e6      	b.n	c0de1696 <decodeScalar+0xa>
        }
    }
}
c0de16c8:	bd70      	pop	{r4, r5, r6, pc}
c0de16ca:	d4d4      	bmi.n	c0de1676 <handleGetPublicKey+0x142>

c0de16cc <handlePerformPrivacyOperation>:
void handlePerformPrivacyOperation(uint8_t p1,
                                   uint8_t p2,
                                   uint8_t *dataBuffer,
                                   uint16_t dataLength,
                                   unsigned int *flags,
                                   unsigned int *tx) {
c0de16cc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de16ce:	b0ad      	sub	sp, #180	; 0xb4
c0de16d0:	4616      	mov	r6, r2
    UNUSED(dataLength);
    uint8_t privateKeyData[INT256_LENGTH];
    uint8_t privateKeyDataSwapped[INT256_LENGTH];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint8_t bip32PathLength = *(dataBuffer++);
c0de16d2:	7812      	ldrb	r2, [r2, #0]
    cx_err_t status = CX_OK;
    if (p2 == P2_PUBLIC_ENCRYPTION_KEY) {
c0de16d4:	2900      	cmp	r1, #0
c0de16d6:	d006      	beq.n	c0de16e6 <handlePerformPrivacyOperation+0x1a>
        if (dataLength < 1 + 4 * bip32PathLength) {
            THROW(0x6700);
        }
    } else if (p2 == P2_SHARED_SECRET) {
c0de16d8:	2901      	cmp	r1, #1
c0de16da:	d000      	beq.n	c0de16de <handlePerformPrivacyOperation+0x12>
c0de16dc:	e0cd      	b.n	c0de187a <handlePerformPrivacyOperation+0x1ae>
        if (dataLength < 1 + 4 * bip32PathLength + 32) {
c0de16de:	0094      	lsls	r4, r2, #2
c0de16e0:	1c64      	adds	r4, r4, #1
c0de16e2:	3420      	adds	r4, #32
c0de16e4:	e001      	b.n	c0de16ea <handlePerformPrivacyOperation+0x1e>
        if (dataLength < 1 + 4 * bip32PathLength) {
c0de16e6:	0094      	lsls	r4, r2, #2
c0de16e8:	1c64      	adds	r4, r4, #1
c0de16ea:	429c      	cmp	r4, r3
c0de16ec:	d900      	bls.n	c0de16f0 <handlePerformPrivacyOperation+0x24>
c0de16ee:	e0c9      	b.n	c0de1884 <handlePerformPrivacyOperation+0x1b8>
        }
    } else {
        THROW(0x6B00);
    }
    cx_ecfp_private_key_t privateKey;
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0de16f0:	1e53      	subs	r3, r2, #1
c0de16f2:	2b0a      	cmp	r3, #10
c0de16f4:	d267      	bcs.n	c0de17c6 <handlePerformPrivacyOperation+0xfa>
c0de16f6:	9108      	str	r1, [sp, #32]
c0de16f8:	9006      	str	r0, [sp, #24]
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0de16fa:	2801      	cmp	r0, #1
c0de16fc:	d900      	bls.n	c0de1700 <handlePerformPrivacyOperation+0x34>
c0de16fe:	e0bc      	b.n	c0de187a <handlePerformPrivacyOperation+0x1ae>
c0de1700:	9833      	ldr	r0, [sp, #204]	; 0xcc
c0de1702:	9002      	str	r0, [sp, #8]
c0de1704:	9832      	ldr	r0, [sp, #200]	; 0xc8
        THROW(0x6B00);
    }
    for (uint8_t i = 0; i < bip32PathLength; i++) {
c0de1706:	9007      	str	r0, [sp, #28]
c0de1708:	1d37      	adds	r7, r6, #4
c0de170a:	2002      	movs	r0, #2
c0de170c:	43c6      	mvns	r6, r0
c0de170e:	a813      	add	r0, sp, #76	; 0x4c
c0de1710:	4611      	mov	r1, r2
c0de1712:	2900      	cmp	r1, #0
c0de1714:	d00e      	beq.n	c0de1734 <handlePerformPrivacyOperation+0x68>
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1716:	5dbb      	ldrb	r3, [r7, r6]
c0de1718:	061b      	lsls	r3, r3, #24
c0de171a:	19bc      	adds	r4, r7, r6
c0de171c:	7865      	ldrb	r5, [r4, #1]
c0de171e:	042d      	lsls	r5, r5, #16
c0de1720:	18eb      	adds	r3, r5, r3
         (buf[off + 2] << 8) | buf[off + 3];
c0de1722:	78a4      	ldrb	r4, [r4, #2]
c0de1724:	0224      	lsls	r4, r4, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1726:	191b      	adds	r3, r3, r4
         (buf[off + 2] << 8) | buf[off + 3];
c0de1728:	783c      	ldrb	r4, [r7, #0]
c0de172a:	191b      	adds	r3, r3, r4
        bip32Path[i] = U4BE(dataBuffer, 0);
c0de172c:	c008      	stmia	r0!, {r3}
    for (uint8_t i = 0; i < bip32PathLength; i++) {
c0de172e:	1d3f      	adds	r7, r7, #4
c0de1730:	1e49      	subs	r1, r1, #1
c0de1732:	e7ee      	b.n	c0de1712 <handlePerformPrivacyOperation+0x46>
    os_perso_derive_node_bip32(
        CX_CURVE_256K1,
        bip32Path,
        bip32PathLength,
        privateKeyData,
        (tmpCtx.publicKeyContext.getChaincode ? tmpCtx.publicKeyContext.chainCode : NULL));
c0de1734:	4859      	ldr	r0, [pc, #356]	; (c0de189c <handlePerformPrivacyOperation+0x1d0>)
c0de1736:	464b      	mov	r3, r9
c0de1738:	1819      	adds	r1, r3, r0
c0de173a:	2095      	movs	r0, #149	; 0x95
c0de173c:	5c08      	ldrb	r0, [r1, r0]
c0de173e:	2800      	cmp	r0, #0
c0de1740:	9305      	str	r3, [sp, #20]
c0de1742:	9104      	str	r1, [sp, #16]
c0de1744:	d001      	beq.n	c0de174a <handlePerformPrivacyOperation+0x7e>
c0de1746:	4608      	mov	r0, r1
c0de1748:	3075      	adds	r0, #117	; 0x75
    os_perso_derive_node_bip32(
c0de174a:	9000      	str	r0, [sp, #0]
c0de174c:	2521      	movs	r5, #33	; 0x21
c0de174e:	a913      	add	r1, sp, #76	; 0x4c
c0de1750:	ab25      	add	r3, sp, #148	; 0x94
c0de1752:	9303      	str	r3, [sp, #12]
c0de1754:	4628      	mov	r0, r5
c0de1756:	f007 fd4d 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0de175a:	ac09      	add	r4, sp, #36	; 0x24
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0de175c:	4628      	mov	r0, r5
c0de175e:	9903      	ldr	r1, [sp, #12]
c0de1760:	4622      	mov	r2, r4
c0de1762:	f000 f8ad 	bl	c0de18c0 <cx_ecfp_init_private_key>
    cx_ecfp_generate_pair(CX_CURVE_256K1, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
c0de1766:	4628      	mov	r0, r5
c0de1768:	4621      	mov	r1, r4
c0de176a:	f000 f8b3 	bl	c0de18d4 <cx_ecfp_generate_pair>
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
                               tmpCtx.publicKeyContext.address,
                               &global_sha3,
                               chainConfig->chainId);
c0de176e:	484c      	ldr	r0, [pc, #304]	; (c0de18a0 <handlePerformPrivacyOperation+0x1d4>)
c0de1770:	9a05      	ldr	r2, [sp, #20]
c0de1772:	5810      	ldr	r0, [r2, r0]
c0de1774:	6901      	ldr	r1, [r0, #16]
c0de1776:	6940      	ldr	r0, [r0, #20]
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
c0de1778:	9100      	str	r1, [sp, #0]
c0de177a:	9001      	str	r0, [sp, #4]
c0de177c:	4849      	ldr	r0, [pc, #292]	; (c0de18a4 <handlePerformPrivacyOperation+0x1d8>)
c0de177e:	1812      	adds	r2, r2, r0
c0de1780:	9804      	ldr	r0, [sp, #16]
        (tmpCtx.publicKeyContext.getChaincode ? tmpCtx.publicKeyContext.chainCode : NULL));
c0de1782:	4601      	mov	r1, r0
c0de1784:	314c      	adds	r1, #76	; 0x4c
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
c0de1786:	f002 ff93 	bl	c0de46b0 <getEthAddressStringFromKey>
    if (p2 == P2_PUBLIC_ENCRYPTION_KEY) {
c0de178a:	9808      	ldr	r0, [sp, #32]
c0de178c:	2800      	cmp	r0, #0
c0de178e:	d01e      	beq.n	c0de17ce <handlePerformPrivacyOperation+0x102>
c0de1790:	19b9      	adds	r1, r7, r6
                              &tmpCtx.publicKeyContext.publicKey,
                              &privateKey,
                              1);
        explicit_bzero(privateKeyDataSwapped, sizeof(privateKeyDataSwapped));
    } else {
        memmove(tmpCtx.publicKeyContext.publicKey.W + 1, dataBuffer, 32);
c0de1792:	4648      	mov	r0, r9
c0de1794:	4e41      	ldr	r6, [pc, #260]	; (c0de189c <handlePerformPrivacyOperation+0x1d0>)
c0de1796:	1984      	adds	r4, r0, r6
c0de1798:	3409      	adds	r4, #9
c0de179a:	2720      	movs	r7, #32
c0de179c:	4620      	mov	r0, r4
c0de179e:	463a      	mov	r2, r7
c0de17a0:	f00c f842 	bl	c0ded828 <__aeabi_memmove>
c0de17a4:	ad25      	add	r5, sp, #148	; 0x94
        status = cx_x25519(tmpCtx.publicKeyContext.publicKey.W + 1, privateKeyData, 32);
c0de17a6:	4620      	mov	r0, r4
c0de17a8:	4629      	mov	r1, r5
c0de17aa:	463a      	mov	r2, r7
c0de17ac:	f001 fca2 	bl	c0de30f4 <cx_x25519>
c0de17b0:	4604      	mov	r4, r0
c0de17b2:	a809      	add	r0, sp, #36	; 0x24
c0de17b4:	2128      	movs	r1, #40	; 0x28
    }
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de17b6:	f00c f843 	bl	c0ded840 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de17ba:	4628      	mov	r0, r5
c0de17bc:	4639      	mov	r1, r7
c0de17be:	f00c f83f 	bl	c0ded840 <explicit_bzero>

    if (status != CX_OK) {
c0de17c2:	2c00      	cmp	r4, #0
c0de17c4:	d021      	beq.n	c0de180a <handlePerformPrivacyOperation+0x13e>
c0de17c6:	20d5      	movs	r0, #213	; 0xd5
c0de17c8:	01c0      	lsls	r0, r0, #7
c0de17ca:	f005 fe2c 	bl	c0de7426 <os_longjmp>
c0de17ce:	a825      	add	r0, sp, #148	; 0x94
c0de17d0:	9005      	str	r0, [sp, #20]
c0de17d2:	af1d      	add	r7, sp, #116	; 0x74
        decodeScalar(privateKeyData, privateKeyDataSwapped);
c0de17d4:	4639      	mov	r1, r7
c0de17d6:	f7ff ff59 	bl	c0de168c <decodeScalar>
c0de17da:	2481      	movs	r4, #129	; 0x81
c0de17dc:	ad09      	add	r5, sp, #36	; 0x24
        cx_ecfp_init_private_key(CX_CURVE_Curve25519, privateKeyDataSwapped, 32, &privateKey);
c0de17de:	4620      	mov	r0, r4
c0de17e0:	4639      	mov	r1, r7
c0de17e2:	462a      	mov	r2, r5
c0de17e4:	f000 f86c 	bl	c0de18c0 <cx_ecfp_init_private_key>
        cx_ecfp_generate_pair(CX_CURVE_Curve25519,
c0de17e8:	4620      	mov	r0, r4
c0de17ea:	4629      	mov	r1, r5
c0de17ec:	f000 f872 	bl	c0de18d4 <cx_ecfp_generate_pair>
c0de17f0:	2420      	movs	r4, #32
        explicit_bzero(privateKeyDataSwapped, sizeof(privateKeyDataSwapped));
c0de17f2:	4e2e      	ldr	r6, [pc, #184]	; (c0de18ac <handlePerformPrivacyOperation+0x1e0>)
c0de17f4:	447e      	add	r6, pc
c0de17f6:	4638      	mov	r0, r7
c0de17f8:	4621      	mov	r1, r4
c0de17fa:	47b0      	blx	r6
c0de17fc:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de17fe:	4628      	mov	r0, r5
c0de1800:	47b0      	blx	r6
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de1802:	9805      	ldr	r0, [sp, #20]
c0de1804:	4621      	mov	r1, r4
c0de1806:	47b0      	blx	r6
c0de1808:	4e24      	ldr	r6, [pc, #144]	; (c0de189c <handlePerformPrivacyOperation+0x1d0>)
        THROW(0x6A80);
    }

#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0de180a:	9806      	ldr	r0, [sp, #24]
c0de180c:	2800      	cmp	r0, #0
c0de180e:	d03d      	beq.n	c0de188c <handlePerformPrivacyOperation+0x1c0>
        *tx = set_result_perform_privacy_operation();
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        snprintf(strings.common.fullAddress,
c0de1810:	4648      	mov	r0, r9
c0de1812:	1981      	adds	r1, r0, r6
c0de1814:	314c      	adds	r1, #76	; 0x4c
c0de1816:	9100      	str	r1, [sp, #0]
c0de1818:	4c23      	ldr	r4, [pc, #140]	; (c0de18a8 <handlePerformPrivacyOperation+0x1dc>)
c0de181a:	1900      	adds	r0, r0, r4
c0de181c:	2135      	movs	r1, #53	; 0x35
c0de181e:	4a24      	ldr	r2, [pc, #144]	; (c0de18b0 <handlePerformPrivacyOperation+0x1e4>)
c0de1820:	447a      	add	r2, pc
c0de1822:	2528      	movs	r5, #40	; 0x28
c0de1824:	462b      	mov	r3, r5
c0de1826:	f006 fb31 	bl	c0de7e8c <snprintf>
c0de182a:	a825      	add	r0, sp, #148	; 0x94
                 sizeof(strings.common.fullAddress),
                 "0x%.*s",
                 40,
                 tmpCtx.publicKeyContext.address);
        for (uint8_t i = 0; i < 32; i++) {
c0de182c:	2d08      	cmp	r5, #8
c0de182e:	d006      	beq.n	c0de183e <handlePerformPrivacyOperation+0x172>
            privateKeyData[i] = tmpCtx.publicKeyContext.publicKey.W[32 - i];
c0de1830:	4649      	mov	r1, r9
c0de1832:	1989      	adds	r1, r1, r6
c0de1834:	5d49      	ldrb	r1, [r1, r5]
c0de1836:	7001      	strb	r1, [r0, #0]
        for (uint8_t i = 0; i < 32; i++) {
c0de1838:	1c40      	adds	r0, r0, #1
c0de183a:	1e6d      	subs	r5, r5, #1
c0de183c:	e7f6      	b.n	c0de182c <handlePerformPrivacyOperation+0x160>
c0de183e:	a825      	add	r0, sp, #148	; 0x94
        }
        snprintf(strings.common.fullAmount,
c0de1840:	9000      	str	r0, [sp, #0]
c0de1842:	4648      	mov	r0, r9
c0de1844:	1900      	adds	r0, r0, r4
c0de1846:	3035      	adds	r0, #53	; 0x35
c0de1848:	214e      	movs	r1, #78	; 0x4e
c0de184a:	4a1a      	ldr	r2, [pc, #104]	; (c0de18b4 <handlePerformPrivacyOperation+0x1e8>)
c0de184c:	447a      	add	r2, pc
c0de184e:	2320      	movs	r3, #32
c0de1850:	f006 fb1c 	bl	c0de7e8c <snprintf>
                 sizeof(strings.common.fullAmount) - 1,
                 "%.*H",
                 32,
                 privateKeyData);
        if (p2 == P2_PUBLIC_ENCRYPTION_KEY) {
c0de1854:	9808      	ldr	r0, [sp, #32]
c0de1856:	2800      	cmp	r0, #0
c0de1858:	d002      	beq.n	c0de1860 <handlePerformPrivacyOperation+0x194>
c0de185a:	4918      	ldr	r1, [pc, #96]	; (c0de18bc <handlePerformPrivacyOperation+0x1f0>)
c0de185c:	4479      	add	r1, pc
c0de185e:	e001      	b.n	c0de1864 <handlePerformPrivacyOperation+0x198>
c0de1860:	4915      	ldr	r1, [pc, #84]	; (c0de18b8 <handlePerformPrivacyOperation+0x1ec>)
c0de1862:	4479      	add	r1, pc
c0de1864:	2000      	movs	r0, #0
c0de1866:	4602      	mov	r2, r0
c0de1868:	f00b f88c 	bl	c0dec984 <ux_flow_init>
c0de186c:	9a07      	ldr	r2, [sp, #28]
            ux_flow_init(0, ux_display_privacy_public_key_flow, NULL);
        } else {
            ux_flow_init(0, ux_display_privacy_shared_secret_flow, NULL);
        }

        *flags |= IO_ASYNCH_REPLY;
c0de186e:	6810      	ldr	r0, [r2, #0]
c0de1870:	2110      	movs	r1, #16
c0de1872:	4301      	orrs	r1, r0
c0de1874:	6011      	str	r1, [r2, #0]
    }
#endif  // NO_CONSENT
}
c0de1876:	b02d      	add	sp, #180	; 0xb4
c0de1878:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de187a:	20d5      	movs	r0, #213	; 0xd5
c0de187c:	01c0      	lsls	r0, r0, #7
c0de187e:	3080      	adds	r0, #128	; 0x80
c0de1880:	f005 fdd1 	bl	c0de7426 <os_longjmp>
c0de1884:	2067      	movs	r0, #103	; 0x67
c0de1886:	0200      	lsls	r0, r0, #8
c0de1888:	f005 fdcd 	bl	c0de7426 <os_longjmp>
        *tx = set_result_perform_privacy_operation();
c0de188c:	f004 fae4 	bl	c0de5e58 <set_result_perform_privacy_operation>
c0de1890:	9902      	ldr	r1, [sp, #8]
c0de1892:	6008      	str	r0, [r1, #0]
c0de1894:	2009      	movs	r0, #9
c0de1896:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0de1898:	f005 fdc5 	bl	c0de7426 <os_longjmp>
c0de189c:	00000124 	.word	0x00000124
c0de18a0:	00000590 	.word	0x00000590
c0de18a4:	000007e8 	.word	0x000007e8
c0de18a8:	000006ba 	.word	0x000006ba
c0de18ac:	0000c049 	.word	0x0000c049
c0de18b0:	0000cabb 	.word	0x0000cabb
c0de18b4:	0000c8fb 	.word	0x0000c8fb
c0de18b8:	0000eb8a 	.word	0x0000eb8a
c0de18bc:	0000eba8 	.word	0x0000eba8

c0de18c0 <cx_ecfp_init_private_key>:
{
c0de18c0:	b580      	push	{r7, lr}
c0de18c2:	4613      	mov	r3, r2
c0de18c4:	2220      	movs	r2, #32
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de18c6:	f001 fbc1 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de18ca:	2800      	cmp	r0, #0
c0de18cc:	d100      	bne.n	c0de18d0 <cx_ecfp_init_private_key+0x10>
c0de18ce:	bd80      	pop	{r7, pc}
c0de18d0:	f005 fda9 	bl	c0de7426 <os_longjmp>

c0de18d4 <cx_ecfp_generate_pair>:
{
c0de18d4:	b580      	push	{r7, lr}
c0de18d6:	460a      	mov	r2, r1
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de18d8:	4905      	ldr	r1, [pc, #20]	; (c0de18f0 <cx_ecfp_generate_pair+0x1c>)
c0de18da:	464b      	mov	r3, r9
c0de18dc:	1859      	adds	r1, r3, r1
c0de18de:	2301      	movs	r3, #1
c0de18e0:	f001 fbae 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de18e4:	2800      	cmp	r0, #0
c0de18e6:	d100      	bne.n	c0de18ea <cx_ecfp_generate_pair+0x16>
c0de18e8:	bd80      	pop	{r7, pc}
c0de18ea:	f005 fd9c 	bl	c0de7426 <os_longjmp>
c0de18ee:	46c0      	nop			; (mov r8, r8)
c0de18f0:	00000124 	.word	0x00000124

c0de18f4 <handleProvideNFTInformation>:
void handleProvideNFTInformation(uint8_t p1,
                                 uint8_t p2,
                                 uint8_t *workBuffer,
                                 uint16_t dataLength,
                                 unsigned int *flags,
                                 unsigned int *tx) {
c0de18f4:	b0a4      	sub	sp, #144	; 0x90
    UNUSED(flags);
    uint8_t hash[INT256_LENGTH];
    cx_ecfp_public_key_t nftKey;
    PRINTF("In handle provide NFTInformation\n");

    if ((pluginType != ERC721) && (pluginType != ERC1155)) {
c0de18f6:	484e      	ldr	r0, [pc, #312]	; (c0de1a30 <handleProvideNFTInformation+0x13c>)
c0de18f8:	4649      	mov	r1, r9
c0de18fa:	5c08      	ldrb	r0, [r1, r0]
c0de18fc:	1e40      	subs	r0, r0, #1
c0de18fe:	2802      	cmp	r0, #2
c0de1900:	d26e      	bcs.n	c0de19e0 <handleProvideNFTInformation+0xec>
c0de1902:	461d      	mov	r5, r3
c0de1904:	4614      	mov	r4, r2
        PRINTF("NFT metadata provided without proper plugin loaded!\n");
        THROW(0x6985);
    }
    tmpCtx.transactionContext.currentItemIndex =
        (tmpCtx.transactionContext.currentItemIndex + 1) % MAX_ITEMS;
c0de1906:	4f4b      	ldr	r7, [pc, #300]	; (c0de1a34 <handleProvideNFTInformation+0x140>)
c0de1908:	4648      	mov	r0, r9
c0de190a:	19c1      	adds	r1, r0, r7
c0de190c:	2041      	movs	r0, #65	; 0x41
c0de190e:	0082      	lsls	r2, r0, #2
c0de1910:	5c8b      	ldrb	r3, [r1, r2]
c0de1912:	2601      	movs	r6, #1
c0de1914:	4630      	mov	r0, r6
c0de1916:	4398      	bics	r0, r3
    tmpCtx.transactionContext.currentItemIndex =
c0de1918:	5488      	strb	r0, [r1, r2]

    PRINTF("Provisioning currentItemIndex %d\n", tmpCtx.transactionContext.currentItemIndex);

    size_t offset = 0;

    if (dataLength <= HEADER_SIZE) {
c0de191a:	2d03      	cmp	r5, #3
c0de191c:	d95c      	bls.n	c0de19d8 <handleProvideNFTInformation+0xe4>
               HEADER_SIZE,
               dataLength);
        THROW(0x6A80);
    }

    uint8_t type = workBuffer[offset];
c0de191e:	7821      	ldrb	r1, [r4, #0]
    switch (type) {
c0de1920:	2901      	cmp	r1, #1
c0de1922:	d159      	bne.n	c0de19d8 <handleProvideNFTInformation+0xe4>
            THROW(0x6a80);
            break;
    }
    offset += TYPE_SIZE;

    uint8_t version = workBuffer[offset];
c0de1924:	7861      	ldrb	r1, [r4, #1]
    switch (version) {
c0de1926:	2901      	cmp	r1, #1
c0de1928:	d156      	bne.n	c0de19d8 <handleProvideNFTInformation+0xe4>
            THROW(0x6a80);
            break;
    }
    offset += VERSION_SIZE;

    uint8_t collectionNameLength = workBuffer[offset];
c0de192a:	78a2      	ldrb	r2, [r4, #2]
    offset += NAME_LENGTH_SIZE;

    // Size of the payload (everything except the signature)
    size_t payloadSize = HEADER_SIZE + collectionNameLength + ADDRESS_LENGTH + CHAIN_ID_SIZE +
                         KEY_ID_SIZE + ALGORITHM_ID_SIZE;
c0de192c:	4611      	mov	r1, r2
c0de192e:	3121      	adds	r1, #33	; 0x21
    if (dataLength < payloadSize) {
c0de1930:	42a9      	cmp	r1, r5
c0de1932:	d851      	bhi.n	c0de19d8 <handleProvideNFTInformation+0xe4>
               payloadSize,
               dataLength);
        THROW(0x6A80);
    }

    if (collectionNameLength > COLLECTION_NAME_MAX_LEN) {
c0de1934:	2a47      	cmp	r2, #71	; 0x47
c0de1936:	d24f      	bcs.n	c0de19d8 <handleProvideNFTInformation+0xe4>
c0de1938:	9102      	str	r1, [sp, #8]
c0de193a:	4611      	mov	r1, r2
c0de193c:	3117      	adds	r1, #23
c0de193e:	9106      	str	r1, [sp, #24]
c0de1940:	1cd1      	adds	r1, r2, #3
c0de1942:	9105      	str	r1, [sp, #20]
c0de1944:	215b      	movs	r1, #91	; 0x5b
               collectionNameLength);
        THROW(0x6A80);
    }

    // Safe because we've checked the size before.
    memcpy(nft->collectionName, workBuffer + offset, collectionNameLength);
c0de1946:	4341      	muls	r1, r0
c0de1948:	4648      	mov	r0, r9
c0de194a:	9007      	str	r0, [sp, #28]
c0de194c:	19c0      	adds	r0, r0, r7
c0de194e:	1840      	adds	r0, r0, r1
c0de1950:	9004      	str	r0, [sp, #16]
c0de1952:	3060      	adds	r0, #96	; 0x60
c0de1954:	9003      	str	r0, [sp, #12]
c0de1956:	1ce1      	adds	r1, r4, #3
c0de1958:	9208      	str	r2, [sp, #32]
c0de195a:	f00b ff61 	bl	c0ded820 <__aeabi_memcpy>
c0de195e:	2000      	movs	r0, #0
    nft->collectionName[collectionNameLength] = '\0';
c0de1960:	9903      	ldr	r1, [sp, #12]
c0de1962:	9a08      	ldr	r2, [sp, #32]
c0de1964:	5488      	strb	r0, [r1, r2]
c0de1966:	9b04      	ldr	r3, [sp, #16]
    memcpy(nft->collectionName, workBuffer + offset, collectionNameLength);
c0de1968:	334c      	adds	r3, #76	; 0x4c

    PRINTF("Length: %d\n", collectionNameLength);
    PRINTF("CollectionName: %s\n", nft->collectionName);
    offset += collectionNameLength;

    memcpy(nft->contractAddress, workBuffer + offset, ADDRESS_LENGTH);
c0de196a:	9805      	ldr	r0, [sp, #20]
c0de196c:	1821      	adds	r1, r4, r0
c0de196e:	2214      	movs	r2, #20
c0de1970:	4618      	mov	r0, r3
c0de1972:	f00b ff55 	bl	c0ded820 <__aeabi_memcpy>
    PRINTF("Address: %.*H\n", ADDRESS_LENGTH, workBuffer + offset);
    offset += ADDRESS_LENGTH;

    uint64_t chainId = u64_from_BE(workBuffer + offset, CHAIN_ID_SIZE);
c0de1976:	9806      	ldr	r0, [sp, #24]
c0de1978:	1820      	adds	r0, r4, r0
c0de197a:	2108      	movs	r1, #8
c0de197c:	f00a fd7a 	bl	c0dec474 <u64_from_BE>
c0de1980:	9106      	str	r1, [sp, #24]
    // this prints raw data, so to have a more meaningful print, display
    // the buffer before the endianness swap
    PRINTF("ChainID: %.*H\n", sizeof(chainId), (workBuffer + offset));
    if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0de1982:	4a2d      	ldr	r2, [pc, #180]	; (c0de1a38 <handleProvideNFTInformation+0x144>)
c0de1984:	9907      	ldr	r1, [sp, #28]
c0de1986:	588b      	ldr	r3, [r1, r2]
c0de1988:	6919      	ldr	r1, [r3, #16]
c0de198a:	695b      	ldr	r3, [r3, #20]
c0de198c:	460a      	mov	r2, r1
c0de198e:	431a      	orrs	r2, r3
c0de1990:	d004      	beq.n	c0de199c <handleProvideNFTInformation+0xa8>
c0de1992:	4041      	eors	r1, r0
c0de1994:	9806      	ldr	r0, [sp, #24]
c0de1996:	4043      	eors	r3, r0
c0de1998:	430b      	orrs	r3, r1
c0de199a:	d11d      	bne.n	c0de19d8 <handleProvideNFTInformation+0xe4>
c0de199c:	9908      	ldr	r1, [sp, #32]
c0de199e:	4608      	mov	r0, r1
c0de19a0:	301f      	adds	r0, #31
        PRINTF("Chain ID token mismatch\n");
        THROW(0x6A80);
    }
    offset += CHAIN_ID_SIZE;

    uint8_t keyId = workBuffer[offset];
c0de19a2:	5c20      	ldrb	r0, [r4, r0]
    uint8_t *rawKey;
    uint8_t rawKeyLen;

    PRINTF("KeyID: %d\n", keyId);
    switch (keyId) {
c0de19a4:	2801      	cmp	r0, #1
c0de19a6:	d117      	bne.n	c0de19d8 <handleProvideNFTInformation+0xe4>
c0de19a8:	4608      	mov	r0, r1
c0de19aa:	3020      	adds	r0, #32
            break;
    }
    PRINTF("RawKey: %.*H\n", rawKeyLen, rawKey);
    offset += KEY_ID_SIZE;

    uint8_t algorithmId = workBuffer[offset];
c0de19ac:	5c20      	ldrb	r0, [r4, r0]
    PRINTF("Algorithm: %d\n", algorithmId);
    cx_curve_t curve;
    verificationAlgo *verificationFn;
    cx_md_t hashId;

    switch (algorithmId) {
c0de19ae:	2801      	cmp	r0, #1
c0de19b0:	d112      	bne.n	c0de19d8 <handleProvideNFTInformation+0xe4>
c0de19b2:	aa1c      	add	r2, sp, #112	; 0x70
c0de19b4:	2320      	movs	r3, #32
            THROW(0x6a80);
            break;
    }
    offset += ALGORITHM_ID_SIZE;
    PRINTF("hashing: %.*H\n", payloadSize, workBuffer);
    cx_hash_sha256(workBuffer, payloadSize, hash, sizeof(hash));
c0de19b6:	4620      	mov	r0, r4
c0de19b8:	9902      	ldr	r1, [sp, #8]
c0de19ba:	f001 fb65 	bl	c0de3088 <cx_hash_sha256>
c0de19be:	9908      	ldr	r1, [sp, #32]

    if (dataLength < payloadSize + SIGNATURE_LENGTH_SIZE) {
c0de19c0:	3122      	adds	r1, #34	; 0x22
c0de19c2:	42a9      	cmp	r1, r5
c0de19c4:	d808      	bhi.n	c0de19d8 <handleProvideNFTInformation+0xe4>
        PRINTF("Data too short to hold signature length\n");
        THROW(0x6a80);
    }

    uint8_t signatureLen = workBuffer[offset];
c0de19c6:	9802      	ldr	r0, [sp, #8]
c0de19c8:	5c22      	ldrb	r2, [r4, r0]
    PRINTF("Sigature len: %d\n", signatureLen);
    if (signatureLen < MIN_DER_SIG_SIZE || signatureLen > MAX_DER_SIG_SIZE) {
c0de19ca:	4610      	mov	r0, r2
c0de19cc:	3843      	subs	r0, #67	; 0x43
c0de19ce:	2806      	cmp	r0, #6
c0de19d0:	d202      	bcs.n	c0de19d8 <handleProvideNFTInformation+0xe4>
               signatureLen);
        THROW(0x6a80);
    }
    offset += SIGNATURE_LENGTH_SIZE;

    if (dataLength < payloadSize + SIGNATURE_LENGTH_SIZE + signatureLen) {
c0de19d2:	1888      	adds	r0, r1, r2
c0de19d4:	42a8      	cmp	r0, r5
c0de19d6:	d908      	bls.n	c0de19ea <handleProvideNFTInformation+0xf6>
c0de19d8:	20d5      	movs	r0, #213	; 0xd5
c0de19da:	01c0      	lsls	r0, r0, #7
c0de19dc:	f005 fd23 	bl	c0de7426 <os_longjmp>
c0de19e0:	20d5      	movs	r0, #213	; 0xd5
c0de19e2:	01c0      	lsls	r0, r0, #7
        THROW(0x6985);
c0de19e4:	38fb      	subs	r0, #251	; 0xfb
c0de19e6:	f005 fd1e 	bl	c0de7426 <os_longjmp>
c0de19ea:	9207      	str	r2, [sp, #28]
c0de19ec:	9108      	str	r1, [sp, #32]
c0de19ee:	2021      	movs	r0, #33	; 0x21
  CX_THROW(cx_ecfp_init_public_key_no_throw(curve, rawkey, key_len, key));
c0de19f0:	4912      	ldr	r1, [pc, #72]	; (c0de1a3c <handleProvideNFTInformation+0x148>)
c0de19f2:	4479      	add	r1, pc
c0de19f4:	2541      	movs	r5, #65	; 0x41
c0de19f6:	ab09      	add	r3, sp, #36	; 0x24
c0de19f8:	462a      	mov	r2, r5
c0de19fa:	f001 fb2d 	bl	c0de3058 <cx_ecfp_init_public_key_no_throw>
c0de19fe:	2800      	cmp	r0, #0
c0de1a00:	d1ec      	bne.n	c0de19dc <handleProvideNFTInformation+0xe8>
 */
static inline bool cx_ecdsa_verify ( const cx_ecfp_public_key_t * pukey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, const unsigned char * sig, unsigned int sig_len)
{
  UNUSED(mode);
  UNUSED(hashID);
  return cx_ecdsa_verify_no_throw(pukey, hash, hash_len, sig, sig_len);
c0de1a02:	9807      	ldr	r0, [sp, #28]
c0de1a04:	9000      	str	r0, [sp, #0]
    if (!verificationFn(&nftKey,
                        CX_LAST,
                        hashId,
                        hash,
                        sizeof(hash),
                        workBuffer + offset,
c0de1a06:	9808      	ldr	r0, [sp, #32]
c0de1a08:	1823      	adds	r3, r4, r0
c0de1a0a:	a809      	add	r0, sp, #36	; 0x24
c0de1a0c:	a91c      	add	r1, sp, #112	; 0x70
c0de1a0e:	2220      	movs	r2, #32
c0de1a10:	f001 fb0a 	bl	c0de3028 <cx_ecdsa_verify_no_throw>
    if (!verificationFn(&nftKey,
c0de1a14:	2800      	cmp	r0, #0
c0de1a16:	d0df      	beq.n	c0de19d8 <handleProvideNFTInformation+0xe4>
        PRINTF("Invalid NFT signature\n");
        THROW(0x6A80);
#endif
    }

    tmpCtx.transactionContext.tokenSet[tmpCtx.transactionContext.currentItemIndex] = 1;
c0de1a18:	4648      	mov	r0, r9
c0de1a1a:	19c0      	adds	r0, r0, r7
c0de1a1c:	00a9      	lsls	r1, r5, #2
c0de1a1e:	5c41      	ldrb	r1, [r0, r1]
c0de1a20:	1840      	adds	r0, r0, r1
c0de1a22:	2181      	movs	r1, #129	; 0x81
c0de1a24:	0049      	lsls	r1, r1, #1
c0de1a26:	5446      	strb	r6, [r0, r1]
c0de1a28:	2009      	movs	r0, #9
c0de1a2a:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0de1a2c:	f005 fcfb 	bl	c0de7426 <os_longjmp>
c0de1a30:	0000011e 	.word	0x0000011e
c0de1a34:	00000124 	.word	0x00000124
c0de1a38:	00000590 	.word	0x00000590
c0de1a3c:	0000dc46 	.word	0x0000dc46

c0de1a40 <handleProvideErc20TokenInformation>:
void handleProvideErc20TokenInformation(uint8_t p1,
                                        uint8_t p2,
                                        uint8_t *workBuffer,
                                        uint16_t dataLength,
                                        unsigned int *flags,
                                        __attribute__((unused)) unsigned int *tx) {
c0de1a40:	b0a2      	sub	sp, #136	; 0x88
c0de1a42:	4614      	mov	r4, r2
    uint32_t chainId;
    uint8_t hash[INT256_LENGTH];
    cx_ecfp_public_key_t tokenKey;

    tmpCtx.transactionContext.currentItemIndex =
        (tmpCtx.transactionContext.currentItemIndex + 1) % MAX_ITEMS;
c0de1a44:	493f      	ldr	r1, [pc, #252]	; (c0de1b44 <handleProvideErc20TokenInformation+0x104>)
c0de1a46:	4648      	mov	r0, r9
c0de1a48:	1840      	adds	r0, r0, r1
c0de1a4a:	2141      	movs	r1, #65	; 0x41
c0de1a4c:	0089      	lsls	r1, r1, #2
c0de1a4e:	5c42      	ldrb	r2, [r0, r1]
c0de1a50:	2601      	movs	r6, #1
c0de1a52:	4637      	mov	r7, r6
c0de1a54:	4397      	bics	r7, r2
    tmpCtx.transactionContext.currentItemIndex =
c0de1a56:	5447      	strb	r7, [r0, r1]
    tokenDefinition_t *token =
        &tmpCtx.transactionContext.extraInfo[tmpCtx.transactionContext.currentItemIndex].token;

    PRINTF("Provisioning currentItemIndex %d\n", tmpCtx.transactionContext.currentItemIndex);

    if (dataLength < 1) {
c0de1a58:	2b00      	cmp	r3, #0
c0de1a5a:	d06e      	beq.n	c0de1b3a <handleProvideErc20TokenInformation+0xfa>
c0de1a5c:	9606      	str	r6, [sp, #24]
        THROW(0x6A80);
    }
    tickerLength = workBuffer[offset++];
c0de1a5e:	7826      	ldrb	r6, [r4, #0]
    dataLength--;
    if ((tickerLength + 1) >= sizeof(token->ticker)) {
c0de1a60:	2e0b      	cmp	r6, #11
c0de1a62:	d26a      	bcs.n	c0de1b3a <handleProvideErc20TokenInformation+0xfa>
c0de1a64:	461d      	mov	r5, r3
        THROW(0x6A80);
    }
    if (dataLength < tickerLength + 20 + 4 + 4) {
c0de1a66:	4631      	mov	r1, r6
c0de1a68:	311c      	adds	r1, #28
    dataLength--;
c0de1a6a:	1e58      	subs	r0, r3, #1
    if (dataLength < tickerLength + 20 + 4 + 4) {
c0de1a6c:	b280      	uxth	r0, r0
c0de1a6e:	4281      	cmp	r1, r0
c0de1a70:	d863      	bhi.n	c0de1b3a <handleProvideErc20TokenInformation+0xfa>
c0de1a72:	1c70      	adds	r0, r6, #1
        THROW(0x6A80);
    }
    cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash, 32);
c0de1a74:	9003      	str	r0, [sp, #12]
c0de1a76:	1c62      	adds	r2, r4, #1
c0de1a78:	9202      	str	r2, [sp, #8]
c0de1a7a:	ab1a      	add	r3, sp, #104	; 0x68
c0de1a7c:	2020      	movs	r0, #32
c0de1a7e:	9005      	str	r0, [sp, #20]
c0de1a80:	4610      	mov	r0, r2
c0de1a82:	461a      	mov	r2, r3
c0de1a84:	9b05      	ldr	r3, [sp, #20]
c0de1a86:	f001 faff 	bl	c0de3088 <cx_hash_sha256>
c0de1a8a:	205b      	movs	r0, #91	; 0x5b
    memmove(token->ticker, workBuffer + offset, tickerLength);
c0de1a8c:	4378      	muls	r0, r7
c0de1a8e:	4649      	mov	r1, r9
c0de1a90:	9104      	str	r1, [sp, #16]
c0de1a92:	4a2c      	ldr	r2, [pc, #176]	; (c0de1b44 <handleProvideErc20TokenInformation+0x104>)
c0de1a94:	1889      	adds	r1, r1, r2
c0de1a96:	180f      	adds	r7, r1, r0
c0de1a98:	9701      	str	r7, [sp, #4]
c0de1a9a:	3760      	adds	r7, #96	; 0x60
c0de1a9c:	4638      	mov	r0, r7
c0de1a9e:	9902      	ldr	r1, [sp, #8]
c0de1aa0:	4632      	mov	r2, r6
c0de1aa2:	f00b fec1 	bl	c0ded828 <__aeabi_memmove>
c0de1aa6:	2000      	movs	r0, #0
c0de1aa8:	9903      	ldr	r1, [sp, #12]
    token->ticker[tickerLength] = ' ';
    token->ticker[tickerLength + 1] = '\0';
c0de1aaa:	5478      	strb	r0, [r7, r1]
    token->ticker[tickerLength] = ' ';
c0de1aac:	9805      	ldr	r0, [sp, #20]
c0de1aae:	55b8      	strb	r0, [r7, r6]
c0de1ab0:	9f01      	ldr	r7, [sp, #4]
    memmove(token->ticker, workBuffer + offset, tickerLength);
c0de1ab2:	4638      	mov	r0, r7
c0de1ab4:	304c      	adds	r0, #76	; 0x4c
    offset += tickerLength;
    dataLength -= tickerLength;
    memmove(token->address, workBuffer + offset, 20);
c0de1ab6:	1861      	adds	r1, r4, r1
c0de1ab8:	2214      	movs	r2, #20
c0de1aba:	f00b feb5 	bl	c0ded828 <__aeabi_memmove>
    offset += 20;
c0de1abe:	4631      	mov	r1, r6
c0de1ac0:	3115      	adds	r1, #21
    dataLength -= 20;
    token->decimals = U4BE(workBuffer, offset);
c0de1ac2:	4620      	mov	r0, r4
c0de1ac4:	f000 f844 	bl	c0de1b50 <U4BE>
c0de1ac8:	216c      	movs	r1, #108	; 0x6c
c0de1aca:	5478      	strb	r0, [r7, r1]
    offset += 4;
c0de1acc:	4631      	mov	r1, r6
c0de1ace:	3119      	adds	r1, #25
    dataLength -= 4;
    chainId = U4BE(workBuffer, offset);
c0de1ad0:	4620      	mov	r0, r4
c0de1ad2:	f000 f83d 	bl	c0de1b50 <U4BE>
    if ((chainConfig->chainId != ETHEREUM_MAINNET_CHAINID) && (chainConfig->chainId != chainId)) {
c0de1ad6:	491c      	ldr	r1, [pc, #112]	; (c0de1b48 <handleProvideErc20TokenInformation+0x108>)
c0de1ad8:	9a04      	ldr	r2, [sp, #16]
c0de1ada:	5852      	ldr	r2, [r2, r1]
c0de1adc:	6911      	ldr	r1, [r2, #16]
c0de1ade:	6952      	ldr	r2, [r2, #20]
c0de1ae0:	460b      	mov	r3, r1
c0de1ae2:	9f06      	ldr	r7, [sp, #24]
c0de1ae4:	407b      	eors	r3, r7
c0de1ae6:	4313      	orrs	r3, r2
c0de1ae8:	d002      	beq.n	c0de1af0 <handleProvideErc20TokenInformation+0xb0>
c0de1aea:	4041      	eors	r1, r0
c0de1aec:	4311      	orrs	r1, r2
c0de1aee:	d124      	bne.n	c0de1b3a <handleProvideErc20TokenInformation+0xfa>
c0de1af0:	2021      	movs	r0, #33	; 0x21
c0de1af2:	4916      	ldr	r1, [pc, #88]	; (c0de1b4c <handleProvideErc20TokenInformation+0x10c>)
c0de1af4:	4479      	add	r1, pc
c0de1af6:	2741      	movs	r7, #65	; 0x41
c0de1af8:	ab07      	add	r3, sp, #28
c0de1afa:	463a      	mov	r2, r7
c0de1afc:	f001 faac 	bl	c0de3058 <cx_ecfp_init_public_key_no_throw>
c0de1b00:	2800      	cmp	r0, #0
c0de1b02:	d11c      	bne.n	c0de1b3e <handleProvideErc20TokenInformation+0xfe>
        PRINTF("ChainId token mismatch: %d vs %d\n", chainConfig->chainId, chainId);
        THROW(0x6A80);
    }
    offset += 4;
    dataLength -= 4;
c0de1b04:	1ba8      	subs	r0, r5, r6
c0de1b06:	381d      	subs	r0, #29
                         CX_LAST,
                         CX_SHA256,
                         hash,
                         32,
                         workBuffer + offset,
                         dataLength)) {
c0de1b08:	b280      	uxth	r0, r0
c0de1b0a:	9000      	str	r0, [sp, #0]
    offset += 4;
c0de1b0c:	1933      	adds	r3, r6, r4
                         workBuffer + offset,
c0de1b0e:	331d      	adds	r3, #29
c0de1b10:	a807      	add	r0, sp, #28
c0de1b12:	a91a      	add	r1, sp, #104	; 0x68
c0de1b14:	2220      	movs	r2, #32
c0de1b16:	f001 fa87 	bl	c0de3028 <cx_ecdsa_verify_no_throw>
    if (!cx_ecdsa_verify(&tokenKey,
c0de1b1a:	2800      	cmp	r0, #0
c0de1b1c:	d00d      	beq.n	c0de1b3a <handleProvideErc20TokenInformation+0xfa>
        THROW(0x6A80);
#endif
    }
#endif

    tmpCtx.transactionContext.tokenSet[tmpCtx.transactionContext.currentItemIndex] = 1;
c0de1b1e:	4648      	mov	r0, r9
c0de1b20:	4908      	ldr	r1, [pc, #32]	; (c0de1b44 <handleProvideErc20TokenInformation+0x104>)
c0de1b22:	1840      	adds	r0, r0, r1
c0de1b24:	00b9      	lsls	r1, r7, #2
c0de1b26:	5c41      	ldrb	r1, [r0, r1]
c0de1b28:	1840      	adds	r0, r0, r1
c0de1b2a:	2181      	movs	r1, #129	; 0x81
c0de1b2c:	0049      	lsls	r1, r1, #1
c0de1b2e:	9a06      	ldr	r2, [sp, #24]
c0de1b30:	5442      	strb	r2, [r0, r1]
c0de1b32:	2009      	movs	r0, #9
c0de1b34:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0de1b36:	f005 fc76 	bl	c0de7426 <os_longjmp>
c0de1b3a:	20d5      	movs	r0, #213	; 0xd5
c0de1b3c:	01c0      	lsls	r0, r0, #7
c0de1b3e:	f005 fc72 	bl	c0de7426 <os_longjmp>
c0de1b42:	46c0      	nop			; (mov r8, r8)
c0de1b44:	00000124 	.word	0x00000124
c0de1b48:	00000590 	.word	0x00000590
c0de1b4c:	0000db85 	.word	0x0000db85

c0de1b50 <U4BE>:
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1b50:	5c42      	ldrb	r2, [r0, r1]
c0de1b52:	0612      	lsls	r2, r2, #24
c0de1b54:	1840      	adds	r0, r0, r1
c0de1b56:	7841      	ldrb	r1, [r0, #1]
c0de1b58:	0409      	lsls	r1, r1, #16
c0de1b5a:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de1b5c:	7882      	ldrb	r2, [r0, #2]
c0de1b5e:	0212      	lsls	r2, r2, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1b60:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de1b62:	78c0      	ldrb	r0, [r0, #3]
c0de1b64:	1808      	adds	r0, r1, r0
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1b66:	4770      	bx	lr

c0de1b68 <handleSetEth2WithdrawalIndex>:
                                  uint8_t p2,
                                  uint8_t *dataBuffer,
                                  uint16_t dataLength,
                                  __attribute__((unused)) unsigned int *flags,
                                  __attribute__((unused)) unsigned int *tx) {
    if (dataLength != 4) {
c0de1b68:	2b04      	cmp	r3, #4
c0de1b6a:	d10b      	bne.n	c0de1b84 <handleSetEth2WithdrawalIndex+0x1c>
        THROW(0x6700);
    }

    if ((p1 != 0) || (p2 != 0)) {
c0de1b6c:	4301      	orrs	r1, r0
c0de1b6e:	d10b      	bne.n	c0de1b88 <handleSetEth2WithdrawalIndex+0x20>
        THROW(0x6B00);
    }

    eth2WithdrawalIndex = U4BE(dataBuffer, 0);
c0de1b70:	4610      	mov	r0, r2
c0de1b72:	f000 f80f 	bl	c0de1b94 <U4BE>
c0de1b76:	4906      	ldr	r1, [pc, #24]	; (c0de1b90 <handleSetEth2WithdrawalIndex+0x28>)
c0de1b78:	464a      	mov	r2, r9
c0de1b7a:	5050      	str	r0, [r2, r1]
c0de1b7c:	2009      	movs	r0, #9
c0de1b7e:	0300      	lsls	r0, r0, #12

    THROW(0x9000);
c0de1b80:	f005 fc51 	bl	c0de7426 <os_longjmp>
c0de1b84:	2067      	movs	r0, #103	; 0x67
c0de1b86:	e000      	b.n	c0de1b8a <handleSetEth2WithdrawalIndex+0x22>
c0de1b88:	206b      	movs	r0, #107	; 0x6b
c0de1b8a:	0200      	lsls	r0, r0, #8
c0de1b8c:	f005 fc4b 	bl	c0de7426 <os_longjmp>
c0de1b90:	00000120 	.word	0x00000120

c0de1b94 <U4BE>:
c0de1b94:	7801      	ldrb	r1, [r0, #0]
c0de1b96:	0609      	lsls	r1, r1, #24
c0de1b98:	7842      	ldrb	r2, [r0, #1]
c0de1b9a:	0412      	lsls	r2, r2, #16
c0de1b9c:	1851      	adds	r1, r2, r1
         (buf[off + 2] << 8) | buf[off + 3];
c0de1b9e:	7882      	ldrb	r2, [r0, #2]
c0de1ba0:	0212      	lsls	r2, r2, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1ba2:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de1ba4:	78c0      	ldrb	r0, [r0, #3]
c0de1ba6:	1808      	adds	r0, r1, r0
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de1ba8:	4770      	bx	lr
c0de1baa:	d4d4      	bmi.n	c0de1b56 <U4BE+0x6>

c0de1bac <handleSetExternalPlugin>:
void handleSetExternalPlugin(uint8_t p1,
                             uint8_t p2,
                             uint8_t *workBuffer,
                             uint16_t dataLength,
                             unsigned int *flags,
                             unsigned int *tx) {
c0de1bac:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de1bae:	b0ad      	sub	sp, #180	; 0xb4
    UNUSED(p2);
    UNUSED(flags);
    PRINTF("Handling set Plugin\n");
    uint8_t hash[INT256_LENGTH];
    cx_ecfp_public_key_t tokenKey;
    uint8_t pluginNameLength = *workBuffer;
c0de1bb0:	7814      	ldrb	r4, [r2, #0]
    PRINTF("plugin Name Length: %d\n", pluginNameLength);
    const size_t payload_size = 1 + pluginNameLength + ADDRESS_LENGTH + SELECTOR_SIZE;
c0de1bb2:	4626      	mov	r6, r4
c0de1bb4:	3619      	adds	r6, #25

    if (dataLength <= payload_size) {
c0de1bb6:	429e      	cmp	r6, r3
c0de1bb8:	d26c      	bcs.n	c0de1c94 <handleSetExternalPlugin+0xe8>
        PRINTF("data too small: expected at least %d got %d\n", payload_size, dataLength);
        THROW(0x6A80);
    }

    if (pluginNameLength + 1 > sizeof(dataContext.tokenContext.pluginName)) {
c0de1bba:	2c1e      	cmp	r4, #30
c0de1bbc:	d26a      	bcs.n	c0de1c94 <handleSetExternalPlugin+0xe8>
c0de1bbe:	461f      	mov	r7, r3
c0de1bc0:	4615      	mov	r5, r2
c0de1bc2:	aa25      	add	r2, sp, #148	; 0x94
c0de1bc4:	2320      	movs	r3, #32
               pluginNameLength + 1);
        THROW(0x6A80);
    }

    // check Ledger's signature over the payload
    cx_hash_sha256(workBuffer, payload_size, hash, sizeof(hash));
c0de1bc6:	4628      	mov	r0, r5
c0de1bc8:	4631      	mov	r1, r6
c0de1bca:	f001 fa5d 	bl	c0de3088 <cx_hash_sha256>
c0de1bce:	2021      	movs	r0, #33	; 0x21
c0de1bd0:	493e      	ldr	r1, [pc, #248]	; (c0de1ccc <handleSetExternalPlugin+0x120>)
c0de1bd2:	4479      	add	r1, pc
c0de1bd4:	2241      	movs	r2, #65	; 0x41
c0de1bd6:	ab12      	add	r3, sp, #72	; 0x48
c0de1bd8:	f001 fa3e 	bl	c0de3058 <cx_ecfp_init_public_key_no_throw>
c0de1bdc:	2800      	cmp	r0, #0
c0de1bde:	d15b      	bne.n	c0de1c98 <handleSetExternalPlugin+0xec>
                         CX_LAST,
                         CX_SHA256,
                         hash,
                         sizeof(hash),
                         workBuffer + payload_size,
                         dataLength - payload_size)) {
c0de1be0:	1bb8      	subs	r0, r7, r6
c0de1be2:	9000      	str	r0, [sp, #0]
                         workBuffer + payload_size,
c0de1be4:	19ab      	adds	r3, r5, r6
c0de1be6:	a812      	add	r0, sp, #72	; 0x48
c0de1be8:	a925      	add	r1, sp, #148	; 0x94
c0de1bea:	2220      	movs	r2, #32
c0de1bec:	f001 fa1c 	bl	c0de3028 <cx_ecdsa_verify_no_throw>
    if (!cx_ecdsa_verify(&tokenKey,
c0de1bf0:	2800      	cmp	r0, #0
c0de1bf2:	d04f      	beq.n	c0de1c94 <handleSetExternalPlugin+0xe8>
#endif
    }

    // move on to the rest of the payload parsing
    workBuffer++;
    memmove(dataContext.tokenContext.pluginName, workBuffer, pluginNameLength);
c0de1bf4:	4931      	ldr	r1, [pc, #196]	; (c0de1cbc <handleSetExternalPlugin+0x110>)
c0de1bf6:	4648      	mov	r0, r9
c0de1bf8:	1846      	adds	r6, r0, r1
    workBuffer++;
c0de1bfa:	1c6d      	adds	r5, r5, #1
    memmove(dataContext.tokenContext.pluginName, workBuffer, pluginNameLength);
c0de1bfc:	4630      	mov	r0, r6
c0de1bfe:	4629      	mov	r1, r5
c0de1c00:	4622      	mov	r2, r4
c0de1c02:	f00b fe11 	bl	c0ded828 <__aeabi_memmove>
c0de1c06:	2700      	movs	r7, #0
    dataContext.tokenContext.pluginName[pluginNameLength] = '\0';
c0de1c08:	5537      	strb	r7, [r6, r4]
c0de1c0a:	482d      	ldr	r0, [pc, #180]	; (c0de1cc0 <handleSetExternalPlugin+0x114>)
    PRINTF("Check external plugin %s\n", dataContext.tokenContext.pluginName);

    // Check if the plugin is present on the device
    uint32_t params[2];
    params[0] = (uint32_t) dataContext.tokenContext.pluginName;
    params[1] = ETH_PLUGIN_CHECK_PRESENCE;
c0de1c0c:	9011      	str	r0, [sp, #68]	; 0x44
    params[0] = (uint32_t) dataContext.tokenContext.pluginName;
c0de1c0e:	9610      	str	r6, [sp, #64]	; 0x40
c0de1c10:	ae04      	add	r6, sp, #16
    BEGIN_TRY {
        TRY {
c0de1c12:	4630      	mov	r0, r6
c0de1c14:	f00b ff4c 	bl	c0dedab0 <setjmp>
c0de1c18:	85b0      	strh	r0, [r6, #44]	; 0x2c
c0de1c1a:	0400      	lsls	r0, r0, #16
c0de1c1c:	d13e      	bne.n	c0de1c9c <handleSetExternalPlugin+0xf0>
c0de1c1e:	ae04      	add	r6, sp, #16
c0de1c20:	4630      	mov	r0, r6
c0de1c22:	f007 fb95 	bl	c0de9350 <try_context_set>
c0de1c26:	900e      	str	r0, [sp, #56]	; 0x38
c0de1c28:	a810      	add	r0, sp, #64	; 0x40
            os_lib_call(params);
c0de1c2a:	f007 fb17 	bl	c0de925c <os_lib_call>
            memset(dataContext.tokenContext.pluginName,
                   0,
                   sizeof(dataContext.tokenContext.pluginName));
            THROW(0x6984);
        }
        FINALLY {
c0de1c2e:	f007 fb85 	bl	c0de933c <try_context_get>
c0de1c32:	42b0      	cmp	r0, r6
c0de1c34:	d102      	bne.n	c0de1c3c <handleSetExternalPlugin+0x90>
c0de1c36:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de1c38:	f007 fb8a 	bl	c0de9350 <try_context_set>
c0de1c3c:	9703      	str	r7, [sp, #12]
c0de1c3e:	a804      	add	r0, sp, #16
        }
    }
    END_TRY;
c0de1c40:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de1c42:	2800      	cmp	r0, #0
c0de1c44:	d128      	bne.n	c0de1c98 <handleSetExternalPlugin+0xec>
c0de1c46:	9e33      	ldr	r6, [sp, #204]	; 0xcc
c0de1c48:	192c      	adds	r4, r5, r4

    PRINTF("Plugin found\n");

    memmove(dataContext.tokenContext.contractAddress, workBuffer, ADDRESS_LENGTH);
c0de1c4a:	464d      	mov	r5, r9
c0de1c4c:	481b      	ldr	r0, [pc, #108]	; (c0de1cbc <handleSetExternalPlugin+0x110>)
c0de1c4e:	182f      	adds	r7, r5, r0
c0de1c50:	4638      	mov	r0, r7
c0de1c52:	3044      	adds	r0, #68	; 0x44
c0de1c54:	2214      	movs	r2, #20
c0de1c56:	4621      	mov	r1, r4
c0de1c58:	f00b fde6 	bl	c0ded828 <__aeabi_memmove>
    workBuffer += ADDRESS_LENGTH;
    memmove(dataContext.tokenContext.methodSelector, workBuffer, SELECTOR_SIZE);
c0de1c5c:	7d60      	ldrb	r0, [r4, #21]
c0de1c5e:	9002      	str	r0, [sp, #8]
c0de1c60:	7de1      	ldrb	r1, [r4, #23]
c0de1c62:	7da2      	ldrb	r2, [r4, #22]
c0de1c64:	7d20      	ldrb	r0, [r4, #20]

    pluginType = EXTERNAL;
c0de1c66:	4c17      	ldr	r4, [pc, #92]	; (c0de1cc4 <handleSetExternalPlugin+0x118>)
c0de1c68:	9b03      	ldr	r3, [sp, #12]
c0de1c6a:	552b      	strb	r3, [r5, r4]
c0de1c6c:	2458      	movs	r4, #88	; 0x58
    memmove(dataContext.tokenContext.methodSelector, workBuffer, SELECTOR_SIZE);
c0de1c6e:	5538      	strb	r0, [r7, r4]
c0de1c70:	3758      	adds	r7, #88	; 0x58
c0de1c72:	70ba      	strb	r2, [r7, #2]
c0de1c74:	70f9      	strb	r1, [r7, #3]
c0de1c76:	9802      	ldr	r0, [sp, #8]
c0de1c78:	7078      	strb	r0, [r7, #1]

    G_io_apdu_buffer[(*tx)++] = 0x90;
c0de1c7a:	6830      	ldr	r0, [r6, #0]
c0de1c7c:	1c41      	adds	r1, r0, #1
c0de1c7e:	6031      	str	r1, [r6, #0]
c0de1c80:	4911      	ldr	r1, [pc, #68]	; (c0de1cc8 <handleSetExternalPlugin+0x11c>)
c0de1c82:	1869      	adds	r1, r5, r1
c0de1c84:	2290      	movs	r2, #144	; 0x90
c0de1c86:	540a      	strb	r2, [r1, r0]
    G_io_apdu_buffer[(*tx)++] = 0x00;
c0de1c88:	6830      	ldr	r0, [r6, #0]
c0de1c8a:	1c42      	adds	r2, r0, #1
c0de1c8c:	6032      	str	r2, [r6, #0]
c0de1c8e:	540b      	strb	r3, [r1, r0]
c0de1c90:	b02d      	add	sp, #180	; 0xb4
c0de1c92:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de1c94:	20d5      	movs	r0, #213	; 0xd5
c0de1c96:	01c0      	lsls	r0, r0, #7
c0de1c98:	f005 fbc5 	bl	c0de7426 <os_longjmp>
c0de1c9c:	a804      	add	r0, sp, #16
        CATCH_OTHER(e) {
c0de1c9e:	8587      	strh	r7, [r0, #44]	; 0x2c
c0de1ca0:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de1ca2:	f007 fb55 	bl	c0de9350 <try_context_set>
            memset(dataContext.tokenContext.pluginName,
c0de1ca6:	4648      	mov	r0, r9
c0de1ca8:	4904      	ldr	r1, [pc, #16]	; (c0de1cbc <handleSetExternalPlugin+0x110>)
c0de1caa:	1840      	adds	r0, r0, r1
c0de1cac:	211e      	movs	r1, #30
c0de1cae:	f00b fdb1 	bl	c0ded814 <__aeabi_memclr>
c0de1cb2:	20d5      	movs	r0, #213	; 0xd5
c0de1cb4:	01c0      	lsls	r0, r0, #7
            THROW(0x6984);
c0de1cb6:	38fc      	subs	r0, #252	; 0xfc
c0de1cb8:	f005 fbb5 	bl	c0de7426 <os_longjmp>
c0de1cbc:	00000594 	.word	0x00000594
c0de1cc0:	000001ff 	.word	0x000001ff
c0de1cc4:	0000011e 	.word	0x0000011e
c0de1cc8:	00000990 	.word	0x00000990
c0de1ccc:	0000dae8 	.word	0x0000dae8

c0de1cd0 <handleSetPlugin>:
void handleSetPlugin(uint8_t p1,
                     uint8_t p2,
                     uint8_t *workBuffer,
                     uint16_t dataLength,
                     unsigned int *flags,
                     unsigned int *tx) {
c0de1cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de1cd2:	b0a3      	sub	sp, #140	; 0x8c
c0de1cd4:	461d      	mov	r5, r3
c0de1cd6:	4614      	mov	r4, r2
c0de1cd8:	a81b      	add	r0, sp, #108	; 0x6c
c0de1cda:	2120      	movs	r1, #32
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(flags);
    PRINTF("Handling set Plugin\n");
    uint8_t hash[INT256_LENGTH] = {0};
c0de1cdc:	f00b fd9a 	bl	c0ded814 <__aeabi_memclr>
c0de1ce0:	a808      	add	r0, sp, #32
c0de1ce2:	214c      	movs	r1, #76	; 0x4c
    cx_ecfp_public_key_t pluginKey = {0};
c0de1ce4:	f00b fd96 	bl	c0ded814 <__aeabi_memclr>
    tokenContext_t *tokenContext = &dataContext.tokenContext;

    size_t offset = 0;

    if (dataLength <= HEADER_SIZE) {
c0de1ce8:	2d03      	cmp	r5, #3
c0de1cea:	d800      	bhi.n	c0de1cee <handleSetPlugin+0x1e>
c0de1cec:	e0a9      	b.n	c0de1e42 <handleSetPlugin+0x172>
               HEADER_SIZE,
               dataLength);
        THROW(0x6A80);
    }

    enum Type type = workBuffer[offset];
c0de1cee:	7820      	ldrb	r0, [r4, #0]
    PRINTF("Type: %d\n", type);
    switch (type) {
c0de1cf0:	2801      	cmp	r0, #1
c0de1cf2:	d000      	beq.n	c0de1cf6 <handleSetPlugin+0x26>
c0de1cf4:	e0a5      	b.n	c0de1e42 <handleSetPlugin+0x172>
            THROW(0x6a80);
            break;
    }
    offset += TYPE_SIZE;

    uint8_t version = workBuffer[offset];
c0de1cf6:	7860      	ldrb	r0, [r4, #1]
    PRINTF("version: %d\n", version);
    switch (version) {
c0de1cf8:	2801      	cmp	r0, #1
c0de1cfa:	d000      	beq.n	c0de1cfe <handleSetPlugin+0x2e>
c0de1cfc:	e0a1      	b.n	c0de1e42 <handleSetPlugin+0x172>
            THROW(0x6a80);
            break;
    }
    offset += VERSION_SIZE;

    uint8_t pluginNameLength = workBuffer[offset];
c0de1cfe:	78a7      	ldrb	r7, [r4, #2]
    offset += PLUGIN_NAME_LENGTH_SIZE;

    // Size of the payload (everything except the signature)
    size_t payloadSize = HEADER_SIZE + pluginNameLength + ADDRESS_LENGTH + SELECTOR_SIZE +
                         CHAIN_ID_SIZE + KEY_ID_SIZE + ALGORITHM_ID_SIZE;
c0de1d00:	4638      	mov	r0, r7
c0de1d02:	3025      	adds	r0, #37	; 0x25
c0de1d04:	9005      	str	r0, [sp, #20]
    if (dataLength < payloadSize) {
c0de1d06:	42a8      	cmp	r0, r5
c0de1d08:	d900      	bls.n	c0de1d0c <handleSetPlugin+0x3c>
c0de1d0a:	e09a      	b.n	c0de1e42 <handleSetPlugin+0x172>
c0de1d0c:	9506      	str	r5, [sp, #24]
               dataLength);
        THROW(0x6A80);
    }

    // `+ 1` because we want to add a null terminating character.
    if (pluginNameLength + 1 > sizeof(tokenContext->pluginName)) {
c0de1d0e:	2f1e      	cmp	r7, #30
c0de1d10:	d300      	bcc.n	c0de1d14 <handleSetPlugin+0x44>
c0de1d12:	e096      	b.n	c0de1e42 <handleSetPlugin+0x172>
c0de1d14:	4638      	mov	r0, r7
c0de1d16:	301b      	adds	r0, #27
c0de1d18:	9003      	str	r0, [sp, #12]
c0de1d1a:	463d      	mov	r5, r7
c0de1d1c:	3517      	adds	r5, #23
c0de1d1e:	1cf8      	adds	r0, r7, #3
               pluginNameLength + 1);
        THROW(0x6A80);
    }

    // Safe because we've checked the size before.
    memcpy(tokenContext->pluginName, workBuffer + offset, pluginNameLength);
c0de1d20:	9002      	str	r0, [sp, #8]
c0de1d22:	484a      	ldr	r0, [pc, #296]	; (c0de1e4c <handleSetPlugin+0x17c>)
c0de1d24:	4649      	mov	r1, r9
c0de1d26:	9104      	str	r1, [sp, #16]
c0de1d28:	180e      	adds	r6, r1, r0
c0de1d2a:	1ce1      	adds	r1, r4, #3
c0de1d2c:	4630      	mov	r0, r6
c0de1d2e:	463a      	mov	r2, r7
c0de1d30:	f00b fd76 	bl	c0ded820 <__aeabi_memcpy>
c0de1d34:	2000      	movs	r0, #0
c0de1d36:	9007      	str	r0, [sp, #28]
    tokenContext->pluginName[pluginNameLength] = '\0';
c0de1d38:	55f0      	strb	r0, [r6, r7]

    PRINTF("Length: %d\n", pluginNameLength);
    PRINTF("plugin name: %s\n", tokenContext->pluginName);
    offset += pluginNameLength;

    memcpy(tokenContext->contractAddress, workBuffer + offset, ADDRESS_LENGTH);
c0de1d3a:	9802      	ldr	r0, [sp, #8]
c0de1d3c:	1821      	adds	r1, r4, r0
c0de1d3e:	4630      	mov	r0, r6
c0de1d40:	3044      	adds	r0, #68	; 0x44
c0de1d42:	2214      	movs	r2, #20
c0de1d44:	f00b fd6c 	bl	c0ded820 <__aeabi_memcpy>
    PRINTF("Address: %.*H\n", ADDRESS_LENGTH, workBuffer + offset);
    offset += ADDRESS_LENGTH;

    memcpy(tokenContext->methodSelector, workBuffer + offset, SELECTOR_SIZE);
c0de1d48:	1960      	adds	r0, r4, r5
c0de1d4a:	7841      	ldrb	r1, [r0, #1]
c0de1d4c:	78c2      	ldrb	r2, [r0, #3]
c0de1d4e:	7880      	ldrb	r0, [r0, #2]
c0de1d50:	5d63      	ldrb	r3, [r4, r5]
c0de1d52:	2558      	movs	r5, #88	; 0x58
c0de1d54:	5573      	strb	r3, [r6, r5]
c0de1d56:	3658      	adds	r6, #88	; 0x58
c0de1d58:	70b0      	strb	r0, [r6, #2]
c0de1d5a:	70f2      	strb	r2, [r6, #3]
c0de1d5c:	7071      	strb	r1, [r6, #1]
    PRINTF("Selector: %.*H\n", SELECTOR_SIZE, tokenContext->methodSelector);
    offset += SELECTOR_SIZE;

    uint64_t chainId = u64_from_BE(workBuffer + offset, CHAIN_ID_SIZE);
c0de1d5e:	9803      	ldr	r0, [sp, #12]
c0de1d60:	1820      	adds	r0, r4, r0
c0de1d62:	2108      	movs	r1, #8
c0de1d64:	f00a fb86 	bl	c0dec474 <u64_from_BE>
    // this prints raw data, so to have a more meaningful print, display
    // the buffer before the endianness swap
    PRINTF("ChainID: %.*H\n", sizeof(chainId), (workBuffer + offset));
    if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0de1d68:	4a39      	ldr	r2, [pc, #228]	; (c0de1e50 <handleSetPlugin+0x180>)
c0de1d6a:	9b04      	ldr	r3, [sp, #16]
c0de1d6c:	589b      	ldr	r3, [r3, r2]
c0de1d6e:	691a      	ldr	r2, [r3, #16]
c0de1d70:	695b      	ldr	r3, [r3, #20]
c0de1d72:	4615      	mov	r5, r2
c0de1d74:	431d      	orrs	r5, r3
c0de1d76:	d003      	beq.n	c0de1d80 <handleSetPlugin+0xb0>
c0de1d78:	4042      	eors	r2, r0
c0de1d7a:	404b      	eors	r3, r1
c0de1d7c:	4313      	orrs	r3, r2
c0de1d7e:	d160      	bne.n	c0de1e42 <handleSetPlugin+0x172>
c0de1d80:	4638      	mov	r0, r7
c0de1d82:	3023      	adds	r0, #35	; 0x23
        PRINTF("Chain ID token mismatch\n");
        THROW(0x6A80);
    }
    offset += CHAIN_ID_SIZE;

    enum KeyId keyId = workBuffer[offset];
c0de1d84:	5c20      	ldrb	r0, [r4, r0]
    uint8_t const *rawKey;
    uint8_t rawKeyLen;

    PRINTF("KeyID: %d\n", keyId);
    switch (keyId) {
c0de1d86:	2802      	cmp	r0, #2
c0de1d88:	9d05      	ldr	r5, [sp, #20]
c0de1d8a:	d15a      	bne.n	c0de1e42 <handleSetPlugin+0x172>
c0de1d8c:	4638      	mov	r0, r7
c0de1d8e:	3024      	adds	r0, #36	; 0x24
    }

    PRINTF("RawKey: %.*H\n", rawKeyLen, rawKey);
    offset += KEY_ID_SIZE;

    uint8_t algorithmId = workBuffer[offset];
c0de1d90:	5c20      	ldrb	r0, [r4, r0]
    PRINTF("Algorithm: %d\n", algorithmId);
    cx_curve_t curve;
    verificationAlgo *verificationFn;
    cx_md_t hashId;

    switch (algorithmId) {
c0de1d92:	2801      	cmp	r0, #1
c0de1d94:	d155      	bne.n	c0de1e42 <handleSetPlugin+0x172>
c0de1d96:	aa1b      	add	r2, sp, #108	; 0x6c
c0de1d98:	2320      	movs	r3, #32
            THROW(0x6a80);
            break;
    }
    offset += ALGORITHM_ID_SIZE;
    PRINTF("hashing: %.*H\n", payloadSize, workBuffer);
    cx_hash_sha256(workBuffer, payloadSize, hash, sizeof(hash));
c0de1d9a:	4620      	mov	r0, r4
c0de1d9c:	4629      	mov	r1, r5
c0de1d9e:	f001 f973 	bl	c0de3088 <cx_hash_sha256>

    if (dataLength < payloadSize + SIGNATURE_LENGTH_SIZE) {
c0de1da2:	463e      	mov	r6, r7
c0de1da4:	3626      	adds	r6, #38	; 0x26
c0de1da6:	9906      	ldr	r1, [sp, #24]
c0de1da8:	428e      	cmp	r6, r1
c0de1daa:	d84a      	bhi.n	c0de1e42 <handleSetPlugin+0x172>
        PRINTF("Data too short to hold signature length\n");
        THROW(0x6a80);
    }

    uint8_t signatureLen = workBuffer[offset];
c0de1dac:	5d65      	ldrb	r5, [r4, r5]
    PRINTF("Signature len: %d\n", signatureLen);
    if (signatureLen < MIN_DER_SIG_SIZE || signatureLen > MAX_DER_SIG_SIZE) {
c0de1dae:	4628      	mov	r0, r5
c0de1db0:	3843      	subs	r0, #67	; 0x43
c0de1db2:	2806      	cmp	r0, #6
c0de1db4:	d245      	bcs.n	c0de1e42 <handleSetPlugin+0x172>
               signatureLen);
        THROW(0x6a80);
    }
    offset += SIGNATURE_LENGTH_SIZE;

    if (dataLength < payloadSize + SIGNATURE_LENGTH_SIZE + signatureLen) {
c0de1db6:	1970      	adds	r0, r6, r5
c0de1db8:	4288      	cmp	r0, r1
c0de1dba:	d842      	bhi.n	c0de1e42 <handleSetPlugin+0x172>
c0de1dbc:	2021      	movs	r0, #33	; 0x21
c0de1dbe:	4927      	ldr	r1, [pc, #156]	; (c0de1e5c <handleSetPlugin+0x18c>)
c0de1dc0:	4479      	add	r1, pc
c0de1dc2:	2241      	movs	r2, #65	; 0x41
c0de1dc4:	ab08      	add	r3, sp, #32
c0de1dc6:	f001 f947 	bl	c0de3058 <cx_ecfp_init_public_key_no_throw>
c0de1dca:	2800      	cmp	r0, #0
c0de1dcc:	d13b      	bne.n	c0de1e46 <handleSetPlugin+0x176>
c0de1dce:	9500      	str	r5, [sp, #0]
    if (!verificationFn(&pluginKey,
                        CX_LAST,
                        hashId,
                        hash,
                        sizeof(hash),
                        workBuffer + offset,
c0de1dd0:	19a3      	adds	r3, r4, r6
c0de1dd2:	a808      	add	r0, sp, #32
c0de1dd4:	a91b      	add	r1, sp, #108	; 0x6c
c0de1dd6:	2220      	movs	r2, #32
c0de1dd8:	f001 f926 	bl	c0de3028 <cx_ecdsa_verify_no_throw>
    if (!verificationFn(&pluginKey,
c0de1ddc:	2800      	cmp	r0, #0
c0de1dde:	d030      	beq.n	c0de1e42 <handleSetPlugin+0x172>
    if (pluginNameLength == sizeof(ERC721_STR) - 1 &&
c0de1de0:	2f07      	cmp	r7, #7
c0de1de2:	d00d      	beq.n	c0de1e00 <handleSetPlugin+0x130>
c0de1de4:	2f06      	cmp	r7, #6
c0de1de6:	d128      	bne.n	c0de1e3a <handleSetPlugin+0x16a>
        strncmp(pluginName, ERC721_STR, pluginNameLength) == 0) {
c0de1de8:	4648      	mov	r0, r9
c0de1dea:	4918      	ldr	r1, [pc, #96]	; (c0de1e4c <handleSetPlugin+0x17c>)
c0de1dec:	1840      	adds	r0, r0, r1
c0de1dee:	491c      	ldr	r1, [pc, #112]	; (c0de1e60 <handleSetPlugin+0x190>)
c0de1df0:	4479      	add	r1, pc
c0de1df2:	2206      	movs	r2, #6
c0de1df4:	f00b fd2e 	bl	c0ded854 <memcmp>
    if (pluginNameLength == sizeof(ERC721_STR) - 1 &&
c0de1df8:	2800      	cmp	r0, #0
c0de1dfa:	d11e      	bne.n	c0de1e3a <handleSetPlugin+0x16a>
c0de1dfc:	2001      	movs	r0, #1
c0de1dfe:	e00a      	b.n	c0de1e16 <handleSetPlugin+0x146>
               strncmp(pluginName, ERC1155_STR, pluginNameLength) == 0) {
c0de1e00:	4648      	mov	r0, r9
c0de1e02:	4912      	ldr	r1, [pc, #72]	; (c0de1e4c <handleSetPlugin+0x17c>)
c0de1e04:	1840      	adds	r0, r0, r1
c0de1e06:	4917      	ldr	r1, [pc, #92]	; (c0de1e64 <handleSetPlugin+0x194>)
c0de1e08:	4479      	add	r1, pc
c0de1e0a:	2207      	movs	r2, #7
c0de1e0c:	f00b fd22 	bl	c0ded854 <memcmp>
    } else if (pluginNameLength == sizeof(ERC1155_STR) - 1 &&
c0de1e10:	2800      	cmp	r0, #0
c0de1e12:	d112      	bne.n	c0de1e3a <handleSetPlugin+0x16a>
c0de1e14:	2002      	movs	r0, #2
c0de1e16:	9929      	ldr	r1, [sp, #164]	; 0xa4
        PRINTF("Invalid NFT signature\n");
        THROW(0x6A80);
#endif
    }

    pluginType = getPluginType(tokenContext->pluginName, pluginNameLength);
c0de1e18:	4a0e      	ldr	r2, [pc, #56]	; (c0de1e54 <handleSetPlugin+0x184>)
c0de1e1a:	464b      	mov	r3, r9
c0de1e1c:	5498      	strb	r0, [r3, r2]
        }
        default:
            break;
    }

    G_io_apdu_buffer[(*tx)++] = 0x90;
c0de1e1e:	6808      	ldr	r0, [r1, #0]
c0de1e20:	1c42      	adds	r2, r0, #1
c0de1e22:	600a      	str	r2, [r1, #0]
c0de1e24:	4a0c      	ldr	r2, [pc, #48]	; (c0de1e58 <handleSetPlugin+0x188>)
c0de1e26:	189a      	adds	r2, r3, r2
c0de1e28:	2390      	movs	r3, #144	; 0x90
c0de1e2a:	5413      	strb	r3, [r2, r0]
    G_io_apdu_buffer[(*tx)++] = 0x00;
c0de1e2c:	6808      	ldr	r0, [r1, #0]
c0de1e2e:	1c43      	adds	r3, r0, #1
c0de1e30:	600b      	str	r3, [r1, #0]
c0de1e32:	9907      	ldr	r1, [sp, #28]
c0de1e34:	5411      	strb	r1, [r2, r0]
}
c0de1e36:	b023      	add	sp, #140	; 0x8c
c0de1e38:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pluginType = getPluginType(tokenContext->pluginName, pluginNameLength);
c0de1e3a:	4806      	ldr	r0, [pc, #24]	; (c0de1e54 <handleSetPlugin+0x184>)
c0de1e3c:	4649      	mov	r1, r9
c0de1e3e:	9a07      	ldr	r2, [sp, #28]
c0de1e40:	540a      	strb	r2, [r1, r0]
c0de1e42:	20d5      	movs	r0, #213	; 0xd5
c0de1e44:	01c0      	lsls	r0, r0, #7
c0de1e46:	f005 faee 	bl	c0de7426 <os_longjmp>
c0de1e4a:	46c0      	nop			; (mov r8, r8)
c0de1e4c:	00000594 	.word	0x00000594
c0de1e50:	00000590 	.word	0x00000590
c0de1e54:	0000011e 	.word	0x0000011e
c0de1e58:	00000990 	.word	0x00000990
c0de1e5c:	0000d93b 	.word	0x0000d93b
c0de1e60:	0000c04f 	.word	0x0000c04f
c0de1e64:	0000c03e 	.word	0x0000c03e

c0de1e68 <handleSignPersonalMessage>:
void handleSignPersonalMessage(uint8_t p1,
                               uint8_t p2,
                               uint8_t *workBuffer,
                               uint16_t dataLength,
                               unsigned int *flags,
                               unsigned int *tx) {
c0de1e68:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de1e6a:	b08f      	sub	sp, #60	; 0x3c
c0de1e6c:	461f      	mov	r7, r3
c0de1e6e:	4615      	mov	r5, r2
    UNUSED(tx);
    uint8_t hashMessage[INT256_LENGTH];
    if (p1 == P1_FIRST) {
c0de1e70:	2880      	cmp	r0, #128	; 0x80
c0de1e72:	d100      	bne.n	c0de1e76 <handleSignPersonalMessage+0xe>
c0de1e74:	e08f      	b.n	c0de1f96 <handleSignPersonalMessage+0x12e>
c0de1e76:	2800      	cmp	r0, #0
c0de1e78:	d000      	beq.n	c0de1e7c <handleSignPersonalMessage+0x14>
c0de1e7a:	e159      	b.n	c0de2130 <handleSignPersonalMessage+0x2c8>
c0de1e7c:	9103      	str	r1, [sp, #12]
c0de1e7e:	9004      	str	r0, [sp, #16]
c0de1e80:	a807      	add	r0, sp, #28
c0de1e82:	2600      	movs	r6, #0
        char tmp[11] = {0};
c0de1e84:	7286      	strb	r6, [r0, #10]
c0de1e86:	8106      	strh	r6, [r0, #8]
c0de1e88:	9608      	str	r6, [sp, #32]
c0de1e8a:	9607      	str	r6, [sp, #28]
        uint32_t i;
        if (dataLength < 1) {
c0de1e8c:	2f00      	cmp	r7, #0
c0de1e8e:	d100      	bne.n	c0de1e92 <handleSignPersonalMessage+0x2a>
c0de1e90:	e14a      	b.n	c0de2128 <handleSignPersonalMessage+0x2c0>
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        if (appState != APP_STATE_IDLE) {
c0de1e92:	4cae      	ldr	r4, [pc, #696]	; (c0de214c <handleSignPersonalMessage+0x2e4>)
c0de1e94:	4648      	mov	r0, r9
c0de1e96:	5d00      	ldrb	r0, [r0, r4]
c0de1e98:	2800      	cmp	r0, #0
c0de1e9a:	d001      	beq.n	c0de1ea0 <handleSignPersonalMessage+0x38>
            reset_app_context();
c0de1e9c:	f004 fbe2 	bl	c0de6664 <reset_app_context>
        }
        appState = APP_STATE_SIGNING_MESSAGE;
c0de1ea0:	4648      	mov	r0, r9
c0de1ea2:	2102      	movs	r1, #2
c0de1ea4:	5501      	strb	r1, [r0, r4]

        tmpCtx.messageSigningContext.pathLength = workBuffer[0];
c0de1ea6:	782b      	ldrb	r3, [r5, #0]
c0de1ea8:	49a9      	ldr	r1, [pc, #676]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de1eaa:	5443      	strb	r3, [r0, r1]
c0de1eac:	9306      	str	r3, [sp, #24]
        if ((tmpCtx.messageSigningContext.pathLength < 0x01) ||
c0de1eae:	1e58      	subs	r0, r3, #1
c0de1eb0:	280a      	cmp	r0, #10
c0de1eb2:	d300      	bcc.n	c0de1eb6 <handleSignPersonalMessage+0x4e>
c0de1eb4:	e138      	b.n	c0de2128 <handleSignPersonalMessage+0x2c0>
c0de1eb6:	4648      	mov	r0, r9
c0de1eb8:	1840      	adds	r0, r0, r1
c0de1eba:	1d04      	adds	r4, r0, #4
            PRINTF("Invalid path\n");
            THROW(0x6a80);
        }
        workBuffer++;
        dataLength--;
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0de1ebc:	1d6d      	adds	r5, r5, #5
        dataLength--;
c0de1ebe:	1e7f      	subs	r7, r7, #1
c0de1ec0:	2003      	movs	r0, #3
c0de1ec2:	43c0      	mvns	r0, r0
c0de1ec4:	9005      	str	r0, [sp, #20]
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0de1ec6:	9805      	ldr	r0, [sp, #20]
c0de1ec8:	1828      	adds	r0, r5, r0
c0de1eca:	9906      	ldr	r1, [sp, #24]
c0de1ecc:	428e      	cmp	r6, r1
c0de1ece:	d20a      	bcs.n	c0de1ee6 <handleSignPersonalMessage+0x7e>
c0de1ed0:	b2b9      	uxth	r1, r7
            if (dataLength < sizeof(uint32_t)) {
c0de1ed2:	2903      	cmp	r1, #3
c0de1ed4:	d800      	bhi.n	c0de1ed8 <handleSignPersonalMessage+0x70>
c0de1ed6:	e127      	b.n	c0de2128 <handleSignPersonalMessage+0x2c0>
                PRINTF("Invalid data\n");
                THROW(0x6a80);
            }
            tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
c0de1ed8:	f000 f94e 	bl	c0de2178 <U4BE>
c0de1edc:	c401      	stmia	r4!, {r0}
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0de1ede:	1d2d      	adds	r5, r5, #4
c0de1ee0:	1c76      	adds	r6, r6, #1
            workBuffer += sizeof(uint32_t);
            dataLength -= sizeof(uint32_t);
c0de1ee2:	1f3f      	subs	r7, r7, #4
c0de1ee4:	e7ef      	b.n	c0de1ec6 <handleSignPersonalMessage+0x5e>
c0de1ee6:	9506      	str	r5, [sp, #24]
c0de1ee8:	b2b9      	uxth	r1, r7
        }
        if (dataLength < sizeof(uint32_t)) {
c0de1eea:	2903      	cmp	r1, #3
c0de1eec:	d800      	bhi.n	c0de1ef0 <handleSignPersonalMessage+0x88>
c0de1eee:	e11b      	b.n	c0de2128 <handleSignPersonalMessage+0x2c0>
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        tmpCtx.messageSigningContext.remainingLength = U4BE(workBuffer, 0);
c0de1ef0:	464c      	mov	r4, r9
c0de1ef2:	4997      	ldr	r1, [pc, #604]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de1ef4:	1865      	adds	r5, r4, r1
c0de1ef6:	f000 f93f 	bl	c0de2178 <U4BE>
c0de1efa:	64e8      	str	r0, [r5, #76]	; 0x4c
 * 
 * @throws           CX_INVALID_PARAMETER
 */
static inline int cx_keccak_init ( cx_sha3_t * hash, size_t size )
{
  CX_THROW(cx_keccak_init_no_throw(hash, size));
c0de1efc:	4d95      	ldr	r5, [pc, #596]	; (c0de2154 <handleSignPersonalMessage+0x2ec>)
c0de1efe:	1960      	adds	r0, r4, r5
c0de1f00:	2101      	movs	r1, #1
c0de1f02:	0209      	lsls	r1, r1, #8
c0de1f04:	f001 f8cc 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de1f08:	2800      	cmp	r0, #0
c0de1f0a:	d000      	beq.n	c0de1f0e <handleSignPersonalMessage+0xa6>
c0de1f0c:	e10e      	b.n	c0de212c <handleSignPersonalMessage+0x2c4>
c0de1f0e:	1f3f      	subs	r7, r7, #4
c0de1f10:	2600      	movs	r6, #0
        workBuffer += sizeof(uint32_t);
        dataLength -= sizeof(uint32_t);
        // Initialize message header + length
        cx_keccak_init(&global_sha3, 256);
        cx_hash((cx_hash_t *) &global_sha3,
c0de1f12:	9600      	str	r6, [sp, #0]
c0de1f14:	9601      	str	r6, [sp, #4]
c0de1f16:	464c      	mov	r4, r9
c0de1f18:	1960      	adds	r0, r4, r5
c0de1f1a:	9005      	str	r0, [sp, #20]
c0de1f1c:	4a91      	ldr	r2, [pc, #580]	; (c0de2164 <handleSignPersonalMessage+0x2fc>)
c0de1f1e:	447a      	add	r2, pc
c0de1f20:	231a      	movs	r3, #26
c0de1f22:	4631      	mov	r1, r6
c0de1f24:	f000 f933 	bl	c0de218e <cx_hash>
                0,
                (uint8_t *) SIGN_MAGIC,
                sizeof(SIGN_MAGIC) - 1,
                NULL,
                0);
        snprintf(tmp, sizeof(tmp), "%u", tmpCtx.messageSigningContext.remainingLength);
c0de1f28:	4889      	ldr	r0, [pc, #548]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de1f2a:	1820      	adds	r0, r4, r0
c0de1f2c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
c0de1f2e:	ad07      	add	r5, sp, #28
c0de1f30:	210b      	movs	r1, #11
c0de1f32:	4a8d      	ldr	r2, [pc, #564]	; (c0de2168 <handleSignPersonalMessage+0x300>)
c0de1f34:	447a      	add	r2, pc
c0de1f36:	4628      	mov	r0, r5
c0de1f38:	f005 ffa8 	bl	c0de7e8c <snprintf>
        cx_hash((cx_hash_t *) &global_sha3, 0, (uint8_t *) tmp, strlen(tmp), NULL, 0);
c0de1f3c:	4628      	mov	r0, r5
c0de1f3e:	f00b fe6f 	bl	c0dedc20 <strlen>
c0de1f42:	4603      	mov	r3, r0
c0de1f44:	9600      	str	r6, [sp, #0]
c0de1f46:	9601      	str	r6, [sp, #4]
c0de1f48:	9805      	ldr	r0, [sp, #20]
c0de1f4a:	4631      	mov	r1, r6
c0de1f4c:	462a      	mov	r2, r5
c0de1f4e:	f000 f91e 	bl	c0de218e <cx_hash>
 *
 * @return          SHA256 identifier.
 */
static inline int cx_sha256_init ( cx_sha256_t * hash )
{
  cx_sha256_init_no_throw(hash);
c0de1f52:	4881      	ldr	r0, [pc, #516]	; (c0de2158 <handleSignPersonalMessage+0x2f0>)
c0de1f54:	1820      	adds	r0, r4, r0
c0de1f56:	f001 f8c7 	bl	c0de30e8 <cx_sha256_init_no_throw>
c0de1f5a:	9d06      	ldr	r5, [sp, #24]
    for (uint8_t idx = 0; idx < length; ++idx) {
c0de1f5c:	b2f0      	uxtb	r0, r6
c0de1f5e:	b2b9      	uxth	r1, r7
c0de1f60:	4281      	cmp	r1, r0
c0de1f62:	d912      	bls.n	c0de1f8a <handleSignPersonalMessage+0x122>
        if (!is_char_special(data[idx]) && ((data[idx] < 0x20) || (data[idx] > 0x7e))) {
c0de1f64:	5c28      	ldrb	r0, [r5, r0]
    return ((c >= '\b') && (c <= '\r'));
c0de1f66:	4601      	mov	r1, r0
c0de1f68:	3908      	subs	r1, #8
    for (uint8_t idx = 0; idx < length; ++idx) {
c0de1f6a:	1c76      	adds	r6, r6, #1
        if (!is_char_special(data[idx]) && ((data[idx] < 0x20) || (data[idx] > 0x7e))) {
c0de1f6c:	2906      	cmp	r1, #6
c0de1f6e:	d3f5      	bcc.n	c0de1f5c <handleSignPersonalMessage+0xf4>
c0de1f70:	3820      	subs	r0, #32
c0de1f72:	285e      	cmp	r0, #94	; 0x5e
c0de1f74:	d9f2      	bls.n	c0de1f5c <handleSignPersonalMessage+0xf4>
        strcpy(strings.tmp.tmp, "0x");  // will display the hex bytes instead
c0de1f76:	4879      	ldr	r0, [pc, #484]	; (c0de215c <handleSignPersonalMessage+0x2f4>)
c0de1f78:	4649      	mov	r1, r9
c0de1f7a:	1808      	adds	r0, r1, r0
c0de1f7c:	497b      	ldr	r1, [pc, #492]	; (c0de216c <handleSignPersonalMessage+0x304>)
c0de1f7e:	4479      	add	r1, pc
c0de1f80:	2203      	movs	r2, #3
c0de1f82:	f00b fc4d 	bl	c0ded820 <__aeabi_memcpy>
c0de1f86:	9d06      	ldr	r5, [sp, #24]
c0de1f88:	e003      	b.n	c0de1f92 <handleSignPersonalMessage+0x12a>
        strings.tmp.tmp[0] = '\0';  // init string as empty
c0de1f8a:	4874      	ldr	r0, [pc, #464]	; (c0de215c <handleSignPersonalMessage+0x2f4>)
c0de1f8c:	4649      	mov	r1, r9
c0de1f8e:	2300      	movs	r3, #0
c0de1f90:	540b      	strb	r3, [r1, r0]
c0de1f92:	9804      	ldr	r0, [sp, #16]
c0de1f94:	9903      	ldr	r1, [sp, #12]
        init_value_str(is_data_ascii(workBuffer, dataLength));

    } else if (p1 != P1_MORE) {
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0de1f96:	2900      	cmp	r1, #0
c0de1f98:	d000      	beq.n	c0de1f9c <handleSignPersonalMessage+0x134>
c0de1f9a:	e0c9      	b.n	c0de2130 <handleSignPersonalMessage+0x2c8>
        THROW(0x6B00);
    }
    if ((p1 == P1_MORE) && (appState != APP_STATE_SIGNING_MESSAGE)) {
c0de1f9c:	2880      	cmp	r0, #128	; 0x80
c0de1f9e:	d105      	bne.n	c0de1fac <handleSignPersonalMessage+0x144>
c0de1fa0:	486a      	ldr	r0, [pc, #424]	; (c0de214c <handleSignPersonalMessage+0x2e4>)
c0de1fa2:	4649      	mov	r1, r9
c0de1fa4:	5c08      	ldrb	r0, [r1, r0]
c0de1fa6:	2802      	cmp	r0, #2
c0de1fa8:	d000      	beq.n	c0de1fac <handleSignPersonalMessage+0x144>
c0de1faa:	e0c5      	b.n	c0de2138 <handleSignPersonalMessage+0x2d0>
        PRINTF("Signature not initialized\n");
        THROW(0x6985);
    }
    if (dataLength > tmpCtx.messageSigningContext.remainingLength) {
c0de1fac:	4968      	ldr	r1, [pc, #416]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de1fae:	4648      	mov	r0, r9
c0de1fb0:	1840      	adds	r0, r0, r1
c0de1fb2:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
c0de1fb4:	b2bf      	uxth	r7, r7
c0de1fb6:	42b8      	cmp	r0, r7
c0de1fb8:	d200      	bcs.n	c0de1fbc <handleSignPersonalMessage+0x154>
c0de1fba:	e0b5      	b.n	c0de2128 <handleSignPersonalMessage+0x2c0>
c0de1fbc:	2600      	movs	r6, #0
        THROW(0x6A80);
    }

    cx_hash((cx_hash_t *) &global_sha3, 0, workBuffer, dataLength, NULL, 0);
c0de1fbe:	9600      	str	r6, [sp, #0]
c0de1fc0:	9601      	str	r6, [sp, #4]
c0de1fc2:	4864      	ldr	r0, [pc, #400]	; (c0de2154 <handleSignPersonalMessage+0x2ec>)
c0de1fc4:	464c      	mov	r4, r9
c0de1fc6:	1820      	adds	r0, r4, r0
c0de1fc8:	4631      	mov	r1, r6
c0de1fca:	462a      	mov	r2, r5
c0de1fcc:	463b      	mov	r3, r7
c0de1fce:	f000 f8de 	bl	c0de218e <cx_hash>
    cx_hash((cx_hash_t *) &tmpContent.sha2, 0, workBuffer, dataLength, NULL, 0);
c0de1fd2:	9600      	str	r6, [sp, #0]
c0de1fd4:	9601      	str	r6, [sp, #4]
c0de1fd6:	4860      	ldr	r0, [pc, #384]	; (c0de2158 <handleSignPersonalMessage+0x2f0>)
c0de1fd8:	1820      	adds	r0, r4, r0
c0de1fda:	4631      	mov	r1, r6
c0de1fdc:	9506      	str	r5, [sp, #24]
c0de1fde:	462a      	mov	r2, r5
c0de1fe0:	463b      	mov	r3, r7
c0de1fe2:	f000 f8d4 	bl	c0de218e <cx_hash>
    tmpCtx.messageSigningContext.remainingLength -= dataLength;
c0de1fe6:	485a      	ldr	r0, [pc, #360]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de1fe8:	1820      	adds	r0, r4, r0
c0de1fea:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
c0de1fec:	9705      	str	r7, [sp, #20]
c0de1fee:	1bc9      	subs	r1, r1, r7
c0de1ff0:	9104      	str	r1, [sp, #16]
c0de1ff2:	64c1      	str	r1, [r0, #76]	; 0x4c
    uint16_t value_strlen = strlen(strings.tmp.tmp);
c0de1ff4:	4f59      	ldr	r7, [pc, #356]	; (c0de215c <handleSignPersonalMessage+0x2f4>)
c0de1ff6:	19e0      	adds	r0, r4, r7
c0de1ff8:	f00b fe12 	bl	c0dedc20 <strlen>
    if ((value_strlen + 1) < sizeof(strings.tmp.tmp)) {
c0de1ffc:	b280      	uxth	r0, r0
c0de1ffe:	28fe      	cmp	r0, #254	; 0xfe
c0de2000:	d831      	bhi.n	c0de2066 <handleSignPersonalMessage+0x1fe>
    return (memcmp(strings.tmp.tmp, "0x", 2) != 0);
c0de2002:	4649      	mov	r1, r9
c0de2004:	5dca      	ldrb	r2, [r1, r7]
c0de2006:	19c9      	adds	r1, r1, r7
c0de2008:	7849      	ldrb	r1, [r1, #1]
c0de200a:	0209      	lsls	r1, r1, #8
c0de200c:	1889      	adds	r1, r1, r2
c0de200e:	4a54      	ldr	r2, [pc, #336]	; (c0de2160 <handleSignPersonalMessage+0x2f8>)
        if (is_ascii) {
c0de2010:	4291      	cmp	r1, r2
c0de2012:	9a06      	ldr	r2, [sp, #24]
c0de2014:	d030      	beq.n	c0de2078 <handleSignPersonalMessage+0x210>
c0de2016:	4634      	mov	r4, r6
            while ((src_idx < length) && (dst_idx < sizeof(strings.tmp.tmp))) {
c0de2018:	b2f1      	uxtb	r1, r6
c0de201a:	9b05      	ldr	r3, [sp, #20]
c0de201c:	4299      	cmp	r1, r3
c0de201e:	d224      	bcs.n	c0de206a <handleSignPersonalMessage+0x202>
c0de2020:	28ff      	cmp	r0, #255	; 0xff
c0de2022:	d822      	bhi.n	c0de206a <handleSignPersonalMessage+0x202>
c0de2024:	5c53      	ldrb	r3, [r2, r1]
    return ((c >= '\b') && (c <= '\r'));
c0de2026:	461e      	mov	r6, r3
c0de2028:	3e08      	subs	r6, #8
c0de202a:	b2f5      	uxtb	r5, r6
c0de202c:	2d06      	cmp	r5, #6
c0de202e:	d301      	bcc.n	c0de2034 <handleSignPersonalMessage+0x1cc>
c0de2030:	2200      	movs	r2, #0
c0de2032:	e000      	b.n	c0de2036 <handleSignPersonalMessage+0x1ce>
c0de2034:	2201      	movs	r2, #1
                if (prev_is_special) {
c0de2036:	07e4      	lsls	r4, r4, #31
c0de2038:	d10a      	bne.n	c0de2050 <handleSignPersonalMessage+0x1e8>
                    if (is_char_special(data[src_idx])) {
c0de203a:	2d05      	cmp	r5, #5
c0de203c:	d80b      	bhi.n	c0de2056 <handleSignPersonalMessage+0x1ee>
                        strings.tmp.tmp[dst_idx] = ' ';
c0de203e:	464b      	mov	r3, r9
c0de2040:	19db      	adds	r3, r3, r7
c0de2042:	2420      	movs	r4, #32
c0de2044:	541c      	strb	r4, [r3, r0]
                if (!is_char_special(data[src_idx])) {
c0de2046:	9b06      	ldr	r3, [sp, #24]
c0de2048:	5c5b      	ldrb	r3, [r3, r1]
    return ((c >= '\b') && (c <= '\r'));
c0de204a:	461e      	mov	r6, r3
c0de204c:	3e08      	subs	r6, #8
                        dst_idx += 1;
c0de204e:	1c40      	adds	r0, r0, #1
    return ((c >= '\b') && (c <= '\r'));
c0de2050:	b2f4      	uxtb	r4, r6
                if (!is_char_special(data[src_idx])) {
c0de2052:	2c06      	cmp	r4, #6
c0de2054:	d303      	bcc.n	c0de205e <handleSignPersonalMessage+0x1f6>
                    strings.tmp.tmp[dst_idx] = data[src_idx];
c0de2056:	464c      	mov	r4, r9
c0de2058:	19e4      	adds	r4, r4, r7
c0de205a:	5423      	strb	r3, [r4, r0]
                    dst_idx += 1;
c0de205c:	1c40      	adds	r0, r0, #1
                src_idx += 1;
c0de205e:	1c4e      	adds	r6, r1, #1
c0de2060:	4614      	mov	r4, r2
c0de2062:	9a06      	ldr	r2, [sp, #24]
c0de2064:	e7d8      	b.n	c0de2018 <handleSignPersonalMessage+0x1b0>
c0de2066:	9a06      	ldr	r2, [sp, #24]
c0de2068:	e033      	b.n	c0de20d2 <handleSignPersonalMessage+0x26a>
            if (dst_idx < sizeof(strings.tmp.tmp)) {
c0de206a:	28ff      	cmp	r0, #255	; 0xff
c0de206c:	d827      	bhi.n	c0de20be <handleSignPersonalMessage+0x256>
                strings.tmp.tmp[dst_idx] = '\0';
c0de206e:	4649      	mov	r1, r9
c0de2070:	19c9      	adds	r1, r1, r7
c0de2072:	2300      	movs	r3, #0
c0de2074:	540b      	strb	r3, [r1, r0]
c0de2076:	e02c      	b.n	c0de20d2 <handleSignPersonalMessage+0x26a>
            for (size_t i = 0; i < length; i++) {
c0de2078:	4649      	mov	r1, r9
c0de207a:	19c9      	adds	r1, r1, r7
c0de207c:	2301      	movs	r3, #1
c0de207e:	021b      	lsls	r3, r3, #8
            length = MIN(length, (sizeof(strings.tmp.tmp) - value_strlen) / 2);
c0de2080:	1a1e      	subs	r6, r3, r0
c0de2082:	0873      	lsrs	r3, r6, #1
c0de2084:	9c05      	ldr	r4, [sp, #20]
c0de2086:	429c      	cmp	r4, r3
c0de2088:	d300      	bcc.n	c0de208c <handleSignPersonalMessage+0x224>
c0de208a:	461c      	mov	r4, r3
c0de208c:	9405      	str	r4, [sp, #20]
c0de208e:	180f      	adds	r7, r1, r0
c0de2090:	2400      	movs	r4, #0
c0de2092:	4d37      	ldr	r5, [pc, #220]	; (c0de2170 <handleSignPersonalMessage+0x308>)
c0de2094:	447d      	add	r5, pc
            for (size_t i = 0; i < length; i++) {
c0de2096:	9805      	ldr	r0, [sp, #20]
c0de2098:	4284      	cmp	r4, r0
c0de209a:	d20b      	bcs.n	c0de20b4 <handleSignPersonalMessage+0x24c>
                         data[i]);
c0de209c:	9806      	ldr	r0, [sp, #24]
c0de209e:	5d03      	ldrb	r3, [r0, r4]
                snprintf(strings.tmp.tmp + value_strlen + 2 * i,
c0de20a0:	4638      	mov	r0, r7
c0de20a2:	4631      	mov	r1, r6
c0de20a4:	462a      	mov	r2, r5
c0de20a6:	f005 fef1 	bl	c0de7e8c <snprintf>
c0de20aa:	9a06      	ldr	r2, [sp, #24]
            for (size_t i = 0; i < length; i++) {
c0de20ac:	1cbf      	adds	r7, r7, #2
c0de20ae:	1eb6      	subs	r6, r6, #2
c0de20b0:	1c64      	adds	r4, r4, #1
c0de20b2:	e7f0      	b.n	c0de2096 <handleSignPersonalMessage+0x22e>

    feed_value_str(workBuffer, dataLength, is_value_str_ascii());

    if (tmpCtx.messageSigningContext.remainingLength == 0) {
c0de20b4:	4648      	mov	r0, r9
c0de20b6:	4926      	ldr	r1, [pc, #152]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de20b8:	1840      	adds	r0, r0, r1
c0de20ba:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
c0de20bc:	e00b      	b.n	c0de20d6 <handleSignPersonalMessage+0x26e>
                memcpy(strings.tmp.tmp + sizeof(strings.tmp.tmp) - sizeof(marker),
c0de20be:	4648      	mov	r0, r9
c0de20c0:	19c0      	adds	r0, r0, r7
c0de20c2:	21fc      	movs	r1, #252	; 0xfc
c0de20c4:	232e      	movs	r3, #46	; 0x2e
c0de20c6:	5443      	strb	r3, [r0, r1]
c0de20c8:	30fc      	adds	r0, #252	; 0xfc
c0de20ca:	2100      	movs	r1, #0
c0de20cc:	70c1      	strb	r1, [r0, #3]
c0de20ce:	7083      	strb	r3, [r0, #2]
c0de20d0:	7043      	strb	r3, [r0, #1]
c0de20d2:	491f      	ldr	r1, [pc, #124]	; (c0de2150 <handleSignPersonalMessage+0x2e8>)
c0de20d4:	9804      	ldr	r0, [sp, #16]
    if (tmpCtx.messageSigningContext.remainingLength == 0) {
c0de20d6:	2800      	cmp	r0, #0
c0de20d8:	d133      	bne.n	c0de2142 <handleSignPersonalMessage+0x2da>
c0de20da:	9814      	ldr	r0, [sp, #80]	; 0x50
        cx_hash((cx_hash_t *) &global_sha3,
c0de20dc:	9005      	str	r0, [sp, #20]
c0de20de:	2720      	movs	r7, #32
c0de20e0:	464c      	mov	r4, r9
c0de20e2:	1860      	adds	r0, r4, r1
c0de20e4:	302c      	adds	r0, #44	; 0x2c
c0de20e6:	9000      	str	r0, [sp, #0]
c0de20e8:	9701      	str	r7, [sp, #4]
c0de20ea:	481a      	ldr	r0, [pc, #104]	; (c0de2154 <handleSignPersonalMessage+0x2ec>)
c0de20ec:	1820      	adds	r0, r4, r0
c0de20ee:	2601      	movs	r6, #1
c0de20f0:	2500      	movs	r5, #0
c0de20f2:	4631      	mov	r1, r6
c0de20f4:	462b      	mov	r3, r5
c0de20f6:	f000 f84a 	bl	c0de218e <cx_hash>
                CX_LAST,
                workBuffer,
                0,
                tmpCtx.messageSigningContext.hash,
                32);
        cx_hash((cx_hash_t *) &tmpContent.sha2, CX_LAST, workBuffer, 0, hashMessage, 32);
c0de20fa:	9701      	str	r7, [sp, #4]
c0de20fc:	a807      	add	r0, sp, #28
c0de20fe:	9000      	str	r0, [sp, #0]
c0de2100:	4815      	ldr	r0, [pc, #84]	; (c0de2158 <handleSignPersonalMessage+0x2f0>)
c0de2102:	1820      	adds	r0, r4, r0
c0de2104:	4631      	mov	r1, r6
c0de2106:	9a06      	ldr	r2, [sp, #24]
c0de2108:	462b      	mov	r3, r5
c0de210a:	f000 f840 	bl	c0de218e <cx_hash>

#ifdef NO_CONSENT
        io_seproxyhal_touch_signMessage_ok(NULL);
#else   // NO_CONSENT
        ux_flow_init(0, ux_sign_flow, NULL);
c0de210e:	4919      	ldr	r1, [pc, #100]	; (c0de2174 <handleSignPersonalMessage+0x30c>)
c0de2110:	4479      	add	r1, pc
c0de2112:	4628      	mov	r0, r5
c0de2114:	462a      	mov	r2, r5
c0de2116:	f00a fc35 	bl	c0dec984 <ux_flow_init>
c0de211a:	9a05      	ldr	r2, [sp, #20]
#endif  // NO_CONSENT

        *flags |= IO_ASYNCH_REPLY;
c0de211c:	6810      	ldr	r0, [r2, #0]
c0de211e:	2110      	movs	r1, #16
c0de2120:	4301      	orrs	r1, r0
c0de2122:	6011      	str	r1, [r2, #0]

    } else {
        THROW(0x9000);
    }
}
c0de2124:	b00f      	add	sp, #60	; 0x3c
c0de2126:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de2128:	20d5      	movs	r0, #213	; 0xd5
c0de212a:	01c0      	lsls	r0, r0, #7
c0de212c:	f005 f97b 	bl	c0de7426 <os_longjmp>
c0de2130:	206b      	movs	r0, #107	; 0x6b
c0de2132:	0200      	lsls	r0, r0, #8
c0de2134:	f005 f977 	bl	c0de7426 <os_longjmp>
c0de2138:	20d5      	movs	r0, #213	; 0xd5
c0de213a:	01c0      	lsls	r0, r0, #7
        THROW(0x6985);
c0de213c:	38fb      	subs	r0, #251	; 0xfb
c0de213e:	f005 f972 	bl	c0de7426 <os_longjmp>
c0de2142:	2009      	movs	r0, #9
c0de2144:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0de2146:	f005 f96e 	bl	c0de7426 <os_longjmp>
c0de214a:	46c0      	nop			; (mov r8, r8)
c0de214c:	0000011c 	.word	0x0000011c
c0de2150:	00000124 	.word	0x00000124
c0de2154:	000007e8 	.word	0x000007e8
c0de2158:	0000026c 	.word	0x0000026c
c0de215c:	000006ba 	.word	0x000006ba
c0de2160:	00007830 	.word	0x00007830
c0de2164:	0000d81e 	.word	0x0000d81e
c0de2168:	0000bee5 	.word	0x0000bee5
c0de216c:	0000c185 	.word	0x0000c185
c0de2170:	0000c023 	.word	0x0000c023
c0de2174:	0000e3a8 	.word	0x0000e3a8

c0de2178 <U4BE>:
c0de2178:	7801      	ldrb	r1, [r0, #0]
c0de217a:	0609      	lsls	r1, r1, #24
c0de217c:	7842      	ldrb	r2, [r0, #1]
c0de217e:	0412      	lsls	r2, r2, #16
c0de2180:	1851      	adds	r1, r2, r1
         (buf[off + 2] << 8) | buf[off + 3];
c0de2182:	7882      	ldrb	r2, [r0, #2]
c0de2184:	0212      	lsls	r2, r2, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2186:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de2188:	78c0      	ldrb	r0, [r0, #3]
c0de218a:	1808      	adds	r0, r1, r0
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de218c:	4770      	bx	lr

c0de218e <cx_hash>:
 * 
 * @throws             INVALID_PARAMETER
 * @throws             CX_INVALID_PARAMETER
 */
static inline int cx_hash ( cx_hash_t * hash, int mode, const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len )
{
c0de218e:	b51c      	push	{r2, r3, r4, lr}
c0de2190:	4604      	mov	r4, r0
c0de2192:	9805      	ldr	r0, [sp, #20]
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de2194:	9001      	str	r0, [sp, #4]
c0de2196:	9804      	ldr	r0, [sp, #16]
c0de2198:	9000      	str	r0, [sp, #0]
c0de219a:	4620      	mov	r0, r4
c0de219c:	f000 ff6e 	bl	c0de307c <cx_hash_no_throw>
c0de21a0:	2800      	cmp	r0, #0
c0de21a2:	d103      	bne.n	c0de21ac <cx_hash+0x1e>
  return cx_hash_get_size(hash);
c0de21a4:	4620      	mov	r0, r4
c0de21a6:	f000 ff63 	bl	c0de3070 <cx_hash_get_size>
c0de21aa:	bd1c      	pop	{r2, r3, r4, pc}
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de21ac:	f005 f93b 	bl	c0de7426 <os_longjmp>

c0de21b0 <handleSignEIP712Message>:
void handleSignEIP712Message(uint8_t p1,
                             uint8_t p2,
                             uint8_t *workBuffer,
                             uint16_t dataLength,
                             unsigned int *flags,
                             unsigned int *tx) {
c0de21b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t i;

    UNUSED(tx);
    if ((p1 != 00) || (p2 != 00)) {
c0de21b2:	4308      	orrs	r0, r1
c0de21b4:	d152      	bne.n	c0de225c <handleSignEIP712Message+0xac>
c0de21b6:	461d      	mov	r5, r3
c0de21b8:	4614      	mov	r4, r2
        THROW(0x6B00);
    }
    if (appState != APP_STATE_IDLE) {
c0de21ba:	482b      	ldr	r0, [pc, #172]	; (c0de2268 <handleSignEIP712Message+0xb8>)
c0de21bc:	4649      	mov	r1, r9
c0de21be:	5c08      	ldrb	r0, [r1, r0]
c0de21c0:	2800      	cmp	r0, #0
c0de21c2:	d001      	beq.n	c0de21c8 <handleSignEIP712Message+0x18>
        reset_app_context();
c0de21c4:	f004 fa4e 	bl	c0de6664 <reset_app_context>
    }
    if (dataLength < 1) {
c0de21c8:	2d00      	cmp	r5, #0
c0de21ca:	d043      	beq.n	c0de2254 <handleSignEIP712Message+0xa4>
        PRINTF("Invalid data\n");
        THROW(0x6a80);
    }
    tmpCtx.messageSigningContext712.pathLength = workBuffer[0];
c0de21cc:	7821      	ldrb	r1, [r4, #0]
c0de21ce:	4b27      	ldr	r3, [pc, #156]	; (c0de226c <handleSignEIP712Message+0xbc>)
c0de21d0:	464a      	mov	r2, r9
c0de21d2:	54d1      	strb	r1, [r2, r3]
    if ((tmpCtx.messageSigningContext712.pathLength < 0x01) ||
c0de21d4:	1e4a      	subs	r2, r1, #1
c0de21d6:	2a0a      	cmp	r2, #10
c0de21d8:	d23c      	bcs.n	c0de2254 <handleSignEIP712Message+0xa4>
c0de21da:	9806      	ldr	r0, [sp, #24]
c0de21dc:	9000      	str	r0, [sp, #0]
c0de21de:	464a      	mov	r2, r9
c0de21e0:	18d2      	adds	r2, r2, r3
c0de21e2:	1d13      	adds	r3, r2, #4
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0de21e4:	3421      	adds	r4, #33	; 0x21
    dataLength--;
c0de21e6:	1e6d      	subs	r5, r5, #1
c0de21e8:	221f      	movs	r2, #31
c0de21ea:	43d2      	mvns	r2, r2
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0de21ec:	2900      	cmp	r1, #0
c0de21ee:	d012      	beq.n	c0de2216 <handleSignEIP712Message+0x66>
        if (dataLength < 4) {
c0de21f0:	b2ae      	uxth	r6, r5
c0de21f2:	2e03      	cmp	r6, #3
c0de21f4:	d92e      	bls.n	c0de2254 <handleSignEIP712Message+0xa4>
c0de21f6:	5ca6      	ldrb	r6, [r4, r2]
c0de21f8:	0636      	lsls	r6, r6, #24
c0de21fa:	18a0      	adds	r0, r4, r2
c0de21fc:	7847      	ldrb	r7, [r0, #1]
c0de21fe:	043f      	lsls	r7, r7, #16
c0de2200:	19be      	adds	r6, r7, r6
         (buf[off + 2] << 8) | buf[off + 3];
c0de2202:	7887      	ldrb	r7, [r0, #2]
c0de2204:	023f      	lsls	r7, r7, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2206:	19f6      	adds	r6, r6, r7
         (buf[off + 2] << 8) | buf[off + 3];
c0de2208:	78c0      	ldrb	r0, [r0, #3]
c0de220a:	1830      	adds	r0, r6, r0
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        tmpCtx.messageSigningContext712.bip32Path[i] = U4BE(workBuffer, 0);
c0de220c:	c301      	stmia	r3!, {r0}
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0de220e:	1d24      	adds	r4, r4, #4
c0de2210:	1e49      	subs	r1, r1, #1
        workBuffer += 4;
        dataLength -= 4;
c0de2212:	1f2d      	subs	r5, r5, #4
c0de2214:	e7ea      	b.n	c0de21ec <handleSignEIP712Message+0x3c>
    }
    if (dataLength < 32 + 32) {
c0de2216:	b2a8      	uxth	r0, r5
c0de2218:	283f      	cmp	r0, #63	; 0x3f
c0de221a:	d91b      	bls.n	c0de2254 <handleSignEIP712Message+0xa4>
c0de221c:	18a1      	adds	r1, r4, r2
        PRINTF("Invalid data\n");
        THROW(0x6a80);
    }
    memmove(tmpCtx.messageSigningContext712.domainHash, workBuffer, 32);
c0de221e:	4648      	mov	r0, r9
c0de2220:	4a12      	ldr	r2, [pc, #72]	; (c0de226c <handleSignEIP712Message+0xbc>)
c0de2222:	1885      	adds	r5, r0, r2
c0de2224:	4628      	mov	r0, r5
c0de2226:	302c      	adds	r0, #44	; 0x2c
c0de2228:	2620      	movs	r6, #32
c0de222a:	4632      	mov	r2, r6
c0de222c:	f00b fafc 	bl	c0ded828 <__aeabi_memmove>
    memmove(tmpCtx.messageSigningContext712.messageHash, workBuffer + 32, 32);
c0de2230:	354c      	adds	r5, #76	; 0x4c
c0de2232:	4628      	mov	r0, r5
c0de2234:	4621      	mov	r1, r4
c0de2236:	4632      	mov	r2, r6
c0de2238:	f00b faf6 	bl	c0ded828 <__aeabi_memmove>

#ifdef NO_CONSENT
    io_seproxyhal_touch_signMessage_ok(NULL);
#else   // NO_CONSENT
    ux_flow_init(0, ux_sign_712_v0_flow, NULL);
c0de223c:	490c      	ldr	r1, [pc, #48]	; (c0de2270 <handleSignEIP712Message+0xc0>)
c0de223e:	4479      	add	r1, pc
c0de2240:	2000      	movs	r0, #0
c0de2242:	4602      	mov	r2, r0
c0de2244:	f00a fb9e 	bl	c0dec984 <ux_flow_init>
c0de2248:	9a00      	ldr	r2, [sp, #0]
#endif  // NO_CONSENT

    *flags |= IO_ASYNCH_REPLY;
c0de224a:	6810      	ldr	r0, [r2, #0]
c0de224c:	2110      	movs	r1, #16
c0de224e:	4301      	orrs	r1, r0
c0de2250:	6011      	str	r1, [r2, #0]
}
c0de2252:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de2254:	20d5      	movs	r0, #213	; 0xd5
c0de2256:	01c0      	lsls	r0, r0, #7
c0de2258:	f005 f8e5 	bl	c0de7426 <os_longjmp>
c0de225c:	20d5      	movs	r0, #213	; 0xd5
c0de225e:	01c0      	lsls	r0, r0, #7
        THROW(0x6B00);
c0de2260:	3080      	adds	r0, #128	; 0x80
c0de2262:	f005 f8e0 	bl	c0de7426 <os_longjmp>
c0de2266:	46c0      	nop			; (mov r8, r8)
c0de2268:	0000011c 	.word	0x0000011c
c0de226c:	00000124 	.word	0x00000124
c0de2270:	0000e342 	.word	0x0000e342

c0de2274 <handleSign>:
void handleSign(uint8_t p1,
                uint8_t p2,
                uint8_t *workBuffer,
                uint16_t dataLength,
                unsigned int *flags,
                unsigned int *tx) {
c0de2274:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de2276:	b087      	sub	sp, #28
c0de2278:	461c      	mov	r4, r3
c0de227a:	9206      	str	r2, [sp, #24]
c0de227c:	460d      	mov	r5, r1
c0de227e:	4606      	mov	r6, r0
    parserStatus_e txResult;
    uint32_t i;
    uint8_t oracle_data_len;
    bool has_oracle_data = false;

    if (os_global_pin_is_validated() != BOLOS_UX_OK) {
c0de2280:	f006 ffd4 	bl	c0de922c <os_global_pin_is_validated>
c0de2284:	28aa      	cmp	r0, #170	; 0xaa
c0de2286:	d000      	beq.n	c0de228a <handleSign+0x16>
c0de2288:	e0f1      	b.n	c0de246e <handleSign+0x1fa>
        PRINTF("Device is PIN-locked");
        THROW(0x6982);
    }

    if (p1 == P1_FIRST) {
c0de228a:	2e80      	cmp	r6, #128	; 0x80
c0de228c:	d100      	bne.n	c0de2290 <handleSign+0x1c>
c0de228e:	e0b2      	b.n	c0de23f6 <handleSign+0x182>
c0de2290:	2e00      	cmp	r6, #0
c0de2292:	d000      	beq.n	c0de2296 <handleSign+0x22>
c0de2294:	e0e3      	b.n	c0de245e <handleSign+0x1ea>
        if (dataLength < 1) {
c0de2296:	2c00      	cmp	r4, #0
c0de2298:	d100      	bne.n	c0de229c <handleSign+0x28>
c0de229a:	e0dc      	b.n	c0de2456 <handleSign+0x1e2>
c0de229c:	9504      	str	r5, [sp, #16]

        // Oracle data requires at least 8 bytes:
        // - 1: version
        // - 6: magic
        // - 1: data len
        if (dataLength >= 8) {
c0de229e:	2c08      	cmp	r4, #8
c0de22a0:	d333      	bcc.n	c0de230a <handleSign+0x96>
            if (workBuffer[0] == 0x01
c0de22a2:	9806      	ldr	r0, [sp, #24]
c0de22a4:	7800      	ldrb	r0, [r0, #0]
                    && workBuffer[1] == 'o'
c0de22a6:	2801      	cmp	r0, #1
c0de22a8:	d12f      	bne.n	c0de230a <handleSign+0x96>
c0de22aa:	9806      	ldr	r0, [sp, #24]
c0de22ac:	7840      	ldrb	r0, [r0, #1]
                    && workBuffer[2] == 'r'
c0de22ae:	286f      	cmp	r0, #111	; 0x6f
c0de22b0:	d12b      	bne.n	c0de230a <handleSign+0x96>
c0de22b2:	9806      	ldr	r0, [sp, #24]
c0de22b4:	7880      	ldrb	r0, [r0, #2]
                    && workBuffer[3] == 'a'
c0de22b6:	2872      	cmp	r0, #114	; 0x72
c0de22b8:	d127      	bne.n	c0de230a <handleSign+0x96>
c0de22ba:	9806      	ldr	r0, [sp, #24]
c0de22bc:	78c0      	ldrb	r0, [r0, #3]
                    && workBuffer[4] == 'c'
c0de22be:	2861      	cmp	r0, #97	; 0x61
c0de22c0:	d123      	bne.n	c0de230a <handleSign+0x96>
c0de22c2:	9806      	ldr	r0, [sp, #24]
c0de22c4:	7900      	ldrb	r0, [r0, #4]
                    && workBuffer[5] == 'l'
c0de22c6:	2863      	cmp	r0, #99	; 0x63
c0de22c8:	d11f      	bne.n	c0de230a <handleSign+0x96>
c0de22ca:	9806      	ldr	r0, [sp, #24]
c0de22cc:	7940      	ldrb	r0, [r0, #5]
                    && workBuffer[6] == 'e') {
c0de22ce:	286c      	cmp	r0, #108	; 0x6c
c0de22d0:	d11b      	bne.n	c0de230a <handleSign+0x96>
c0de22d2:	9806      	ldr	r0, [sp, #24]
c0de22d4:	7980      	ldrb	r0, [r0, #6]
            if (workBuffer[0] == 0x01
c0de22d6:	2865      	cmp	r0, #101	; 0x65
c0de22d8:	d117      	bne.n	c0de230a <handleSign+0x96>
                // There is oracle data, read it!
                has_oracle_data = true;

                oracle_data_len = workBuffer[7];
c0de22da:	9806      	ldr	r0, [sp, #24]
c0de22dc:	79c5      	ldrb	r5, [r0, #7]
                workBuffer += 8;
                dataLength -= 8;
c0de22de:	3c08      	subs	r4, #8
c0de22e0:	b2a0      	uxth	r0, r4

                if (oracle_data_len > dataLength) {
c0de22e2:	42a8      	cmp	r0, r5
c0de22e4:	d200      	bcs.n	c0de22e8 <handleSign+0x74>
c0de22e6:	e0ce      	b.n	c0de2486 <handleSign+0x212>
                    PRINTF("Invalid oracle data length\n");
                    THROW(0x6a81);
                }

                if (oracle_data_len > sizeof(strings.common.oracle_data)) {
c0de22e8:	2d52      	cmp	r5, #82	; 0x52
c0de22ea:	d300      	bcc.n	c0de22ee <handleSign+0x7a>
c0de22ec:	e0cf      	b.n	c0de248e <handleSign+0x21a>
c0de22ee:	9f06      	ldr	r7, [sp, #24]
c0de22f0:	3708      	adds	r7, #8
                    PRINTF("Invalid oracle data too large\n");
                    THROW(0x6a82);
                }

                strlcpy(strings.common.oracle_data, workBuffer, sizeof(strings.common.oracle_data));
c0de22f2:	486a      	ldr	r0, [pc, #424]	; (c0de249c <handleSign+0x228>)
c0de22f4:	4649      	mov	r1, r9
c0de22f6:	1808      	adds	r0, r1, r0
c0de22f8:	30be      	adds	r0, #190	; 0xbe
c0de22fa:	2251      	movs	r2, #81	; 0x51
c0de22fc:	4639      	mov	r1, r7
c0de22fe:	f00b fc69 	bl	c0dedbd4 <strlcpy>

                workBuffer += oracle_data_len;
                dataLength -= oracle_data_len;
c0de2302:	1b64      	subs	r4, r4, r5
                workBuffer += oracle_data_len;
c0de2304:	197f      	adds	r7, r7, r5
c0de2306:	9706      	str	r7, [sp, #24]
c0de2308:	e007      	b.n	c0de231a <handleSign+0xa6>
            }
        }

        if (!has_oracle_data && N_storage.requireOracle) {
c0de230a:	486d      	ldr	r0, [pc, #436]	; (c0de24c0 <handleSign+0x24c>)
c0de230c:	4478      	add	r0, pc
c0de230e:	f005 ff99 	bl	c0de8244 <pic>
c0de2312:	78c0      	ldrb	r0, [r0, #3]
c0de2314:	2800      	cmp	r0, #0
c0de2316:	d000      	beq.n	c0de231a <handleSign+0xa6>
c0de2318:	e0ac      	b.n	c0de2474 <handleSign+0x200>
            PRINTF("Missing oracle data\n");
            ui_warning_oracle_data();
            THROW(0x6a83);
        }

        if (appState != APP_STATE_IDLE) {
c0de231a:	4d61      	ldr	r5, [pc, #388]	; (c0de24a0 <handleSign+0x22c>)
c0de231c:	4648      	mov	r0, r9
c0de231e:	5d40      	ldrb	r0, [r0, r5]
c0de2320:	2800      	cmp	r0, #0
c0de2322:	d001      	beq.n	c0de2328 <handleSign+0xb4>
            reset_app_context();
c0de2324:	f004 f99e 	bl	c0de6664 <reset_app_context>
c0de2328:	9605      	str	r6, [sp, #20]
        }
        appState = APP_STATE_SIGNING_TX;
c0de232a:	464a      	mov	r2, r9
c0de232c:	2001      	movs	r0, #1
c0de232e:	9003      	str	r0, [sp, #12]
c0de2330:	5550      	strb	r0, [r2, r5]
        tmpCtx.transactionContext.pathLength = workBuffer[0];
c0de2332:	9806      	ldr	r0, [sp, #24]
c0de2334:	7800      	ldrb	r0, [r0, #0]
c0de2336:	495b      	ldr	r1, [pc, #364]	; (c0de24a4 <handleSign+0x230>)
c0de2338:	5450      	strb	r0, [r2, r1]
        if ((tmpCtx.transactionContext.pathLength < 0x01) ||
c0de233a:	1e42      	subs	r2, r0, #1
c0de233c:	2a0a      	cmp	r2, #10
c0de233e:	d300      	bcc.n	c0de2342 <handleSign+0xce>
c0de2340:	e089      	b.n	c0de2456 <handleSign+0x1e2>
            (tmpCtx.transactionContext.pathLength > MAX_BIP32_PATH)) {
            PRINTF("Invalid path\n");
            THROW(0x6a80);
        }
        workBuffer++;
        dataLength--;
c0de2342:	1e64      	subs	r4, r4, #1
c0de2344:	2200      	movs	r2, #0
c0de2346:	4613      	mov	r3, r2
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0de2348:	9d06      	ldr	r5, [sp, #24]
c0de234a:	18ad      	adds	r5, r5, r2
c0de234c:	4283      	cmp	r3, r0
c0de234e:	d214      	bcs.n	c0de237a <handleSign+0x106>
            if (dataLength < 4) {
c0de2350:	b2a6      	uxth	r6, r4
c0de2352:	2e03      	cmp	r6, #3
c0de2354:	d97f      	bls.n	c0de2456 <handleSign+0x1e2>
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2356:	78ae      	ldrb	r6, [r5, #2]
c0de2358:	0436      	lsls	r6, r6, #16
c0de235a:	786f      	ldrb	r7, [r5, #1]
c0de235c:	063f      	lsls	r7, r7, #24
c0de235e:	19f6      	adds	r6, r6, r7
         (buf[off + 2] << 8) | buf[off + 3];
c0de2360:	78ef      	ldrb	r7, [r5, #3]
c0de2362:	023f      	lsls	r7, r7, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2364:	19f6      	adds	r6, r6, r7
         (buf[off + 2] << 8) | buf[off + 3];
c0de2366:	792d      	ldrb	r5, [r5, #4]
c0de2368:	1975      	adds	r5, r6, r5
                PRINTF("Invalid data\n");
                THROW(0x6a80);
            }
            tmpCtx.transactionContext.bip32Path[i] = U4BE(workBuffer, 0);
c0de236a:	464e      	mov	r6, r9
c0de236c:	1876      	adds	r6, r6, r1
c0de236e:	18b6      	adds	r6, r6, r2
c0de2370:	6075      	str	r5, [r6, #4]
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0de2372:	1d12      	adds	r2, r2, #4
c0de2374:	1c5b      	adds	r3, r3, #1
            workBuffer += 4;
            dataLength -= 4;
c0de2376:	1f24      	subs	r4, r4, #4
c0de2378:	e7e6      	b.n	c0de2348 <handleSign+0xd4>
        }
        tmpContent.txContent.dataPresent = false;
c0de237a:	484b      	ldr	r0, [pc, #300]	; (c0de24a8 <handleSign+0x234>)
c0de237c:	4649      	mov	r1, r9
c0de237e:	180a      	adds	r2, r1, r0
c0de2380:	20c3      	movs	r0, #195	; 0xc3
c0de2382:	2600      	movs	r6, #0
c0de2384:	5416      	strb	r6, [r2, r0]
        dataContext.tokenContext.pluginStatus = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de2386:	4849      	ldr	r0, [pc, #292]	; (c0de24ac <handleSign+0x238>)
c0de2388:	1808      	adds	r0, r1, r0
c0de238a:	9f03      	ldr	r7, [sp, #12]
c0de238c:	7787      	strb	r7, [r0, #30]

        initTx(&txContext, &global_sha3, &tmpContent.txContent, customProcessor, NULL);
c0de238e:	9600      	str	r6, [sp, #0]
c0de2390:	4847      	ldr	r0, [pc, #284]	; (c0de24b0 <handleSign+0x23c>)
c0de2392:	1808      	adds	r0, r1, r0
c0de2394:	4b47      	ldr	r3, [pc, #284]	; (c0de24b4 <handleSign+0x240>)
c0de2396:	18c9      	adds	r1, r1, r3
c0de2398:	4b4a      	ldr	r3, [pc, #296]	; (c0de24c4 <handleSign+0x250>)
c0de239a:	447b      	add	r3, pc
c0de239c:	f001 fd52 	bl	c0de3e44 <initTx>

        // EIP 2718: TransactionType might be present before the TransactionPayload.
        uint8_t txType = *workBuffer;
c0de23a0:	1c68      	adds	r0, r5, #1
c0de23a2:	9006      	str	r0, [sp, #24]
c0de23a4:	57e8      	ldrsb	r0, [r5, r7]
        if (txType >= MIN_TX_TYPE && txType <= MAX_TX_TYPE) {
c0de23a6:	2800      	cmp	r0, #0
c0de23a8:	d41d      	bmi.n	c0de23e6 <handleSign+0x172>
c0de23aa:	b2c0      	uxtb	r0, r0
c0de23ac:	9003      	str	r0, [sp, #12]
            // Enumerate through all supported txTypes here...
            if (txType == EIP2930 || txType == EIP1559) {
c0de23ae:	1e40      	subs	r0, r0, #1
c0de23b0:	2801      	cmp	r0, #1
c0de23b2:	d865      	bhi.n	c0de2480 <handleSign+0x20c>
c0de23b4:	9600      	str	r6, [sp, #0]
c0de23b6:	9601      	str	r6, [sp, #4]
c0de23b8:	4648      	mov	r0, r9
c0de23ba:	4f3e      	ldr	r7, [pc, #248]	; (c0de24b4 <handleSign+0x240>)
c0de23bc:	19c0      	adds	r0, r0, r7
c0de23be:	2301      	movs	r3, #1
c0de23c0:	4631      	mov	r1, r6
c0de23c2:	9a06      	ldr	r2, [sp, #24]
c0de23c4:	f000 fe5a 	bl	c0de307c <cx_hash_no_throw>
c0de23c8:	2800      	cmp	r0, #0
c0de23ca:	d157      	bne.n	c0de247c <handleSign+0x208>
  return cx_hash_get_size(hash);
c0de23cc:	464e      	mov	r6, r9
c0de23ce:	19f0      	adds	r0, r6, r7
c0de23d0:	f000 fe4e 	bl	c0de3070 <cx_hash_get_size>
                cx_hash((cx_hash_t *) &global_sha3, 0, workBuffer, 1, NULL, 0);
                txContext.txType = txType;
c0de23d4:	4836      	ldr	r0, [pc, #216]	; (c0de24b0 <handleSign+0x23c>)
c0de23d6:	1830      	adds	r0, r6, r0
c0de23d8:	213c      	movs	r1, #60	; 0x3c
c0de23da:	9a03      	ldr	r2, [sp, #12]
c0de23dc:	5442      	strb	r2, [r0, r1]
                workBuffer++;
                dataLength--;
c0de23de:	1ca8      	adds	r0, r5, #2
c0de23e0:	9006      	str	r0, [sp, #24]
c0de23e2:	1e64      	subs	r4, r4, #1
c0de23e4:	e005      	b.n	c0de23f2 <handleSign+0x17e>
            } else {
                PRINTF("Transaction type %d not supported\n", txType);
                THROW(0x6501);
            }
        } else {
            txContext.txType = LEGACY;
c0de23e6:	4648      	mov	r0, r9
c0de23e8:	4931      	ldr	r1, [pc, #196]	; (c0de24b0 <handleSign+0x23c>)
c0de23ea:	1840      	adds	r0, r0, r1
c0de23ec:	213c      	movs	r1, #60	; 0x3c
c0de23ee:	22c0      	movs	r2, #192	; 0xc0
c0de23f0:	5442      	strb	r2, [r0, r1]
c0de23f2:	9e05      	ldr	r6, [sp, #20]
c0de23f4:	9d04      	ldr	r5, [sp, #16]
        }
        PRINTF("TxType: %x\n", txContext.txType);
    } else if (p1 != P1_MORE) {
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0de23f6:	2d00      	cmp	r5, #0
c0de23f8:	d131      	bne.n	c0de245e <handleSign+0x1ea>
        THROW(0x6B00);
    }
    if ((p1 == P1_MORE) && (appState != APP_STATE_SIGNING_TX)) {
c0de23fa:	2e80      	cmp	r6, #128	; 0x80
c0de23fc:	d104      	bne.n	c0de2408 <handleSign+0x194>
c0de23fe:	4828      	ldr	r0, [pc, #160]	; (c0de24a0 <handleSign+0x22c>)
c0de2400:	4649      	mov	r1, r9
c0de2402:	5c08      	ldrb	r0, [r1, r0]
c0de2404:	2801      	cmp	r0, #1
c0de2406:	d12e      	bne.n	c0de2466 <handleSign+0x1f2>
        PRINTF("Signature not initialized\n");
        THROW(0x6985);
    }
    if (txContext.currentField == RLP_NONE) {
c0de2408:	4829      	ldr	r0, [pc, #164]	; (c0de24b0 <handleSign+0x23c>)
c0de240a:	4649      	mov	r1, r9
c0de240c:	5c09      	ldrb	r1, [r1, r0]
c0de240e:	2900      	cmp	r1, #0
c0de2410:	d029      	beq.n	c0de2466 <handleSign+0x1f2>
        THROW(0x6985);
    }
    txResult = processTx(&txContext,
                         workBuffer,
                         dataLength,
                         (chainConfig->kind == CHAIN_KIND_WANCHAIN ? TX_FLAG_TYPE : 0));
c0de2412:	492a      	ldr	r1, [pc, #168]	; (c0de24bc <handleSign+0x248>)
c0de2414:	464a      	mov	r2, r9
c0de2416:	5851      	ldr	r1, [r2, r1]
c0de2418:	7e09      	ldrb	r1, [r1, #24]
c0de241a:	1fc9      	subs	r1, r1, #7
c0de241c:	424b      	negs	r3, r1
c0de241e:	414b      	adcs	r3, r1
    txResult = processTx(&txContext,
c0de2420:	1810      	adds	r0, r2, r0
                         dataLength,
c0de2422:	b2a2      	uxth	r2, r4
    txResult = processTx(&txContext,
c0de2424:	9906      	ldr	r1, [sp, #24]
c0de2426:	f001 fd87 	bl	c0de3f38 <processTx>
    switch (txResult) {
c0de242a:	2801      	cmp	r0, #1
c0de242c:	d004      	beq.n	c0de2438 <handleSign+0x1c4>
c0de242e:	2802      	cmp	r0, #2
c0de2430:	d109      	bne.n	c0de2446 <handleSign+0x1d2>
c0de2432:	2000      	movs	r0, #0
            PRINTF("Unexpected parser status\n");
            THROW(0x6A80);
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0de2434:	f003 ff5c 	bl	c0de62f0 <finalizeParsing>
c0de2438:	980c      	ldr	r0, [sp, #48]	; 0x30
    }

    *flags |= IO_ASYNCH_REPLY;
c0de243a:	6801      	ldr	r1, [r0, #0]
c0de243c:	2210      	movs	r2, #16
c0de243e:	430a      	orrs	r2, r1
c0de2440:	6002      	str	r2, [r0, #0]
}
c0de2442:	b007      	add	sp, #28
c0de2444:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (txResult) {
c0de2446:	2803      	cmp	r0, #3
c0de2448:	d005      	beq.n	c0de2456 <handleSign+0x1e2>
c0de244a:	2800      	cmp	r0, #0
c0de244c:	d103      	bne.n	c0de2456 <handleSign+0x1e2>
c0de244e:	2009      	movs	r0, #9
c0de2450:	0300      	lsls	r0, r0, #12
            THROW(0x9000);
c0de2452:	f004 ffe8 	bl	c0de7426 <os_longjmp>
c0de2456:	480f      	ldr	r0, [pc, #60]	; (c0de2494 <handleSign+0x220>)
c0de2458:	30fe      	adds	r0, #254	; 0xfe
c0de245a:	f004 ffe4 	bl	c0de7426 <os_longjmp>
c0de245e:	480e      	ldr	r0, [pc, #56]	; (c0de2498 <handleSign+0x224>)
c0de2460:	307e      	adds	r0, #126	; 0x7e
c0de2462:	f004 ffe0 	bl	c0de7426 <os_longjmp>
c0de2466:	480b      	ldr	r0, [pc, #44]	; (c0de2494 <handleSign+0x220>)
c0de2468:	1cc0      	adds	r0, r0, #3
c0de246a:	f004 ffdc 	bl	c0de7426 <os_longjmp>
c0de246e:	4809      	ldr	r0, [pc, #36]	; (c0de2494 <handleSign+0x220>)
        THROW(0x6982);
c0de2470:	f004 ffd9 	bl	c0de7426 <os_longjmp>
            ui_warning_oracle_data();
c0de2474:	f004 f944 	bl	c0de6700 <ui_warning_oracle_data>
c0de2478:	4807      	ldr	r0, [pc, #28]	; (c0de2498 <handleSign+0x224>)
            THROW(0x6a83);
c0de247a:	1c40      	adds	r0, r0, #1
c0de247c:	f004 ffd3 	bl	c0de7426 <os_longjmp>
c0de2480:	480d      	ldr	r0, [pc, #52]	; (c0de24b8 <handleSign+0x244>)
                THROW(0x6501);
c0de2482:	f004 ffd0 	bl	c0de7426 <os_longjmp>
c0de2486:	4803      	ldr	r0, [pc, #12]	; (c0de2494 <handleSign+0x220>)
                    THROW(0x6a81);
c0de2488:	30ff      	adds	r0, #255	; 0xff
c0de248a:	f004 ffcc 	bl	c0de7426 <os_longjmp>
c0de248e:	4802      	ldr	r0, [pc, #8]	; (c0de2498 <handleSign+0x224>)
                    THROW(0x6a82);
c0de2490:	f004 ffc9 	bl	c0de7426 <os_longjmp>
c0de2494:	00006982 	.word	0x00006982
c0de2498:	00006a82 	.word	0x00006a82
c0de249c:	000006ba 	.word	0x000006ba
c0de24a0:	0000011c 	.word	0x0000011c
c0de24a4:	00000124 	.word	0x00000124
c0de24a8:	0000026c 	.word	0x0000026c
c0de24ac:	00000594 	.word	0x00000594
c0de24b0:	0000022c 	.word	0x0000022c
c0de24b4:	000007e8 	.word	0x000007e8
c0de24b8:	00006501 	.word	0x00006501
c0de24bc:	00000590 	.word	0x00000590
c0de24c0:	0000f3f0 	.word	0x0000f3f0
c0de24c4:	00003b17 	.word	0x00003b17

c0de24c8 <handleStarkwareGetPublicKey>:
void handleStarkwareGetPublicKey(uint8_t p1,
                                 uint8_t p2,
                                 uint8_t *dataBuffer,
                                 uint16_t dataLength,
                                 unsigned int *flags,
                                 unsigned int *tx) {
c0de24c8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de24ca:	b09f      	sub	sp, #124	; 0x7c
c0de24cc:	4616      	mov	r6, r2
c0de24ce:	460f      	mov	r7, r1
c0de24d0:	4604      	mov	r4, r0
    UNUSED(dataLength);
    uint8_t privateKeyData[32];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);
c0de24d2:	7815      	ldrb	r5, [r2, #0]
    cx_ecfp_private_key_t privateKey;
    reset_app_context();
c0de24d4:	f004 f8c6 	bl	c0de6664 <reset_app_context>
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0de24d8:	1e68      	subs	r0, r5, #1
c0de24da:	280a      	cmp	r0, #10
c0de24dc:	d25f      	bcs.n	c0de259e <handleStarkwareGetPublicKey+0xd6>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0de24de:	2c02      	cmp	r4, #2
c0de24e0:	d258      	bcs.n	c0de2594 <handleStarkwareGetPublicKey+0xcc>
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0de24e2:	2f00      	cmp	r7, #0
c0de24e4:	d156      	bne.n	c0de2594 <handleStarkwareGetPublicKey+0xcc>
c0de24e6:	1c70      	adds	r0, r6, #1
c0de24e8:	9925      	ldr	r1, [sp, #148]	; 0x94
c0de24ea:	9102      	str	r1, [sp, #8]
c0de24ec:	9f24      	ldr	r7, [sp, #144]	; 0x90
c0de24ee:	a90d      	add	r1, sp, #52	; 0x34
c0de24f0:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
c0de24f2:	2a00      	cmp	r2, #0
c0de24f4:	d00d      	beq.n	c0de2512 <handleStarkwareGetPublicKey+0x4a>
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de24f6:	7803      	ldrb	r3, [r0, #0]
c0de24f8:	061b      	lsls	r3, r3, #24
c0de24fa:	7846      	ldrb	r6, [r0, #1]
c0de24fc:	0436      	lsls	r6, r6, #16
c0de24fe:	18f3      	adds	r3, r6, r3
         (buf[off + 2] << 8) | buf[off + 3];
c0de2500:	7886      	ldrb	r6, [r0, #2]
c0de2502:	0236      	lsls	r6, r6, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2504:	199b      	adds	r3, r3, r6
         (buf[off + 2] << 8) | buf[off + 3];
c0de2506:	78c6      	ldrb	r6, [r0, #3]
c0de2508:	199b      	adds	r3, r3, r6
        bip32Path[i] = U4BE(dataBuffer, 0);
c0de250a:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0de250c:	1d00      	adds	r0, r0, #4
c0de250e:	1e52      	subs	r2, r2, #1
c0de2510:	e7ef      	b.n	c0de24f2 <handleStarkwareGetPublicKey+0x2a>
        dataBuffer += 4;
    }
    io_seproxyhal_io_heartbeat();
c0de2512:	f005 fb45 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de2516:	a80d      	add	r0, sp, #52	; 0x34
c0de2518:	ae17      	add	r6, sp, #92	; 0x5c
    starkDerivePrivateKey(bip32Path, bip32PathLength, privateKeyData);
c0de251a:	4629      	mov	r1, r5
c0de251c:	4632      	mov	r2, r6
c0de251e:	f005 ff1b 	bl	c0de8358 <starkDerivePrivateKey>
c0de2522:	2051      	movs	r0, #81	; 0x51
c0de2524:	2220      	movs	r2, #32
c0de2526:	ab03      	add	r3, sp, #12
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de2528:	4631      	mov	r1, r6
c0de252a:	f000 fd8f 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de252e:	2800      	cmp	r0, #0
c0de2530:	d133      	bne.n	c0de259a <handleStarkwareGetPublicKey+0xd2>
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
    io_seproxyhal_io_heartbeat();
c0de2532:	f005 fb35 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de2536:	4e20      	ldr	r6, [pc, #128]	; (c0de25b8 <handleStarkwareGetPublicKey+0xf0>)
c0de2538:	4648      	mov	r0, r9
c0de253a:	1981      	adds	r1, r0, r6
c0de253c:	2051      	movs	r0, #81	; 0x51
c0de253e:	aa03      	add	r2, sp, #12
c0de2540:	2501      	movs	r5, #1
c0de2542:	462b      	mov	r3, r5
c0de2544:	f000 fd7c 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de2548:	2800      	cmp	r0, #0
c0de254a:	d126      	bne.n	c0de259a <handleStarkwareGetPublicKey+0xd2>
c0de254c:	a803      	add	r0, sp, #12
c0de254e:	2128      	movs	r1, #40	; 0x28
    cx_ecfp_generate_pair(CX_CURVE_Stark256, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de2550:	f00b f976 	bl	c0ded840 <explicit_bzero>
c0de2554:	a817      	add	r0, sp, #92	; 0x5c
c0de2556:	2120      	movs	r1, #32
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de2558:	f00b f972 	bl	c0ded840 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0de255c:	f005 fb20 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0de2560:	2c00      	cmp	r4, #0
c0de2562:	d020      	beq.n	c0de25a6 <handleStarkwareGetPublicKey+0xde>
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        // prepare for a UI based reply
        snprintf(strings.tmp.tmp,
c0de2564:	4648      	mov	r0, r9
c0de2566:	1981      	adds	r1, r0, r6
c0de2568:	3109      	adds	r1, #9
c0de256a:	9100      	str	r1, [sp, #0]
c0de256c:	4913      	ldr	r1, [pc, #76]	; (c0de25bc <handleStarkwareGetPublicKey+0xf4>)
c0de256e:	1840      	adds	r0, r0, r1
c0de2570:	0229      	lsls	r1, r5, #8
c0de2572:	4a13      	ldr	r2, [pc, #76]	; (c0de25c0 <handleStarkwareGetPublicKey+0xf8>)
c0de2574:	447a      	add	r2, pc
c0de2576:	2320      	movs	r3, #32
c0de2578:	f005 fc88 	bl	c0de7e8c <snprintf>
                 sizeof(strings.tmp.tmp),
                 "0x%.*H",
                 32,
                 tmpCtx.publicKeyContext.publicKey.W + 1);
        ux_flow_init(0, ux_display_stark_public_flow, NULL);
c0de257c:	4911      	ldr	r1, [pc, #68]	; (c0de25c4 <handleStarkwareGetPublicKey+0xfc>)
c0de257e:	4479      	add	r1, pc
c0de2580:	2000      	movs	r0, #0
c0de2582:	4602      	mov	r2, r0
c0de2584:	f00a f9fe 	bl	c0dec984 <ux_flow_init>

        *flags |= IO_ASYNCH_REPLY;
c0de2588:	6838      	ldr	r0, [r7, #0]
c0de258a:	2110      	movs	r1, #16
c0de258c:	4301      	orrs	r1, r0
c0de258e:	6039      	str	r1, [r7, #0]
    }
#endif  // NO_CONSENT
}
c0de2590:	b01f      	add	sp, #124	; 0x7c
c0de2592:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de2594:	20d5      	movs	r0, #213	; 0xd5
c0de2596:	01c0      	lsls	r0, r0, #7
c0de2598:	3080      	adds	r0, #128	; 0x80
c0de259a:	f004 ff44 	bl	c0de7426 <os_longjmp>
c0de259e:	20d5      	movs	r0, #213	; 0xd5
c0de25a0:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0de25a2:	f004 ff40 	bl	c0de7426 <os_longjmp>
        *tx = set_result_get_stark_publicKey();
c0de25a6:	f004 f84b 	bl	c0de6640 <set_result_get_stark_publicKey>
c0de25aa:	9902      	ldr	r1, [sp, #8]
c0de25ac:	6008      	str	r0, [r1, #0]
c0de25ae:	2009      	movs	r0, #9
c0de25b0:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0de25b2:	f004 ff38 	bl	c0de7426 <os_longjmp>
c0de25b6:	46c0      	nop			; (mov r8, r8)
c0de25b8:	00000124 	.word	0x00000124
c0de25bc:	000006ba 	.word	0x000006ba
c0de25c0:	0000bb63 	.word	0x0000bb63
c0de25c4:	0000e37a 	.word	0x0000e37a

c0de25c8 <handleStarkwareProvideQuantum>:
void handleStarkwareProvideQuantum(uint8_t p1,
                                   __attribute__((unused)) uint8_t p2,
                                   uint8_t *dataBuffer,
                                   uint16_t dataLength,
                                   __attribute__((unused)) unsigned int *flags,
                                   __attribute__((unused)) unsigned int *tx) {
c0de25c8:	b082      	sub	sp, #8
c0de25ca:	461e      	mov	r6, r3
c0de25cc:	4615      	mov	r5, r2
c0de25ce:	4604      	mov	r4, r0
    size_t i = 0;
    uint8_t expectedDataSize = 20 + 32;
    uint8_t addressZero = 0;
    tokenDefinition_t *currentToken = NULL;
    if (appState != APP_STATE_IDLE) {
c0de25d0:	4835      	ldr	r0, [pc, #212]	; (c0de26a8 <handleStarkwareProvideQuantum+0xe0>)
c0de25d2:	4649      	mov	r1, r9
c0de25d4:	5c08      	ldrb	r0, [r1, r0]
c0de25d6:	2800      	cmp	r0, #0
c0de25d8:	d001      	beq.n	c0de25de <handleStarkwareProvideQuantum+0x16>
        reset_app_context();
c0de25da:	f004 f843 	bl	c0de6664 <reset_app_context>
    }
    switch (p1) {
c0de25de:	1e60      	subs	r0, r4, #1
c0de25e0:	2805      	cmp	r0, #5
c0de25e2:	d22d      	bcs.n	c0de2640 <handleStarkwareProvideQuantum+0x78>
c0de25e4:	2054      	movs	r0, #84	; 0x54
            expectedDataSize += 32;
            break;
        default:
            THROW(0x6B00);
    }
    if (dataLength != expectedDataSize) {
c0de25e6:	42b0      	cmp	r0, r6
c0de25e8:	d154      	bne.n	c0de2694 <handleStarkwareProvideQuantum+0xcc>
        THROW(0x6700);
    }
    if (p1 == STARK_QUANTUM_LEGACY) {
c0de25ea:	2c00      	cmp	r4, #0
c0de25ec:	9401      	str	r4, [sp, #4]
c0de25ee:	d106      	bne.n	c0de25fe <handleStarkwareProvideQuantum+0x36>
c0de25f0:	2000      	movs	r0, #0
                    size_t targetLength,
                    uint8_t decimals);

static __attribute__((no_instrument_function)) inline int allzeroes(void *buf, size_t n) {
    uint8_t *p = (uint8_t *) buf;
    for (size_t i = 0; i < n; ++i) {
c0de25f2:	2814      	cmp	r0, #20
c0de25f4:	d028      	beq.n	c0de2648 <handleStarkwareProvideQuantum+0x80>
        if (p[i]) {
c0de25f6:	5c29      	ldrb	r1, [r5, r0]
    for (size_t i = 0; i < n; ++i) {
c0de25f8:	1c40      	adds	r0, r0, #1
        if (p[i]) {
c0de25fa:	2900      	cmp	r1, #0
c0de25fc:	d0f9      	beq.n	c0de25f2 <handleStarkwareProvideQuantum+0x2a>
        addressZero = allzeroes(dataBuffer, 20);
    }
    if ((p1 != STARK_QUANTUM_ETH) && !addressZero) {
c0de25fe:	2c01      	cmp	r4, #1
c0de2600:	d022      	beq.n	c0de2648 <handleStarkwareProvideQuantum+0x80>
c0de2602:	20b5      	movs	r0, #181	; 0xb5
c0de2604:	43c7      	mvns	r7, r0
c0de2606:	2600      	movs	r6, #0
c0de2608:	4c28      	ldr	r4, [pc, #160]	; (c0de26ac <handleStarkwareProvideQuantum+0xe4>)
        for (i = 0; i < MAX_ITEMS; i++) {
c0de260a:	2f00      	cmp	r7, #0
c0de260c:	d014      	beq.n	c0de2638 <handleStarkwareProvideQuantum+0x70>
            currentToken = &tmpCtx.transactionContext.extraInfo[i].token;
            if (tmpCtx.transactionContext.tokenSet[i] &&
c0de260e:	4648      	mov	r0, r9
c0de2610:	1900      	adds	r0, r0, r4
c0de2612:	1981      	adds	r1, r0, r6
c0de2614:	2081      	movs	r0, #129	; 0x81
c0de2616:	0040      	lsls	r0, r0, #1
c0de2618:	5c09      	ldrb	r1, [r1, r0]
c0de261a:	2900      	cmp	r1, #0
c0de261c:	d009      	beq.n	c0de2632 <handleStarkwareProvideQuantum+0x6a>
                (memcmp(currentToken->address, dataBuffer, 20) == 0)) {
c0de261e:	4649      	mov	r1, r9
c0de2620:	1909      	adds	r1, r1, r4
c0de2622:	19c9      	adds	r1, r1, r7
c0de2624:	1808      	adds	r0, r1, r0
c0de2626:	2214      	movs	r2, #20
c0de2628:	4629      	mov	r1, r5
c0de262a:	f00b f913 	bl	c0ded854 <memcmp>
            if (tmpCtx.transactionContext.tokenSet[i] &&
c0de262e:	2800      	cmp	r0, #0
c0de2630:	d00b      	beq.n	c0de264a <handleStarkwareProvideQuantum+0x82>
        for (i = 0; i < MAX_ITEMS; i++) {
c0de2632:	375b      	adds	r7, #91	; 0x5b
c0de2634:	1c76      	adds	r6, r6, #1
c0de2636:	e7e8      	b.n	c0de260a <handleStarkwareProvideQuantum+0x42>
c0de2638:	20d5      	movs	r0, #213	; 0xd5
c0de263a:	01c0      	lsls	r0, r0, #7
                break;
            }
        }
        if (i == MAX_ITEMS) {
            PRINTF("Associated token not found\n");
            THROW(0x6A80);
c0de263c:	f004 fef3 	bl	c0de7426 <os_longjmp>
    switch (p1) {
c0de2640:	2c00      	cmp	r4, #0
c0de2642:	d12b      	bne.n	c0de269c <handleStarkwareProvideQuantum+0xd4>
c0de2644:	2034      	movs	r0, #52	; 0x34
c0de2646:	e7ce      	b.n	c0de25e6 <handleStarkwareProvideQuantum+0x1e>
c0de2648:	2602      	movs	r6, #2
        }
    } else {
        i = MAX_ITEMS;
    }
    memmove(dataContext.tokenContext.quantum, dataBuffer + 20, 32);
c0de264a:	4c19      	ldr	r4, [pc, #100]	; (c0de26b0 <handleStarkwareProvideQuantum+0xe8>)
c0de264c:	4648      	mov	r0, r9
c0de264e:	1900      	adds	r0, r0, r4
c0de2650:	30e4      	adds	r0, #228	; 0xe4
c0de2652:	4629      	mov	r1, r5
c0de2654:	3114      	adds	r1, #20
c0de2656:	2220      	movs	r2, #32
c0de2658:	f00b f8e6 	bl	c0ded828 <__aeabi_memmove>
c0de265c:	9f01      	ldr	r7, [sp, #4]
    if (p1 != STARK_QUANTUM_LEGACY) {
c0de265e:	2f00      	cmp	r7, #0
c0de2660:	d009      	beq.n	c0de2676 <handleStarkwareProvideQuantum+0xae>
        memmove(dataContext.tokenContext.mintingBlob, dataBuffer + 20 + 32, 32);
c0de2662:	4648      	mov	r0, r9
c0de2664:	1900      	adds	r0, r0, r4
c0de2666:	2141      	movs	r1, #65	; 0x41
c0de2668:	0089      	lsls	r1, r1, #2
c0de266a:	1840      	adds	r0, r0, r1
c0de266c:	3534      	adds	r5, #52	; 0x34
c0de266e:	2220      	movs	r2, #32
c0de2670:	4629      	mov	r1, r5
c0de2672:	f00b f8d9 	bl	c0ded828 <__aeabi_memmove>
    }
    dataContext.tokenContext.quantumIndex = i;
    dataContext.tokenContext.quantumType = p1;
    quantumSet = true;
c0de2676:	480f      	ldr	r0, [pc, #60]	; (c0de26b4 <handleStarkwareProvideQuantum+0xec>)
    dataContext.tokenContext.quantumIndex = i;
c0de2678:	4649      	mov	r1, r9
c0de267a:	2201      	movs	r2, #1
    quantumSet = true;
c0de267c:	540a      	strb	r2, [r1, r0]
    dataContext.tokenContext.quantumIndex = i;
c0de267e:	1908      	adds	r0, r1, r4
c0de2680:	21ff      	movs	r1, #255	; 0xff
c0de2682:	3126      	adds	r1, #38	; 0x26
    dataContext.tokenContext.quantumType = p1;
c0de2684:	5447      	strb	r7, [r0, r1]
c0de2686:	2149      	movs	r1, #73	; 0x49
c0de2688:	0089      	lsls	r1, r1, #2
    dataContext.tokenContext.quantumIndex = i;
c0de268a:	5446      	strb	r6, [r0, r1]
c0de268c:	2009      	movs	r0, #9
c0de268e:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0de2690:	f004 fec9 	bl	c0de7426 <os_longjmp>
c0de2694:	2067      	movs	r0, #103	; 0x67
c0de2696:	0200      	lsls	r0, r0, #8
        THROW(0x6700);
c0de2698:	f004 fec5 	bl	c0de7426 <os_longjmp>
c0de269c:	20d5      	movs	r0, #213	; 0xd5
c0de269e:	01c0      	lsls	r0, r0, #7
            THROW(0x6B00);
c0de26a0:	3080      	adds	r0, #128	; 0x80
c0de26a2:	f004 fec0 	bl	c0de7426 <os_longjmp>
c0de26a6:	46c0      	nop			; (mov r8, r8)
c0de26a8:	0000011c 	.word	0x0000011c
c0de26ac:	00000124 	.word	0x00000124
c0de26b0:	00000594 	.word	0x00000594
c0de26b4:	0000011f 	.word	0x0000011f

c0de26b8 <handleStarkwareSignMessage>:
void handleStarkwareSignMessage(uint8_t p1,
                                uint8_t p2,
                                uint8_t *dataBuffer,
                                uint16_t dataLength,
                                unsigned int *flags,
                                __attribute__((unused)) unsigned int *tx) {
c0de26b8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de26ba:	b0c1      	sub	sp, #260	; 0x104
c0de26bc:	9314      	str	r3, [sp, #80]	; 0x50
c0de26be:	4614      	mov	r4, r2
c0de26c0:	460f      	mov	r7, r1
c0de26c2:	4605      	mov	r5, r0
    uint8_t order = 1;
    uint8_t protocol = 2;
    uint8_t preOffset, postOffset;
    uint8_t zeroTest;
    // Initial checks
    if (appState != APP_STATE_IDLE) {
c0de26c4:	48f4      	ldr	r0, [pc, #976]	; (c0de2a98 <handleStarkwareSignMessage+0x3e0>)
c0de26c6:	4649      	mov	r1, r9
c0de26c8:	5c08      	ldrb	r0, [r1, r0]
    uint8_t bip32PathLength = *(dataBuffer);
c0de26ca:	7816      	ldrb	r6, [r2, #0]
    if (appState != APP_STATE_IDLE) {
c0de26cc:	2800      	cmp	r0, #0
c0de26ce:	d001      	beq.n	c0de26d4 <handleStarkwareSignMessage+0x1c>
        reset_app_context();
c0de26d0:	f003 ffc8 	bl	c0de6664 <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0de26d4:	1e70      	subs	r0, r6, #1
c0de26d6:	280a      	cmp	r0, #10
c0de26d8:	d300      	bcc.n	c0de26dc <handleStarkwareSignMessage+0x24>
c0de26da:	e274      	b.n	c0de2bc6 <handleStarkwareSignMessage+0x50e>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    switch (p1) {
c0de26dc:	1f28      	subs	r0, r5, #4
c0de26de:	2301      	movs	r3, #1
c0de26e0:	2802      	cmp	r0, #2
c0de26e2:	d30c      	bcc.n	c0de26fe <handleStarkwareSignMessage+0x46>
c0de26e4:	2d03      	cmp	r5, #3
c0de26e6:	d01c      	beq.n	c0de2722 <handleStarkwareSignMessage+0x6a>
c0de26e8:	2200      	movs	r2, #0
c0de26ea:	2d02      	cmp	r5, #2
c0de26ec:	9212      	str	r2, [sp, #72]	; 0x48
c0de26ee:	d008      	beq.n	c0de2702 <handleStarkwareSignMessage+0x4a>
c0de26f0:	2d01      	cmp	r5, #1
c0de26f2:	d000      	beq.n	c0de26f6 <handleStarkwareSignMessage+0x3e>
c0de26f4:	e26b      	b.n	c0de2bce <handleStarkwareSignMessage+0x516>
c0de26f6:	9711      	str	r7, [sp, #68]	; 0x44
c0de26f8:	2200      	movs	r2, #0
c0de26fa:	9212      	str	r2, [sp, #72]	; 0x48
c0de26fc:	e014      	b.n	c0de2728 <handleStarkwareSignMessage+0x70>
c0de26fe:	2221      	movs	r2, #33	; 0x21
c0de2700:	9312      	str	r3, [sp, #72]	; 0x48
        if (dataLength != (20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4 + 1 + 4 * bip32PathLength +
                           2 * postOffset)) {
            THROW(0x6700);
        }
    } else {
        if (dataLength != (20 + 32 + 32 + 4 + 4 + 8 + 4 + 4 + 1 + 4 * bip32PathLength + postOffset +
c0de2702:	2d05      	cmp	r5, #5
c0de2704:	d001      	beq.n	c0de270a <handleStarkwareSignMessage+0x52>
c0de2706:	206d      	movs	r0, #109	; 0x6d
c0de2708:	e000      	b.n	c0de270c <handleStarkwareSignMessage+0x54>
c0de270a:	20a1      	movs	r0, #161	; 0xa1
c0de270c:	00b1      	lsls	r1, r6, #2
c0de270e:	1840      	adds	r0, r0, r1
c0de2710:	1880      	adds	r0, r0, r2
c0de2712:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de2714:	4288      	cmp	r0, r1
c0de2716:	d000      	beq.n	c0de271a <handleStarkwareSignMessage+0x62>
c0de2718:	e25e      	b.n	c0de2bd8 <handleStarkwareSignMessage+0x520>
c0de271a:	2000      	movs	r0, #0
c0de271c:	2101      	movs	r1, #1
c0de271e:	9013      	str	r0, [sp, #76]	; 0x4c
c0de2720:	e00e      	b.n	c0de2740 <handleStarkwareSignMessage+0x88>
c0de2722:	9711      	str	r7, [sp, #68]	; 0x44
c0de2724:	2221      	movs	r2, #33	; 0x21
c0de2726:	9312      	str	r3, [sp, #72]	; 0x48
                           2 * postOffset)) {
c0de2728:	0050      	lsls	r0, r2, #1
c0de272a:	00b1      	lsls	r1, r6, #2
        if (dataLength != (20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4 + 1 + 4 * bip32PathLength +
c0de272c:	1808      	adds	r0, r1, r0
c0de272e:	3089      	adds	r0, #137	; 0x89
c0de2730:	2100      	movs	r1, #0
c0de2732:	9f14      	ldr	r7, [sp, #80]	; 0x50
c0de2734:	42b8      	cmp	r0, r7
c0de2736:	9313      	str	r3, [sp, #76]	; 0x4c
c0de2738:	4608      	mov	r0, r1
c0de273a:	9f11      	ldr	r7, [sp, #68]	; 0x44
c0de273c:	d000      	beq.n	c0de2740 <handleStarkwareSignMessage+0x88>
c0de273e:	e24b      	b.n	c0de2bd8 <handleStarkwareSignMessage+0x520>
c0de2740:	9006      	str	r0, [sp, #24]
c0de2742:	9107      	str	r1, [sp, #28]
c0de2744:	950f      	str	r5, [sp, #60]	; 0x3c
c0de2746:	9304      	str	r3, [sp, #16]
c0de2748:	9211      	str	r2, [sp, #68]	; 0x44
                           (p1 == P1_STARK_CONDITIONAL_TRANSFER ? 32 + 20 : 0))) {
            THROW(0x6700);
        }
    }
    if (p2 != 0) {
c0de274a:	2f00      	cmp	r7, #0
c0de274c:	d000      	beq.n	c0de2750 <handleStarkwareSignMessage+0x98>
c0de274e:	e23e      	b.n	c0de2bce <handleStarkwareSignMessage+0x516>
c0de2750:	9846      	ldr	r0, [sp, #280]	; 0x118
        THROW(0x6B00);
    }
    tmpCtx.transactionContext.pathLength = bip32PathLength;
c0de2752:	9009      	str	r0, [sp, #36]	; 0x24
c0de2754:	49d1      	ldr	r1, [pc, #836]	; (c0de2a9c <handleStarkwareSignMessage+0x3e4>)
c0de2756:	4648      	mov	r0, r9
c0de2758:	5446      	strb	r6, [r0, r1]
c0de275a:	1840      	adds	r0, r0, r1
c0de275c:	1d07      	adds	r7, r0, #4
c0de275e:	2501      	movs	r5, #1
c0de2760:	9603      	str	r6, [sp, #12]
c0de2762:	b2e9      	uxtb	r1, r5
    for (i = 0; i < bip32PathLength; i++) {
c0de2764:	2e00      	cmp	r6, #0
c0de2766:	d006      	beq.n	c0de2776 <handleStarkwareSignMessage+0xbe>
        tmpCtx.transactionContext.bip32Path[i] = U4BE(dataBuffer, offset);
c0de2768:	4620      	mov	r0, r4
c0de276a:	f000 fa57 	bl	c0de2c1c <U4BE>
c0de276e:	c701      	stmia	r7!, {r0}
    for (i = 0; i < bip32PathLength; i++) {
c0de2770:	1e76      	subs	r6, r6, #1
        PRINTF("Storing path %d %d\n", i, tmpCtx.transactionContext.bip32Path[i]);
        offset += 4;
c0de2772:	1d2d      	adds	r5, r5, #4
c0de2774:	e7f5      	b.n	c0de2762 <handleStarkwareSignMessage+0xaa>
    }
    // Discard the path to use part of dataBuffer as a temporary buffer
    memmove(dataBuffer, dataBuffer + offset, dataLength - offset);
c0de2776:	1863      	adds	r3, r4, r1
c0de2778:	9814      	ldr	r0, [sp, #80]	; 0x50
c0de277a:	1a42      	subs	r2, r0, r1
c0de277c:	4620      	mov	r0, r4
c0de277e:	4619      	mov	r1, r3
c0de2780:	f00b f852 	bl	c0ded828 <__aeabi_memmove>
c0de2784:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    dataContext.starkContext.conditional = (p1 == P1_STARK_CONDITIONAL_TRANSFER);
c0de2786:	1f58      	subs	r0, r3, #5
c0de2788:	4241      	negs	r1, r0
c0de278a:	4141      	adcs	r1, r0
c0de278c:	4ac4      	ldr	r2, [pc, #784]	; (c0de2aa0 <handleStarkwareSignMessage+0x3e8>)
c0de278e:	4648      	mov	r0, r9
c0de2790:	1880      	adds	r0, r0, r2
c0de2792:	2280      	movs	r2, #128	; 0x80
c0de2794:	920d      	str	r2, [sp, #52]	; 0x34
c0de2796:	5481      	strb	r1, [r0, r2]
    if (dataContext.starkContext.conditional) {
c0de2798:	2b05      	cmp	r3, #5
c0de279a:	9e11      	ldr	r6, [sp, #68]	; 0x44
c0de279c:	d111      	bne.n	c0de27c2 <handleStarkwareSignMessage+0x10a>
        memmove(dataContext.starkContext.fact,
c0de279e:	4648      	mov	r0, r9
c0de27a0:	49bf      	ldr	r1, [pc, #764]	; (c0de2aa0 <handleStarkwareSignMessage+0x3e8>)
c0de27a2:	1845      	adds	r5, r0, r1
c0de27a4:	4628      	mov	r0, r5
c0de27a6:	30a1      	adds	r0, #161	; 0xa1
                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4 + 8 + 4 + 4,
c0de27a8:	19a7      	adds	r7, r4, r6
c0de27aa:	4639      	mov	r1, r7
c0de27ac:	316c      	adds	r1, #108	; 0x6c
c0de27ae:	2220      	movs	r2, #32
        memmove(dataContext.starkContext.fact,
c0de27b0:	f00b f83a 	bl	c0ded828 <__aeabi_memmove>
                32);
        memmove(dataContext.starkContext.conditionAddress,
c0de27b4:	35c1      	adds	r5, #193	; 0xc1
                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4 + 8 + 4 + 4 + 32,
c0de27b6:	378c      	adds	r7, #140	; 0x8c
c0de27b8:	2214      	movs	r2, #20
        memmove(dataContext.starkContext.conditionAddress,
c0de27ba:	4628      	mov	r0, r5
c0de27bc:	4639      	mov	r1, r7
c0de27be:	f00b f833 	bl	c0ded828 <__aeabi_memmove>
c0de27c2:	9f12      	ldr	r7, [sp, #72]	; 0x48
                20);
        PRINTF("Fact %.*H\n", 32, dataContext.starkContext.fact);
        PRINTF("Address %.*H\n", 20, dataContext.starkContext.conditionAddress);
    }

    zeroTest = allzeroes(dataBuffer + preOffset, 20);
c0de27c4:	19e0      	adds	r0, r4, r7
c0de27c6:	9010      	str	r0, [sp, #64]	; 0x40
c0de27c8:	f000 fa34 	bl	c0de2c34 <allzeroes>
c0de27cc:	2101      	movs	r1, #1
c0de27ce:	910a      	str	r1, [sp, #40]	; 0x28
    if (zeroTest && (protocol == 2) && (dataBuffer[0] != STARK_QUANTUM_ETH)) {
c0de27d0:	404f      	eors	r7, r1
c0de27d2:	0600      	lsls	r0, r0, #24
c0de27d4:	d005      	beq.n	c0de27e2 <handleStarkwareSignMessage+0x12a>
c0de27d6:	2f00      	cmp	r7, #0
c0de27d8:	d103      	bne.n	c0de27e2 <handleStarkwareSignMessage+0x12a>
c0de27da:	7821      	ldrb	r1, [r4, #0]
c0de27dc:	2901      	cmp	r1, #1
c0de27de:	d000      	beq.n	c0de27e2 <handleStarkwareSignMessage+0x12a>
c0de27e0:	e1f1      	b.n	c0de2bc6 <handleStarkwareSignMessage+0x50e>
        PRINTF("stark - unexpected quantum descriptor type for null first address %d\n",
               dataBuffer[0]);
        THROW(0x6A80);
    }
    if (!zeroTest && getKnownToken(dataBuffer + preOffset) == NULL) {
c0de27e2:	2800      	cmp	r0, #0
c0de27e4:	d105      	bne.n	c0de27f2 <handleStarkwareSignMessage+0x13a>
c0de27e6:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de27e8:	f003 fffa 	bl	c0de67e0 <getKnownToken>
c0de27ec:	2800      	cmp	r0, #0
c0de27ee:	d100      	bne.n	c0de27f2 <handleStarkwareSignMessage+0x13a>
c0de27f0:	e1e9      	b.n	c0de2bc6 <handleStarkwareSignMessage+0x50e>
        PRINTF("stark - cannot process unknown token %.*H", 20, dataBuffer + preOffset);
        THROW(0x6A80);
    }
    if (order) {
c0de27f2:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de27f4:	2800      	cmp	r0, #0
c0de27f6:	d018      	beq.n	c0de282a <handleStarkwareSignMessage+0x172>
        zeroTest = allzeroes(dataBuffer + 20 + 32 + postOffset + preOffset, 20);
c0de27f8:	19a0      	adds	r0, r4, r6
c0de27fa:	9912      	ldr	r1, [sp, #72]	; 0x48
c0de27fc:	1845      	adds	r5, r0, r1
c0de27fe:	3534      	adds	r5, #52	; 0x34
c0de2800:	4628      	mov	r0, r5
c0de2802:	f000 fa17 	bl	c0de2c34 <allzeroes>
        if (zeroTest && (protocol == 2) && (dataBuffer[1 + 20 + 32 + 32] != STARK_QUANTUM_ETH)) {
c0de2806:	b2c1      	uxtb	r1, r0
c0de2808:	424a      	negs	r2, r1
c0de280a:	414a      	adcs	r2, r1
c0de280c:	433a      	orrs	r2, r7
c0de280e:	d104      	bne.n	c0de281a <handleStarkwareSignMessage+0x162>
c0de2810:	2155      	movs	r1, #85	; 0x55
c0de2812:	5c61      	ldrb	r1, [r4, r1]
c0de2814:	2901      	cmp	r1, #1
c0de2816:	d000      	beq.n	c0de281a <handleStarkwareSignMessage+0x162>
c0de2818:	e1d5      	b.n	c0de2bc6 <handleStarkwareSignMessage+0x50e>
            PRINTF("stark - unexpected quantum descriptor type for null second address %d\n",
                   dataBuffer[1 + 20 + 32 + 32]);
            THROW(0x6A80);
        }
        if (!zeroTest && getKnownToken(dataBuffer + 20 + 32 + postOffset + preOffset) == NULL) {
c0de281a:	0600      	lsls	r0, r0, #24
c0de281c:	d105      	bne.n	c0de282a <handleStarkwareSignMessage+0x172>
c0de281e:	4628      	mov	r0, r5
c0de2820:	f003 ffde 	bl	c0de67e0 <getKnownToken>
c0de2824:	2800      	cmp	r0, #0
c0de2826:	d100      	bne.n	c0de282a <handleStarkwareSignMessage+0x172>
c0de2828:	e1cd      	b.n	c0de2bc6 <handleStarkwareSignMessage+0x50e>
                   dataBuffer + 20 + 32 + postOffset + preOffset);
            THROW(0x6A80);
        }
    }
    // Prepare the Stark parameters
    io_seproxyhal_io_heartbeat();
c0de282a:	f005 f9b9 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de282e:	2100      	movs	r1, #0
c0de2830:	9f12      	ldr	r7, [sp, #72]	; 0x48
    compute_token_id(&global_sha3,
                     dataBuffer + preOffset,
                     (protocol == 2 ? dataBuffer[0] : STARK_QUANTUM_LEGACY),
c0de2832:	2f00      	cmp	r7, #0
c0de2834:	460a      	mov	r2, r1
c0de2836:	d000      	beq.n	c0de283a <handleStarkwareSignMessage+0x182>
c0de2838:	7822      	ldrb	r2, [r4, #0]
    compute_token_id(&global_sha3,
c0de283a:	4648      	mov	r0, r9
c0de283c:	4be9      	ldr	r3, [pc, #932]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
c0de283e:	18c3      	adds	r3, r0, r3
c0de2840:	9101      	str	r1, [sp, #4]
c0de2842:	9302      	str	r3, [sp, #8]
                     dataBuffer + preOffset + 20,
                     (protocol == 2 ? dataBuffer + 1 + 20 + 32 : NULL),
c0de2844:	2f00      	cmp	r7, #0
c0de2846:	d101      	bne.n	c0de284c <handleStarkwareSignMessage+0x194>
c0de2848:	4639      	mov	r1, r7
c0de284a:	e001      	b.n	c0de2850 <handleStarkwareSignMessage+0x198>
c0de284c:	4621      	mov	r1, r4
c0de284e:	3135      	adds	r1, #53	; 0x35
    compute_token_id(&global_sha3,
c0de2850:	9100      	str	r1, [sp, #0]
c0de2852:	49e5      	ldr	r1, [pc, #916]	; (c0de2be8 <handleStarkwareSignMessage+0x530>)
c0de2854:	1840      	adds	r0, r0, r1
c0de2856:	9910      	ldr	r1, [sp, #64]	; 0x40
                     dataBuffer + preOffset + 20,
c0de2858:	460b      	mov	r3, r1
c0de285a:	3314      	adds	r3, #20
c0de285c:	9308      	str	r3, [sp, #32]
    compute_token_id(&global_sha3,
c0de285e:	f005 ff0b 	bl	c0de8678 <compute_token_id>
                     false,
                     dataContext.starkContext.w1);
    if (order) {
c0de2862:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de2864:	2800      	cmp	r0, #0
c0de2866:	d014      	beq.n	c0de2892 <handleStarkwareSignMessage+0x1da>
        io_seproxyhal_io_heartbeat();
        compute_token_id(&global_sha3,
                         dataBuffer + 20 + 32 + postOffset + preOffset,
c0de2868:	19a0      	adds	r0, r4, r6
c0de286a:	19c5      	adds	r5, r0, r7
        io_seproxyhal_io_heartbeat();
c0de286c:	f005 f998 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de2870:	2000      	movs	r0, #0
                         (protocol == 2 ? dataBuffer[1 + 20 + 32 + 32] : STARK_QUANTUM_LEGACY),
c0de2872:	2f00      	cmp	r7, #0
c0de2874:	4602      	mov	r2, r0
c0de2876:	d001      	beq.n	c0de287c <handleStarkwareSignMessage+0x1c4>
c0de2878:	2155      	movs	r1, #85	; 0x55
c0de287a:	5c62      	ldrb	r2, [r4, r1]
c0de287c:	3534      	adds	r5, #52	; 0x34
        compute_token_id(&global_sha3,
c0de287e:	4649      	mov	r1, r9
c0de2880:	4bd8      	ldr	r3, [pc, #864]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
c0de2882:	18cb      	adds	r3, r1, r3
c0de2884:	3320      	adds	r3, #32
c0de2886:	9001      	str	r0, [sp, #4]
c0de2888:	9302      	str	r3, [sp, #8]
                         dataBuffer + 20 + 32 + postOffset + preOffset + 20,
                         (protocol == 2 ? dataBuffer + 1 + 20 + 32 + 32 + 1 + 20 + 32 : NULL),
c0de288a:	2f00      	cmp	r7, #0
c0de288c:	d10e      	bne.n	c0de28ac <handleStarkwareSignMessage+0x1f4>
c0de288e:	4638      	mov	r0, r7
c0de2890:	e00e      	b.n	c0de28b0 <handleStarkwareSignMessage+0x1f8>
                         false,
                         dataContext.starkContext.w2);
        offset = 20 + 32 + postOffset + 20 + 32 + postOffset;
    } else {
        memmove(dataContext.starkContext.w2, dataBuffer + 20 + 32 + postOffset, 32);
c0de2892:	4648      	mov	r0, r9
c0de2894:	4dd3      	ldr	r5, [pc, #844]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
c0de2896:	1940      	adds	r0, r0, r5
c0de2898:	3020      	adds	r0, #32
c0de289a:	19a1      	adds	r1, r4, r6
c0de289c:	3134      	adds	r1, #52	; 0x34
c0de289e:	2220      	movs	r2, #32
c0de28a0:	f00a ffc2 	bl	c0ded828 <__aeabi_memmove>
c0de28a4:	2054      	movs	r0, #84	; 0x54
        offset = 20 + 32 + postOffset + 32;
c0de28a6:	4330      	orrs	r0, r6
c0de28a8:	4606      	mov	r6, r0
c0de28aa:	e00e      	b.n	c0de28ca <handleStarkwareSignMessage+0x212>
c0de28ac:	4620      	mov	r0, r4
c0de28ae:	308a      	adds	r0, #138	; 0x8a
        compute_token_id(&global_sha3,
c0de28b0:	9000      	str	r0, [sp, #0]
c0de28b2:	48cd      	ldr	r0, [pc, #820]	; (c0de2be8 <handleStarkwareSignMessage+0x530>)
c0de28b4:	1808      	adds	r0, r1, r0
                         dataBuffer + 20 + 32 + postOffset + preOffset + 20,
c0de28b6:	462b      	mov	r3, r5
c0de28b8:	3314      	adds	r3, #20
        compute_token_id(&global_sha3,
c0de28ba:	4629      	mov	r1, r5
c0de28bc:	f005 fedc 	bl	c0de8678 <compute_token_id>
c0de28c0:	2048      	movs	r0, #72	; 0x48
        offset = 20 + 32 + postOffset + 20 + 32 + postOffset;
c0de28c2:	4330      	orrs	r0, r6
c0de28c4:	1836      	adds	r6, r6, r0
c0de28c6:	3620      	adds	r6, #32
c0de28c8:	4dc6      	ldr	r5, [pc, #792]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
    }

    poorstream_init(&bitstream, dataContext.starkContext.w3);
c0de28ca:	4648      	mov	r0, r9
c0de28cc:	1941      	adds	r1, r0, r5
c0de28ce:	3140      	adds	r1, #64	; 0x40
c0de28d0:	af28      	add	r7, sp, #160	; 0xa0
c0de28d2:	4638      	mov	r0, r7
c0de28d4:	f005 fcd2 	bl	c0de827c <poorstream_init>
c0de28d8:	200b      	movs	r0, #11
    poorstream_write_bits(&bitstream, 0, 11);  // padding
c0de28da:	9000      	str	r0, [sp, #0]
c0de28dc:	2500      	movs	r5, #0
c0de28de:	49c5      	ldr	r1, [pc, #788]	; (c0de2bf4 <handleStarkwareSignMessage+0x53c>)
c0de28e0:	4479      	add	r1, pc
c0de28e2:	4638      	mov	r0, r7
c0de28e4:	462a      	mov	r2, r5
c0de28e6:	462b      	mov	r3, r5
c0de28e8:	9114      	str	r1, [sp, #80]	; 0x50
c0de28ea:	4788      	blx	r1
c0de28ec:	2004      	movs	r0, #4
    poorstream_write_bits(&bitstream,
c0de28ee:	9000      	str	r0, [sp, #0]
c0de28f0:	980f      	ldr	r0, [sp, #60]	; 0x3c
                          (p1 == P1_STARK_CONDITIONAL_TRANSFER ? STARK_CONDITIONAL_TRANSFER_TYPE
c0de28f2:	2805      	cmp	r0, #5
c0de28f4:	d001      	beq.n	c0de28fa <handleStarkwareSignMessage+0x242>
c0de28f6:	9a07      	ldr	r2, [sp, #28]
c0de28f8:	e000      	b.n	c0de28fc <handleStarkwareSignMessage+0x244>
c0de28fa:	2202      	movs	r2, #2
c0de28fc:	2805      	cmp	r0, #5
c0de28fe:	950c      	str	r5, [sp, #48]	; 0x30
c0de2900:	d000      	beq.n	c0de2904 <handleStarkwareSignMessage+0x24c>
c0de2902:	9d06      	ldr	r5, [sp, #24]
    poorstream_write_bits(&bitstream,
c0de2904:	4638      	mov	r0, r7
c0de2906:	462b      	mov	r3, r5
c0de2908:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de290a:	4788      	blx	r1
c0de290c:	9607      	str	r6, [sp, #28]
                           : order                             ? STARK_ORDER_TYPE
                                                               : STARK_TRANSFER_TYPE),
                          4);
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset), 31);
c0de290e:	b2f6      	uxtb	r6, r6
c0de2910:	4ab9      	ldr	r2, [pc, #740]	; (c0de2bf8 <handleStarkwareSignMessage+0x540>)
c0de2912:	447a      	add	r2, pc
c0de2914:	920f      	str	r2, [sp, #60]	; 0x3c
c0de2916:	4620      	mov	r0, r4
c0de2918:	4631      	mov	r1, r6
c0de291a:	4790      	blx	r2
c0de291c:	4602      	mov	r2, r0
c0de291e:	4638      	mov	r0, r7
c0de2920:	970e      	str	r7, [sp, #56]	; 0x38
c0de2922:	271f      	movs	r7, #31
c0de2924:	9700      	str	r7, [sp, #0]
c0de2926:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0de2928:	462b      	mov	r3, r5
c0de292a:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de292c:	4788      	blx	r1
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset + 4), 31);
c0de292e:	1d31      	adds	r1, r6, #4
c0de2930:	4620      	mov	r0, r4
c0de2932:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0de2934:	4790      	blx	r2
c0de2936:	4602      	mov	r2, r0
c0de2938:	9706      	str	r7, [sp, #24]
c0de293a:	9700      	str	r7, [sp, #0]
c0de293c:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de293e:	462b      	mov	r3, r5
c0de2940:	9d14      	ldr	r5, [sp, #80]	; 0x50
c0de2942:	47a8      	blx	r5
    poorstream_write_bits(&bitstream, U8BE(dataBuffer, offset + 4 + 4), 63);
c0de2944:	4631      	mov	r1, r6
c0de2946:	3108      	adds	r1, #8
c0de2948:	4620      	mov	r0, r4
c0de294a:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
c0de294c:	47b8      	blx	r7
c0de294e:	9005      	str	r0, [sp, #20]
c0de2950:	4631      	mov	r1, r6
c0de2952:	310c      	adds	r1, #12
c0de2954:	4620      	mov	r0, r4
c0de2956:	47b8      	blx	r7
c0de2958:	4602      	mov	r2, r0
c0de295a:	203f      	movs	r0, #63	; 0x3f
c0de295c:	900f      	str	r0, [sp, #60]	; 0x3c
c0de295e:	9000      	str	r0, [sp, #0]
c0de2960:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de2962:	9b05      	ldr	r3, [sp, #20]
c0de2964:	47a8      	blx	r5
    if (order) {
c0de2966:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de2968:	2800      	cmp	r0, #0
c0de296a:	d00e      	beq.n	c0de298a <handleStarkwareSignMessage+0x2d2>
        poorstream_write_bits(&bitstream, U8BE(dataBuffer, offset + 4 + 4 + 8), 63);
c0de296c:	4631      	mov	r1, r6
c0de296e:	3110      	adds	r1, #16
c0de2970:	4620      	mov	r0, r4
c0de2972:	f000 f953 	bl	c0de2c1c <U4BE>
c0de2976:	4605      	mov	r5, r0
c0de2978:	3614      	adds	r6, #20
c0de297a:	4620      	mov	r0, r4
c0de297c:	4631      	mov	r1, r6
c0de297e:	f000 f94d 	bl	c0de2c1c <U4BE>
c0de2982:	462b      	mov	r3, r5
c0de2984:	4602      	mov	r2, r0
c0de2986:	2718      	movs	r7, #24
c0de2988:	e002      	b.n	c0de2990 <handleStarkwareSignMessage+0x2d8>
c0de298a:	2710      	movs	r7, #16
c0de298c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0de298e:	4613      	mov	r3, r2
c0de2990:	4625      	mov	r5, r4
c0de2992:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0de2994:	9000      	str	r0, [sp, #0]
c0de2996:	ae28      	add	r6, sp, #160	; 0xa0
c0de2998:	4630      	mov	r0, r6
c0de299a:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de299c:	4788      	blx	r1
c0de299e:	9807      	ldr	r0, [sp, #28]
c0de29a0:	19c0      	adds	r0, r0, r7
        offset += 4 + 4 + 8 + 8;
    } else {
        poorstream_write_bits(&bitstream, 0, 63);
        offset += 4 + 4 + 8;
    }
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset), 31);
c0de29a2:	b2c4      	uxtb	r4, r0
c0de29a4:	4628      	mov	r0, r5
c0de29a6:	4621      	mov	r1, r4
c0de29a8:	f000 f938 	bl	c0de2c1c <U4BE>
c0de29ac:	4602      	mov	r2, r0
c0de29ae:	9806      	ldr	r0, [sp, #24]
c0de29b0:	9000      	str	r0, [sp, #0]
c0de29b2:	462f      	mov	r7, r5
c0de29b4:	2500      	movs	r5, #0
c0de29b6:	4630      	mov	r0, r6
c0de29b8:	462b      	mov	r3, r5
c0de29ba:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de29bc:	4788      	blx	r1
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset + 4), 22);
c0de29be:	1d21      	adds	r1, r4, #4
c0de29c0:	970b      	str	r7, [sp, #44]	; 0x2c
c0de29c2:	4638      	mov	r0, r7
c0de29c4:	f000 f92a 	bl	c0de2c1c <U4BE>
c0de29c8:	4602      	mov	r2, r0
c0de29ca:	2016      	movs	r0, #22
c0de29cc:	9000      	str	r0, [sp, #0]
c0de29ce:	4630      	mov	r0, r6
c0de29d0:	462b      	mov	r3, r5
c0de29d2:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de29d4:	4788      	blx	r1

    PRINTF("stark w1 %.*H\n", 32, dataContext.starkContext.w1);
    PRINTF("stark w2 %.*H\n", 32, dataContext.starkContext.w2);
    PRINTF("stark w3 %.*H\n", 32, dataContext.starkContext.w3);

    if (dataContext.starkContext.conditional) {
c0de29d6:	4648      	mov	r0, r9
c0de29d8:	4e82      	ldr	r6, [pc, #520]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
c0de29da:	1980      	adds	r0, r0, r6
c0de29dc:	990d      	ldr	r1, [sp, #52]	; 0x34
c0de29de:	5c40      	ldrb	r0, [r0, r1]
c0de29e0:	2800      	cmp	r0, #0
c0de29e2:	d021      	beq.n	c0de2a28 <handleStarkwareSignMessage+0x370>
c0de29e4:	4648      	mov	r0, r9
c0de29e6:	4980      	ldr	r1, [pc, #512]	; (c0de2be8 <handleStarkwareSignMessage+0x530>)
c0de29e8:	1840      	adds	r0, r0, r1
c0de29ea:	990a      	ldr	r1, [sp, #40]	; 0x28
c0de29ec:	0209      	lsls	r1, r1, #8
c0de29ee:	f000 fb57 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de29f2:	2800      	cmp	r0, #0
c0de29f4:	d000      	beq.n	c0de29f8 <handleStarkwareSignMessage+0x340>
c0de29f6:	e0ed      	b.n	c0de2bd4 <handleStarkwareSignMessage+0x51c>
        cx_keccak_init(&global_sha3, 256);
        cx_hash((cx_hash_t *) &global_sha3,
c0de29f8:	9500      	str	r5, [sp, #0]
c0de29fa:	4648      	mov	r0, r9
c0de29fc:	1986      	adds	r6, r0, r6
c0de29fe:	4631      	mov	r1, r6
c0de2a00:	31c1      	adds	r1, #193	; 0xc1
c0de2a02:	2214      	movs	r2, #20
c0de2a04:	4628      	mov	r0, r5
c0de2a06:	462b      	mov	r3, r5
c0de2a08:	f000 f920 	bl	c0de2c4c <cx_hash>
c0de2a0c:	2220      	movs	r2, #32
                0,
                dataContext.starkContext.conditionAddress,
                20,
                NULL,
                0);
        cx_hash((cx_hash_t *) &global_sha3,
c0de2a0e:	9200      	str	r2, [sp, #0]
c0de2a10:	4631      	mov	r1, r6
c0de2a12:	31a1      	adds	r1, #161	; 0xa1
c0de2a14:	4633      	mov	r3, r6
c0de2a16:	3360      	adds	r3, #96	; 0x60
c0de2a18:	2001      	movs	r0, #1
c0de2a1a:	f000 f917 	bl	c0de2c4c <cx_hash>
c0de2a1e:	2060      	movs	r0, #96	; 0x60
                CX_LAST,
                dataContext.starkContext.fact,
                32,
                dataContext.starkContext.w4,
                32);
        dataContext.starkContext.w4[0] &= 0x03;
c0de2a20:	5c31      	ldrb	r1, [r6, r0]
c0de2a22:	2203      	movs	r2, #3
c0de2a24:	400a      	ands	r2, r1
c0de2a26:	5432      	strb	r2, [r6, r0]
        PRINTF("stark w4 %.*H\n", 32, dataContext.starkContext.w4);
    }
    // Prepare the UI
    if (order) {
c0de2a28:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de2a2a:	2800      	cmp	r0, #0
c0de2a2c:	d03a      	beq.n	c0de2aa4 <handleStarkwareSignMessage+0x3ec>
        io_seproxyhal_io_heartbeat();
        // amount to sell
        stark_get_amount_string(dataBuffer + preOffset,
c0de2a2e:	4870      	ldr	r0, [pc, #448]	; (c0de2bf0 <handleStarkwareSignMessage+0x538>)
c0de2a30:	4649      	mov	r1, r9
c0de2a32:	180d      	adds	r5, r1, r0
c0de2a34:	9514      	str	r5, [sp, #80]	; 0x50
c0de2a36:	3535      	adds	r5, #53	; 0x35
        io_seproxyhal_io_heartbeat();
c0de2a38:	f005 f8b2 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
        stark_get_amount_string(dataBuffer + preOffset,
c0de2a3c:	9500      	str	r5, [sp, #0]
c0de2a3e:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de2a40:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
                                dataBuffer + preOffset + 20,
                                dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4,
c0de2a42:	183d      	adds	r5, r7, r0
c0de2a44:	3534      	adds	r5, #52	; 0x34
c0de2a46:	182c      	adds	r4, r5, r0
c0de2a48:	4622      	mov	r2, r4
c0de2a4a:	323c      	adds	r2, #60	; 0x3c
                                (char *) (dataBuffer + TMP_OFFSET),
c0de2a4c:	378c      	adds	r7, #140	; 0x8c
        stark_get_amount_string(dataBuffer + preOffset,
c0de2a4e:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de2a50:	9908      	ldr	r1, [sp, #32]
c0de2a52:	463b      	mov	r3, r7
c0de2a54:	f005 fcc6 	bl	c0de83e4 <stark_get_amount_string>
                                strings.common.fullAmount);
        io_seproxyhal_io_heartbeat();
        // amount to buy
        stark_get_amount_string(
c0de2a58:	9e14      	ldr	r6, [sp, #80]	; 0x50
c0de2a5a:	3684      	adds	r6, #132	; 0x84
        io_seproxyhal_io_heartbeat();
c0de2a5c:	f005 f8a0 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
        stark_get_amount_string(
c0de2a60:	9600      	str	r6, [sp, #0]
            dataBuffer + 20 + 32 + postOffset + preOffset,
c0de2a62:	9812      	ldr	r0, [sp, #72]	; 0x48
c0de2a64:	1828      	adds	r0, r5, r0
            dataBuffer + 20 + 32 + postOffset + preOffset + 20,
c0de2a66:	4601      	mov	r1, r0
c0de2a68:	3114      	adds	r1, #20
            dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4 + 8,
c0de2a6a:	3444      	adds	r4, #68	; 0x44
        stark_get_amount_string(
c0de2a6c:	4622      	mov	r2, r4
c0de2a6e:	463b      	mov	r3, r7
c0de2a70:	f005 fcb8 	bl	c0de83e4 <stark_get_amount_string>
c0de2a74:	2048      	movs	r0, #72	; 0x48
c0de2a76:	9911      	ldr	r1, [sp, #68]	; 0x44
            strings.common.maxFee);
        // src vault ID
        snprintf(strings.common.fullAddress,
                 sizeof(strings.common.fullAddress),
                 "%d",
                 U4BE(dataBuffer, 20 + 32 + postOffset + 20 + 32 + postOffset));
c0de2a78:	4308      	orrs	r0, r1
c0de2a7a:	1809      	adds	r1, r1, r0
c0de2a7c:	3120      	adds	r1, #32
c0de2a7e:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de2a80:	f000 f8cc 	bl	c0de2c1c <U4BE>
c0de2a84:	4603      	mov	r3, r0
c0de2a86:	2135      	movs	r1, #53	; 0x35
        snprintf(strings.common.fullAddress,
c0de2a88:	4a62      	ldr	r2, [pc, #392]	; (c0de2c14 <handleStarkwareSignMessage+0x55c>)
c0de2a8a:	447a      	add	r2, pc
c0de2a8c:	9814      	ldr	r0, [sp, #80]	; 0x50
c0de2a8e:	f005 f9fd 	bl	c0de7e8c <snprintf>
c0de2a92:	4961      	ldr	r1, [pc, #388]	; (c0de2c18 <handleStarkwareSignMessage+0x560>)
c0de2a94:	4479      	add	r1, pc
c0de2a96:	e088      	b.n	c0de2baa <handleStarkwareSignMessage+0x4f2>
c0de2a98:	0000011c 	.word	0x0000011c
c0de2a9c:	00000124 	.word	0x00000124
c0de2aa0:	00000594 	.word	0x00000594
    } else {
        cx_ecfp_public_key_t publicKey;
        // Check if the transfer is a self transfer
        io_seproxyhal_io_heartbeat();
        starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0de2aa4:	4648      	mov	r0, r9
c0de2aa6:	494e      	ldr	r1, [pc, #312]	; (c0de2be0 <handleStarkwareSignMessage+0x528>)
c0de2aa8:	1845      	adds	r5, r0, r1
        io_seproxyhal_io_heartbeat();
c0de2aaa:	f005 f879 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
        starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0de2aae:	1d28      	adds	r0, r5, #4
c0de2ab0:	ad39      	add	r5, sp, #228	; 0xe4
c0de2ab2:	9903      	ldr	r1, [sp, #12]
c0de2ab4:	462a      	mov	r2, r5
c0de2ab6:	f005 fc4f 	bl	c0de8358 <starkDerivePrivateKey>
c0de2aba:	2051      	movs	r0, #81	; 0x51
c0de2abc:	2220      	movs	r2, #32
c0de2abe:	ab2f      	add	r3, sp, #188	; 0xbc
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de2ac0:	4629      	mov	r1, r5
c0de2ac2:	f000 fac3 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de2ac6:	2800      	cmp	r0, #0
c0de2ac8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
c0de2aca:	d000      	beq.n	c0de2ace <handleStarkwareSignMessage+0x416>
c0de2acc:	e082      	b.n	c0de2bd4 <handleStarkwareSignMessage+0x51c>
        cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
        io_seproxyhal_io_heartbeat();
c0de2ace:	f005 f867 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de2ad2:	2051      	movs	r0, #81	; 0x51
c0de2ad4:	a915      	add	r1, sp, #84	; 0x54
c0de2ad6:	aa2f      	add	r2, sp, #188	; 0xbc
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de2ad8:	9b04      	ldr	r3, [sp, #16]
c0de2ada:	f000 fab1 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de2ade:	2800      	cmp	r0, #0
c0de2ae0:	d178      	bne.n	c0de2bd4 <handleStarkwareSignMessage+0x51c>
c0de2ae2:	a82f      	add	r0, sp, #188	; 0xbc
c0de2ae4:	2128      	movs	r1, #40	; 0x28
        cx_ecfp_generate_pair(CX_CURVE_Stark256, &publicKey, &privateKey, 1);
        explicit_bzero(&privateKey, sizeof(privateKey));
c0de2ae6:	9114      	str	r1, [sp, #80]	; 0x50
c0de2ae8:	f00a feaa 	bl	c0ded840 <explicit_bzero>
c0de2aec:	a839      	add	r0, sp, #228	; 0xe4
c0de2aee:	2620      	movs	r6, #32
        explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de2af0:	4631      	mov	r1, r6
c0de2af2:	f00a fea5 	bl	c0ded840 <explicit_bzero>
        io_seproxyhal_io_heartbeat();
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0de2af6:	9811      	ldr	r0, [sp, #68]	; 0x44
c0de2af8:	1825      	adds	r5, r4, r0
        io_seproxyhal_io_heartbeat();
c0de2afa:	f005 f851 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0de2afe:	462f      	mov	r7, r5
c0de2b00:	3734      	adds	r7, #52	; 0x34
c0de2b02:	a815      	add	r0, sp, #84	; 0x54
c0de2b04:	3009      	adds	r0, #9
c0de2b06:	4639      	mov	r1, r7
c0de2b08:	4632      	mov	r2, r6
c0de2b0a:	f00a fea3 	bl	c0ded854 <memcmp>
c0de2b0e:	9013      	str	r0, [sp, #76]	; 0x4c
        PRINTF("self transfer %d\n", selfTransfer);
        io_seproxyhal_io_heartbeat();
        // amount to transfer
        stark_get_amount_string(dataBuffer + preOffset,
c0de2b10:	4836      	ldr	r0, [pc, #216]	; (c0de2bec <handleStarkwareSignMessage+0x534>)
c0de2b12:	4649      	mov	r1, r9
c0de2b14:	9112      	str	r1, [sp, #72]	; 0x48
c0de2b16:	180e      	adds	r6, r1, r0
        io_seproxyhal_io_heartbeat();
c0de2b18:	f005 f842 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
        stark_get_amount_string(dataBuffer + preOffset,
c0de2b1c:	9600      	str	r6, [sp, #0]
                                dataBuffer + preOffset + 20,
                                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4,
c0de2b1e:	355c      	adds	r5, #92	; 0x5c
                                (char *) (dataBuffer + TMP_OFFSET),
c0de2b20:	4623      	mov	r3, r4
c0de2b22:	338c      	adds	r3, #140	; 0x8c
        stark_get_amount_string(dataBuffer + preOffset,
c0de2b24:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de2b26:	9908      	ldr	r1, [sp, #32]
c0de2b28:	462a      	mov	r2, r5
c0de2b2a:	f005 fc5b 	bl	c0de83e4 <stark_get_amount_string>
c0de2b2e:	2054      	movs	r0, #84	; 0x54
                                tmpContent.tmp);
        // dest vault ID
        snprintf(strings.tmp.tmp2,
                 sizeof(strings.tmp.tmp2),
                 "%d",
                 U4BE(dataBuffer, 20 + 32 + postOffset + 32 + 4));
c0de2b30:	9911      	ldr	r1, [sp, #68]	; 0x44
c0de2b32:	4308      	orrs	r0, r1
c0de2b34:	1d01      	adds	r1, r0, #4
c0de2b36:	4620      	mov	r0, r4
c0de2b38:	f000 f870 	bl	c0de2c1c <U4BE>
c0de2b3c:	4603      	mov	r3, r0
        snprintf(strings.tmp.tmp2,
c0de2b3e:	492c      	ldr	r1, [pc, #176]	; (c0de2bf0 <handleStarkwareSignMessage+0x538>)
c0de2b40:	9812      	ldr	r0, [sp, #72]	; 0x48
c0de2b42:	1840      	adds	r0, r0, r1
c0de2b44:	990a      	ldr	r1, [sp, #40]	; 0x28
c0de2b46:	020c      	lsls	r4, r1, #8
c0de2b48:	1900      	adds	r0, r0, r4
c0de2b4a:	4a2c      	ldr	r2, [pc, #176]	; (c0de2bfc <handleStarkwareSignMessage+0x544>)
c0de2b4c:	447a      	add	r2, pc
c0de2b4e:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de2b50:	f005 f99c 	bl	c0de7e8c <snprintf>
        if (!selfTransfer) {
c0de2b54:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de2b56:	2800      	cmp	r0, #0
c0de2b58:	d01a      	beq.n	c0de2b90 <handleStarkwareSignMessage+0x4d8>
            memmove(dataContext.starkContext.transferDestination,
c0de2b5a:	464e      	mov	r6, r9
c0de2b5c:	4821      	ldr	r0, [pc, #132]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
c0de2b5e:	1830      	adds	r0, r6, r0
c0de2b60:	9014      	str	r0, [sp, #80]	; 0x50
c0de2b62:	3081      	adds	r0, #129	; 0x81
c0de2b64:	2520      	movs	r5, #32
c0de2b66:	4639      	mov	r1, r7
c0de2b68:	462a      	mov	r2, r5
c0de2b6a:	f00a fe5d 	bl	c0ded828 <__aeabi_memmove>
                    dataBuffer + 20 + 32 + postOffset,
                    32);
            snprintf(strings.tmp.tmp,
c0de2b6e:	9700      	str	r7, [sp, #0]
c0de2b70:	481f      	ldr	r0, [pc, #124]	; (c0de2bf0 <handleStarkwareSignMessage+0x538>)
c0de2b72:	1830      	adds	r0, r6, r0
c0de2b74:	4a24      	ldr	r2, [pc, #144]	; (c0de2c08 <handleStarkwareSignMessage+0x550>)
c0de2b76:	447a      	add	r2, pc
c0de2b78:	4621      	mov	r1, r4
c0de2b7a:	462b      	mov	r3, r5
c0de2b7c:	f005 f986 	bl	c0de7e8c <snprintf>
c0de2b80:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de2b82:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de2b84:	5c08      	ldrb	r0, [r1, r0]
                (dataContext.starkContext.conditional ? ux_stark_self_transfer_conditional_flow
                                                      : ux_stark_self_transfer_flow),
                NULL);
        } else {
            ux_flow_init(0,
                         (dataContext.starkContext.conditional ? ux_stark_transfer_conditional_flow
c0de2b86:	2800      	cmp	r0, #0
c0de2b88:	d00d      	beq.n	c0de2ba6 <handleStarkwareSignMessage+0x4ee>
c0de2b8a:	4921      	ldr	r1, [pc, #132]	; (c0de2c10 <handleStarkwareSignMessage+0x558>)
c0de2b8c:	4479      	add	r1, pc
c0de2b8e:	e00c      	b.n	c0de2baa <handleStarkwareSignMessage+0x4f2>
c0de2b90:	4648      	mov	r0, r9
c0de2b92:	4914      	ldr	r1, [pc, #80]	; (c0de2be4 <handleStarkwareSignMessage+0x52c>)
c0de2b94:	1840      	adds	r0, r0, r1
c0de2b96:	990d      	ldr	r1, [sp, #52]	; 0x34
c0de2b98:	5c40      	ldrb	r0, [r0, r1]
                (dataContext.starkContext.conditional ? ux_stark_self_transfer_conditional_flow
c0de2b9a:	2800      	cmp	r0, #0
c0de2b9c:	9c09      	ldr	r4, [sp, #36]	; 0x24
c0de2b9e:	d00f      	beq.n	c0de2bc0 <handleStarkwareSignMessage+0x508>
c0de2ba0:	4918      	ldr	r1, [pc, #96]	; (c0de2c04 <handleStarkwareSignMessage+0x54c>)
c0de2ba2:	4479      	add	r1, pc
c0de2ba4:	e002      	b.n	c0de2bac <handleStarkwareSignMessage+0x4f4>
c0de2ba6:	4919      	ldr	r1, [pc, #100]	; (c0de2c0c <handleStarkwareSignMessage+0x554>)
c0de2ba8:	4479      	add	r1, pc
c0de2baa:	9c09      	ldr	r4, [sp, #36]	; 0x24
c0de2bac:	2000      	movs	r0, #0
c0de2bae:	4602      	mov	r2, r0
c0de2bb0:	f009 fee8 	bl	c0dec984 <ux_flow_init>
                                                               : ux_stark_transfer_flow),
                         NULL);
        }
    }

    *flags |= IO_ASYNCH_REPLY;
c0de2bb4:	6820      	ldr	r0, [r4, #0]
c0de2bb6:	2110      	movs	r1, #16
c0de2bb8:	4301      	orrs	r1, r0
c0de2bba:	6021      	str	r1, [r4, #0]
}
c0de2bbc:	b041      	add	sp, #260	; 0x104
c0de2bbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de2bc0:	490f      	ldr	r1, [pc, #60]	; (c0de2c00 <handleStarkwareSignMessage+0x548>)
c0de2bc2:	4479      	add	r1, pc
c0de2bc4:	e7f2      	b.n	c0de2bac <handleStarkwareSignMessage+0x4f4>
c0de2bc6:	20d5      	movs	r0, #213	; 0xd5
c0de2bc8:	01c0      	lsls	r0, r0, #7
c0de2bca:	f004 fc2c 	bl	c0de7426 <os_longjmp>
c0de2bce:	20d5      	movs	r0, #213	; 0xd5
c0de2bd0:	01c0      	lsls	r0, r0, #7
c0de2bd2:	3080      	adds	r0, #128	; 0x80
c0de2bd4:	f004 fc27 	bl	c0de7426 <os_longjmp>
c0de2bd8:	2067      	movs	r0, #103	; 0x67
c0de2bda:	0200      	lsls	r0, r0, #8
c0de2bdc:	f004 fc23 	bl	c0de7426 <os_longjmp>
c0de2be0:	00000124 	.word	0x00000124
c0de2be4:	00000594 	.word	0x00000594
c0de2be8:	000007e8 	.word	0x000007e8
c0de2bec:	0000026c 	.word	0x0000026c
c0de2bf0:	000006ba 	.word	0x000006ba
c0de2bf4:	000059dd 	.word	0x000059dd
c0de2bf8:	00000307 	.word	0x00000307
c0de2bfc:	0000b1f8 	.word	0x0000b1f8
c0de2c00:	0000dff6 	.word	0x0000dff6
c0de2c04:	0000e05a 	.word	0x0000e05a
c0de2c08:	0000b561 	.word	0x0000b561
c0de2c0c:	0000dff0 	.word	0x0000dff0
c0de2c10:	0000e048 	.word	0x0000e048
c0de2c14:	0000b2ba 	.word	0x0000b2ba
c0de2c18:	0000df70 	.word	0x0000df70

c0de2c1c <U4BE>:
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2c1c:	5c42      	ldrb	r2, [r0, r1]
c0de2c1e:	0612      	lsls	r2, r2, #24
c0de2c20:	1840      	adds	r0, r0, r1
c0de2c22:	7841      	ldrb	r1, [r0, #1]
c0de2c24:	0409      	lsls	r1, r1, #16
c0de2c26:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de2c28:	7882      	ldrb	r2, [r0, #2]
c0de2c2a:	0212      	lsls	r2, r2, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2c2c:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de2c2e:	78c0      	ldrb	r0, [r0, #3]
c0de2c30:	1808      	adds	r0, r1, r0
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2c32:	4770      	bx	lr

c0de2c34 <allzeroes>:
static __attribute__((no_instrument_function)) inline int allzeroes(void *buf, size_t n) {
c0de2c34:	2100      	movs	r1, #0
    for (size_t i = 0; i < n; ++i) {
c0de2c36:	2914      	cmp	r1, #20
c0de2c38:	d005      	beq.n	c0de2c46 <allzeroes+0x12>
        if (p[i]) {
c0de2c3a:	5c42      	ldrb	r2, [r0, r1]
    for (size_t i = 0; i < n; ++i) {
c0de2c3c:	1c49      	adds	r1, r1, #1
        if (p[i]) {
c0de2c3e:	2a00      	cmp	r2, #0
c0de2c40:	d0f9      	beq.n	c0de2c36 <allzeroes+0x2>
c0de2c42:	2000      	movs	r0, #0
            return 0;
        }
    }
    return 1;
}
c0de2c44:	4770      	bx	lr
c0de2c46:	2001      	movs	r0, #1
c0de2c48:	4770      	bx	lr
c0de2c4a:	d4d4      	bmi.n	c0de2bf6 <handleStarkwareSignMessage+0x53e>

c0de2c4c <cx_hash>:
{
c0de2c4c:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0de2c4e:	4614      	mov	r4, r2
c0de2c50:	460a      	mov	r2, r1
c0de2c52:	4601      	mov	r1, r0
c0de2c54:	9806      	ldr	r0, [sp, #24]
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de2c56:	9300      	str	r3, [sp, #0]
c0de2c58:	9001      	str	r0, [sp, #4]
c0de2c5a:	4d07      	ldr	r5, [pc, #28]	; (c0de2c78 <cx_hash+0x2c>)
c0de2c5c:	4648      	mov	r0, r9
c0de2c5e:	1940      	adds	r0, r0, r5
c0de2c60:	4623      	mov	r3, r4
c0de2c62:	f000 fa0b 	bl	c0de307c <cx_hash_no_throw>
c0de2c66:	2800      	cmp	r0, #0
c0de2c68:	d104      	bne.n	c0de2c74 <cx_hash+0x28>
  return cx_hash_get_size(hash);
c0de2c6a:	4648      	mov	r0, r9
c0de2c6c:	1940      	adds	r0, r0, r5
c0de2c6e:	f000 f9ff 	bl	c0de3070 <cx_hash_get_size>
c0de2c72:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de2c74:	f004 fbd7 	bl	c0de7426 <os_longjmp>
c0de2c78:	000007e8 	.word	0x000007e8

c0de2c7c <handleStarkwareUnsafeSign>:
void handleStarkwareUnsafeSign(uint8_t p1,
                               uint8_t p2,
                               uint8_t *dataBuffer,
                               uint16_t dataLength,
                               unsigned int *flags,
                               __attribute__((unused)) unsigned int *tx) {
c0de2c7c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de2c7e:	b0a7      	sub	sp, #156	; 0x9c
c0de2c80:	4615      	mov	r5, r2
c0de2c82:	460f      	mov	r7, r1
c0de2c84:	4606      	mov	r6, r0
    cx_ecfp_public_key_t publicKey;
    cx_ecfp_private_key_t privateKey;
    uint8_t bip32PathLength = *(dataBuffer);
    uint8_t offset = 1;
    // Initial checks
    if (appState != APP_STATE_IDLE) {
c0de2c86:	4a3f      	ldr	r2, [pc, #252]	; (c0de2d84 <handleStarkwareUnsafeSign+0x108>)
c0de2c88:	4649      	mov	r1, r9
c0de2c8a:	5c89      	ldrb	r1, [r1, r2]
    uint8_t bip32PathLength = *(dataBuffer);
c0de2c8c:	782c      	ldrb	r4, [r5, #0]
    if (appState != APP_STATE_IDLE) {
c0de2c8e:	2900      	cmp	r1, #0
c0de2c90:	d003      	beq.n	c0de2c9a <handleStarkwareUnsafeSign+0x1e>
c0de2c92:	9301      	str	r3, [sp, #4]
        reset_app_context();
c0de2c94:	f003 fce6 	bl	c0de6664 <reset_app_context>
c0de2c98:	9b01      	ldr	r3, [sp, #4]
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0de2c9a:	1e61      	subs	r1, r4, #1
c0de2c9c:	290a      	cmp	r1, #10
c0de2c9e:	d263      	bcs.n	c0de2d68 <handleStarkwareUnsafeSign+0xec>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != 0) || (p2 != 0)) {
c0de2ca0:	4337      	orrs	r7, r6
c0de2ca2:	d165      	bne.n	c0de2d70 <handleStarkwareUnsafeSign+0xf4>
        THROW(0x6B00);
    }

    if (dataLength != 32 + 4 * bip32PathLength + 1) {
c0de2ca4:	00a0      	lsls	r0, r4, #2
c0de2ca6:	3021      	adds	r0, #33	; 0x21
c0de2ca8:	4298      	cmp	r0, r3
c0de2caa:	d166      	bne.n	c0de2d7a <handleStarkwareUnsafeSign+0xfe>
c0de2cac:	982c      	ldr	r0, [sp, #176]	; 0xb0
        THROW(0x6700);
    }

    tmpCtx.transactionContext.pathLength = bip32PathLength;
c0de2cae:	9001      	str	r0, [sp, #4]
c0de2cb0:	4935      	ldr	r1, [pc, #212]	; (c0de2d88 <handleStarkwareUnsafeSign+0x10c>)
c0de2cb2:	4648      	mov	r0, r9
c0de2cb4:	5444      	strb	r4, [r0, r1]
c0de2cb6:	1840      	adds	r0, r0, r1
c0de2cb8:	1d00      	adds	r0, r0, #4
c0de2cba:	2101      	movs	r1, #1
c0de2cbc:	4622      	mov	r2, r4
c0de2cbe:	b2cb      	uxtb	r3, r1
c0de2cc0:	18e9      	adds	r1, r5, r3
    for (i = 0; i < bip32PathLength; i++) {
c0de2cc2:	2a00      	cmp	r2, #0
c0de2cc4:	d00d      	beq.n	c0de2ce2 <handleStarkwareUnsafeSign+0x66>
c0de2cc6:	5cef      	ldrb	r7, [r5, r3]
c0de2cc8:	063f      	lsls	r7, r7, #24
c0de2cca:	784e      	ldrb	r6, [r1, #1]
c0de2ccc:	0436      	lsls	r6, r6, #16
c0de2cce:	19f6      	adds	r6, r6, r7
         (buf[off + 2] << 8) | buf[off + 3];
c0de2cd0:	788f      	ldrb	r7, [r1, #2]
c0de2cd2:	023f      	lsls	r7, r7, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de2cd4:	19f6      	adds	r6, r6, r7
         (buf[off + 2] << 8) | buf[off + 3];
c0de2cd6:	78c9      	ldrb	r1, [r1, #3]
c0de2cd8:	1871      	adds	r1, r6, r1
        tmpCtx.transactionContext.bip32Path[i] = U4BE(dataBuffer, offset);
c0de2cda:	c002      	stmia	r0!, {r1}
    for (i = 0; i < bip32PathLength; i++) {
c0de2cdc:	1e52      	subs	r2, r2, #1
        PRINTF("Storing path %d %d\n", i, tmpCtx.transactionContext.bip32Path[i]);
        offset += 4;
c0de2cde:	1d19      	adds	r1, r3, #4
c0de2ce0:	e7ed      	b.n	c0de2cbe <handleStarkwareUnsafeSign+0x42>
    }
    memmove(dataContext.starkContext.w2, dataBuffer + offset, 32);
c0de2ce2:	4f2a      	ldr	r7, [pc, #168]	; (c0de2d8c <handleStarkwareUnsafeSign+0x110>)
c0de2ce4:	464e      	mov	r6, r9
c0de2ce6:	19f0      	adds	r0, r6, r7
c0de2ce8:	3020      	adds	r0, #32
c0de2cea:	2520      	movs	r5, #32
c0de2cec:	462a      	mov	r2, r5
c0de2cee:	f00a fd9b 	bl	c0ded828 <__aeabi_memmove>
    io_seproxyhal_io_heartbeat();
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0de2cf2:	4825      	ldr	r0, [pc, #148]	; (c0de2d88 <handleStarkwareUnsafeSign+0x10c>)
c0de2cf4:	1836      	adds	r6, r6, r0
    io_seproxyhal_io_heartbeat();
c0de2cf6:	f004 ff53 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0de2cfa:	1d30      	adds	r0, r6, #4
c0de2cfc:	ae1f      	add	r6, sp, #124	; 0x7c
c0de2cfe:	4621      	mov	r1, r4
c0de2d00:	4632      	mov	r2, r6
c0de2d02:	f005 fb29 	bl	c0de8358 <starkDerivePrivateKey>
c0de2d06:	2051      	movs	r0, #81	; 0x51
c0de2d08:	ab02      	add	r3, sp, #8
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de2d0a:	4631      	mov	r1, r6
c0de2d0c:	462a      	mov	r2, r5
c0de2d0e:	f000 f99d 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de2d12:	2800      	cmp	r0, #0
c0de2d14:	d133      	bne.n	c0de2d7e <handleStarkwareUnsafeSign+0x102>
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
    io_seproxyhal_io_heartbeat();
c0de2d16:	f004 ff43 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de2d1a:	2051      	movs	r0, #81	; 0x51
c0de2d1c:	a90c      	add	r1, sp, #48	; 0x30
c0de2d1e:	aa02      	add	r2, sp, #8
c0de2d20:	2301      	movs	r3, #1
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de2d22:	f000 f98d 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de2d26:	2800      	cmp	r0, #0
c0de2d28:	d129      	bne.n	c0de2d7e <handleStarkwareUnsafeSign+0x102>
c0de2d2a:	a802      	add	r0, sp, #8
c0de2d2c:	2128      	movs	r1, #40	; 0x28
    cx_ecfp_generate_pair(CX_CURVE_Stark256, &publicKey, &privateKey, 1);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de2d2e:	f00a fd87 	bl	c0ded840 <explicit_bzero>
c0de2d32:	a81f      	add	r0, sp, #124	; 0x7c
c0de2d34:	2420      	movs	r4, #32
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de2d36:	4621      	mov	r1, r4
c0de2d38:	f00a fd82 	bl	c0ded840 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0de2d3c:	f004 ff30 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    memmove(dataContext.starkContext.w1, publicKey.W + 1, 32);
c0de2d40:	4648      	mov	r0, r9
c0de2d42:	19c0      	adds	r0, r0, r7
c0de2d44:	a90c      	add	r1, sp, #48	; 0x30
c0de2d46:	3109      	adds	r1, #9
c0de2d48:	4622      	mov	r2, r4
c0de2d4a:	f00a fd69 	bl	c0ded820 <__aeabi_memcpy>
    ux_flow_init(0, ux_stark_unsafe_sign_flow, NULL);
c0de2d4e:	4910      	ldr	r1, [pc, #64]	; (c0de2d90 <handleStarkwareUnsafeSign+0x114>)
c0de2d50:	4479      	add	r1, pc
c0de2d52:	2000      	movs	r0, #0
c0de2d54:	4602      	mov	r2, r0
c0de2d56:	f009 fe15 	bl	c0dec984 <ux_flow_init>
c0de2d5a:	9a01      	ldr	r2, [sp, #4]

    *flags |= IO_ASYNCH_REPLY;
c0de2d5c:	6810      	ldr	r0, [r2, #0]
c0de2d5e:	2110      	movs	r1, #16
c0de2d60:	4301      	orrs	r1, r0
c0de2d62:	6011      	str	r1, [r2, #0]
}
c0de2d64:	b027      	add	sp, #156	; 0x9c
c0de2d66:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de2d68:	20d5      	movs	r0, #213	; 0xd5
c0de2d6a:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0de2d6c:	f004 fb5b 	bl	c0de7426 <os_longjmp>
c0de2d70:	20d5      	movs	r0, #213	; 0xd5
c0de2d72:	01c0      	lsls	r0, r0, #7
        THROW(0x6B00);
c0de2d74:	3080      	adds	r0, #128	; 0x80
c0de2d76:	f004 fb56 	bl	c0de7426 <os_longjmp>
c0de2d7a:	2067      	movs	r0, #103	; 0x67
c0de2d7c:	0200      	lsls	r0, r0, #8
c0de2d7e:	f004 fb52 	bl	c0de7426 <os_longjmp>
c0de2d82:	46c0      	nop			; (mov r8, r8)
c0de2d84:	0000011c 	.word	0x0000011c
c0de2d88:	00000124 	.word	0x00000124
c0de2d8c:	00000594 	.word	0x00000594
c0de2d90:	0000df80 	.word	0x0000df80

c0de2d94 <get_underlying_asset_decimals>:
    {"CBAT", 18},
    {"CREP", 18},
    {"cSAI", 18},
};

bool get_underlying_asset_decimals(char *compound_ticker, uint8_t *out_decimals) {
c0de2d94:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de2d96:	9101      	str	r1, [sp, #4]
c0de2d98:	4606      	mov	r6, r0
c0de2d9a:	2000      	movs	r0, #0
c0de2d9c:	4d0e      	ldr	r5, [pc, #56]	; (c0de2dd8 <get_underlying_asset_decimals+0x44>)
c0de2d9e:	447d      	add	r5, pc
c0de2da0:	9002      	str	r0, [sp, #8]
    for (size_t i = 0; i < NUM_COMPOUND_BINDINGS; i++) {
c0de2da2:	4604      	mov	r4, r0
c0de2da4:	340d      	adds	r4, #13
c0de2da6:	2c82      	cmp	r4, #130	; 0x82
c0de2da8:	d013      	beq.n	c0de2dd2 <get_underlying_asset_decimals+0x3e>
        underlying_asset_decimals_t *binding =
            (underlying_asset_decimals_t *) PIC(&UNDERLYING_ASSET_DECIMALS[i]);
c0de2daa:	1828      	adds	r0, r5, r0
c0de2dac:	f005 fa4a 	bl	c0de8244 <pic>
c0de2db0:	4607      	mov	r7, r0
c0de2db2:	210c      	movs	r1, #12
        if (strncmp(binding->c_ticker,
                    compound_ticker,
                    strnlen(binding->c_ticker, MAX_TICKER_LEN)) == 0) {
c0de2db4:	f00a ffb2 	bl	c0dedd1c <strnlen>
c0de2db8:	4602      	mov	r2, r0
        if (strncmp(binding->c_ticker,
c0de2dba:	4638      	mov	r0, r7
c0de2dbc:	4631      	mov	r1, r6
c0de2dbe:	f00a ff63 	bl	c0dedc88 <strncmp>
c0de2dc2:	2800      	cmp	r0, #0
c0de2dc4:	4620      	mov	r0, r4
c0de2dc6:	d1ed      	bne.n	c0de2da4 <get_underlying_asset_decimals+0x10>
            *out_decimals = binding->decimals;
c0de2dc8:	7b38      	ldrb	r0, [r7, #12]
c0de2dca:	9901      	ldr	r1, [sp, #4]
c0de2dcc:	7008      	strb	r0, [r1, #0]
c0de2dce:	2001      	movs	r0, #1
            return true;
        }
    }
    return false;
}
c0de2dd0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de2dd2:	9802      	ldr	r0, [sp, #8]
c0de2dd4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de2dd6:	46c0      	nop			; (mov r8, r8)
c0de2dd8:	0000c9b9 	.word	0x0000c9b9

c0de2ddc <compound_plugin_call>:

void compound_plugin_call(int message, void *parameters) {
c0de2ddc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de2dde:	460c      	mov	r4, r1
c0de2de0:	2183      	movs	r1, #131	; 0x83
c0de2de2:	0049      	lsls	r1, r1, #1
    switch (message) {
c0de2de4:	4288      	cmp	r0, r1
c0de2de6:	d038      	beq.n	c0de2e5a <compound_plugin_call+0x7e>
c0de2de8:	2181      	movs	r1, #129	; 0x81
c0de2dea:	0049      	lsls	r1, r1, #1
c0de2dec:	4288      	cmp	r0, r1
c0de2dee:	d051      	beq.n	c0de2e94 <compound_plugin_call+0xb8>
c0de2df0:	21ff      	movs	r1, #255	; 0xff
c0de2df2:	460a      	mov	r2, r1
c0de2df4:	3204      	adds	r2, #4
c0de2df6:	4290      	cmp	r0, r2
c0de2df8:	d05a      	beq.n	c0de2eb0 <compound_plugin_call+0xd4>
c0de2dfa:	2241      	movs	r2, #65	; 0x41
c0de2dfc:	0092      	lsls	r2, r2, #2
c0de2dfe:	4290      	cmp	r0, r2
c0de2e00:	d05f      	beq.n	c0de2ec2 <compound_plugin_call+0xe6>
c0de2e02:	460a      	mov	r2, r1
c0de2e04:	3206      	adds	r2, #6
c0de2e06:	4290      	cmp	r0, r2
c0de2e08:	d077      	beq.n	c0de2efa <compound_plugin_call+0x11e>
c0de2e0a:	3102      	adds	r1, #2
c0de2e0c:	4288      	cmp	r0, r1
c0de2e0e:	d000      	beq.n	c0de2e12 <compound_plugin_call+0x36>
c0de2e10:	e0b0      	b.n	c0de2f74 <compound_plugin_call+0x198>
        case ETH_PLUGIN_INIT_CONTRACT: {
            ethPluginInitContract_t *msg = (ethPluginInitContract_t *) parameters;
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0de2e12:	68e5      	ldr	r5, [r4, #12]
c0de2e14:	2600      	movs	r6, #0
c0de2e16:	4f72      	ldr	r7, [pc, #456]	; (c0de2fe0 <compound_plugin_call+0x204>)
c0de2e18:	447f      	add	r7, pc
            size_t i;
            for (i = 0; i < NUM_COMPOUND_SELECTORS; i++) {
c0de2e1a:	2e04      	cmp	r6, #4
c0de2e1c:	d100      	bne.n	c0de2e20 <compound_plugin_call+0x44>
c0de2e1e:	e080      	b.n	c0de2f22 <compound_plugin_call+0x146>
                if (memcmp((uint8_t *) PIC(COMPOUND_SELECTORS[i]), msg->selector, SELECTOR_SIZE) ==
c0de2e20:	6838      	ldr	r0, [r7, #0]
c0de2e22:	f005 fa0f 	bl	c0de8244 <pic>
c0de2e26:	7801      	ldrb	r1, [r0, #0]
c0de2e28:	7842      	ldrb	r2, [r0, #1]
c0de2e2a:	0212      	lsls	r2, r2, #8
c0de2e2c:	1851      	adds	r1, r2, r1
c0de2e2e:	7882      	ldrb	r2, [r0, #2]
c0de2e30:	78c0      	ldrb	r0, [r0, #3]
c0de2e32:	0200      	lsls	r0, r0, #8
c0de2e34:	1880      	adds	r0, r0, r2
c0de2e36:	0400      	lsls	r0, r0, #16
c0de2e38:	1840      	adds	r0, r0, r1
c0de2e3a:	6961      	ldr	r1, [r4, #20]
c0de2e3c:	780a      	ldrb	r2, [r1, #0]
c0de2e3e:	784b      	ldrb	r3, [r1, #1]
c0de2e40:	021b      	lsls	r3, r3, #8
c0de2e42:	189a      	adds	r2, r3, r2
c0de2e44:	788b      	ldrb	r3, [r1, #2]
c0de2e46:	78c9      	ldrb	r1, [r1, #3]
c0de2e48:	0209      	lsls	r1, r1, #8
c0de2e4a:	18c9      	adds	r1, r1, r3
c0de2e4c:	0409      	lsls	r1, r1, #16
c0de2e4e:	1889      	adds	r1, r1, r2
c0de2e50:	4288      	cmp	r0, r1
c0de2e52:	d065      	beq.n	c0de2f20 <compound_plugin_call+0x144>
            for (i = 0; i < NUM_COMPOUND_SELECTORS; i++) {
c0de2e54:	1d3f      	adds	r7, r7, #4
c0de2e56:	1c76      	adds	r6, r6, #1
c0de2e58:	e7df      	b.n	c0de2e1a <compound_plugin_call+0x3e>
c0de2e5a:	4626      	mov	r6, r4
c0de2e5c:	3620      	adds	r6, #32
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0de2e5e:	7830      	ldrb	r0, [r6, #0]
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0de2e60:	69e5      	ldr	r5, [r4, #28]
            switch (msg->screenIndex) {
c0de2e62:	2801      	cmp	r0, #1
c0de2e64:	d100      	bne.n	c0de2e68 <compound_plugin_call+0x8c>
c0de2e66:	e095      	b.n	c0de2f94 <compound_plugin_call+0x1b8>
c0de2e68:	2800      	cmp	r0, #0
c0de2e6a:	d000      	beq.n	c0de2e6e <compound_plugin_call+0x92>
c0de2e6c:	e082      	b.n	c0de2f74 <compound_plugin_call+0x198>
                case 0: {
                    strlcpy(msg->title, "Amount", msg->titleLength);
c0de2e6e:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de2e70:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de2e72:	4961      	ldr	r1, [pc, #388]	; (c0de2ff8 <compound_plugin_call+0x21c>)
c0de2e74:	4479      	add	r1, pc
c0de2e76:	f00a fead 	bl	c0dedbd4 <strlcpy>
c0de2e7a:	202d      	movs	r0, #45	; 0x2d
                    if (context->selectorIndex != COMPOUND_REDEEM) {
                        ticker_ptr++;
                    }
                    amountToString(context->amount,
                                   sizeof(context->amount),
                                   context->decimals,
c0de2e7c:	5c2a      	ldrb	r2, [r5, r0]
                    if (context->selectorIndex != COMPOUND_REDEEM) {
c0de2e7e:	7828      	ldrb	r0, [r5, #0]
                                   ticker_ptr,
                                   msg->msg,
c0de2e80:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de2e82:	2364      	movs	r3, #100	; 0x64
                    amountToString(context->amount,
c0de2e84:	9100      	str	r1, [sp, #0]
c0de2e86:	9301      	str	r3, [sp, #4]
c0de2e88:	462b      	mov	r3, r5
                    if (context->selectorIndex != COMPOUND_REDEEM) {
c0de2e8a:	2801      	cmp	r0, #1
c0de2e8c:	d100      	bne.n	c0de2e90 <compound_plugin_call+0xb4>
c0de2e8e:	e094      	b.n	c0de2fba <compound_plugin_call+0x1de>
c0de2e90:	3322      	adds	r3, #34	; 0x22
c0de2e92:	e093      	b.n	c0de2fbc <compound_plugin_call+0x1e0>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0de2e94:	68a0      	ldr	r0, [r4, #8]
            if (context->selectorIndex != CETH_MINT) {
c0de2e96:	7801      	ldrb	r1, [r0, #0]
c0de2e98:	2903      	cmp	r1, #3
c0de2e9a:	d03e      	beq.n	c0de2f1a <compound_plugin_call+0x13e>
                switch (msg->parameterOffset) {
c0de2e9c:	6921      	ldr	r1, [r4, #16]
c0de2e9e:	2904      	cmp	r1, #4
c0de2ea0:	d13b      	bne.n	c0de2f1a <compound_plugin_call+0x13e>
                        memmove(context->amount, msg->parameter, 32);
c0de2ea2:	68e1      	ldr	r1, [r4, #12]
c0de2ea4:	1c40      	adds	r0, r0, #1
c0de2ea6:	2220      	movs	r2, #32
c0de2ea8:	f00a fcbe 	bl	c0ded828 <__aeabi_memmove>
c0de2eac:	2004      	movs	r0, #4
c0de2eae:	e035      	b.n	c0de2f1c <compound_plugin_call+0x140>
c0de2eb0:	2004      	movs	r0, #4
            msg->result = ETH_PLUGIN_RESULT_OK;
c0de2eb2:	77a0      	strb	r0, [r4, #30]
c0de2eb4:	4849      	ldr	r0, [pc, #292]	; (c0de2fdc <compound_plugin_call+0x200>)
            msg->uiType = ETH_UI_TYPE_GENERIC;
c0de2eb6:	83a0      	strh	r0, [r4, #28]
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0de2eb8:	6860      	ldr	r0, [r4, #4]
c0de2eba:	6800      	ldr	r0, [r0, #0]
c0de2ebc:	30a5      	adds	r0, #165	; 0xa5
c0de2ebe:	60e0      	str	r0, [r4, #12]
c0de2ec0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            if (msg->item1 != NULL) {
c0de2ec2:	68e1      	ldr	r1, [r4, #12]
c0de2ec4:	2900      	cmp	r1, #0
c0de2ec6:	d016      	beq.n	c0de2ef6 <compound_plugin_call+0x11a>
c0de2ec8:	68a5      	ldr	r5, [r4, #8]
                strlcpy(context->ticker_1, msg->item1->token.ticker, MAX_TICKER_LEN);
c0de2eca:	462e      	mov	r6, r5
c0de2ecc:	3621      	adds	r6, #33	; 0x21
c0de2ece:	3114      	adds	r1, #20
c0de2ed0:	220c      	movs	r2, #12
c0de2ed2:	4630      	mov	r0, r6
c0de2ed4:	f00a fe7e 	bl	c0dedbd4 <strlcpy>
                switch (context->selectorIndex) {
c0de2ed8:	7828      	ldrb	r0, [r5, #0]
c0de2eda:	1e81      	subs	r1, r0, #2
c0de2edc:	2902      	cmp	r1, #2
c0de2ede:	d303      	bcc.n	c0de2ee8 <compound_plugin_call+0x10c>
c0de2ee0:	2801      	cmp	r0, #1
c0de2ee2:	d072      	beq.n	c0de2fca <compound_plugin_call+0x1ee>
c0de2ee4:	2800      	cmp	r0, #0
c0de2ee6:	d106      	bne.n	c0de2ef6 <compound_plugin_call+0x11a>
                            get_underlying_asset_decimals(context->ticker_1, &context->decimals)
c0de2ee8:	352d      	adds	r5, #45	; 0x2d
c0de2eea:	4630      	mov	r0, r6
c0de2eec:	4629      	mov	r1, r5
c0de2eee:	f7ff ff51 	bl	c0de2d94 <get_underlying_asset_decimals>
c0de2ef2:	2800      	cmp	r0, #0
c0de2ef4:	d16e      	bne.n	c0de2fd4 <compound_plugin_call+0x1f8>
c0de2ef6:	2006      	movs	r0, #6
c0de2ef8:	e06d      	b.n	c0de2fd6 <compound_plugin_call+0x1fa>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0de2efa:	68a5      	ldr	r5, [r4, #8]
            strlcpy(msg->name, "Type", msg->nameLength);
c0de2efc:	68e0      	ldr	r0, [r4, #12]
c0de2efe:	6922      	ldr	r2, [r4, #16]
c0de2f00:	4939      	ldr	r1, [pc, #228]	; (c0de2fe8 <compound_plugin_call+0x20c>)
c0de2f02:	4479      	add	r1, pc
c0de2f04:	f00a fe66 	bl	c0dedbd4 <strlcpy>
            switch (context->selectorIndex) {
c0de2f08:	7828      	ldrb	r0, [r5, #0]
c0de2f0a:	2802      	cmp	r0, #2
c0de2f0c:	d333      	bcc.n	c0de2f76 <compound_plugin_call+0x19a>
c0de2f0e:	1e80      	subs	r0, r0, #2
c0de2f10:	2801      	cmp	r0, #1
c0de2f12:	d836      	bhi.n	c0de2f82 <compound_plugin_call+0x1a6>
c0de2f14:	4936      	ldr	r1, [pc, #216]	; (c0de2ff0 <compound_plugin_call+0x214>)
c0de2f16:	4479      	add	r1, pc
c0de2f18:	e02f      	b.n	c0de2f7a <compound_plugin_call+0x19e>
c0de2f1a:	2000      	movs	r0, #0
c0de2f1c:	7520      	strb	r0, [r4, #20]
c0de2f1e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                    context->selectorIndex = i;
c0de2f20:	702e      	strb	r6, [r5, #0]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0de2f22:	68a0      	ldr	r0, [r4, #8]
c0de2f24:	6800      	ldr	r0, [r0, #0]
c0de2f26:	2142      	movs	r1, #66	; 0x42
    for (size_t i = 0; i < n; ++i) {
c0de2f28:	2962      	cmp	r1, #98	; 0x62
c0de2f2a:	d006      	beq.n	c0de2f3a <compound_plugin_call+0x15e>
        if (p[i]) {
c0de2f2c:	5c42      	ldrb	r2, [r0, r1]
c0de2f2e:	1c49      	adds	r1, r1, #1
c0de2f30:	2a00      	cmp	r2, #0
c0de2f32:	d0f9      	beq.n	c0de2f28 <compound_plugin_call+0x14c>
                if (context->selectorIndex != CETH_MINT) {
c0de2f34:	7828      	ldrb	r0, [r5, #0]
c0de2f36:	2803      	cmp	r0, #3
c0de2f38:	d11a      	bne.n	c0de2f70 <compound_plugin_call+0x194>
            if (i == NUM_COMPOUND_SELECTORS) {
c0de2f3a:	2e04      	cmp	r6, #4
c0de2f3c:	d018      	beq.n	c0de2f70 <compound_plugin_call+0x194>
            if (msg->dataSize != COMPOUND_EXPECTED_DATA_SIZE[context->selectorIndex]) {
c0de2f3e:	7828      	ldrb	r0, [r5, #0]
c0de2f40:	4928      	ldr	r1, [pc, #160]	; (c0de2fe4 <compound_plugin_call+0x208>)
c0de2f42:	4479      	add	r1, pc
c0de2f44:	5c09      	ldrb	r1, [r1, r0]
c0de2f46:	69a2      	ldr	r2, [r4, #24]
c0de2f48:	428a      	cmp	r2, r1
c0de2f4a:	d111      	bne.n	c0de2f70 <compound_plugin_call+0x194>
            if (context->selectorIndex == CETH_MINT) {
c0de2f4c:	2803      	cmp	r0, #3
c0de2f4e:	d10d      	bne.n	c0de2f6c <compound_plugin_call+0x190>
                memset(context->amount, 0, sizeof(context->amount));
c0de2f50:	1c6d      	adds	r5, r5, #1
c0de2f52:	2120      	movs	r1, #32
c0de2f54:	4628      	mov	r0, r5
c0de2f56:	f00a fc5d 	bl	c0ded814 <__aeabi_memclr>
                            msg->pluginSharedRO->txContent->value.length,
c0de2f5a:	68a0      	ldr	r0, [r4, #8]
c0de2f5c:	6801      	ldr	r1, [r0, #0]
c0de2f5e:	2062      	movs	r0, #98	; 0x62
c0de2f60:	5c0a      	ldrb	r2, [r1, r0]
                memmove(context->amount + sizeof(context->amount) -
c0de2f62:	1aa8      	subs	r0, r5, r2
c0de2f64:	3020      	adds	r0, #32
                            msg->pluginSharedRO->txContent->value.length,
c0de2f66:	3142      	adds	r1, #66	; 0x42
                memmove(context->amount + sizeof(context->amount) -
c0de2f68:	f00a fc5e 	bl	c0ded828 <__aeabi_memmove>
c0de2f6c:	2004      	movs	r0, #4
c0de2f6e:	e000      	b.n	c0de2f72 <compound_plugin_call+0x196>
c0de2f70:	2000      	movs	r0, #0
c0de2f72:	7060      	strb	r0, [r4, #1]
c0de2f74:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de2f76:	491d      	ldr	r1, [pc, #116]	; (c0de2fec <compound_plugin_call+0x210>)
c0de2f78:	4479      	add	r1, pc
c0de2f7a:	6960      	ldr	r0, [r4, #20]
c0de2f7c:	69a2      	ldr	r2, [r4, #24]
c0de2f7e:	f00a fe29 	bl	c0dedbd4 <strlcpy>
            strlcat(msg->version, " Assets", msg->versionLength);
c0de2f82:	6960      	ldr	r0, [r4, #20]
c0de2f84:	69a2      	ldr	r2, [r4, #24]
c0de2f86:	491b      	ldr	r1, [pc, #108]	; (c0de2ff4 <compound_plugin_call+0x218>)
c0de2f88:	4479      	add	r1, pc
c0de2f8a:	f00a fdef 	bl	c0dedb6c <strlcat>
c0de2f8e:	2004      	movs	r0, #4
            msg->result = ETH_PLUGIN_RESULT_OK;
c0de2f90:	7720      	strb	r0, [r4, #28]
c0de2f92:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                                   100);
                    msg->result = ETH_PLUGIN_RESULT_OK;
                } break;

                case 1:
                    strlcpy(msg->title, "Contract", msg->titleLength);
c0de2f94:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de2f96:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de2f98:	4918      	ldr	r1, [pc, #96]	; (c0de2ffc <compound_plugin_call+0x220>)
c0de2f9a:	4479      	add	r1, pc
c0de2f9c:	f00a fe1a 	bl	c0dedbd4 <strlcpy>
                    strlcpy(msg->msg, "Compound ", msg->msgLength);
c0de2fa0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de2fa2:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de2fa4:	4916      	ldr	r1, [pc, #88]	; (c0de3000 <compound_plugin_call+0x224>)
c0de2fa6:	4479      	add	r1, pc
c0de2fa8:	f00a fe14 	bl	c0dedbd4 <strlcpy>
                    strlcat(msg->msg,
c0de2fac:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
                            context->ticker_1 + 1,
                            msg->msgLength);  // remove the 'c' char at beginning of compound ticker
c0de2fae:	6b22      	ldr	r2, [r4, #48]	; 0x30
                            context->ticker_1 + 1,
c0de2fb0:	3522      	adds	r5, #34	; 0x22
                    strlcat(msg->msg,
c0de2fb2:	4629      	mov	r1, r5
c0de2fb4:	f00a fdda 	bl	c0dedb6c <strlcat>
c0de2fb8:	e004      	b.n	c0de2fc4 <compound_plugin_call+0x1e8>
c0de2fba:	3321      	adds	r3, #33	; 0x21
                    amountToString(context->amount,
c0de2fbc:	1c68      	adds	r0, r5, #1
c0de2fbe:	2120      	movs	r1, #32
c0de2fc0:	f009 fad7 	bl	c0dec572 <amountToString>
c0de2fc4:	2004      	movs	r0, #4
c0de2fc6:	7530      	strb	r0, [r6, #20]
c0de2fc8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                        context->decimals = msg->item1->token.decimals;
c0de2fca:	68e0      	ldr	r0, [r4, #12]
c0de2fcc:	2120      	movs	r1, #32
c0de2fce:	5c40      	ldrb	r0, [r0, r1]
c0de2fd0:	212d      	movs	r1, #45	; 0x2d
c0de2fd2:	5468      	strb	r0, [r5, r1]
c0de2fd4:	2004      	movs	r0, #4
c0de2fd6:	7560      	strb	r0, [r4, #21]
c0de2fd8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de2fda:	46c0      	nop			; (mov r8, r8)
c0de2fdc:	00000202 	.word	0x00000202
c0de2fe0:	0000cc04 	.word	0x0000cc04
c0de2fe4:	0000c892 	.word	0x0000c892
c0de2fe8:	0000b0ea 	.word	0x0000b0ea
c0de2fec:	0000aff3 	.word	0x0000aff3
c0de2ff0:	0000b325 	.word	0x0000b325
c0de2ff4:	0000b134 	.word	0x0000b134
c0de2ff8:	0000b005 	.word	0x0000b005
c0de2ffc:	0000b057 	.word	0x0000b057
c0de3000:	0000b0cf 	.word	0x0000b0cf

c0de3004 <cx_crc16>:
CX_TRAMPOLINE _NR_cx_blake2b_final                         cx_blake2b_final
CX_TRAMPOLINE _NR_cx_blake2b_get_output_size               cx_blake2b_get_output_size
CX_TRAMPOLINE _NR_cx_blake2b_init2_no_throw                cx_blake2b_init2_no_throw
CX_TRAMPOLINE _NR_cx_blake2b_init_no_throw                 cx_blake2b_init_no_throw
CX_TRAMPOLINE _NR_cx_blake2b_update                        cx_blake2b_update
CX_TRAMPOLINE _NR_cx_crc16                                 cx_crc16
c0de3004:	b403      	push	{r0, r1}
c0de3006:	4801      	ldr	r0, [pc, #4]	; (c0de300c <cx_crc16+0x8>)
c0de3008:	e07d      	b.n	c0de3106 <cx_trampoline_helper>
c0de300a:	0000      	.short	0x0000
c0de300c:	0000000b 	.word	0x0000000b

c0de3010 <cx_crc16_update>:
CX_TRAMPOLINE _NR_cx_crc16_update                          cx_crc16_update
c0de3010:	b403      	push	{r0, r1}
c0de3012:	4801      	ldr	r0, [pc, #4]	; (c0de3018 <cx_crc16_update+0x8>)
c0de3014:	e077      	b.n	c0de3106 <cx_trampoline_helper>
c0de3016:	0000      	.short	0x0000
c0de3018:	0000000c 	.word	0x0000000c

c0de301c <cx_ecdsa_sign_no_throw>:
CX_TRAMPOLINE _NR_cx_des_enc_block                         cx_des_enc_block
CX_TRAMPOLINE _NR_cx_des_init_key_no_throw                 cx_des_init_key_no_throw
CX_TRAMPOLINE _NR_cx_des_iv_no_throw                       cx_des_iv_no_throw
CX_TRAMPOLINE _NR_cx_des_no_throw                          cx_des_no_throw
CX_TRAMPOLINE _NR_cx_ecdh_no_throw                         cx_ecdh_no_throw
CX_TRAMPOLINE _NR_cx_ecdsa_sign_no_throw                   cx_ecdsa_sign_no_throw
c0de301c:	b403      	push	{r0, r1}
c0de301e:	4801      	ldr	r0, [pc, #4]	; (c0de3024 <cx_ecdsa_sign_no_throw+0x8>)
c0de3020:	e071      	b.n	c0de3106 <cx_trampoline_helper>
c0de3022:	0000      	.short	0x0000
c0de3024:	00000015 	.word	0x00000015

c0de3028 <cx_ecdsa_verify_no_throw>:
CX_TRAMPOLINE _NR_cx_ecdsa_verify_no_throw                 cx_ecdsa_verify_no_throw
c0de3028:	b403      	push	{r0, r1}
c0de302a:	4801      	ldr	r0, [pc, #4]	; (c0de3030 <cx_ecdsa_verify_no_throw+0x8>)
c0de302c:	e06b      	b.n	c0de3106 <cx_trampoline_helper>
c0de302e:	0000      	.short	0x0000
c0de3030:	00000016 	.word	0x00000016

c0de3034 <cx_ecfp_add_point_no_throw>:
CX_TRAMPOLINE _NR_cx_ecfp_add_point_no_throw               cx_ecfp_add_point_no_throw
c0de3034:	b403      	push	{r0, r1}
c0de3036:	4801      	ldr	r0, [pc, #4]	; (c0de303c <cx_ecfp_add_point_no_throw+0x8>)
c0de3038:	e065      	b.n	c0de3106 <cx_trampoline_helper>
c0de303a:	0000      	.short	0x0000
c0de303c:	00000017 	.word	0x00000017

c0de3040 <cx_ecfp_generate_pair_no_throw>:
CX_TRAMPOLINE _NR_cx_ecfp_decode_sig_der                   cx_ecfp_decode_sig_der
CX_TRAMPOLINE _NR_cx_ecfp_encode_sig_der                   cx_ecfp_encode_sig_der
CX_TRAMPOLINE _NR_cx_ecfp_generate_pair2_no_throw          cx_ecfp_generate_pair2_no_throw
CX_TRAMPOLINE _NR_cx_ecfp_generate_pair_no_throw           cx_ecfp_generate_pair_no_throw
c0de3040:	b403      	push	{r0, r1}
c0de3042:	4801      	ldr	r0, [pc, #4]	; (c0de3048 <cx_ecfp_generate_pair_no_throw+0x8>)
c0de3044:	e05f      	b.n	c0de3106 <cx_trampoline_helper>
c0de3046:	0000      	.short	0x0000
c0de3048:	0000001b 	.word	0x0000001b

c0de304c <cx_ecfp_init_private_key_no_throw>:
CX_TRAMPOLINE _NR_cx_ecfp_init_private_key_no_throw        cx_ecfp_init_private_key_no_throw
c0de304c:	b403      	push	{r0, r1}
c0de304e:	4801      	ldr	r0, [pc, #4]	; (c0de3054 <cx_ecfp_init_private_key_no_throw+0x8>)
c0de3050:	e059      	b.n	c0de3106 <cx_trampoline_helper>
c0de3052:	0000      	.short	0x0000
c0de3054:	0000001c 	.word	0x0000001c

c0de3058 <cx_ecfp_init_public_key_no_throw>:
CX_TRAMPOLINE _NR_cx_ecfp_init_public_key_no_throw         cx_ecfp_init_public_key_no_throw
c0de3058:	b403      	push	{r0, r1}
c0de305a:	4801      	ldr	r0, [pc, #4]	; (c0de3060 <cx_ecfp_init_public_key_no_throw+0x8>)
c0de305c:	e053      	b.n	c0de3106 <cx_trampoline_helper>
c0de305e:	0000      	.short	0x0000
c0de3060:	0000001d 	.word	0x0000001d

c0de3064 <cx_ecfp_scalar_mult_no_throw>:
CX_TRAMPOLINE _NR_cx_ecfp_scalar_mult_no_throw             cx_ecfp_scalar_mult_no_throw
c0de3064:	b403      	push	{r0, r1}
c0de3066:	4801      	ldr	r0, [pc, #4]	; (c0de306c <cx_ecfp_scalar_mult_no_throw+0x8>)
c0de3068:	e04d      	b.n	c0de3106 <cx_trampoline_helper>
c0de306a:	0000      	.short	0x0000
c0de306c:	0000001e 	.word	0x0000001e

c0de3070 <cx_hash_get_size>:
CX_TRAMPOLINE _NR_cx_groestl_get_output_size               cx_groestl_get_output_size
CX_TRAMPOLINE _NR_cx_groestl_init_no_throw                 cx_groestl_init_no_throw
CX_TRAMPOLINE _NR_cx_groestl_update                        cx_groestl_update
CX_TRAMPOLINE _NR_cx_hash_final                            cx_hash_final
CX_TRAMPOLINE _NR_cx_hash_get_info                         cx_hash_get_info
CX_TRAMPOLINE _NR_cx_hash_get_size                         cx_hash_get_size
c0de3070:	b403      	push	{r0, r1}
c0de3072:	4801      	ldr	r0, [pc, #4]	; (c0de3078 <cx_hash_get_size+0x8>)
c0de3074:	e047      	b.n	c0de3106 <cx_trampoline_helper>
c0de3076:	0000      	.short	0x0000
c0de3078:	0000002f 	.word	0x0000002f

c0de307c <cx_hash_no_throw>:
CX_TRAMPOLINE _NR_cx_hash_init                             cx_hash_init
CX_TRAMPOLINE _NR_cx_hash_init_ex                          cx_hash_init_ex
CX_TRAMPOLINE _NR_cx_hash_no_throw                         cx_hash_no_throw
c0de307c:	b403      	push	{r0, r1}
c0de307e:	4801      	ldr	r0, [pc, #4]	; (c0de3084 <cx_hash_no_throw+0x8>)
c0de3080:	e041      	b.n	c0de3106 <cx_trampoline_helper>
c0de3082:	0000      	.short	0x0000
c0de3084:	00000032 	.word	0x00000032

c0de3088 <cx_hash_sha256>:
CX_TRAMPOLINE _NR_cx_hash_sha256                           cx_hash_sha256
c0de3088:	b403      	push	{r0, r1}
c0de308a:	4801      	ldr	r0, [pc, #4]	; (c0de3090 <cx_hash_sha256+0x8>)
c0de308c:	e03b      	b.n	c0de3106 <cx_trampoline_helper>
c0de308e:	0000      	.short	0x0000
c0de3090:	00000033 	.word	0x00000033

c0de3094 <cx_hash_sha512>:
CX_TRAMPOLINE _NR_cx_hash_sha512                           cx_hash_sha512
c0de3094:	b403      	push	{r0, r1}
c0de3096:	4801      	ldr	r0, [pc, #4]	; (c0de309c <cx_hash_sha512+0x8>)
c0de3098:	e035      	b.n	c0de3106 <cx_trampoline_helper>
c0de309a:	0000      	.short	0x0000
c0de309c:	00000034 	.word	0x00000034

c0de30a0 <cx_keccak_init_no_throw>:
CX_TRAMPOLINE _NR_cx_hmac_sha384_init                      cx_hmac_sha384_init
CX_TRAMPOLINE _NR_cx_hmac_sha512                           cx_hmac_sha512
CX_TRAMPOLINE _NR_cx_hmac_sha512_init_no_throw             cx_hmac_sha512_init_no_throw
CX_TRAMPOLINE _NR_cx_hmac_update                           cx_hmac_update
CX_TRAMPOLINE _NR_cx_init                                  cx_init
CX_TRAMPOLINE _NR_cx_keccak_init_no_throw                  cx_keccak_init_no_throw
c0de30a0:	b403      	push	{r0, r1}
c0de30a2:	4801      	ldr	r0, [pc, #4]	; (c0de30a8 <cx_keccak_init_no_throw+0x8>)
c0de30a4:	e02f      	b.n	c0de3106 <cx_trampoline_helper>
c0de30a6:	0000      	.short	0x0000
c0de30a8:	00000044 	.word	0x00000044

c0de30ac <cx_math_cmp_no_throw>:
CX_TRAMPOLINE _NR_cx_math_addm_no_throw                    cx_math_addm_no_throw
CX_TRAMPOLINE _NR_cx_math_add_no_throw                     cx_math_add_no_throw
CX_TRAMPOLINE _NR_cx_math_cmp_no_throw                     cx_math_cmp_no_throw
c0de30ac:	b403      	push	{r0, r1}
c0de30ae:	4801      	ldr	r0, [pc, #4]	; (c0de30b4 <cx_math_cmp_no_throw+0x8>)
c0de30b0:	e029      	b.n	c0de3106 <cx_trampoline_helper>
c0de30b2:	0000      	.short	0x0000
c0de30b4:	00000047 	.word	0x00000047

c0de30b8 <cx_math_modm_no_throw>:
CX_TRAMPOLINE _NR_cx_math_invintm_no_throw                 cx_math_invintm_no_throw
CX_TRAMPOLINE _NR_cx_math_invprimem_no_throw               cx_math_invprimem_no_throw
CX_TRAMPOLINE _NR_cx_math_is_prime_no_throw                cx_math_is_prime_no_throw
CX_TRAMPOLINE _NR_cx_math_modm_no_throw                    cx_math_modm_no_throw
c0de30b8:	b403      	push	{r0, r1}
c0de30ba:	4801      	ldr	r0, [pc, #4]	; (c0de30c0 <cx_math_modm_no_throw+0x8>)
c0de30bc:	e023      	b.n	c0de3106 <cx_trampoline_helper>
c0de30be:	0000      	.short	0x0000
c0de30c0:	0000004b 	.word	0x0000004b

c0de30c4 <cx_math_mult_no_throw>:
CX_TRAMPOLINE _NR_cx_math_multm_no_throw                   cx_math_multm_no_throw
CX_TRAMPOLINE _NR_cx_math_mult_no_throw                    cx_math_mult_no_throw
c0de30c4:	b403      	push	{r0, r1}
c0de30c6:	4801      	ldr	r0, [pc, #4]	; (c0de30cc <cx_math_mult_no_throw+0x8>)
c0de30c8:	e01d      	b.n	c0de3106 <cx_trampoline_helper>
c0de30ca:	0000      	.short	0x0000
c0de30cc:	0000004d 	.word	0x0000004d

c0de30d0 <cx_rng_no_throw>:
CX_TRAMPOLINE _NR_cx_pbkdf2_hmac                           cx_pbkdf2_hmac
CX_TRAMPOLINE _NR_cx_pbkdf2_no_throw                       cx_pbkdf2_no_throw
CX_TRAMPOLINE _NR_cx_ripemd160_final                       cx_ripemd160_final
CX_TRAMPOLINE _NR_cx_ripemd160_init_no_throw               cx_ripemd160_init_no_throw
CX_TRAMPOLINE _NR_cx_ripemd160_update                      cx_ripemd160_update
CX_TRAMPOLINE _NR_cx_rng_no_throw                          cx_rng_no_throw
c0de30d0:	b403      	push	{r0, r1}
c0de30d2:	4801      	ldr	r0, [pc, #4]	; (c0de30d8 <cx_rng_no_throw+0x8>)
c0de30d4:	e017      	b.n	c0de3106 <cx_trampoline_helper>
c0de30d6:	0000      	.short	0x0000
c0de30d8:	00000058 	.word	0x00000058

c0de30dc <cx_rng_u32_range_func>:
CX_TRAMPOLINE _NR_cx_rng_rfc6979                           cx_rng_rfc6979
CX_TRAMPOLINE _NR_cx_rng_rfc6979_init                      cx_rng_rfc6979_init
CX_TRAMPOLINE _NR_cx_rng_rfc6979_next                      cx_rng_rfc6979_next
CX_TRAMPOLINE _NR_cx_rng_u32_range_func                    cx_rng_u32_range_func
c0de30dc:	b403      	push	{r0, r1}
c0de30de:	4801      	ldr	r0, [pc, #4]	; (c0de30e4 <cx_rng_u32_range_func+0x8>)
c0de30e0:	e011      	b.n	c0de3106 <cx_trampoline_helper>
c0de30e2:	0000      	.short	0x0000
c0de30e4:	0000005c 	.word	0x0000005c

c0de30e8 <cx_sha256_init_no_throw>:
CX_TRAMPOLINE _NR_cx_sha224_init_no_throw                  cx_sha224_init_no_throw
CX_TRAMPOLINE _NR_cx_sha256_final                          cx_sha256_final
CX_TRAMPOLINE _NR_cx_sha256_init_no_throw                  cx_sha256_init_no_throw
c0de30e8:	b403      	push	{r0, r1}
c0de30ea:	4801      	ldr	r0, [pc, #4]	; (c0de30f0 <cx_sha256_init_no_throw+0x8>)
c0de30ec:	e00b      	b.n	c0de3106 <cx_trampoline_helper>
c0de30ee:	0000      	.short	0x0000
c0de30f0:	0000005f 	.word	0x0000005f

c0de30f4 <cx_x25519>:
CX_TRAMPOLINE _NR_cx_shake256_init_no_throw                cx_shake256_init_no_throw
CX_TRAMPOLINE _NR_cx_swap_buffer32                         cx_swap_buffer32
CX_TRAMPOLINE _NR_cx_swap_buffer64                         cx_swap_buffer64
CX_TRAMPOLINE _NR_cx_swap_uint32                           cx_swap_uint32
CX_TRAMPOLINE _NR_cx_swap_uint64                           cx_swap_uint64
CX_TRAMPOLINE _NR_cx_x25519                                cx_x25519
c0de30f4:	b403      	push	{r0, r1}
c0de30f6:	4801      	ldr	r0, [pc, #4]	; (c0de30fc <cx_x25519+0x8>)
c0de30f8:	e005      	b.n	c0de3106 <cx_trampoline_helper>
c0de30fa:	0000      	.short	0x0000
c0de30fc:	00000070 	.word	0x00000070

c0de3100 <cx_x448>:
CX_TRAMPOLINE _NR_cx_x448                                  cx_x448
c0de3100:	b403      	push	{r0, r1}
c0de3102:	4802      	ldr	r0, [pc, #8]	; (c0de310c <cx_trampoline_helper+0x6>)
c0de3104:	e7ff      	b.n	c0de3106 <cx_trampoline_helper>

c0de3106 <cx_trampoline_helper>:

.thumb_func
cx_trampoline_helper:
  ldr  r1, =CX_TRAMPOLINE_ADDR // _cx_trampoline address
c0de3106:	4902      	ldr	r1, [pc, #8]	; (c0de3110 <cx_trampoline_helper+0xa>)
  bx   r1
c0de3108:	4708      	bx	r1
c0de310a:	0000      	.short	0x0000
CX_TRAMPOLINE _NR_cx_x448                                  cx_x448
c0de310c:	00000071 	.word	0x00000071
  ldr  r1, =CX_TRAMPOLINE_ADDR // _cx_trampoline address
c0de3110:	00210001 	.word	0x00210001

c0de3114 <erc1155_plugin_call>:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}

void erc1155_plugin_call(int message, void *parameters) {
c0de3114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de3116:	460c      	mov	r4, r1
c0de3118:	2183      	movs	r1, #131	; 0x83
c0de311a:	0049      	lsls	r1, r1, #1
    switch (message) {
c0de311c:	4288      	cmp	r0, r1
c0de311e:	d01f      	beq.n	c0de3160 <erc1155_plugin_call+0x4c>
c0de3120:	2181      	movs	r1, #129	; 0x81
c0de3122:	0049      	lsls	r1, r1, #1
c0de3124:	4288      	cmp	r0, r1
c0de3126:	d01f      	beq.n	c0de3168 <erc1155_plugin_call+0x54>
c0de3128:	21ff      	movs	r1, #255	; 0xff
c0de312a:	460a      	mov	r2, r1
c0de312c:	3204      	adds	r2, #4
c0de312e:	4290      	cmp	r0, r2
c0de3130:	d01e      	beq.n	c0de3170 <erc1155_plugin_call+0x5c>
c0de3132:	2241      	movs	r2, #65	; 0x41
c0de3134:	0092      	lsls	r2, r2, #2
c0de3136:	4290      	cmp	r0, r2
c0de3138:	d027      	beq.n	c0de318a <erc1155_plugin_call+0x76>
c0de313a:	460a      	mov	r2, r1
c0de313c:	3206      	adds	r2, #6
c0de313e:	4290      	cmp	r0, r2
c0de3140:	d026      	beq.n	c0de3190 <erc1155_plugin_call+0x7c>
c0de3142:	3102      	adds	r1, #2
c0de3144:	4288      	cmp	r0, r1
c0de3146:	d10e      	bne.n	c0de3166 <erc1155_plugin_call+0x52>
    if (NO_NFT_METADATA) {
c0de3148:	484d      	ldr	r0, [pc, #308]	; (c0de3280 <erc1155_plugin_call+0x16c>)
c0de314a:	4649      	mov	r1, r9
c0de314c:	1808      	adds	r0, r1, r0
c0de314e:	30a7      	adds	r0, #167	; 0xa7
    erc1155_context_t *context = (erc1155_context_t *) msg->pluginContext;
c0de3150:	68e5      	ldr	r5, [r4, #12]
c0de3152:	215b      	movs	r1, #91	; 0x5b
    if (NO_NFT_METADATA) {
c0de3154:	f000 f8a0 	bl	c0de3298 <allzeroes>
c0de3158:	2800      	cmp	r0, #0
c0de315a:	d03c      	beq.n	c0de31d6 <erc1155_plugin_call+0xc2>
c0de315c:	2000      	movs	r0, #0
c0de315e:	e06c      	b.n	c0de323a <erc1155_plugin_call+0x126>
        } break;
        case ETH_PLUGIN_QUERY_CONTRACT_ID: {
            handle_query_contract_id(parameters);
        } break;
        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            handle_query_contract_ui_1155(parameters);
c0de3160:	4620      	mov	r0, r4
c0de3162:	f000 f975 	bl	c0de3450 <handle_query_contract_ui_1155>
        } break;
        default:
            PRINTF("Unhandled message %d\n", message);
            break;
    }
}
c0de3166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            handle_provide_parameter_1155(parameters);
c0de3168:	4620      	mov	r0, r4
c0de316a:	f000 f8a1 	bl	c0de32b0 <handle_provide_parameter_1155>
}
c0de316e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    erc1155_context_t *context = (erc1155_context_t *) msg->pluginContext;
c0de3170:	68a0      	ldr	r0, [r4, #8]
c0de3172:	216c      	movs	r1, #108	; 0x6c
    if (context->selectorIndex != SAFE_BATCH_TRANSFER) {
c0de3174:	5c41      	ldrb	r1, [r0, r1]
c0de3176:	2902      	cmp	r1, #2
c0de3178:	d120      	bne.n	c0de31bc <erc1155_plugin_call+0xa8>
c0de317a:	2004      	movs	r0, #4
            msg->numScreens = 4;
c0de317c:	7760      	strb	r0, [r4, #29]
c0de317e:	2000      	movs	r0, #0
        msg->tokenLookup1 = NULL;
c0de3180:	60e0      	str	r0, [r4, #12]
    msg->tokenLookup2 = NULL;
c0de3182:	6120      	str	r0, [r4, #16]
    if (!allzeroes((void *) &msg->pluginSharedRO->txContent->value,
c0de3184:	6860      	ldr	r0, [r4, #4]
c0de3186:	6800      	ldr	r0, [r0, #0]
c0de3188:	e064      	b.n	c0de3254 <erc1155_plugin_call+0x140>
c0de318a:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de318c:	7560      	strb	r0, [r4, #21]
}
c0de318e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3190:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de3192:	7720      	strb	r0, [r4, #28]
    erc1155_context_t *context = (erc1155_context_t *) msg->pluginContext;
c0de3194:	68a5      	ldr	r5, [r4, #8]
    strlcpy(msg->name, "NFT", msg->nameLength);
c0de3196:	68e0      	ldr	r0, [r4, #12]
c0de3198:	6922      	ldr	r2, [r4, #16]
c0de319a:	493b      	ldr	r1, [pc, #236]	; (c0de3288 <erc1155_plugin_call+0x174>)
c0de319c:	4479      	add	r1, pc
c0de319e:	f00a fd19 	bl	c0dedbd4 <strlcpy>
c0de31a2:	206c      	movs	r0, #108	; 0x6c
    switch (context->selectorIndex) {
c0de31a4:	5c28      	ldrb	r0, [r5, r0]
c0de31a6:	2802      	cmp	r0, #2
c0de31a8:	d038      	beq.n	c0de321c <erc1155_plugin_call+0x108>
c0de31aa:	2801      	cmp	r0, #1
c0de31ac:	d03b      	beq.n	c0de3226 <erc1155_plugin_call+0x112>
c0de31ae:	2800      	cmp	r0, #0
c0de31b0:	d140      	bne.n	c0de3234 <erc1155_plugin_call+0x120>
            strlcpy(msg->version, "Allowance", msg->versionLength);
c0de31b2:	6960      	ldr	r0, [r4, #20]
c0de31b4:	69a2      	ldr	r2, [r4, #24]
c0de31b6:	4935      	ldr	r1, [pc, #212]	; (c0de328c <erc1155_plugin_call+0x178>)
c0de31b8:	4479      	add	r1, pc
c0de31ba:	e038      	b.n	c0de322e <erc1155_plugin_call+0x11a>
c0de31bc:	2200      	movs	r2, #0
    msg->tokenLookup2 = NULL;
c0de31be:	6122      	str	r2, [r4, #16]
        msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0de31c0:	6860      	ldr	r0, [r4, #4]
c0de31c2:	6800      	ldr	r0, [r0, #0]
c0de31c4:	4603      	mov	r3, r0
c0de31c6:	33a5      	adds	r3, #165	; 0xa5
c0de31c8:	60e3      	str	r3, [r4, #12]
    switch (context->selectorIndex) {
c0de31ca:	2900      	cmp	r1, #0
c0de31cc:	d040      	beq.n	c0de3250 <erc1155_plugin_call+0x13c>
c0de31ce:	2901      	cmp	r1, #1
c0de31d0:	d14e      	bne.n	c0de3270 <erc1155_plugin_call+0x15c>
c0de31d2:	2105      	movs	r1, #5
c0de31d4:	e03d      	b.n	c0de3252 <erc1155_plugin_call+0x13e>
c0de31d6:	356b      	adds	r5, #107	; 0x6b
c0de31d8:	2600      	movs	r6, #0
c0de31da:	4f2a      	ldr	r7, [pc, #168]	; (c0de3284 <erc1155_plugin_call+0x170>)
c0de31dc:	447f      	add	r7, pc
    for (i = 0; i < SELECTORS_COUNT; i++) {
c0de31de:	2e03      	cmp	r6, #3
c0de31e0:	d02a      	beq.n	c0de3238 <erc1155_plugin_call+0x124>
        if (memcmp((uint8_t *) PIC(ERC1155_SELECTORS[i]), msg->selector, SELECTOR_SIZE) == 0) {
c0de31e2:	6838      	ldr	r0, [r7, #0]
c0de31e4:	f005 f82e 	bl	c0de8244 <pic>
c0de31e8:	7801      	ldrb	r1, [r0, #0]
c0de31ea:	7842      	ldrb	r2, [r0, #1]
c0de31ec:	0212      	lsls	r2, r2, #8
c0de31ee:	1851      	adds	r1, r2, r1
c0de31f0:	7882      	ldrb	r2, [r0, #2]
c0de31f2:	78c0      	ldrb	r0, [r0, #3]
c0de31f4:	0200      	lsls	r0, r0, #8
c0de31f6:	1880      	adds	r0, r0, r2
c0de31f8:	0400      	lsls	r0, r0, #16
c0de31fa:	1840      	adds	r0, r0, r1
c0de31fc:	6961      	ldr	r1, [r4, #20]
c0de31fe:	780a      	ldrb	r2, [r1, #0]
c0de3200:	784b      	ldrb	r3, [r1, #1]
c0de3202:	021b      	lsls	r3, r3, #8
c0de3204:	189a      	adds	r2, r3, r2
c0de3206:	788b      	ldrb	r3, [r1, #2]
c0de3208:	78c9      	ldrb	r1, [r1, #3]
c0de320a:	0209      	lsls	r1, r1, #8
c0de320c:	18c9      	adds	r1, r1, r3
c0de320e:	0409      	lsls	r1, r1, #16
c0de3210:	1889      	adds	r1, r1, r2
c0de3212:	4288      	cmp	r0, r1
c0de3214:	d013      	beq.n	c0de323e <erc1155_plugin_call+0x12a>
    for (i = 0; i < SELECTORS_COUNT; i++) {
c0de3216:	1d3f      	adds	r7, r7, #4
c0de3218:	1c76      	adds	r6, r6, #1
c0de321a:	e7e0      	b.n	c0de31de <erc1155_plugin_call+0xca>
            strlcpy(msg->version, "Batch Transfer", msg->versionLength);
c0de321c:	6960      	ldr	r0, [r4, #20]
c0de321e:	69a2      	ldr	r2, [r4, #24]
c0de3220:	491c      	ldr	r1, [pc, #112]	; (c0de3294 <erc1155_plugin_call+0x180>)
c0de3222:	4479      	add	r1, pc
c0de3224:	e003      	b.n	c0de322e <erc1155_plugin_call+0x11a>
            strlcpy(msg->version, "Transfer", msg->versionLength);
c0de3226:	6960      	ldr	r0, [r4, #20]
c0de3228:	69a2      	ldr	r2, [r4, #24]
c0de322a:	4919      	ldr	r1, [pc, #100]	; (c0de3290 <erc1155_plugin_call+0x17c>)
c0de322c:	4479      	add	r1, pc
c0de322e:	f00a fcd1 	bl	c0dedbd4 <strlcpy>
}
c0de3232:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3234:	2000      	movs	r0, #0
c0de3236:	e016      	b.n	c0de3266 <erc1155_plugin_call+0x152>
c0de3238:	2006      	movs	r0, #6
c0de323a:	7060      	strb	r0, [r4, #1]
c0de323c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de323e:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de3240:	7060      	strb	r0, [r4, #1]
            context->selectorIndex = i;
c0de3242:	706e      	strb	r6, [r5, #1]
    switch (context->selectorIndex) {
c0de3244:	b2f0      	uxtb	r0, r6
c0de3246:	1e41      	subs	r1, r0, #1
c0de3248:	2902      	cmp	r1, #2
c0de324a:	d213      	bcs.n	c0de3274 <erc1155_plugin_call+0x160>
c0de324c:	2000      	movs	r0, #0
c0de324e:	e015      	b.n	c0de327c <erc1155_plugin_call+0x168>
c0de3250:	2103      	movs	r1, #3
c0de3252:	7761      	strb	r1, [r4, #29]
    if (!allzeroes((void *) &msg->pluginSharedRO->txContent->value,
c0de3254:	3042      	adds	r0, #66	; 0x42
c0de3256:	2121      	movs	r1, #33	; 0x21
c0de3258:	f000 f81e 	bl	c0de3298 <allzeroes>
c0de325c:	2800      	cmp	r0, #0
c0de325e:	d004      	beq.n	c0de326a <erc1155_plugin_call+0x156>
c0de3260:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de3262:	77a0      	strb	r0, [r4, #30]
c0de3264:	2002      	movs	r0, #2
c0de3266:	7720      	strb	r0, [r4, #28]
}
c0de3268:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de326a:	2000      	movs	r0, #0
        msg->result = ETH_PLUGIN_RESULT_ERROR;
c0de326c:	77a0      	strb	r0, [r4, #30]
}
c0de326e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            msg->result = ETH_PLUGIN_RESULT_ERROR;
c0de3270:	77a2      	strb	r2, [r4, #30]
}
c0de3272:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (context->selectorIndex) {
c0de3274:	2800      	cmp	r0, #0
c0de3276:	d000      	beq.n	c0de327a <erc1155_plugin_call+0x166>
c0de3278:	e770      	b.n	c0de315c <erc1155_plugin_call+0x48>
c0de327a:	2008      	movs	r0, #8
c0de327c:	7028      	strb	r0, [r5, #0]
}
c0de327e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3280:	00000124 	.word	0x00000124
c0de3284:	0000c610 	.word	0x0000c610
c0de3288:	0000add6 	.word	0x0000add6
c0de328c:	0000ac13 	.word	0x0000ac13
c0de3290:	0000af68 	.word	0x0000af68
c0de3294:	0000af39 	.word	0x0000af39

c0de3298 <allzeroes>:
    for (size_t i = 0; i < n; ++i) {
c0de3298:	2900      	cmp	r1, #0
c0de329a:	d007      	beq.n	c0de32ac <allzeroes+0x14>
        if (p[i]) {
c0de329c:	1c42      	adds	r2, r0, #1
c0de329e:	1e49      	subs	r1, r1, #1
c0de32a0:	7800      	ldrb	r0, [r0, #0]
c0de32a2:	2800      	cmp	r0, #0
c0de32a4:	4610      	mov	r0, r2
c0de32a6:	d0f7      	beq.n	c0de3298 <allzeroes>
c0de32a8:	2000      	movs	r0, #0
}
c0de32aa:	4770      	bx	lr
c0de32ac:	2001      	movs	r0, #1
c0de32ae:	4770      	bx	lr

c0de32b0 <handle_provide_parameter_1155>:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}

void handle_provide_parameter_1155(void *parameters) {
c0de32b0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de32b2:	b089      	sub	sp, #36	; 0x24
c0de32b4:	2503      	movs	r5, #3
    PRINTF("erc1155 plugin provide parameter %d %.*H\n",
           msg->parameterOffset,
           PARAMETER_LENGTH,
           msg->parameter);

    msg->result = ETH_PLUGIN_RESULT_SUCCESSFUL;
c0de32b6:	7505      	strb	r5, [r0, #20]
    erc1155_context_t *context = (erc1155_context_t *) msg->pluginContext;
c0de32b8:	6884      	ldr	r4, [r0, #8]
c0de32ba:	216c      	movs	r1, #108	; 0x6c

    // if (context->targetOffset > SELECTOR_SIZE &&
    //     context->targetOffset != msg->parameterOffset - SELECTOR_SIZE) {
    //     return;
    // }
    switch (context->selectorIndex) {
c0de32bc:	5c61      	ldrb	r1, [r4, r1]
c0de32be:	4627      	mov	r7, r4
c0de32c0:	3758      	adds	r7, #88	; 0x58
c0de32c2:	2900      	cmp	r1, #0
c0de32c4:	d013      	beq.n	c0de32ee <handle_provide_parameter_1155+0x3e>
c0de32c6:	2902      	cmp	r1, #2
c0de32c8:	d021      	beq.n	c0de330e <handle_provide_parameter_1155+0x5e>
c0de32ca:	2901      	cmp	r1, #1
c0de32cc:	d11c      	bne.n	c0de3308 <handle_provide_parameter_1155+0x58>
    switch (context->next_param) {
c0de32ce:	7cf9      	ldrb	r1, [r7, #19]
c0de32d0:	2900      	cmp	r1, #0
c0de32d2:	d02d      	beq.n	c0de3330 <handle_provide_parameter_1155+0x80>
c0de32d4:	2907      	cmp	r1, #7
c0de32d6:	d035      	beq.n	c0de3344 <handle_provide_parameter_1155+0x94>
c0de32d8:	2904      	cmp	r1, #4
c0de32da:	d042      	beq.n	c0de3362 <handle_provide_parameter_1155+0xb2>
c0de32dc:	2901      	cmp	r1, #1
c0de32de:	d16a      	bne.n	c0de33b6 <handle_provide_parameter_1155+0x106>
            copy_address(context->address, msg->parameter, sizeof(context->address));
c0de32e0:	68c1      	ldr	r1, [r0, #12]
c0de32e2:	2214      	movs	r2, #20
c0de32e4:	4620      	mov	r0, r4
c0de32e6:	f001 fd55 	bl	c0de4d94 <copy_address>
c0de32ea:	2004      	movs	r0, #4
c0de32ec:	e062      	b.n	c0de33b4 <handle_provide_parameter_1155+0x104>
    switch (context->next_param) {
c0de32ee:	7cf9      	ldrb	r1, [r7, #19]
c0de32f0:	2909      	cmp	r1, #9
c0de32f2:	d01f      	beq.n	c0de3334 <handle_provide_parameter_1155+0x84>
c0de32f4:	2908      	cmp	r1, #8
c0de32f6:	d107      	bne.n	c0de3308 <handle_provide_parameter_1155+0x58>
c0de32f8:	2109      	movs	r1, #9
            context->next_param = APPROVED;
c0de32fa:	74f9      	strb	r1, [r7, #19]
            copy_address(context->address, msg->parameter, sizeof(context->address));
c0de32fc:	68c1      	ldr	r1, [r0, #12]
c0de32fe:	2214      	movs	r2, #20
c0de3300:	4620      	mov	r0, r4
c0de3302:	f001 fd47 	bl	c0de4d94 <copy_address>
c0de3306:	e056      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
c0de3308:	2100      	movs	r1, #0
c0de330a:	7501      	strb	r1, [r0, #20]
c0de330c:	e053      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
    switch (context->next_param) {
c0de330e:	7cf9      	ldrb	r1, [r7, #19]
c0de3310:	2907      	cmp	r1, #7
c0de3312:	d02e      	beq.n	c0de3372 <handle_provide_parameter_1155+0xc2>
c0de3314:	2901      	cmp	r1, #1
c0de3316:	d047      	beq.n	c0de33a8 <handle_provide_parameter_1155+0xf8>
c0de3318:	2902      	cmp	r1, #2
c0de331a:	d04e      	beq.n	c0de33ba <handle_provide_parameter_1155+0x10a>
c0de331c:	2903      	cmp	r1, #3
c0de331e:	d054      	beq.n	c0de33ca <handle_provide_parameter_1155+0x11a>
c0de3320:	2904      	cmp	r1, #4
c0de3322:	d062      	beq.n	c0de33ea <handle_provide_parameter_1155+0x13a>
c0de3324:	2905      	cmp	r1, #5
c0de3326:	d06b      	beq.n	c0de3400 <handle_provide_parameter_1155+0x150>
c0de3328:	2906      	cmp	r1, #6
c0de332a:	d070      	beq.n	c0de340e <handle_provide_parameter_1155+0x15e>
c0de332c:	2900      	cmp	r1, #0
c0de332e:	d142      	bne.n	c0de33b6 <handle_provide_parameter_1155+0x106>
c0de3330:	2001      	movs	r0, #1
c0de3332:	e03f      	b.n	c0de33b4 <handle_provide_parameter_1155+0x104>
            context->approved = msg->parameter[PARAMETER_LENGTH - 1];
c0de3334:	68c0      	ldr	r0, [r0, #12]
c0de3336:	7fc0      	ldrb	r0, [r0, #31]
c0de3338:	210a      	movs	r1, #10
            context->next_param = NONE;
c0de333a:	74f9      	strb	r1, [r7, #19]
            context->approved = msg->parameter[PARAMETER_LENGTH - 1];
c0de333c:	1e41      	subs	r1, r0, #1
c0de333e:	4188      	sbcs	r0, r1
c0de3340:	74b8      	strb	r0, [r7, #18]
c0de3342:	e038      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
            copy_parameter(new_value, msg->parameter, sizeof(new_value));
c0de3344:	68c1      	ldr	r1, [r0, #12]
c0de3346:	466d      	mov	r5, sp
c0de3348:	2620      	movs	r6, #32
c0de334a:	4628      	mov	r0, r5
c0de334c:	4632      	mov	r2, r6
c0de334e:	f001 fd2a 	bl	c0de4da6 <copy_parameter>
            convertUint256BE(new_value, INT256_LENGTH, &context->value);
c0de3352:	3438      	adds	r4, #56	; 0x38
c0de3354:	4628      	mov	r0, r5
c0de3356:	4631      	mov	r1, r6
c0de3358:	4622      	mov	r2, r4
c0de335a:	f009 f875 	bl	c0dec448 <convertUint256BE>
c0de335e:	200a      	movs	r0, #10
c0de3360:	e028      	b.n	c0de33b4 <handle_provide_parameter_1155+0x104>
            copy_parameter(context->tokenId, msg->parameter, sizeof(context->tokenId));
c0de3362:	68c1      	ldr	r1, [r0, #12]
c0de3364:	3414      	adds	r4, #20
c0de3366:	2220      	movs	r2, #32
c0de3368:	4620      	mov	r0, r4
c0de336a:	f001 fd1c 	bl	c0de4da6 <copy_parameter>
c0de336e:	2007      	movs	r0, #7
c0de3370:	e020      	b.n	c0de33b4 <handle_provide_parameter_1155+0x104>
            copy_parameter(context->tokenId, msg->parameter, sizeof(context->value));
c0de3372:	68c1      	ldr	r1, [r0, #12]
c0de3374:	4625      	mov	r5, r4
c0de3376:	3514      	adds	r5, #20
c0de3378:	2620      	movs	r6, #32
c0de337a:	4628      	mov	r0, r5
c0de337c:	4632      	mov	r2, r6
c0de337e:	f001 fd12 	bl	c0de4da6 <copy_parameter>
c0de3382:	466a      	mov	r2, sp
            convertUint256BE(context->tokenId, sizeof(context->tokenId), &new_value);
c0de3384:	4628      	mov	r0, r5
c0de3386:	4631      	mov	r1, r6
c0de3388:	4615      	mov	r5, r2
c0de338a:	f009 f85d 	bl	c0dec448 <convertUint256BE>
            add256(&context->value, &new_value, &context->value);
c0de338e:	3438      	adds	r4, #56	; 0x38
c0de3390:	4620      	mov	r0, r4
c0de3392:	4629      	mov	r1, r5
c0de3394:	4622      	mov	r2, r4
c0de3396:	f007 fe5c 	bl	c0deb052 <add256>
            if (--context->values_array_len == 0) {
c0de339a:	8938      	ldrh	r0, [r7, #8]
c0de339c:	1e40      	subs	r0, r0, #1
c0de339e:	8138      	strh	r0, [r7, #8]
c0de33a0:	0400      	lsls	r0, r0, #16
c0de33a2:	d129      	bne.n	c0de33f8 <handle_provide_parameter_1155+0x148>
c0de33a4:	200a      	movs	r0, #10
c0de33a6:	e026      	b.n	c0de33f6 <handle_provide_parameter_1155+0x146>
            copy_address(context->address, msg->parameter, sizeof(context->address));
c0de33a8:	68c1      	ldr	r1, [r0, #12]
c0de33aa:	2214      	movs	r2, #20
c0de33ac:	4620      	mov	r0, r4
c0de33ae:	f001 fcf1 	bl	c0de4d94 <copy_address>
c0de33b2:	2002      	movs	r0, #2
c0de33b4:	74f8      	strb	r0, [r7, #19]
        default:
            PRINTF("Selector index %d not supported\n", context->selectorIndex);
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}
c0de33b6:	b009      	add	sp, #36	; 0x24
c0de33b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                U4BE(msg->parameter, PARAMETER_LENGTH - sizeof(context->ids_offset)) + 4;
c0de33ba:	68c0      	ldr	r0, [r0, #12]
c0de33bc:	f000 f83c 	bl	c0de3438 <U4BE>
c0de33c0:	2105      	movs	r1, #5
            context->next_param = VALUE_OFFSET;
c0de33c2:	74f9      	strb	r1, [r7, #19]
                U4BE(msg->parameter, PARAMETER_LENGTH - sizeof(context->ids_offset)) + 4;
c0de33c4:	1d00      	adds	r0, r0, #4
            context->ids_offset =
c0de33c6:	65e0      	str	r0, [r4, #92]	; 0x5c
c0de33c8:	e7f5      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
            if ((msg->parameterOffset + PARAMETER_LENGTH) > context->ids_offset) {
c0de33ca:	6de1      	ldr	r1, [r4, #92]	; 0x5c
c0de33cc:	6902      	ldr	r2, [r0, #16]
c0de33ce:	3220      	adds	r2, #32
c0de33d0:	428a      	cmp	r2, r1
c0de33d2:	d9f0      	bls.n	c0de33b6 <handle_provide_parameter_1155+0x106>
                    U2BE(msg->parameter, PARAMETER_LENGTH - sizeof(context->ids_array_len));
c0de33d4:	68c0      	ldr	r0, [r0, #12]
  return (buf[off] << 8) | buf[off + 1];
c0de33d6:	7fc1      	ldrb	r1, [r0, #31]
c0de33d8:	7f80      	ldrb	r0, [r0, #30]
c0de33da:	2204      	movs	r2, #4
                context->next_param = TOKEN_ID;
c0de33dc:	74fa      	strb	r2, [r7, #19]
c0de33de:	2200      	movs	r2, #0
                context->array_index = 0;
c0de33e0:	823a      	strh	r2, [r7, #16]
c0de33e2:	0200      	lsls	r0, r0, #8
c0de33e4:	1840      	adds	r0, r0, r1
                context->ids_array_len =
c0de33e6:	8038      	strh	r0, [r7, #0]
c0de33e8:	e7e5      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
            if (--context->ids_array_len == 0) {
c0de33ea:	8838      	ldrh	r0, [r7, #0]
c0de33ec:	1e40      	subs	r0, r0, #1
c0de33ee:	8038      	strh	r0, [r7, #0]
c0de33f0:	0400      	lsls	r0, r0, #16
c0de33f2:	d101      	bne.n	c0de33f8 <handle_provide_parameter_1155+0x148>
c0de33f4:	2006      	movs	r0, #6
c0de33f6:	74f8      	strb	r0, [r7, #19]
c0de33f8:	8a38      	ldrh	r0, [r7, #16]
c0de33fa:	1c40      	adds	r0, r0, #1
c0de33fc:	8238      	strh	r0, [r7, #16]
c0de33fe:	e7da      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
                U4BE(msg->parameter, PARAMETER_LENGTH - sizeof(context->values_offset)) + 4;
c0de3400:	68c0      	ldr	r0, [r0, #12]
c0de3402:	f000 f819 	bl	c0de3438 <U4BE>
            context->next_param = TOKEN_IDS_LENGTH;
c0de3406:	74fd      	strb	r5, [r7, #19]
                U4BE(msg->parameter, PARAMETER_LENGTH - sizeof(context->values_offset)) + 4;
c0de3408:	1d00      	adds	r0, r0, #4
            context->values_offset =
c0de340a:	6660      	str	r0, [r4, #100]	; 0x64
c0de340c:	e7d3      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>
            if ((msg->parameterOffset + PARAMETER_LENGTH) > context->values_offset) {
c0de340e:	6e61      	ldr	r1, [r4, #100]	; 0x64
c0de3410:	6902      	ldr	r2, [r0, #16]
c0de3412:	3220      	adds	r2, #32
c0de3414:	428a      	cmp	r2, r1
c0de3416:	d9ce      	bls.n	c0de33b6 <handle_provide_parameter_1155+0x106>
                    U2BE(msg->parameter, PARAMETER_LENGTH - sizeof(context->values_array_len));
c0de3418:	68c0      	ldr	r0, [r0, #12]
c0de341a:	7fc1      	ldrb	r1, [r0, #31]
c0de341c:	7f80      	ldrb	r0, [r0, #30]
c0de341e:	2207      	movs	r2, #7
                context->next_param = VALUE;
c0de3420:	74fa      	strb	r2, [r7, #19]
c0de3422:	2200      	movs	r2, #0
                context->array_index = 0;
c0de3424:	823a      	strh	r2, [r7, #16]
c0de3426:	0200      	lsls	r0, r0, #8
c0de3428:	1840      	adds	r0, r0, r1
                context->values_array_len =
c0de342a:	8138      	strh	r0, [r7, #8]
                explicit_bzero(&context->value, sizeof(context->value));
c0de342c:	3438      	adds	r4, #56	; 0x38
c0de342e:	2120      	movs	r1, #32
c0de3430:	4620      	mov	r0, r4
c0de3432:	f00a fa05 	bl	c0ded840 <explicit_bzero>
c0de3436:	e7be      	b.n	c0de33b6 <handle_provide_parameter_1155+0x106>

c0de3438 <U4BE>:
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de3438:	7f01      	ldrb	r1, [r0, #28]
c0de343a:	0609      	lsls	r1, r1, #24
c0de343c:	7f42      	ldrb	r2, [r0, #29]
c0de343e:	0412      	lsls	r2, r2, #16
c0de3440:	1851      	adds	r1, r2, r1
         (buf[off + 2] << 8) | buf[off + 3];
c0de3442:	7f82      	ldrb	r2, [r0, #30]
c0de3444:	0212      	lsls	r2, r2, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de3446:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de3448:	7fc0      	ldrb	r0, [r0, #31]
c0de344a:	1808      	adds	r0, r1, r0
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de344c:	4770      	bx	lr
c0de344e:	d4d4      	bmi.n	c0de33fa <handle_provide_parameter_1155+0x14a>

c0de3450 <handle_query_contract_ui_1155>:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}

void handle_query_contract_ui_1155(void *parameters) {
c0de3450:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de3452:	b08f      	sub	sp, #60	; 0x3c
c0de3454:	4604      	mov	r4, r0
c0de3456:	2034      	movs	r0, #52	; 0x34
c0de3458:	2104      	movs	r1, #4
    ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
    erc1155_context_t *context = (erc1155_context_t *) msg->pluginContext;

    msg->result = ETH_PLUGIN_RESULT_OK;
c0de345a:	5421      	strb	r1, [r4, r0]
    erc1155_context_t *context = (erc1155_context_t *) msg->pluginContext;
c0de345c:	69e5      	ldr	r5, [r4, #28]
c0de345e:	206c      	movs	r0, #108	; 0x6c
    switch (context->selectorIndex) {
c0de3460:	5c29      	ldrb	r1, [r5, r0]
c0de3462:	4620      	mov	r0, r4
c0de3464:	3020      	adds	r0, #32
c0de3466:	462f      	mov	r7, r5
c0de3468:	3768      	adds	r7, #104	; 0x68
c0de346a:	2902      	cmp	r1, #2
c0de346c:	d010      	beq.n	c0de3490 <handle_query_contract_ui_1155+0x40>
c0de346e:	2901      	cmp	r1, #1
c0de3470:	d016      	beq.n	c0de34a0 <handle_query_contract_ui_1155+0x50>
c0de3472:	2900      	cmp	r1, #0
c0de3474:	d124      	bne.n	c0de34c0 <handle_query_contract_ui_1155+0x70>
    switch (msg->screenIndex) {
c0de3476:	7801      	ldrb	r1, [r0, #0]
c0de3478:	2902      	cmp	r1, #2
c0de347a:	d024      	beq.n	c0de34c6 <handle_query_contract_ui_1155+0x76>
c0de347c:	2901      	cmp	r1, #1
c0de347e:	d03a      	beq.n	c0de34f6 <handle_query_contract_ui_1155+0xa6>
c0de3480:	2900      	cmp	r1, #0
c0de3482:	d11d      	bne.n	c0de34c0 <handle_query_contract_ui_1155+0x70>
            if (context->approved) {
c0de3484:	78b8      	ldrb	r0, [r7, #2]
c0de3486:	2800      	cmp	r0, #0
c0de3488:	d076      	beq.n	c0de3578 <handle_query_contract_ui_1155+0x128>
c0de348a:	4949      	ldr	r1, [pc, #292]	; (c0de35b0 <handle_query_contract_ui_1155+0x160>)
c0de348c:	4479      	add	r1, pc
c0de348e:	e075      	b.n	c0de357c <handle_query_contract_ui_1155+0x12c>
    switch (msg->screenIndex) {
c0de3490:	7801      	ldrb	r1, [r0, #0]
c0de3492:	2903      	cmp	r1, #3
c0de3494:	d03c      	beq.n	c0de3510 <handle_query_contract_ui_1155+0xc0>
c0de3496:	2901      	cmp	r1, #1
c0de3498:	d028      	beq.n	c0de34ec <handle_query_contract_ui_1155+0x9c>
c0de349a:	2902      	cmp	r1, #2
c0de349c:	d109      	bne.n	c0de34b2 <handle_query_contract_ui_1155+0x62>
c0de349e:	e012      	b.n	c0de34c6 <handle_query_contract_ui_1155+0x76>
    switch (msg->screenIndex) {
c0de34a0:	7801      	ldrb	r1, [r0, #0]
c0de34a2:	2904      	cmp	r1, #4
c0de34a4:	d04c      	beq.n	c0de3540 <handle_query_contract_ui_1155+0xf0>
c0de34a6:	2901      	cmp	r1, #1
c0de34a8:	d020      	beq.n	c0de34ec <handle_query_contract_ui_1155+0x9c>
c0de34aa:	2902      	cmp	r1, #2
c0de34ac:	d00b      	beq.n	c0de34c6 <handle_query_contract_ui_1155+0x76>
c0de34ae:	2903      	cmp	r1, #3
c0de34b0:	d054      	beq.n	c0de355c <handle_query_contract_ui_1155+0x10c>
c0de34b2:	2900      	cmp	r1, #0
c0de34b4:	d104      	bne.n	c0de34c0 <handle_query_contract_ui_1155+0x70>
c0de34b6:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de34b8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de34ba:	493f      	ldr	r1, [pc, #252]	; (c0de35b8 <handle_query_contract_ui_1155+0x168>)
c0de34bc:	4479      	add	r1, pc
c0de34be:	e05f      	b.n	c0de3580 <handle_query_contract_ui_1155+0x130>
c0de34c0:	2100      	movs	r1, #0
c0de34c2:	7501      	strb	r1, [r0, #20]
c0de34c4:	e06c      	b.n	c0de35a0 <handle_query_contract_ui_1155+0x150>
c0de34c6:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de34c8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de34ca:	493e      	ldr	r1, [pc, #248]	; (c0de35c4 <handle_query_contract_ui_1155+0x174>)
c0de34cc:	4479      	add	r1, pc
c0de34ce:	f00a fb81 	bl	c0dedbd4 <strlcpy>
c0de34d2:	4834      	ldr	r0, [pc, #208]	; (c0de35a4 <handle_query_contract_ui_1155+0x154>)
c0de34d4:	464b      	mov	r3, r9
c0de34d6:	5818      	ldr	r0, [r3, r0]
c0de34d8:	6905      	ldr	r5, [r0, #16]
c0de34da:	6946      	ldr	r6, [r0, #20]
c0de34dc:	68a0      	ldr	r0, [r4, #8]
c0de34de:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de34e0:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de34e2:	9500      	str	r5, [sp, #0]
c0de34e4:	9601      	str	r6, [sp, #4]
c0de34e6:	4c30      	ldr	r4, [pc, #192]	; (c0de35a8 <handle_query_contract_ui_1155+0x158>)
c0de34e8:	191b      	adds	r3, r3, r4
c0de34ea:	e057      	b.n	c0de359c <handle_query_contract_ui_1155+0x14c>
c0de34ec:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de34ee:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de34f0:	4935      	ldr	r1, [pc, #212]	; (c0de35c8 <handle_query_contract_ui_1155+0x178>)
c0de34f2:	4479      	add	r1, pc
c0de34f4:	e003      	b.n	c0de34fe <handle_query_contract_ui_1155+0xae>
            strlcpy(msg->title, "To Manage ALL", msg->titleLength);
c0de34f6:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de34f8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de34fa:	492e      	ldr	r1, [pc, #184]	; (c0de35b4 <handle_query_contract_ui_1155+0x164>)
c0de34fc:	4479      	add	r1, pc
c0de34fe:	f00a fb69 	bl	c0dedbd4 <strlcpy>
c0de3502:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de3504:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3506:	68a1      	ldr	r1, [r4, #8]
c0de3508:	3114      	adds	r1, #20
c0de350a:	f00a fb63 	bl	c0dedbd4 <strlcpy>
c0de350e:	e047      	b.n	c0de35a0 <handle_query_contract_ui_1155+0x150>
            strlcpy(msg->title, "Total Quantity", msg->titleLength);
c0de3510:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3512:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3514:	492d      	ldr	r1, [pc, #180]	; (c0de35cc <handle_query_contract_ui_1155+0x17c>)
c0de3516:	4479      	add	r1, pc
c0de3518:	f00a fb5c 	bl	c0dedbd4 <strlcpy>
            tostring256(&context->value, 10, &quantity_str[0], sizeof(quantity_str));
c0de351c:	3538      	adds	r5, #56	; 0x38
c0de351e:	210a      	movs	r1, #10
c0de3520:	ae03      	add	r6, sp, #12
c0de3522:	2330      	movs	r3, #48	; 0x30
c0de3524:	4628      	mov	r0, r5
c0de3526:	4632      	mov	r2, r6
c0de3528:	f007 ff84 	bl	c0deb434 <tostring256>
            snprintf(msg->msg,
c0de352c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
                     msg->msgLength,
c0de352e:	6b21      	ldr	r1, [r4, #48]	; 0x30
                     context->array_index);
c0de3530:	883a      	ldrh	r2, [r7, #0]
            snprintf(msg->msg,
c0de3532:	9200      	str	r2, [sp, #0]
c0de3534:	4a26      	ldr	r2, [pc, #152]	; (c0de35d0 <handle_query_contract_ui_1155+0x180>)
c0de3536:	447a      	add	r2, pc
c0de3538:	4633      	mov	r3, r6
c0de353a:	f004 fca7 	bl	c0de7e8c <snprintf>
c0de353e:	e02f      	b.n	c0de35a0 <handle_query_contract_ui_1155+0x150>
            strlcpy(msg->title, "Quantity", msg->titleLength);
c0de3540:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3542:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3544:	491e      	ldr	r1, [pc, #120]	; (c0de35c0 <handle_query_contract_ui_1155+0x170>)
c0de3546:	4479      	add	r1, pc
c0de3548:	f00a fb44 	bl	c0dedbd4 <strlcpy>
            tostring256(&context->value, 10, msg->msg, msg->msgLength);
c0de354c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
c0de354e:	6b23      	ldr	r3, [r4, #48]	; 0x30
c0de3550:	3538      	adds	r5, #56	; 0x38
c0de3552:	210a      	movs	r1, #10
c0de3554:	4628      	mov	r0, r5
c0de3556:	f007 ff6d 	bl	c0deb434 <tostring256>
c0de355a:	e021      	b.n	c0de35a0 <handle_query_contract_ui_1155+0x150>
            strlcpy(msg->title, "NFT ID", msg->titleLength);
c0de355c:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de355e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3560:	4916      	ldr	r1, [pc, #88]	; (c0de35bc <handle_query_contract_ui_1155+0x16c>)
c0de3562:	4479      	add	r1, pc
c0de3564:	f00a fb36 	bl	c0dedbd4 <strlcpy>
                               msg->msg,
c0de3568:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
                               msg->msgLength);
c0de356a:	6b23      	ldr	r3, [r4, #48]	; 0x30
            uint256_to_decimal(context->tokenId,
c0de356c:	3514      	adds	r5, #20
c0de356e:	2120      	movs	r1, #32
c0de3570:	4628      	mov	r0, r5
c0de3572:	f008 ff93 	bl	c0dec49c <uint256_to_decimal>
c0de3576:	e013      	b.n	c0de35a0 <handle_query_contract_ui_1155+0x150>
c0de3578:	490c      	ldr	r1, [pc, #48]	; (c0de35ac <handle_query_contract_ui_1155+0x15c>)
c0de357a:	4479      	add	r1, pc
c0de357c:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de357e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3580:	f00a fb28 	bl	c0dedbd4 <strlcpy>
c0de3584:	4807      	ldr	r0, [pc, #28]	; (c0de35a4 <handle_query_contract_ui_1155+0x154>)
c0de3586:	464b      	mov	r3, r9
c0de3588:	5818      	ldr	r0, [r3, r0]
c0de358a:	6906      	ldr	r6, [r0, #16]
c0de358c:	6940      	ldr	r0, [r0, #20]
c0de358e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de3590:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3592:	9600      	str	r6, [sp, #0]
c0de3594:	9001      	str	r0, [sp, #4]
c0de3596:	4804      	ldr	r0, [pc, #16]	; (c0de35a8 <handle_query_contract_ui_1155+0x158>)
c0de3598:	181b      	adds	r3, r3, r0
c0de359a:	4628      	mov	r0, r5
c0de359c:	f001 f94e 	bl	c0de483c <getEthDisplayableAddress>
        default:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            PRINTF("Unsupported selector index %d\n", context->selectorIndex);
            break;
    }
}
c0de35a0:	b00f      	add	sp, #60	; 0x3c
c0de35a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de35a4:	00000590 	.word	0x00000590
c0de35a8:	000007e8 	.word	0x000007e8
c0de35ac:	0000ad68 	.word	0x0000ad68
c0de35b0:	0000ae2f 	.word	0x0000ae2f
c0de35b4:	0000a984 	.word	0x0000a984
c0de35b8:	0000aa0a 	.word	0x0000aa0a
c0de35bc:	0000acde 	.word	0x0000acde
c0de35c0:	0000abce 	.word	0x0000abce
c0de35c4:	0000acf8 	.word	0x0000acf8
c0de35c8:	0000aab7 	.word	0x0000aab7
c0de35cc:	0000aa21 	.word	0x0000aa21
c0de35d0:	0000a9bd 	.word	0x0000a9bd

c0de35d4 <check_contract>:

    // wstETH
    {"Wrapped stETH", {0xae, 0x7a, 0xb9, 0x65, 0x20, 0xde, 0x3a, 0x18, 0xe5, 0xe1,
                       0x11, 0xb5, 0xea, 0xab, 0x09, 0x53, 0x12, 0xd7, 0xfe, 0x84}}};

bool check_contract(erc20_parameters_t *context) {
c0de35d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de35d6:	9000      	str	r0, [sp, #0]
c0de35d8:	1c45      	adds	r5, r0, #1
c0de35da:	270e      	movs	r7, #14
c0de35dc:	480d      	ldr	r0, [pc, #52]	; (c0de3614 <check_contract+0x40>)
c0de35de:	4478      	add	r0, pc
    for (size_t i = 0; i < NUM_CONTRACTS; i++) {
c0de35e0:	1e7f      	subs	r7, r7, #1
c0de35e2:	d014      	beq.n	c0de360e <check_contract+0x3a>
c0de35e4:	4604      	mov	r4, r0
c0de35e6:	3423      	adds	r4, #35	; 0x23
        contract_t *contract = (contract_t *) PIC(&CONTRACTS[i]);
c0de35e8:	f004 fe2c 	bl	c0de8244 <pic>
c0de35ec:	4606      	mov	r6, r0
        if (memcmp(contract->address, context->destinationAddress, ADDRESS_LENGTH) == 0) {
c0de35ee:	300f      	adds	r0, #15
c0de35f0:	2214      	movs	r2, #20
c0de35f2:	4629      	mov	r1, r5
c0de35f4:	f00a f92e 	bl	c0ded854 <memcmp>
c0de35f8:	2800      	cmp	r0, #0
c0de35fa:	4620      	mov	r0, r4
c0de35fc:	d1f0      	bne.n	c0de35e0 <check_contract+0xc>
c0de35fe:	9800      	ldr	r0, [sp, #0]
            strlcpy(context->contract_name, contract->name, sizeof(context->contract_name));
c0de3600:	3044      	adds	r0, #68	; 0x44
c0de3602:	220f      	movs	r2, #15
c0de3604:	4631      	mov	r1, r6
c0de3606:	f00a fae5 	bl	c0dedbd4 <strlcpy>
c0de360a:	2001      	movs	r0, #1
            return true;
        }
    }
    return false;
}
c0de360c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de360e:	2000      	movs	r0, #0
c0de3610:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3612:	46c0      	nop			; (mov r8, r8)
c0de3614:	0000c21a 	.word	0x0000c21a

c0de3618 <erc20_plugin_available_check>:

bool erc20_plugin_available_check() {
#ifdef HAVE_STARKWARE
    if (quantumSet) {
c0de3618:	4809      	ldr	r0, [pc, #36]	; (c0de3640 <erc20_plugin_available_check+0x28>)
c0de361a:	4649      	mov	r1, r9
c0de361c:	5c09      	ldrb	r1, [r1, r0]
c0de361e:	2001      	movs	r0, #1
c0de3620:	2900      	cmp	r1, #0
c0de3622:	d009      	beq.n	c0de3638 <erc20_plugin_available_check+0x20>
        switch (dataContext.tokenContext.quantumType) {
c0de3624:	4907      	ldr	r1, [pc, #28]	; (c0de3644 <erc20_plugin_available_check+0x2c>)
c0de3626:	464a      	mov	r2, r9
c0de3628:	1851      	adds	r1, r2, r1
c0de362a:	22ff      	movs	r2, #255	; 0xff
c0de362c:	3226      	adds	r2, #38	; 0x26
c0de362e:	5c89      	ldrb	r1, [r1, r2]
c0de3630:	2904      	cmp	r1, #4
c0de3632:	d802      	bhi.n	c0de363a <erc20_plugin_available_check+0x22>
c0de3634:	2903      	cmp	r1, #3
c0de3636:	d000      	beq.n	c0de363a <erc20_plugin_available_check+0x22>
                return false;
        }
    }
#endif
    return true;
}
c0de3638:	4770      	bx	lr
c0de363a:	2000      	movs	r0, #0
c0de363c:	4770      	bx	lr
c0de363e:	46c0      	nop			; (mov r8, r8)
c0de3640:	0000011f 	.word	0x0000011f
c0de3644:	00000594 	.word	0x00000594

c0de3648 <erc20_plugin_call>:

void erc20_plugin_call(int message, void *parameters) {
c0de3648:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de364a:	460c      	mov	r4, r1
c0de364c:	2183      	movs	r1, #131	; 0x83
c0de364e:	0049      	lsls	r1, r1, #1
    switch (message) {
c0de3650:	4288      	cmp	r0, r1
c0de3652:	d05f      	beq.n	c0de3714 <erc20_plugin_call+0xcc>
c0de3654:	2181      	movs	r1, #129	; 0x81
c0de3656:	0049      	lsls	r1, r1, #1
c0de3658:	4288      	cmp	r0, r1
c0de365a:	d07f      	beq.n	c0de375c <erc20_plugin_call+0x114>
c0de365c:	21ff      	movs	r1, #255	; 0xff
c0de365e:	460a      	mov	r2, r1
c0de3660:	3204      	adds	r2, #4
c0de3662:	4290      	cmp	r0, r2
c0de3664:	d018      	beq.n	c0de3698 <erc20_plugin_call+0x50>
c0de3666:	2241      	movs	r2, #65	; 0x41
c0de3668:	0092      	lsls	r2, r2, #2
c0de366a:	4290      	cmp	r0, r2
c0de366c:	d025      	beq.n	c0de36ba <erc20_plugin_call+0x72>
c0de366e:	460a      	mov	r2, r1
c0de3670:	3206      	adds	r2, #6
c0de3672:	4290      	cmp	r0, r2
c0de3674:	d03f      	beq.n	c0de36f6 <erc20_plugin_call+0xae>
c0de3676:	3102      	adds	r1, #2
c0de3678:	4288      	cmp	r0, r1
c0de367a:	d000      	beq.n	c0de367e <erc20_plugin_call+0x36>
c0de367c:	e0c7      	b.n	c0de380e <erc20_plugin_call+0x1c6>
        case ETH_PLUGIN_INIT_CONTRACT: {
            ethPluginInitContract_t *msg = (ethPluginInitContract_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
            // enforce that ETH amount should be 0
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0de367e:	68a0      	ldr	r0, [r4, #8]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0de3680:	68e3      	ldr	r3, [r4, #12]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0de3682:	6800      	ldr	r0, [r0, #0]
c0de3684:	2142      	movs	r1, #66	; 0x42
    for (size_t i = 0; i < n; ++i) {
c0de3686:	2962      	cmp	r1, #98	; 0x62
c0de3688:	d073      	beq.n	c0de3772 <erc20_plugin_call+0x12a>
        if (p[i]) {
c0de368a:	5c42      	ldrb	r2, [r0, r1]
c0de368c:	1c49      	adds	r1, r1, #1
c0de368e:	2a00      	cmp	r2, #0
c0de3690:	d0f9      	beq.n	c0de3686 <erc20_plugin_call+0x3e>
c0de3692:	2000      	movs	r0, #0
                PRINTF("Err: Transaction amount is not 0\n");
                msg->result = ETH_PLUGIN_RESULT_ERROR;
c0de3694:	7060      	strb	r0, [r4, #1]
c0de3696:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            }
        } break;

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0de3698:	68a0      	ldr	r0, [r4, #8]
            PRINTF("erc20 plugin finalize\n");
            if (context->selectorIndex == ERC20_TRANSFER) {
c0de369a:	7801      	ldrb	r1, [r0, #0]
c0de369c:	2901      	cmp	r1, #1
c0de369e:	d100      	bne.n	c0de36a2 <erc20_plugin_call+0x5a>
c0de36a0:	e08e      	b.n	c0de37c0 <erc20_plugin_call+0x178>
c0de36a2:	2900      	cmp	r1, #0
c0de36a4:	d000      	beq.n	c0de36a8 <erc20_plugin_call+0x60>
c0de36a6:	e0b2      	b.n	c0de380e <erc20_plugin_call+0x1c6>
c0de36a8:	2104      	movs	r1, #4
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
                msg->amount = context->amount;
                msg->address = context->destinationAddress;
                msg->uiType = ETH_UI_TYPE_AMOUNT_ADDRESS;
                msg->result = ETH_PLUGIN_RESULT_OK;
c0de36aa:	77a1      	strb	r1, [r4, #30]
c0de36ac:	2101      	movs	r1, #1
                msg->uiType = ETH_UI_TYPE_AMOUNT_ADDRESS;
c0de36ae:	7721      	strb	r1, [r4, #28]
                msg->address = context->destinationAddress;
c0de36b0:	1c41      	adds	r1, r0, #1
                msg->amount = context->amount;
c0de36b2:	3016      	adds	r0, #22
c0de36b4:	6160      	str	r0, [r4, #20]
                msg->address = context->destinationAddress;
c0de36b6:	61a1      	str	r1, [r4, #24]
c0de36b8:	e086      	b.n	c0de37c8 <erc20_plugin_call+0x180>
            ethPluginProvideInfo_t *msg = (ethPluginProvideInfo_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
            PRINTF("erc20 plugin provide token 1: %d - 2: %d\n",
                   (msg->item1 != NULL),
                   (msg->item2 != NULL));
            if (msg->item1 != NULL) {
c0de36ba:	68e1      	ldr	r1, [r4, #12]
c0de36bc:	2900      	cmp	r1, #0
c0de36be:	d07c      	beq.n	c0de37ba <erc20_plugin_call+0x172>
c0de36c0:	68a5      	ldr	r5, [r4, #8]
c0de36c2:	462e      	mov	r6, r5
c0de36c4:	3642      	adds	r6, #66	; 0x42
c0de36c6:	2000      	movs	r0, #0
                context->target = TARGET_ADDRESS;
c0de36c8:	7070      	strb	r0, [r6, #1]
                strlcpy(context->ticker, msg->item1->token.ticker, MAX_TICKER_LEN);
c0de36ca:	4628      	mov	r0, r5
c0de36cc:	3036      	adds	r0, #54	; 0x36
c0de36ce:	3114      	adds	r1, #20
c0de36d0:	220c      	movs	r2, #12
c0de36d2:	f00a fa7f 	bl	c0dedbd4 <strlcpy>
                context->decimals = msg->item1->token.decimals;
c0de36d6:	68e0      	ldr	r0, [r4, #12]
c0de36d8:	2120      	movs	r1, #32
c0de36da:	5c40      	ldrb	r0, [r0, r1]
c0de36dc:	7030      	strb	r0, [r6, #0]
                if (context->selectorIndex == ERC20_APPROVE) {
c0de36de:	7828      	ldrb	r0, [r5, #0]
c0de36e0:	2801      	cmp	r0, #1
c0de36e2:	d106      	bne.n	c0de36f2 <erc20_plugin_call+0xaa>
                    if (check_contract(context)) {
c0de36e4:	4628      	mov	r0, r5
c0de36e6:	f7ff ff75 	bl	c0de35d4 <check_contract>
c0de36ea:	2800      	cmp	r0, #0
c0de36ec:	d001      	beq.n	c0de36f2 <erc20_plugin_call+0xaa>
c0de36ee:	2001      	movs	r0, #1
                        context->target = TARGET_CONTRACT;
c0de36f0:	7070      	strb	r0, [r6, #1]
c0de36f2:	2004      	movs	r0, #4
c0de36f4:	e062      	b.n	c0de37bc <erc20_plugin_call+0x174>
            }
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_ID: {
            ethQueryContractID_t *msg = (ethQueryContractID_t *) parameters;
            strlcpy(msg->name, "Type", msg->nameLength);
c0de36f6:	68e0      	ldr	r0, [r4, #12]
c0de36f8:	6922      	ldr	r2, [r4, #16]
c0de36fa:	4959      	ldr	r1, [pc, #356]	; (c0de3860 <erc20_plugin_call+0x218>)
c0de36fc:	4479      	add	r1, pc
c0de36fe:	f00a fa69 	bl	c0dedbd4 <strlcpy>
            strlcpy(msg->version, "Approve", msg->versionLength);
c0de3702:	6960      	ldr	r0, [r4, #20]
c0de3704:	69a2      	ldr	r2, [r4, #24]
c0de3706:	4957      	ldr	r1, [pc, #348]	; (c0de3864 <erc20_plugin_call+0x21c>)
c0de3708:	4479      	add	r1, pc
c0de370a:	f00a fa63 	bl	c0dedbd4 <strlcpy>
c0de370e:	2004      	movs	r0, #4
            msg->result = ETH_PLUGIN_RESULT_OK;
c0de3710:	7720      	strb	r0, [r4, #28]
c0de3712:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de3714:	4626      	mov	r6, r4
c0de3716:	3620      	adds	r6, #32
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0de3718:	7830      	ldrb	r0, [r6, #0]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0de371a:	69e5      	ldr	r5, [r4, #28]
c0de371c:	462f      	mov	r7, r5
c0de371e:	3742      	adds	r7, #66	; 0x42
            switch (msg->screenIndex) {
c0de3720:	2801      	cmp	r0, #1
c0de3722:	d056      	beq.n	c0de37d2 <erc20_plugin_call+0x18a>
c0de3724:	2800      	cmp	r0, #0
c0de3726:	d172      	bne.n	c0de380e <erc20_plugin_call+0x1c6>
                case 0:
                    strlcpy(msg->title, "Amount", msg->titleLength);
c0de3728:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de372a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de372c:	494e      	ldr	r1, [pc, #312]	; (c0de3868 <erc20_plugin_call+0x220>)
c0de372e:	4479      	add	r1, pc
c0de3730:	f00a fa50 	bl	c0dedbd4 <strlcpy>
                    if (ismaxint(context->amount, sizeof(context->amount))) {
c0de3734:	4628      	mov	r0, r5
c0de3736:	3016      	adds	r0, #22
c0de3738:	2100      	movs	r1, #0
static __attribute__((no_instrument_function)) inline int ismaxint(uint8_t *buf, int n) {
    for (int i = 0; i < n; ++i) {
c0de373a:	2920      	cmp	r1, #32
c0de373c:	d068      	beq.n	c0de3810 <erc20_plugin_call+0x1c8>
        if (buf[i] != 0xff) {
c0de373e:	5c42      	ldrb	r2, [r0, r1]
    for (int i = 0; i < n; ++i) {
c0de3740:	1c49      	adds	r1, r1, #1
        if (buf[i] != 0xff) {
c0de3742:	2aff      	cmp	r2, #255	; 0xff
c0de3744:	d0f9      	beq.n	c0de373a <erc20_plugin_call+0xf2>
                        strlcpy(msg->msg, "Unlimited ", msg->msgLength);
                        strlcat(msg->msg, context->ticker, msg->msgLength);
                    } else {
                        amountToString(context->amount,
                                       sizeof(context->amount),
                                       context->decimals,
c0de3746:	783a      	ldrb	r2, [r7, #0]
                                       context->ticker,
                                       msg->msg,
c0de3748:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de374a:	2364      	movs	r3, #100	; 0x64
                        amountToString(context->amount,
c0de374c:	9100      	str	r1, [sp, #0]
c0de374e:	9301      	str	r3, [sp, #4]
                                       context->ticker,
c0de3750:	3536      	adds	r5, #54	; 0x36
c0de3752:	2120      	movs	r1, #32
                        amountToString(context->amount,
c0de3754:	462b      	mov	r3, r5
c0de3756:	f008 ff0c 	bl	c0dec572 <amountToString>
c0de375a:	e078      	b.n	c0de384e <erc20_plugin_call+0x206>
            switch (msg->parameterOffset) {
c0de375c:	6921      	ldr	r1, [r4, #16]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0de375e:	68a0      	ldr	r0, [r4, #8]
            switch (msg->parameterOffset) {
c0de3760:	2924      	cmp	r1, #36	; 0x24
c0de3762:	d046      	beq.n	c0de37f2 <erc20_plugin_call+0x1aa>
c0de3764:	2904      	cmp	r1, #4
c0de3766:	d14b      	bne.n	c0de3800 <erc20_plugin_call+0x1b8>
                    memmove(context->destinationAddress, msg->parameter + 12, 20);
c0de3768:	68e1      	ldr	r1, [r4, #12]
c0de376a:	1c40      	adds	r0, r0, #1
c0de376c:	310c      	adds	r1, #12
c0de376e:	2214      	movs	r2, #20
c0de3770:	e042      	b.n	c0de37f8 <erc20_plugin_call+0x1b0>
c0de3772:	9302      	str	r3, [sp, #8]
c0de3774:	2500      	movs	r5, #0
c0de3776:	4f39      	ldr	r7, [pc, #228]	; (c0de385c <erc20_plugin_call+0x214>)
c0de3778:	447f      	add	r7, pc
c0de377a:	462e      	mov	r6, r5
                for (i = 0; i < NUM_ERC20_SELECTORS; i++) {
c0de377c:	2e02      	cmp	r6, #2
c0de377e:	d045      	beq.n	c0de380c <erc20_plugin_call+0x1c4>
                    if (memcmp((uint8_t *) PIC(ERC20_SELECTORS[i]), msg->selector, SELECTOR_SIZE) ==
c0de3780:	6838      	ldr	r0, [r7, #0]
c0de3782:	f004 fd5f 	bl	c0de8244 <pic>
c0de3786:	7801      	ldrb	r1, [r0, #0]
c0de3788:	7842      	ldrb	r2, [r0, #1]
c0de378a:	0212      	lsls	r2, r2, #8
c0de378c:	1851      	adds	r1, r2, r1
c0de378e:	7882      	ldrb	r2, [r0, #2]
c0de3790:	78c0      	ldrb	r0, [r0, #3]
c0de3792:	0200      	lsls	r0, r0, #8
c0de3794:	1880      	adds	r0, r0, r2
c0de3796:	0400      	lsls	r0, r0, #16
c0de3798:	1840      	adds	r0, r0, r1
c0de379a:	6961      	ldr	r1, [r4, #20]
c0de379c:	780a      	ldrb	r2, [r1, #0]
c0de379e:	784b      	ldrb	r3, [r1, #1]
c0de37a0:	021b      	lsls	r3, r3, #8
c0de37a2:	189a      	adds	r2, r3, r2
c0de37a4:	788b      	ldrb	r3, [r1, #2]
c0de37a6:	78c9      	ldrb	r1, [r1, #3]
c0de37a8:	0209      	lsls	r1, r1, #8
c0de37aa:	18c9      	adds	r1, r1, r3
c0de37ac:	0409      	lsls	r1, r1, #16
c0de37ae:	1889      	adds	r1, r1, r2
c0de37b0:	4288      	cmp	r0, r1
c0de37b2:	d028      	beq.n	c0de3806 <erc20_plugin_call+0x1be>
                for (i = 0; i < NUM_ERC20_SELECTORS; i++) {
c0de37b4:	1d3f      	adds	r7, r7, #4
c0de37b6:	1c76      	adds	r6, r6, #1
c0de37b8:	e7e0      	b.n	c0de377c <erc20_plugin_call+0x134>
c0de37ba:	2006      	movs	r0, #6
c0de37bc:	7560      	strb	r0, [r4, #21]
c0de37be:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de37c0:	2004      	movs	r0, #4
                msg->result = ETH_PLUGIN_RESULT_OK;
c0de37c2:	77a0      	strb	r0, [r4, #30]
c0de37c4:	4824      	ldr	r0, [pc, #144]	; (c0de3858 <erc20_plugin_call+0x210>)
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0de37c6:	83a0      	strh	r0, [r4, #28]
c0de37c8:	6860      	ldr	r0, [r4, #4]
c0de37ca:	6800      	ldr	r0, [r0, #0]
c0de37cc:	30a5      	adds	r0, #165	; 0xa5
c0de37ce:	60e0      	str	r0, [r4, #12]
c0de37d0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de37d2:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de37d4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                                       100);
                    }
                    msg->result = ETH_PLUGIN_RESULT_OK;
                    break;
                case 1:
                    if (context->target >= TARGET_CONTRACT) {
c0de37d6:	7879      	ldrb	r1, [r7, #1]
c0de37d8:	2900      	cmp	r1, #0
c0de37da:	d026      	beq.n	c0de382a <erc20_plugin_call+0x1e2>
                        strlcpy(msg->title, "Contract", msg->titleLength);
c0de37dc:	4923      	ldr	r1, [pc, #140]	; (c0de386c <erc20_plugin_call+0x224>)
c0de37de:	4479      	add	r1, pc
c0de37e0:	f00a f9f8 	bl	c0dedbd4 <strlcpy>
                        strlcpy(msg->msg, context->contract_name, msg->msgLength);
c0de37e4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de37e6:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de37e8:	3544      	adds	r5, #68	; 0x44
c0de37ea:	4629      	mov	r1, r5
c0de37ec:	f00a f9f2 	bl	c0dedbd4 <strlcpy>
c0de37f0:	e02d      	b.n	c0de384e <erc20_plugin_call+0x206>
                    memmove(context->amount, msg->parameter, 32);
c0de37f2:	68e1      	ldr	r1, [r4, #12]
c0de37f4:	3016      	adds	r0, #22
c0de37f6:	2220      	movs	r2, #32
c0de37f8:	f00a f816 	bl	c0ded828 <__aeabi_memmove>
c0de37fc:	2004      	movs	r0, #4
c0de37fe:	e000      	b.n	c0de3802 <erc20_plugin_call+0x1ba>
c0de3800:	2000      	movs	r0, #0
c0de3802:	7520      	strb	r0, [r4, #20]
c0de3804:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                        context->selectorIndex = i;
c0de3806:	9802      	ldr	r0, [sp, #8]
c0de3808:	7006      	strb	r6, [r0, #0]
c0de380a:	2504      	movs	r5, #4
c0de380c:	7065      	strb	r5, [r4, #1]
c0de380e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                        strlcpy(msg->msg, "Unlimited ", msg->msgLength);
c0de3810:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de3812:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3814:	4917      	ldr	r1, [pc, #92]	; (c0de3874 <erc20_plugin_call+0x22c>)
c0de3816:	4479      	add	r1, pc
c0de3818:	f00a f9dc 	bl	c0dedbd4 <strlcpy>
                        strlcat(msg->msg, context->ticker, msg->msgLength);
c0de381c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de381e:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3820:	3536      	adds	r5, #54	; 0x36
c0de3822:	4629      	mov	r1, r5
c0de3824:	f00a f9a2 	bl	c0dedb6c <strlcat>
c0de3828:	e011      	b.n	c0de384e <erc20_plugin_call+0x206>
                    } else {
                        strlcpy(msg->title, "Address", msg->titleLength);
c0de382a:	4911      	ldr	r1, [pc, #68]	; (c0de3870 <erc20_plugin_call+0x228>)
c0de382c:	4479      	add	r1, pc
c0de382e:	f00a f9d1 	bl	c0dedbd4 <strlcpy>
                        getEthDisplayableAddress(context->destinationAddress,
                                                 msg->msg,
                                                 msg->msgLength,
                                                 msg->pluginSharedRW->sha3,
                                                 chainConfig->chainId);
c0de3832:	4808      	ldr	r0, [pc, #32]	; (c0de3854 <erc20_plugin_call+0x20c>)
c0de3834:	4649      	mov	r1, r9
c0de3836:	5808      	ldr	r0, [r1, r0]
c0de3838:	6907      	ldr	r7, [r0, #16]
c0de383a:	6940      	ldr	r0, [r0, #20]
                                                 msg->msg,
c0de383c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
                                                 msg->msgLength,
c0de383e:	6b22      	ldr	r2, [r4, #48]	; 0x30
                                                 msg->pluginSharedRW->sha3,
c0de3840:	6823      	ldr	r3, [r4, #0]
c0de3842:	681b      	ldr	r3, [r3, #0]
                        getEthDisplayableAddress(context->destinationAddress,
c0de3844:	9700      	str	r7, [sp, #0]
c0de3846:	9001      	str	r0, [sp, #4]
c0de3848:	1c68      	adds	r0, r5, #1
c0de384a:	f000 fff7 	bl	c0de483c <getEthDisplayableAddress>
c0de384e:	2004      	movs	r0, #4
c0de3850:	7530      	strb	r0, [r6, #20]
c0de3852:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de3854:	00000590 	.word	0x00000590
c0de3858:	00000202 	.word	0x00000202
c0de385c:	0000c28c 	.word	0x0000c28c
c0de3860:	0000a8f0 	.word	0x0000a8f0
c0de3864:	0000a63f 	.word	0x0000a63f
c0de3868:	0000a74b 	.word	0x0000a74b
c0de386c:	0000a813 	.word	0x0000a813
c0de3870:	0000a971 	.word	0x0000a971
c0de3874:	0000a7a3 	.word	0x0000a7a3

c0de3878 <erc721_plugin_call>:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}

void erc721_plugin_call(int message, void *parameters) {
c0de3878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de387a:	460c      	mov	r4, r1
c0de387c:	2183      	movs	r1, #131	; 0x83
c0de387e:	0049      	lsls	r1, r1, #1
    switch (message) {
c0de3880:	4288      	cmp	r0, r1
c0de3882:	d01f      	beq.n	c0de38c4 <erc721_plugin_call+0x4c>
c0de3884:	2181      	movs	r1, #129	; 0x81
c0de3886:	0049      	lsls	r1, r1, #1
c0de3888:	4288      	cmp	r0, r1
c0de388a:	d01f      	beq.n	c0de38cc <erc721_plugin_call+0x54>
c0de388c:	21ff      	movs	r1, #255	; 0xff
c0de388e:	460a      	mov	r2, r1
c0de3890:	3204      	adds	r2, #4
c0de3892:	4290      	cmp	r0, r2
c0de3894:	d01e      	beq.n	c0de38d4 <erc721_plugin_call+0x5c>
c0de3896:	2241      	movs	r2, #65	; 0x41
c0de3898:	0092      	lsls	r2, r2, #2
c0de389a:	4290      	cmp	r0, r2
c0de389c:	d03a      	beq.n	c0de3914 <erc721_plugin_call+0x9c>
c0de389e:	460a      	mov	r2, r1
c0de38a0:	3206      	adds	r2, #6
c0de38a2:	4290      	cmp	r0, r2
c0de38a4:	d039      	beq.n	c0de391a <erc721_plugin_call+0xa2>
c0de38a6:	3102      	adds	r1, #2
c0de38a8:	4288      	cmp	r0, r1
c0de38aa:	d10e      	bne.n	c0de38ca <erc721_plugin_call+0x52>
    if (NO_NFT_METADATA) {
c0de38ac:	4847      	ldr	r0, [pc, #284]	; (c0de39cc <erc721_plugin_call+0x154>)
c0de38ae:	4649      	mov	r1, r9
c0de38b0:	1808      	adds	r0, r1, r0
c0de38b2:	30a7      	adds	r0, #167	; 0xa7
    erc721_context_t *context = (erc721_context_t *) msg->pluginContext;
c0de38b4:	68e5      	ldr	r5, [r4, #12]
c0de38b6:	215b      	movs	r1, #91	; 0x5b
    if (NO_NFT_METADATA) {
c0de38b8:	f000 f892 	bl	c0de39e0 <allzeroes>
c0de38bc:	2800      	cmp	r0, #0
c0de38be:	d048      	beq.n	c0de3952 <erc721_plugin_call+0xda>
c0de38c0:	2000      	movs	r0, #0
c0de38c2:	e06a      	b.n	c0de399a <erc721_plugin_call+0x122>
        } break;
        case ETH_PLUGIN_QUERY_CONTRACT_ID: {
            handle_query_contract_id(parameters);
        } break;
        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            handle_query_contract_ui_721(parameters);
c0de38c4:	4620      	mov	r0, r4
c0de38c6:	f000 f903 	bl	c0de3ad0 <handle_query_contract_ui_721>
        } break;
        default:
            PRINTF("Unhandled message %d\n", message);
            break;
    }
}
c0de38ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            handle_provide_parameter_721(parameters);
c0de38cc:	4620      	mov	r0, r4
c0de38ce:	f000 f893 	bl	c0de39f8 <handle_provide_parameter_721>
}
c0de38d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de38d4:	2500      	movs	r5, #0
    msg->tokenLookup2 = NULL;
c0de38d6:	6125      	str	r5, [r4, #16]
    msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0de38d8:	6860      	ldr	r0, [r4, #4]
    erc721_context_t *context = (erc721_context_t *) msg->pluginContext;
c0de38da:	68a1      	ldr	r1, [r4, #8]
    msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0de38dc:	6800      	ldr	r0, [r0, #0]
c0de38de:	4602      	mov	r2, r0
c0de38e0:	32a5      	adds	r2, #165	; 0xa5
c0de38e2:	60e2      	str	r2, [r4, #12]
c0de38e4:	2236      	movs	r2, #54	; 0x36
    switch (context->selectorIndex) {
c0de38e6:	5c8e      	ldrb	r6, [r1, r2]
c0de38e8:	1eb2      	subs	r2, r6, #2
c0de38ea:	2705      	movs	r7, #5
c0de38ec:	2104      	movs	r1, #4
c0de38ee:	2a03      	cmp	r2, #3
c0de38f0:	d305      	bcc.n	c0de38fe <erc721_plugin_call+0x86>
c0de38f2:	2e00      	cmp	r6, #0
c0de38f4:	d003      	beq.n	c0de38fe <erc721_plugin_call+0x86>
c0de38f6:	2e01      	cmp	r6, #1
c0de38f8:	d10a      	bne.n	c0de3910 <erc721_plugin_call+0x98>
c0de38fa:	2704      	movs	r7, #4
c0de38fc:	2103      	movs	r1, #3
c0de38fe:	7761      	strb	r1, [r4, #29]
    if (!allzeroes((void *) &msg->pluginSharedRO->txContent->value,
c0de3900:	3042      	adds	r0, #66	; 0x42
c0de3902:	2121      	movs	r1, #33	; 0x21
c0de3904:	f000 f86c 	bl	c0de39e0 <allzeroes>
c0de3908:	2800      	cmp	r0, #0
c0de390a:	d154      	bne.n	c0de39b6 <erc721_plugin_call+0x13e>
        if (context->selectorIndex == SET_APPROVAL_FOR_ALL) {
c0de390c:	2e01      	cmp	r6, #1
c0de390e:	d151      	bne.n	c0de39b4 <erc721_plugin_call+0x13c>
c0de3910:	77a5      	strb	r5, [r4, #30]
}
c0de3912:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3914:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de3916:	7560      	strb	r0, [r4, #21]
}
c0de3918:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de391a:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de391c:	7720      	strb	r0, [r4, #28]
    erc721_context_t *context = (erc721_context_t *) msg->pluginContext;
c0de391e:	68a5      	ldr	r5, [r4, #8]
    strlcpy(msg->name, "NFT", msg->nameLength);
c0de3920:	68e0      	ldr	r0, [r4, #12]
c0de3922:	6922      	ldr	r2, [r4, #16]
c0de3924:	492b      	ldr	r1, [pc, #172]	; (c0de39d4 <erc721_plugin_call+0x15c>)
c0de3926:	4479      	add	r1, pc
c0de3928:	f00a f954 	bl	c0dedbd4 <strlcpy>
c0de392c:	2036      	movs	r0, #54	; 0x36
    switch (context->selectorIndex) {
c0de392e:	5c28      	ldrb	r0, [r5, r0]
c0de3930:	1e81      	subs	r1, r0, #2
c0de3932:	2903      	cmp	r1, #3
c0de3934:	d204      	bcs.n	c0de3940 <erc721_plugin_call+0xc8>
            strlcpy(msg->version, "Transfer", msg->versionLength);
c0de3936:	6960      	ldr	r0, [r4, #20]
c0de3938:	69a2      	ldr	r2, [r4, #24]
c0de393a:	4928      	ldr	r1, [pc, #160]	; (c0de39dc <erc721_plugin_call+0x164>)
c0de393c:	4479      	add	r1, pc
c0de393e:	e005      	b.n	c0de394c <erc721_plugin_call+0xd4>
    switch (context->selectorIndex) {
c0de3940:	2801      	cmp	r0, #1
c0de3942:	d835      	bhi.n	c0de39b0 <erc721_plugin_call+0x138>
            strlcpy(msg->version, "Allowance", msg->versionLength);
c0de3944:	6960      	ldr	r0, [r4, #20]
c0de3946:	69a2      	ldr	r2, [r4, #24]
c0de3948:	4923      	ldr	r1, [pc, #140]	; (c0de39d8 <erc721_plugin_call+0x160>)
c0de394a:	4479      	add	r1, pc
c0de394c:	f00a f942 	bl	c0dedbd4 <strlcpy>
}
c0de3950:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3952:	3535      	adds	r5, #53	; 0x35
c0de3954:	2600      	movs	r6, #0
c0de3956:	4f1e      	ldr	r7, [pc, #120]	; (c0de39d0 <erc721_plugin_call+0x158>)
c0de3958:	447f      	add	r7, pc
    for (i = 0; i < SELECTORS_COUNT; i++) {
c0de395a:	2e05      	cmp	r6, #5
c0de395c:	d01c      	beq.n	c0de3998 <erc721_plugin_call+0x120>
        if (memcmp((uint8_t *) PIC(ERC721_SELECTORS[i]), msg->selector, SELECTOR_SIZE) == 0) {
c0de395e:	6838      	ldr	r0, [r7, #0]
c0de3960:	f004 fc70 	bl	c0de8244 <pic>
c0de3964:	7801      	ldrb	r1, [r0, #0]
c0de3966:	7842      	ldrb	r2, [r0, #1]
c0de3968:	0212      	lsls	r2, r2, #8
c0de396a:	1851      	adds	r1, r2, r1
c0de396c:	7882      	ldrb	r2, [r0, #2]
c0de396e:	78c0      	ldrb	r0, [r0, #3]
c0de3970:	0200      	lsls	r0, r0, #8
c0de3972:	1880      	adds	r0, r0, r2
c0de3974:	0400      	lsls	r0, r0, #16
c0de3976:	1840      	adds	r0, r0, r1
c0de3978:	6961      	ldr	r1, [r4, #20]
c0de397a:	780a      	ldrb	r2, [r1, #0]
c0de397c:	784b      	ldrb	r3, [r1, #1]
c0de397e:	021b      	lsls	r3, r3, #8
c0de3980:	189a      	adds	r2, r3, r2
c0de3982:	788b      	ldrb	r3, [r1, #2]
c0de3984:	78c9      	ldrb	r1, [r1, #3]
c0de3986:	0209      	lsls	r1, r1, #8
c0de3988:	18c9      	adds	r1, r1, r3
c0de398a:	0409      	lsls	r1, r1, #16
c0de398c:	1889      	adds	r1, r1, r2
c0de398e:	4288      	cmp	r0, r1
c0de3990:	d005      	beq.n	c0de399e <erc721_plugin_call+0x126>
    for (i = 0; i < SELECTORS_COUNT; i++) {
c0de3992:	1d3f      	adds	r7, r7, #4
c0de3994:	1c76      	adds	r6, r6, #1
c0de3996:	e7e0      	b.n	c0de395a <erc721_plugin_call+0xe2>
c0de3998:	2006      	movs	r0, #6
c0de399a:	7060      	strb	r0, [r4, #1]
}
c0de399c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de399e:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de39a0:	7060      	strb	r0, [r4, #1]
            context->selectorIndex = i;
c0de39a2:	706e      	strb	r6, [r5, #1]
    switch (context->selectorIndex) {
c0de39a4:	b2f1      	uxtb	r1, r6
c0de39a6:	1e8a      	subs	r2, r1, #2
c0de39a8:	2a03      	cmp	r2, #3
c0de39aa:	d209      	bcs.n	c0de39c0 <erc721_plugin_call+0x148>
c0de39ac:	2000      	movs	r0, #0
c0de39ae:	e00a      	b.n	c0de39c6 <erc721_plugin_call+0x14e>
c0de39b0:	2000      	movs	r0, #0
c0de39b2:	e003      	b.n	c0de39bc <erc721_plugin_call+0x144>
            msg->numScreens++;
c0de39b4:	7767      	strb	r7, [r4, #29]
c0de39b6:	2004      	movs	r0, #4
    msg->result = ETH_PLUGIN_RESULT_OK;
c0de39b8:	77a0      	strb	r0, [r4, #30]
c0de39ba:	2002      	movs	r0, #2
c0de39bc:	7720      	strb	r0, [r4, #28]
}
c0de39be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (context->selectorIndex) {
c0de39c0:	2901      	cmp	r1, #1
c0de39c2:	d900      	bls.n	c0de39c6 <erc721_plugin_call+0x14e>
c0de39c4:	e77c      	b.n	c0de38c0 <erc721_plugin_call+0x48>
c0de39c6:	7028      	strb	r0, [r5, #0]
}
c0de39c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de39ca:	46c0      	nop			; (mov r8, r8)
c0de39cc:	00000124 	.word	0x00000124
c0de39d0:	0000c07c 	.word	0x0000c07c
c0de39d4:	0000a64c 	.word	0x0000a64c
c0de39d8:	0000a481 	.word	0x0000a481
c0de39dc:	0000a858 	.word	0x0000a858

c0de39e0 <allzeroes>:
    for (size_t i = 0; i < n; ++i) {
c0de39e0:	2900      	cmp	r1, #0
c0de39e2:	d007      	beq.n	c0de39f4 <allzeroes+0x14>
        if (p[i]) {
c0de39e4:	1c42      	adds	r2, r0, #1
c0de39e6:	1e49      	subs	r1, r1, #1
c0de39e8:	7800      	ldrb	r0, [r0, #0]
c0de39ea:	2800      	cmp	r0, #0
c0de39ec:	4610      	mov	r0, r2
c0de39ee:	d0f7      	beq.n	c0de39e0 <allzeroes>
c0de39f0:	2000      	movs	r0, #0
}
c0de39f2:	4770      	bx	lr
c0de39f4:	2001      	movs	r0, #1
c0de39f6:	4770      	bx	lr

c0de39f8 <handle_provide_parameter_721>:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}

void handle_provide_parameter_721(void *parameters) {
c0de39f8:	b5b0      	push	{r4, r5, r7, lr}
c0de39fa:	2503      	movs	r5, #3
    PRINTF("erc721 plugin provide parameter %d %.*H\n",
           msg->parameterOffset,
           PARAMETER_LENGTH,
           msg->parameter);

    msg->result = ETH_PLUGIN_RESULT_SUCCESSFUL;
c0de39fc:	7505      	strb	r5, [r0, #20]
    erc721_context_t *context = (erc721_context_t *) msg->pluginContext;
c0de39fe:	6881      	ldr	r1, [r0, #8]
c0de3a00:	2236      	movs	r2, #54	; 0x36
    switch (context->selectorIndex) {
c0de3a02:	5c8a      	ldrb	r2, [r1, r2]
c0de3a04:	1e93      	subs	r3, r2, #2
c0de3a06:	2b02      	cmp	r3, #2
c0de3a08:	d314      	bcc.n	c0de3a34 <handle_provide_parameter_721+0x3c>
c0de3a0a:	2a04      	cmp	r2, #4
c0de3a0c:	d025      	beq.n	c0de3a5a <handle_provide_parameter_721+0x62>
c0de3a0e:	460c      	mov	r4, r1
c0de3a10:	3434      	adds	r4, #52	; 0x34
c0de3a12:	2a01      	cmp	r2, #1
c0de3a14:	d010      	beq.n	c0de3a38 <handle_provide_parameter_721+0x40>
c0de3a16:	2a00      	cmp	r2, #0
c0de3a18:	d11c      	bne.n	c0de3a54 <handle_provide_parameter_721+0x5c>
    switch (context->next_param) {
c0de3a1a:	7862      	ldrb	r2, [r4, #1]
c0de3a1c:	2a03      	cmp	r2, #3
c0de3a1e:	d020      	beq.n	c0de3a62 <handle_provide_parameter_721+0x6a>
c0de3a20:	2a04      	cmp	r2, #4
c0de3a22:	d117      	bne.n	c0de3a54 <handle_provide_parameter_721+0x5c>
            copy_address(context->address, msg->parameter, sizeof(context->address));
c0de3a24:	68c3      	ldr	r3, [r0, #12]
c0de3a26:	2214      	movs	r2, #20
c0de3a28:	4608      	mov	r0, r1
c0de3a2a:	4619      	mov	r1, r3
c0de3a2c:	f001 f9b2 	bl	c0de4d94 <copy_address>
            context->next_param = TOKEN_ID;
c0de3a30:	7065      	strb	r5, [r4, #1]
        default:
            PRINTF("Selector index %d not supported\n", context->selectorIndex);
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}
c0de3a32:	bdb0      	pop	{r4, r5, r7, pc}
c0de3a34:	2201      	movs	r2, #1
c0de3a36:	e011      	b.n	c0de3a5c <handle_provide_parameter_721+0x64>
    switch (context->next_param) {
c0de3a38:	7862      	ldrb	r2, [r4, #1]
c0de3a3a:	2a05      	cmp	r2, #5
c0de3a3c:	d01b      	beq.n	c0de3a76 <handle_provide_parameter_721+0x7e>
c0de3a3e:	2a04      	cmp	r2, #4
c0de3a40:	d108      	bne.n	c0de3a54 <handle_provide_parameter_721+0x5c>
c0de3a42:	2205      	movs	r2, #5
            context->next_param = APPROVED;
c0de3a44:	7062      	strb	r2, [r4, #1]
            copy_address(context->address, msg->parameter, sizeof(context->address));
c0de3a46:	68c3      	ldr	r3, [r0, #12]
c0de3a48:	2214      	movs	r2, #20
c0de3a4a:	4608      	mov	r0, r1
c0de3a4c:	4619      	mov	r1, r3
c0de3a4e:	f001 f9a1 	bl	c0de4d94 <copy_address>
}
c0de3a52:	bdb0      	pop	{r4, r5, r7, pc}
c0de3a54:	2100      	movs	r1, #0
c0de3a56:	7501      	strb	r1, [r0, #20]
c0de3a58:	bdb0      	pop	{r4, r5, r7, pc}
c0de3a5a:	2200      	movs	r2, #0
c0de3a5c:	f000 f813 	bl	c0de3a86 <handle_transfer>
c0de3a60:	bdb0      	pop	{r4, r5, r7, pc}
            copy_parameter(context->tokenId, msg->parameter, sizeof(context->tokenId));
c0de3a62:	68c3      	ldr	r3, [r0, #12]
c0de3a64:	3114      	adds	r1, #20
c0de3a66:	2220      	movs	r2, #32
c0de3a68:	4608      	mov	r0, r1
c0de3a6a:	4619      	mov	r1, r3
c0de3a6c:	f001 f99b 	bl	c0de4da6 <copy_parameter>
c0de3a70:	2006      	movs	r0, #6
            context->next_param = NONE;
c0de3a72:	7060      	strb	r0, [r4, #1]
}
c0de3a74:	bdb0      	pop	{r4, r5, r7, pc}
c0de3a76:	2106      	movs	r1, #6
            context->next_param = NONE;
c0de3a78:	7061      	strb	r1, [r4, #1]
            context->approved = msg->parameter[PARAMETER_LENGTH - 1];
c0de3a7a:	68c0      	ldr	r0, [r0, #12]
c0de3a7c:	7fc0      	ldrb	r0, [r0, #31]
c0de3a7e:	1e41      	subs	r1, r0, #1
c0de3a80:	4188      	sbcs	r0, r1
c0de3a82:	7020      	strb	r0, [r4, #0]
}
c0de3a84:	bdb0      	pop	{r4, r5, r7, pc}

c0de3a86 <handle_transfer>:
                            bool strict) {
c0de3a86:	b510      	push	{r4, lr}
c0de3a88:	2335      	movs	r3, #53	; 0x35
    switch (context->next_param) {
c0de3a8a:	5ccb      	ldrb	r3, [r1, r3]
c0de3a8c:	460c      	mov	r4, r1
c0de3a8e:	3435      	adds	r4, #53	; 0x35
c0de3a90:	2b03      	cmp	r3, #3
c0de3a92:	d005      	beq.n	c0de3aa0 <handle_transfer+0x1a>
c0de3a94:	2b01      	cmp	r3, #1
c0de3a96:	d00c      	beq.n	c0de3ab2 <handle_transfer+0x2c>
c0de3a98:	2b00      	cmp	r3, #0
c0de3a9a:	d113      	bne.n	c0de3ac4 <handle_transfer+0x3e>
c0de3a9c:	2001      	movs	r0, #1
c0de3a9e:	e00f      	b.n	c0de3ac0 <handle_transfer+0x3a>
            copy_parameter(context->tokenId, msg->parameter, sizeof(context->tokenId));
c0de3aa0:	68c3      	ldr	r3, [r0, #12]
c0de3aa2:	3114      	adds	r1, #20
c0de3aa4:	2220      	movs	r2, #32
c0de3aa6:	4608      	mov	r0, r1
c0de3aa8:	4619      	mov	r1, r3
c0de3aaa:	f001 f97c 	bl	c0de4da6 <copy_parameter>
c0de3aae:	2006      	movs	r0, #6
c0de3ab0:	e006      	b.n	c0de3ac0 <handle_transfer+0x3a>
            copy_address(context->address, msg->parameter, sizeof(context->address));
c0de3ab2:	68c3      	ldr	r3, [r0, #12]
c0de3ab4:	2214      	movs	r2, #20
c0de3ab6:	4608      	mov	r0, r1
c0de3ab8:	4619      	mov	r1, r3
c0de3aba:	f001 f96b 	bl	c0de4d94 <copy_address>
c0de3abe:	2003      	movs	r0, #3
c0de3ac0:	7020      	strb	r0, [r4, #0]
}
c0de3ac2:	bd10      	pop	{r4, pc}
            if (strict) {
c0de3ac4:	2a00      	cmp	r2, #0
c0de3ac6:	d001      	beq.n	c0de3acc <handle_transfer+0x46>
c0de3ac8:	2100      	movs	r1, #0
                msg->result = ETH_PLUGIN_RESULT_ERROR;
c0de3aca:	7501      	strb	r1, [r0, #20]
}
c0de3acc:	bd10      	pop	{r4, pc}
c0de3ace:	d4d4      	bmi.n	c0de3a7a <handle_provide_parameter_721+0x82>

c0de3ad0 <handle_query_contract_ui_721>:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            break;
    }
}

void handle_query_contract_ui_721(void *parameters) {
c0de3ad0:	b57c      	push	{r2, r3, r4, r5, r6, lr}
c0de3ad2:	4604      	mov	r4, r0
c0de3ad4:	2034      	movs	r0, #52	; 0x34
c0de3ad6:	2104      	movs	r1, #4
    ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
    erc721_context_t *context = (erc721_context_t *) msg->pluginContext;

    msg->result = ETH_PLUGIN_RESULT_OK;
c0de3ad8:	5421      	strb	r1, [r4, r0]
    erc721_context_t *context = (erc721_context_t *) msg->pluginContext;
c0de3ada:	69e5      	ldr	r5, [r4, #28]
c0de3adc:	2036      	movs	r0, #54	; 0x36
    switch (context->selectorIndex) {
c0de3ade:	5c29      	ldrb	r1, [r5, r0]
c0de3ae0:	1e8a      	subs	r2, r1, #2
c0de3ae2:	4620      	mov	r0, r4
c0de3ae4:	3020      	adds	r0, #32
c0de3ae6:	2a03      	cmp	r2, #3
c0de3ae8:	d20d      	bcs.n	c0de3b06 <handle_query_contract_ui_721+0x36>
    switch (msg->screenIndex) {
c0de3aea:	7801      	ldrb	r1, [r0, #0]
c0de3aec:	2903      	cmp	r1, #3
c0de3aee:	d041      	beq.n	c0de3b74 <handle_query_contract_ui_721+0xa4>
c0de3af0:	2901      	cmp	r1, #1
c0de3af2:	d04d      	beq.n	c0de3b90 <handle_query_contract_ui_721+0xc0>
c0de3af4:	2902      	cmp	r1, #2
c0de3af6:	d02a      	beq.n	c0de3b4e <handle_query_contract_ui_721+0x7e>
c0de3af8:	2900      	cmp	r1, #0
c0de3afa:	d125      	bne.n	c0de3b48 <handle_query_contract_ui_721+0x78>
            strlcpy(msg->title, "To", msg->titleLength);
c0de3afc:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3afe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3b00:	4940      	ldr	r1, [pc, #256]	; (c0de3c04 <handle_query_contract_ui_721+0x134>)
c0de3b02:	4479      	add	r1, pc
c0de3b04:	e05f      	b.n	c0de3bc6 <handle_query_contract_ui_721+0xf6>
    switch (context->selectorIndex) {
c0de3b06:	2901      	cmp	r1, #1
c0de3b08:	d00f      	beq.n	c0de3b2a <handle_query_contract_ui_721+0x5a>
c0de3b0a:	2900      	cmp	r1, #0
c0de3b0c:	d11c      	bne.n	c0de3b48 <handle_query_contract_ui_721+0x78>
    switch (msg->screenIndex) {
c0de3b0e:	7801      	ldrb	r1, [r0, #0]
c0de3b10:	2903      	cmp	r1, #3
c0de3b12:	d02f      	beq.n	c0de3b74 <handle_query_contract_ui_721+0xa4>
c0de3b14:	2901      	cmp	r1, #1
c0de3b16:	d045      	beq.n	c0de3ba4 <handle_query_contract_ui_721+0xd4>
c0de3b18:	2902      	cmp	r1, #2
c0de3b1a:	d018      	beq.n	c0de3b4e <handle_query_contract_ui_721+0x7e>
c0de3b1c:	2900      	cmp	r1, #0
c0de3b1e:	d113      	bne.n	c0de3b48 <handle_query_contract_ui_721+0x78>
            strlcpy(msg->title, "Allow", msg->titleLength);
c0de3b20:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3b22:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3b24:	4932      	ldr	r1, [pc, #200]	; (c0de3bf0 <handle_query_contract_ui_721+0x120>)
c0de3b26:	4479      	add	r1, pc
c0de3b28:	e04d      	b.n	c0de3bc6 <handle_query_contract_ui_721+0xf6>
    switch (msg->screenIndex) {
c0de3b2a:	7801      	ldrb	r1, [r0, #0]
c0de3b2c:	2902      	cmp	r1, #2
c0de3b2e:	d00e      	beq.n	c0de3b4e <handle_query_contract_ui_721+0x7e>
c0de3b30:	2901      	cmp	r1, #1
c0de3b32:	d032      	beq.n	c0de3b9a <handle_query_contract_ui_721+0xca>
c0de3b34:	2900      	cmp	r1, #0
c0de3b36:	d107      	bne.n	c0de3b48 <handle_query_contract_ui_721+0x78>
c0de3b38:	4628      	mov	r0, r5
c0de3b3a:	3034      	adds	r0, #52	; 0x34
            if (context->approved) {
c0de3b3c:	7800      	ldrb	r0, [r0, #0]
c0de3b3e:	2800      	cmp	r0, #0
c0de3b40:	d03d      	beq.n	c0de3bbe <handle_query_contract_ui_721+0xee>
c0de3b42:	492e      	ldr	r1, [pc, #184]	; (c0de3bfc <handle_query_contract_ui_721+0x12c>)
c0de3b44:	4479      	add	r1, pc
c0de3b46:	e03c      	b.n	c0de3bc2 <handle_query_contract_ui_721+0xf2>
c0de3b48:	2100      	movs	r1, #0
c0de3b4a:	7501      	strb	r1, [r0, #20]
        default:
            msg->result = ETH_PLUGIN_RESULT_ERROR;
            PRINTF("Unsupported selector index %d\n", context->selectorIndex);
            break;
    }
}
c0de3b4c:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
c0de3b4e:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3b50:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3b52:	492e      	ldr	r1, [pc, #184]	; (c0de3c0c <handle_query_contract_ui_721+0x13c>)
c0de3b54:	4479      	add	r1, pc
c0de3b56:	f00a f83d 	bl	c0dedbd4 <strlcpy>
c0de3b5a:	4823      	ldr	r0, [pc, #140]	; (c0de3be8 <handle_query_contract_ui_721+0x118>)
c0de3b5c:	464b      	mov	r3, r9
c0de3b5e:	5818      	ldr	r0, [r3, r0]
c0de3b60:	6905      	ldr	r5, [r0, #16]
c0de3b62:	6946      	ldr	r6, [r0, #20]
c0de3b64:	68a0      	ldr	r0, [r4, #8]
c0de3b66:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de3b68:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3b6a:	9500      	str	r5, [sp, #0]
c0de3b6c:	9601      	str	r6, [sp, #4]
c0de3b6e:	4c1f      	ldr	r4, [pc, #124]	; (c0de3bec <handle_query_contract_ui_721+0x11c>)
c0de3b70:	191b      	adds	r3, r3, r4
c0de3b72:	e036      	b.n	c0de3be2 <handle_query_contract_ui_721+0x112>
c0de3b74:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3b76:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3b78:	4925      	ldr	r1, [pc, #148]	; (c0de3c10 <handle_query_contract_ui_721+0x140>)
c0de3b7a:	4479      	add	r1, pc
c0de3b7c:	f00a f82a 	bl	c0dedbd4 <strlcpy>
c0de3b80:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
c0de3b82:	6b23      	ldr	r3, [r4, #48]	; 0x30
c0de3b84:	3514      	adds	r5, #20
c0de3b86:	2120      	movs	r1, #32
c0de3b88:	4628      	mov	r0, r5
c0de3b8a:	f008 fc87 	bl	c0dec49c <uint256_to_decimal>
c0de3b8e:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
            strlcpy(msg->title, "Collection Name", msg->titleLength);
c0de3b90:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3b92:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3b94:	491c      	ldr	r1, [pc, #112]	; (c0de3c08 <handle_query_contract_ui_721+0x138>)
c0de3b96:	4479      	add	r1, pc
c0de3b98:	e008      	b.n	c0de3bac <handle_query_contract_ui_721+0xdc>
            strlcpy(msg->title, "To Manage ALL", msg->titleLength);
c0de3b9a:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3b9c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3b9e:	4918      	ldr	r1, [pc, #96]	; (c0de3c00 <handle_query_contract_ui_721+0x130>)
c0de3ba0:	4479      	add	r1, pc
c0de3ba2:	e003      	b.n	c0de3bac <handle_query_contract_ui_721+0xdc>
            strlcpy(msg->title, "To Manage Your", msg->titleLength);
c0de3ba4:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3ba6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3ba8:	4912      	ldr	r1, [pc, #72]	; (c0de3bf4 <handle_query_contract_ui_721+0x124>)
c0de3baa:	4479      	add	r1, pc
c0de3bac:	f00a f812 	bl	c0dedbd4 <strlcpy>
c0de3bb0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de3bb2:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3bb4:	68a1      	ldr	r1, [r4, #8]
c0de3bb6:	3114      	adds	r1, #20
c0de3bb8:	f00a f80c 	bl	c0dedbd4 <strlcpy>
}
c0de3bbc:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
c0de3bbe:	490e      	ldr	r1, [pc, #56]	; (c0de3bf8 <handle_query_contract_ui_721+0x128>)
c0de3bc0:	4479      	add	r1, pc
c0de3bc2:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3bc4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3bc6:	f00a f805 	bl	c0dedbd4 <strlcpy>
c0de3bca:	4807      	ldr	r0, [pc, #28]	; (c0de3be8 <handle_query_contract_ui_721+0x118>)
c0de3bcc:	464b      	mov	r3, r9
c0de3bce:	5818      	ldr	r0, [r3, r0]
c0de3bd0:	6906      	ldr	r6, [r0, #16]
c0de3bd2:	6940      	ldr	r0, [r0, #20]
c0de3bd4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de3bd6:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3bd8:	9600      	str	r6, [sp, #0]
c0de3bda:	9001      	str	r0, [sp, #4]
c0de3bdc:	4803      	ldr	r0, [pc, #12]	; (c0de3bec <handle_query_contract_ui_721+0x11c>)
c0de3bde:	181b      	adds	r3, r3, r0
c0de3be0:	4628      	mov	r0, r5
c0de3be2:	f000 fe2b 	bl	c0de483c <getEthDisplayableAddress>
c0de3be6:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
c0de3be8:	00000590 	.word	0x00000590
c0de3bec:	000007e8 	.word	0x000007e8
c0de3bf0:	0000a795 	.word	0x0000a795
c0de3bf4:	0000a31f 	.word	0x0000a31f
c0de3bf8:	0000a722 	.word	0x0000a722
c0de3bfc:	0000a777 	.word	0x0000a777
c0de3c00:	0000a2e0 	.word	0x0000a2e0
c0de3c04:	0000a3c4 	.word	0x0000a3c4
c0de3c08:	0000a413 	.word	0x0000a413
c0de3c0c:	0000a670 	.word	0x0000a670
c0de3c10:	0000a6c6 	.word	0x0000a6c6

c0de3c14 <eth2_plugin_call>:
typedef struct eth2_deposit_parameters_t {
    uint8_t valid;
    char deposit_address[ETH2_DEPOSIT_PUBKEY_LENGTH];
} eth2_deposit_parameters_t;

void eth2_plugin_call(int message, void *parameters) {
c0de3c14:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de3c16:	b095      	sub	sp, #84	; 0x54
c0de3c18:	460c      	mov	r4, r1
c0de3c1a:	2183      	movs	r1, #131	; 0x83
c0de3c1c:	0049      	lsls	r1, r1, #1
    switch (message) {
c0de3c1e:	4288      	cmp	r0, r1
c0de3c20:	d01e      	beq.n	c0de3c60 <eth2_plugin_call+0x4c>
c0de3c22:	2181      	movs	r1, #129	; 0x81
c0de3c24:	0049      	lsls	r1, r1, #1
c0de3c26:	4288      	cmp	r0, r1
c0de3c28:	d039      	beq.n	c0de3c9e <eth2_plugin_call+0x8a>
c0de3c2a:	21ff      	movs	r1, #255	; 0xff
c0de3c2c:	460a      	mov	r2, r1
c0de3c2e:	3204      	adds	r2, #4
c0de3c30:	4290      	cmp	r0, r2
c0de3c32:	d054      	beq.n	c0de3cde <eth2_plugin_call+0xca>
c0de3c34:	460a      	mov	r2, r1
c0de3c36:	3206      	adds	r2, #6
c0de3c38:	4290      	cmp	r0, r2
c0de3c3a:	d059      	beq.n	c0de3cf0 <eth2_plugin_call+0xdc>
c0de3c3c:	3102      	adds	r1, #2
c0de3c3e:	4288      	cmp	r0, r1
c0de3c40:	d000      	beq.n	c0de3c44 <eth2_plugin_call+0x30>
c0de3c42:	e0b9      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
        case ETH_PLUGIN_INIT_CONTRACT: {
            ethPluginInitContract_t *msg = (ethPluginInitContract_t *) parameters;
            eth2_deposit_parameters_t *context = (eth2_deposit_parameters_t *) msg->pluginContext;
            if (memcmp(deposit_contract_address,
                       msg->pluginSharedRO->txContent->destination,
c0de3c44:	68a0      	ldr	r0, [r4, #8]
            eth2_deposit_parameters_t *context = (eth2_deposit_parameters_t *) msg->pluginContext;
c0de3c46:	68e5      	ldr	r5, [r4, #12]
                       msg->pluginSharedRO->txContent->destination,
c0de3c48:	6801      	ldr	r1, [r0, #0]
c0de3c4a:	31a5      	adds	r1, #165	; 0xa5
            if (memcmp(deposit_contract_address,
c0de3c4c:	4878      	ldr	r0, [pc, #480]	; (c0de3e30 <eth2_plugin_call+0x21c>)
c0de3c4e:	4478      	add	r0, pc
c0de3c50:	2214      	movs	r2, #20
c0de3c52:	f009 fdff 	bl	c0ded854 <memcmp>
c0de3c56:	2800      	cmp	r0, #0
c0de3c58:	d059      	beq.n	c0de3d0e <eth2_plugin_call+0xfa>
c0de3c5a:	2000      	movs	r0, #0
                       sizeof(deposit_contract_address)) != 0) {
                PRINTF("eth2plugin: failed to check deposit contract\n");
                context->valid = 0;
                msg->result = ETH_PLUGIN_RESULT_ERROR;
c0de3c5c:	7060      	strb	r0, [r4, #1]
c0de3c5e:	e059      	b.n	c0de3d14 <eth2_plugin_call+0x100>
c0de3c60:	4626      	mov	r6, r4
c0de3c62:	3620      	adds	r6, #32
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            eth2_deposit_parameters_t *context = (eth2_deposit_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0de3c64:	7830      	ldrb	r0, [r6, #0]
c0de3c66:	2801      	cmp	r0, #1
c0de3c68:	d059      	beq.n	c0de3d1e <eth2_plugin_call+0x10a>
c0de3c6a:	2800      	cmp	r0, #0
c0de3c6c:	d000      	beq.n	c0de3c70 <eth2_plugin_call+0x5c>
c0de3c6e:	e0a3      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
                case 0: {  // Amount screen
                    uint8_t decimals = WEI_TO_ETHER;
                    char *ticker = chainConfig->coinName;
c0de3c70:	4869      	ldr	r0, [pc, #420]	; (c0de3e18 <eth2_plugin_call+0x204>)
c0de3c72:	464f      	mov	r7, r9
c0de3c74:	583d      	ldr	r5, [r7, r0]
                    strlcpy(msg->title, "Amount", msg->titleLength);
c0de3c76:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3c78:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3c7a:	4970      	ldr	r1, [pc, #448]	; (c0de3e3c <eth2_plugin_call+0x228>)
c0de3c7c:	4479      	add	r1, pc
c0de3c7e:	f009 ffa9 	bl	c0dedbd4 <strlcpy>
                    amountToString(tmpContent.txContent.value.value,
                                   tmpContent.txContent.value.length,
c0de3c82:	4866      	ldr	r0, [pc, #408]	; (c0de3e1c <eth2_plugin_call+0x208>)
c0de3c84:	1838      	adds	r0, r7, r0
c0de3c86:	2162      	movs	r1, #98	; 0x62
c0de3c88:	5c41      	ldrb	r1, [r0, r1]
                                   decimals,
                                   ticker,
                                   msg->msg,
c0de3c8a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
c0de3c8c:	2364      	movs	r3, #100	; 0x64
                    amountToString(tmpContent.txContent.value.value,
c0de3c8e:	9200      	str	r2, [sp, #0]
c0de3c90:	9301      	str	r3, [sp, #4]
c0de3c92:	3042      	adds	r0, #66	; 0x42
c0de3c94:	2212      	movs	r2, #18
c0de3c96:	462b      	mov	r3, r5
c0de3c98:	f008 fc6b 	bl	c0dec572 <amountToString>
c0de3c9c:	e04b      	b.n	c0de3d36 <eth2_plugin_call+0x122>
            switch (msg->parameterOffset) {
c0de3c9e:	6920      	ldr	r0, [r4, #16]
c0de3ca0:	1f00      	subs	r0, r0, #4
c0de3ca2:	2105      	movs	r1, #5
c0de3ca4:	41c8      	rors	r0, r1
c0de3ca6:	4601      	mov	r1, r0
c0de3ca8:	390a      	subs	r1, #10
c0de3caa:	2903      	cmp	r1, #3
c0de3cac:	d200      	bcs.n	c0de3cb0 <eth2_plugin_call+0x9c>
c0de3cae:	e081      	b.n	c0de3db4 <eth2_plugin_call+0x1a0>
c0de3cb0:	68a5      	ldr	r5, [r4, #8]
c0de3cb2:	2800      	cmp	r0, #0
c0de3cb4:	d042      	beq.n	c0de3d3c <eth2_plugin_call+0x128>
c0de3cb6:	2809      	cmp	r0, #9
c0de3cb8:	d042      	beq.n	c0de3d40 <eth2_plugin_call+0x12c>
c0de3cba:	2802      	cmp	r0, #2
c0de3cbc:	d042      	beq.n	c0de3d44 <eth2_plugin_call+0x130>
c0de3cbe:	2803      	cmp	r0, #3
c0de3cc0:	d078      	beq.n	c0de3db4 <eth2_plugin_call+0x1a0>
c0de3cc2:	2804      	cmp	r0, #4
c0de3cc4:	d041      	beq.n	c0de3d4a <eth2_plugin_call+0x136>
c0de3cc6:	2805      	cmp	r0, #5
c0de3cc8:	d041      	beq.n	c0de3d4e <eth2_plugin_call+0x13a>
c0de3cca:	2806      	cmp	r0, #6
c0de3ccc:	d045      	beq.n	c0de3d5a <eth2_plugin_call+0x146>
c0de3cce:	2807      	cmp	r0, #7
c0de3cd0:	d060      	beq.n	c0de3d94 <eth2_plugin_call+0x180>
c0de3cd2:	2808      	cmp	r0, #8
c0de3cd4:	d072      	beq.n	c0de3dbc <eth2_plugin_call+0x1a8>
c0de3cd6:	2801      	cmp	r0, #1
c0de3cd8:	d16e      	bne.n	c0de3db8 <eth2_plugin_call+0x1a4>
c0de3cda:	20e0      	movs	r0, #224	; 0xe0
c0de3cdc:	e05b      	b.n	c0de3d96 <eth2_plugin_call+0x182>
            eth2_deposit_parameters_t *context = (eth2_deposit_parameters_t *) msg->pluginContext;
c0de3cde:	68a0      	ldr	r0, [r4, #8]
            if (context->valid) {
c0de3ce0:	7800      	ldrb	r0, [r0, #0]
c0de3ce2:	2800      	cmp	r0, #0
c0de3ce4:	d018      	beq.n	c0de3d18 <eth2_plugin_call+0x104>
c0de3ce6:	2004      	movs	r0, #4
                msg->result = ETH_PLUGIN_RESULT_OK;
c0de3ce8:	77a0      	strb	r0, [r4, #30]
c0de3cea:	484d      	ldr	r0, [pc, #308]	; (c0de3e20 <eth2_plugin_call+0x20c>)
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0de3cec:	83a0      	strh	r0, [r4, #28]
c0de3cee:	e063      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
            strlcpy(msg->name, "ETH2", msg->nameLength);
c0de3cf0:	68e0      	ldr	r0, [r4, #12]
c0de3cf2:	6922      	ldr	r2, [r4, #16]
c0de3cf4:	494f      	ldr	r1, [pc, #316]	; (c0de3e34 <eth2_plugin_call+0x220>)
c0de3cf6:	4479      	add	r1, pc
c0de3cf8:	f009 ff6c 	bl	c0dedbd4 <strlcpy>
            strlcpy(msg->version, "Deposit", msg->versionLength);
c0de3cfc:	6960      	ldr	r0, [r4, #20]
c0de3cfe:	69a2      	ldr	r2, [r4, #24]
c0de3d00:	494d      	ldr	r1, [pc, #308]	; (c0de3e38 <eth2_plugin_call+0x224>)
c0de3d02:	4479      	add	r1, pc
c0de3d04:	f009 ff66 	bl	c0dedbd4 <strlcpy>
c0de3d08:	2004      	movs	r0, #4
            msg->result = ETH_PLUGIN_RESULT_OK;
c0de3d0a:	7720      	strb	r0, [r4, #28]
c0de3d0c:	e054      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
c0de3d0e:	2004      	movs	r0, #4
                msg->result = ETH_PLUGIN_RESULT_OK;
c0de3d10:	7060      	strb	r0, [r4, #1]
c0de3d12:	2001      	movs	r0, #1
c0de3d14:	7028      	strb	r0, [r5, #0]
c0de3d16:	e04f      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
c0de3d18:	2006      	movs	r0, #6
                msg->result = ETH_PLUGIN_RESULT_FALLBACK;
c0de3d1a:	77a0      	strb	r0, [r4, #30]
c0de3d1c:	e04c      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
            eth2_deposit_parameters_t *context = (eth2_deposit_parameters_t *) msg->pluginContext;
c0de3d1e:	69e5      	ldr	r5, [r4, #28]
                                   100);
                    msg->result = ETH_PLUGIN_RESULT_OK;
                } break;
                case 1: {  // Deposit pubkey screen
                    strlcpy(msg->title, "Validator", msg->titleLength);
c0de3d20:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de3d22:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de3d24:	4946      	ldr	r1, [pc, #280]	; (c0de3e40 <eth2_plugin_call+0x22c>)
c0de3d26:	4479      	add	r1, pc
c0de3d28:	f009 ff54 	bl	c0dedbd4 <strlcpy>
                    strlcpy(msg->msg, context->deposit_address, msg->msgLength);
c0de3d2c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de3d2e:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de3d30:	1c69      	adds	r1, r5, #1
c0de3d32:	f009 ff4f 	bl	c0dedbd4 <strlcpy>
c0de3d36:	2004      	movs	r0, #4
c0de3d38:	7530      	strb	r0, [r6, #20]
c0de3d3a:	e03d      	b.n	c0de3db8 <eth2_plugin_call+0x1a4>
c0de3d3c:	2080      	movs	r0, #128	; 0x80
c0de3d3e:	e02a      	b.n	c0de3d96 <eth2_plugin_call+0x182>
c0de3d40:	2060      	movs	r0, #96	; 0x60
c0de3d42:	e028      	b.n	c0de3d96 <eth2_plugin_call+0x182>
c0de3d44:	2009      	movs	r0, #9
c0de3d46:	0140      	lsls	r0, r0, #5
c0de3d48:	e025      	b.n	c0de3d96 <eth2_plugin_call+0x182>
c0de3d4a:	2030      	movs	r0, #48	; 0x30
c0de3d4c:	e023      	b.n	c0de3d96 <eth2_plugin_call+0x182>
                           msg->parameter,
c0de3d4e:	68e1      	ldr	r1, [r4, #12]
                    memcpy(context->deposit_address,
c0de3d50:	1c68      	adds	r0, r5, #1
c0de3d52:	2230      	movs	r2, #48	; 0x30
c0de3d54:	f009 fd64 	bl	c0ded820 <__aeabi_memcpy>
c0de3d58:	e02c      	b.n	c0de3db4 <eth2_plugin_call+0x1a0>
                           msg->parameter,
c0de3d5a:	68e1      	ldr	r1, [r4, #12]
                    memcpy(context->deposit_address + 32,
c0de3d5c:	4628      	mov	r0, r5
c0de3d5e:	3021      	adds	r0, #33	; 0x21
c0de3d60:	2210      	movs	r2, #16
c0de3d62:	f009 fd5d 	bl	c0ded820 <__aeabi_memcpy>
                                             chainConfig->chainId);
c0de3d66:	482c      	ldr	r0, [pc, #176]	; (c0de3e18 <eth2_plugin_call+0x204>)
c0de3d68:	4649      	mov	r1, r9
c0de3d6a:	5808      	ldr	r0, [r1, r0]
c0de3d6c:	6901      	ldr	r1, [r0, #16]
c0de3d6e:	6940      	ldr	r0, [r0, #20]
                                             msg->pluginSharedRW->sha3,
c0de3d70:	6822      	ldr	r2, [r4, #0]
c0de3d72:	6813      	ldr	r3, [r2, #0]
                    getEthDisplayableAddress((uint8_t *) context->deposit_address,
c0de3d74:	9100      	str	r1, [sp, #0]
c0de3d76:	9001      	str	r0, [sp, #4]
                    memcpy(context->deposit_address + 32,
c0de3d78:	1c6d      	adds	r5, r5, #1
c0de3d7a:	ae09      	add	r6, sp, #36	; 0x24
c0de3d7c:	2730      	movs	r7, #48	; 0x30
                    getEthDisplayableAddress((uint8_t *) context->deposit_address,
c0de3d7e:	4628      	mov	r0, r5
c0de3d80:	4631      	mov	r1, r6
c0de3d82:	463a      	mov	r2, r7
c0de3d84:	f000 fd5a 	bl	c0de483c <getEthDisplayableAddress>
                    strlcpy(context->deposit_address, tmp, ETH2_DEPOSIT_PUBKEY_LENGTH);
c0de3d88:	4628      	mov	r0, r5
c0de3d8a:	4631      	mov	r1, r6
c0de3d8c:	463a      	mov	r2, r7
c0de3d8e:	f009 ff21 	bl	c0dedbd4 <strlcpy>
c0de3d92:	e00f      	b.n	c0de3db4 <eth2_plugin_call+0x1a0>
c0de3d94:	2020      	movs	r0, #32
                    index = U4BE(msg->parameter, 32 - 4);
c0de3d96:	68e1      	ldr	r1, [r4, #12]
c0de3d98:	7f0a      	ldrb	r2, [r1, #28]
c0de3d9a:	0612      	lsls	r2, r2, #24
c0de3d9c:	7f4b      	ldrb	r3, [r1, #29]
c0de3d9e:	041b      	lsls	r3, r3, #16
c0de3da0:	189a      	adds	r2, r3, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de3da2:	7f8b      	ldrb	r3, [r1, #30]
c0de3da4:	021b      	lsls	r3, r3, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de3da6:	18d2      	adds	r2, r2, r3
         (buf[off + 2] << 8) | buf[off + 3];
c0de3da8:	7fc9      	ldrb	r1, [r1, #31]
c0de3daa:	1851      	adds	r1, r2, r1
                    if (index != check) {
c0de3dac:	4281      	cmp	r1, r0
c0de3dae:	d001      	beq.n	c0de3db4 <eth2_plugin_call+0x1a0>
c0de3db0:	2000      	movs	r0, #0
                        context->valid = 0;
c0de3db2:	7028      	strb	r0, [r5, #0]
c0de3db4:	2004      	movs	r0, #4
c0de3db6:	7520      	strb	r0, [r4, #20]
        } break;

        default:
            PRINTF("Unhandled message %d\n", message);
    }
}
c0de3db8:	b015      	add	sp, #84	; 0x54
c0de3dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de3dbc:	20e1      	movs	r0, #225	; 0xe1
c0de3dbe:	0100      	lsls	r0, r0, #4
                    withdrawalKeyPath[1] = WITHDRAWAL_KEY_PATH_2;
c0de3dc0:	9006      	str	r0, [sp, #24]
c0de3dc2:	4818      	ldr	r0, [pc, #96]	; (c0de3e24 <eth2_plugin_call+0x210>)
                    withdrawalKeyPath[0] = WITHDRAWAL_KEY_PATH_1;
c0de3dc4:	9005      	str	r0, [sp, #20]
                    if (eth2WithdrawalIndex > INDEX_MAX) {
c0de3dc6:	4818      	ldr	r0, [pc, #96]	; (c0de3e28 <eth2_plugin_call+0x214>)
c0de3dc8:	4649      	mov	r1, r9
c0de3dca:	5808      	ldr	r0, [r1, r0]
c0de3dcc:	4917      	ldr	r1, [pc, #92]	; (c0de3e2c <eth2_plugin_call+0x218>)
c0de3dce:	4288      	cmp	r0, r1
c0de3dd0:	d302      	bcc.n	c0de3dd8 <eth2_plugin_call+0x1c4>
c0de3dd2:	2100      	movs	r1, #0
                        context->valid = 0;
c0de3dd4:	7029      	strb	r1, [r5, #0]
                        msg->result = ETH_PLUGIN_RESULT_ERROR;
c0de3dd6:	7521      	strb	r1, [r4, #20]
c0de3dd8:	2700      	movs	r7, #0
                    withdrawalKeyPath[3] = WITHDRAWAL_KEY_PATH_4;
c0de3dda:	9708      	str	r7, [sp, #32]
                    withdrawalKeyPath[2] = eth2WithdrawalIndex;
c0de3ddc:	9007      	str	r0, [sp, #28]
c0de3dde:	a805      	add	r0, sp, #20
c0de3de0:	2104      	movs	r1, #4
c0de3de2:	ae09      	add	r6, sp, #36	; 0x24
c0de3de4:	9102      	str	r1, [sp, #8]
                    getEth2PublicKey(withdrawalKeyPath, 4, tmp);
c0de3de6:	4632      	mov	r2, r6
c0de3de8:	f7fd fae6 	bl	c0de13b8 <getEth2PublicKey>
c0de3dec:	2130      	movs	r1, #48	; 0x30
c0de3dee:	2320      	movs	r3, #32
                    cx_hash_sha256(tmp, 48, tmp, 32);
c0de3df0:	9304      	str	r3, [sp, #16]
c0de3df2:	4630      	mov	r0, r6
c0de3df4:	4632      	mov	r2, r6
c0de3df6:	f7ff f947 	bl	c0de3088 <cx_hash_sha256>
c0de3dfa:	9703      	str	r7, [sp, #12]
                    tmp[0] = 0;
c0de3dfc:	7037      	strb	r7, [r6, #0]
                    if (memcmp(tmp, msg->parameter, 32) != 0) {
c0de3dfe:	68e1      	ldr	r1, [r4, #12]
c0de3e00:	4630      	mov	r0, r6
c0de3e02:	9a04      	ldr	r2, [sp, #16]
c0de3e04:	f009 fd26 	bl	c0ded854 <memcmp>
c0de3e08:	2800      	cmp	r0, #0
c0de3e0a:	d002      	beq.n	c0de3e12 <eth2_plugin_call+0x1fe>
c0de3e0c:	9803      	ldr	r0, [sp, #12]
                        context->valid = 0;
c0de3e0e:	7028      	strb	r0, [r5, #0]
c0de3e10:	e7d1      	b.n	c0de3db6 <eth2_plugin_call+0x1a2>
                        msg->result = ETH_PLUGIN_RESULT_OK;
c0de3e12:	9802      	ldr	r0, [sp, #8]
c0de3e14:	e7cf      	b.n	c0de3db6 <eth2_plugin_call+0x1a2>
c0de3e16:	46c0      	nop			; (mov r8, r8)
c0de3e18:	00000590 	.word	0x00000590
c0de3e1c:	0000026c 	.word	0x0000026c
c0de3e20:	00000202 	.word	0x00000202
c0de3e24:	0000305d 	.word	0x0000305d
c0de3e28:	00000120 	.word	0x00000120
c0de3e2c:	00010001 	.word	0x00010001
c0de3e30:	0000bd9a 	.word	0x0000bd9a
c0de3e34:	0000a1e2 	.word	0x0000a1e2
c0de3e38:	0000a55f 	.word	0x0000a55f
c0de3e3c:	0000a1fd 	.word	0x0000a1fd
c0de3e40:	0000a168 	.word	0x0000a168

c0de3e44 <initTx>:

void initTx(txContext_t *context,
            cx_sha3_t *sha3,
            txContent_t *content,
            ustreamProcess_t customProcessor,
            void *extra) {
c0de3e44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de3e46:	461d      	mov	r5, r3
c0de3e48:	4616      	mov	r6, r2
c0de3e4a:	460c      	mov	r4, r1
c0de3e4c:	4607      	mov	r7, r0
c0de3e4e:	2140      	movs	r1, #64	; 0x40
    memset(context, 0, sizeof(txContext_t));
c0de3e50:	f009 fce0 	bl	c0ded814 <__aeabi_memclr>
    context->sha3 = sha3;
    context->content = content;
c0de3e54:	637e      	str	r6, [r7, #52]	; 0x34
    context->sha3 = sha3;
c0de3e56:	607c      	str	r4, [r7, #4]
c0de3e58:	9806      	ldr	r0, [sp, #24]
    context->customProcessor = customProcessor;
    context->extra = extra;
c0de3e5a:	63b8      	str	r0, [r7, #56]	; 0x38
    context->customProcessor = customProcessor;
c0de3e5c:	633d      	str	r5, [r7, #48]	; 0x30
c0de3e5e:	2001      	movs	r0, #1
    context->currentField = RLP_NONE + 1;
c0de3e60:	7038      	strb	r0, [r7, #0]
c0de3e62:	0201      	lsls	r1, r0, #8
c0de3e64:	4620      	mov	r0, r4
c0de3e66:	f7ff f91b 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de3e6a:	2800      	cmp	r0, #0
c0de3e6c:	d100      	bne.n	c0de3e70 <initTx+0x2c>
    cx_keccak_init(context->sha3, 256);
}
c0de3e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de3e70:	f003 fad9 	bl	c0de7426 <os_longjmp>

c0de3e74 <readTxByte>:

uint8_t readTxByte(txContext_t *context) {
c0de3e74:	b51c      	push	{r2, r3, r4, lr}
    uint8_t data;
    if (context->commandLength < 1) {
c0de3e76:	6a82      	ldr	r2, [r0, #40]	; 0x28
c0de3e78:	2a00      	cmp	r2, #0
c0de3e7a:	d019      	beq.n	c0de3eb0 <readTxByte+0x3c>
        PRINTF("readTxByte Underflow\n");
        THROW(EXCEPTION);
    }
    data = *context->workBuffer;
c0de3e7c:	6a43      	ldr	r3, [r0, #36]	; 0x24
c0de3e7e:	7819      	ldrb	r1, [r3, #0]
c0de3e80:	ac01      	add	r4, sp, #4
c0de3e82:	7021      	strb	r1, [r4, #0]
    context->workBuffer++;
    context->commandLength--;
c0de3e84:	1e52      	subs	r2, r2, #1
    context->workBuffer++;
c0de3e86:	1c5b      	adds	r3, r3, #1
c0de3e88:	6243      	str	r3, [r0, #36]	; 0x24
    context->commandLength--;
c0de3e8a:	6282      	str	r2, [r0, #40]	; 0x28
    if (context->processingField) {
c0de3e8c:	7c42      	ldrb	r2, [r0, #17]
c0de3e8e:	2a00      	cmp	r2, #0
c0de3e90:	d005      	beq.n	c0de3e9e <readTxByte+0x2a>
        context->currentFieldPos++;
c0de3e92:	68c2      	ldr	r2, [r0, #12]
c0de3e94:	1c52      	adds	r2, r2, #1
c0de3e96:	60c2      	str	r2, [r0, #12]
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0de3e98:	7c82      	ldrb	r2, [r0, #18]
c0de3e9a:	2a00      	cmp	r2, #0
c0de3e9c:	d106      	bne.n	c0de3eac <readTxByte+0x38>
        cx_hash((cx_hash_t *) context->sha3, 0, &data, 1, NULL, 0);
c0de3e9e:	6840      	ldr	r0, [r0, #4]
c0de3ea0:	ac01      	add	r4, sp, #4
c0de3ea2:	2201      	movs	r2, #1
c0de3ea4:	4621      	mov	r1, r4
c0de3ea6:	f000 f806 	bl	c0de3eb6 <cx_hash>
    }
    return data;
c0de3eaa:	7821      	ldrb	r1, [r4, #0]
c0de3eac:	4608      	mov	r0, r1
c0de3eae:	bd1c      	pop	{r2, r3, r4, pc}
c0de3eb0:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de3eb2:	f003 fab8 	bl	c0de7426 <os_longjmp>

c0de3eb6 <cx_hash>:
{
c0de3eb6:	b51c      	push	{r2, r3, r4, lr}
c0de3eb8:	4613      	mov	r3, r2
c0de3eba:	460a      	mov	r2, r1
c0de3ebc:	4604      	mov	r4, r0
c0de3ebe:	2100      	movs	r1, #0
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de3ec0:	9100      	str	r1, [sp, #0]
c0de3ec2:	9101      	str	r1, [sp, #4]
c0de3ec4:	f7ff f8da 	bl	c0de307c <cx_hash_no_throw>
c0de3ec8:	2800      	cmp	r0, #0
c0de3eca:	d103      	bne.n	c0de3ed4 <cx_hash+0x1e>
  return cx_hash_get_size(hash);
c0de3ecc:	4620      	mov	r0, r4
c0de3ece:	f7ff f8cf 	bl	c0de3070 <cx_hash_get_size>
c0de3ed2:	bd1c      	pop	{r2, r3, r4, pc}
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de3ed4:	f003 faa7 	bl	c0de7426 <os_longjmp>

c0de3ed8 <copyTxData>:
}

void copyTxData(txContext_t *context, uint8_t *out, uint32_t length) {
c0de3ed8:	b5b0      	push	{r4, r5, r7, lr}
c0de3eda:	4605      	mov	r5, r0
    if (context->commandLength < length) {
c0de3edc:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0de3ede:	4290      	cmp	r0, r2
c0de3ee0:	d327      	bcc.n	c0de3f32 <copyTxData+0x5a>
c0de3ee2:	4614      	mov	r4, r2
        PRINTF("copyTxData Underflow\n");
        THROW(EXCEPTION);
    }
    if (out != NULL) {
c0de3ee4:	2900      	cmp	r1, #0
c0de3ee6:	d005      	beq.n	c0de3ef4 <copyTxData+0x1c>
        memmove(out, context->workBuffer, length);
c0de3ee8:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0de3eea:	4608      	mov	r0, r1
c0de3eec:	4611      	mov	r1, r2
c0de3eee:	4622      	mov	r2, r4
c0de3ef0:	f009 fc9a 	bl	c0ded828 <__aeabi_memmove>
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0de3ef4:	7c68      	ldrb	r0, [r5, #17]
c0de3ef6:	2800      	cmp	r0, #0
c0de3ef8:	d009      	beq.n	c0de3f0e <copyTxData+0x36>
c0de3efa:	7ca8      	ldrb	r0, [r5, #18]
c0de3efc:	2800      	cmp	r0, #0
c0de3efe:	d006      	beq.n	c0de3f0e <copyTxData+0x36>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
    }
    context->workBuffer += length;
c0de3f00:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0de3f02:	1900      	adds	r0, r0, r4
c0de3f04:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0de3f06:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0de3f08:	1b00      	subs	r0, r0, r4
c0de3f0a:	62a8      	str	r0, [r5, #40]	; 0x28
c0de3f0c:	e00d      	b.n	c0de3f2a <copyTxData+0x52>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
c0de3f0e:	6a69      	ldr	r1, [r5, #36]	; 0x24
c0de3f10:	6868      	ldr	r0, [r5, #4]
c0de3f12:	4622      	mov	r2, r4
c0de3f14:	f7ff ffcf 	bl	c0de3eb6 <cx_hash>
    context->workBuffer += length;
c0de3f18:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0de3f1a:	1900      	adds	r0, r0, r4
c0de3f1c:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0de3f1e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0de3f20:	1b00      	subs	r0, r0, r4
c0de3f22:	62a8      	str	r0, [r5, #40]	; 0x28
    if (context->processingField) {
c0de3f24:	7c68      	ldrb	r0, [r5, #17]
c0de3f26:	2800      	cmp	r0, #0
c0de3f28:	d002      	beq.n	c0de3f30 <copyTxData+0x58>
        context->currentFieldPos += length;
c0de3f2a:	68e8      	ldr	r0, [r5, #12]
c0de3f2c:	1900      	adds	r0, r0, r4
c0de3f2e:	60e8      	str	r0, [r5, #12]
    }
}
c0de3f30:	bdb0      	pop	{r4, r5, r7, pc}
c0de3f32:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de3f34:	f003 fa77 	bl	c0de7426 <os_longjmp>

c0de3f38 <processTx>:
}

parserStatus_e processTx(txContext_t *context,
                         uint8_t *buffer,
                         uint32_t length,
                         uint32_t processingFlags) {
c0de3f38:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de3f3a:	b08d      	sub	sp, #52	; 0x34
c0de3f3c:	9300      	str	r3, [sp, #0]
c0de3f3e:	4616      	mov	r6, r2
c0de3f40:	460f      	mov	r7, r1
c0de3f42:	4604      	mov	r4, r0
c0de3f44:	ad01      	add	r5, sp, #4
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0de3f46:	4628      	mov	r0, r5
c0de3f48:	f009 fdb2 	bl	c0dedab0 <setjmp>
c0de3f4c:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0de3f4e:	0400      	lsls	r0, r0, #16
c0de3f50:	d007      	beq.n	c0de3f62 <processTx+0x2a>
c0de3f52:	a801      	add	r0, sp, #4
c0de3f54:	2100      	movs	r1, #0
            context->commandLength = length;
            context->processingFlags = processingFlags;
            result = processTxInternal(context);
            PRINTF("result: %d\n");
        }
        CATCH_OTHER(e) {
c0de3f56:	8581      	strh	r1, [r0, #44]	; 0x2c
c0de3f58:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de3f5a:	f005 f9f9 	bl	c0de9350 <try_context_set>
c0de3f5e:	2403      	movs	r4, #3
c0de3f60:	e00b      	b.n	c0de3f7a <processTx+0x42>
c0de3f62:	a801      	add	r0, sp, #4
        TRY {
c0de3f64:	f005 f9f4 	bl	c0de9350 <try_context_set>
            context->workBuffer = buffer;
c0de3f68:	6267      	str	r7, [r4, #36]	; 0x24
            context->commandLength = length;
c0de3f6a:	62a6      	str	r6, [r4, #40]	; 0x28
            context->processingFlags = processingFlags;
c0de3f6c:	9900      	ldr	r1, [sp, #0]
c0de3f6e:	62e1      	str	r1, [r4, #44]	; 0x2c
        TRY {
c0de3f70:	900b      	str	r0, [sp, #44]	; 0x2c
            result = processTxInternal(context);
c0de3f72:	4620      	mov	r0, r4
c0de3f74:	f000 f812 	bl	c0de3f9c <processTxInternal>
c0de3f78:	4604      	mov	r4, r0
            result = USTREAM_FAULT;
        }
        FINALLY {
c0de3f7a:	f005 f9df 	bl	c0de933c <try_context_get>
c0de3f7e:	a901      	add	r1, sp, #4
c0de3f80:	4288      	cmp	r0, r1
c0de3f82:	d102      	bne.n	c0de3f8a <processTx+0x52>
c0de3f84:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0de3f86:	f005 f9e3 	bl	c0de9350 <try_context_set>
c0de3f8a:	a801      	add	r0, sp, #4
        }
    }
    END_TRY;
c0de3f8c:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de3f8e:	2800      	cmp	r0, #0
c0de3f90:	d102      	bne.n	c0de3f98 <processTx+0x60>
    return result;
c0de3f92:	4620      	mov	r0, r4
c0de3f94:	b00d      	add	sp, #52	; 0x34
c0de3f96:	bdf0      	pop	{r4, r5, r6, r7, pc}
    END_TRY;
c0de3f98:	f003 fa45 	bl	c0de7426 <os_longjmp>

c0de3f9c <processTxInternal>:
static parserStatus_e processTxInternal(txContext_t *context) {
c0de3f9c:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de3f9e:	4604      	mov	r4, r0
c0de3fa0:	4605      	mov	r5, r0
c0de3fa2:	3510      	adds	r5, #16
c0de3fa4:	3008      	adds	r0, #8
c0de3fa6:	9000      	str	r0, [sp, #0]
c0de3fa8:	4627      	mov	r7, r4
c0de3faa:	3718      	adds	r7, #24
c0de3fac:	4626      	mov	r6, r4
c0de3fae:	363c      	adds	r6, #60	; 0x3c
        if (PARSING_IS_DONE(context)) {
c0de3fb0:	7830      	ldrb	r0, [r6, #0]
c0de3fb2:	2801      	cmp	r0, #1
c0de3fb4:	d00f      	beq.n	c0de3fd6 <processTxInternal+0x3a>
c0de3fb6:	2802      	cmp	r0, #2
c0de3fb8:	d009      	beq.n	c0de3fce <processTxInternal+0x32>
c0de3fba:	28c0      	cmp	r0, #192	; 0xc0
c0de3fbc:	d10f      	bne.n	c0de3fde <processTxInternal+0x42>
c0de3fbe:	7821      	ldrb	r1, [r4, #0]
c0de3fc0:	2002      	movs	r0, #2
c0de3fc2:	2909      	cmp	r1, #9
c0de3fc4:	d100      	bne.n	c0de3fc8 <processTxInternal+0x2c>
c0de3fc6:	e091      	b.n	c0de40ec <processTxInternal+0x150>
c0de3fc8:	290c      	cmp	r1, #12
c0de3fca:	d108      	bne.n	c0de3fde <processTxInternal+0x42>
c0de3fcc:	e100      	b.n	c0de41d0 <processTxInternal+0x234>
c0de3fce:	7820      	ldrb	r0, [r4, #0]
c0de3fd0:	280c      	cmp	r0, #12
c0de3fd2:	d104      	bne.n	c0de3fde <processTxInternal+0x42>
c0de3fd4:	e0f5      	b.n	c0de41c2 <processTxInternal+0x226>
c0de3fd6:	7820      	ldrb	r0, [r4, #0]
c0de3fd8:	280b      	cmp	r0, #11
c0de3fda:	d100      	bne.n	c0de3fde <processTxInternal+0x42>
c0de3fdc:	e0f1      	b.n	c0de41c2 <processTxInternal+0x226>
        if (context->commandLength == 0) {
c0de3fde:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0de3fe0:	2800      	cmp	r0, #0
c0de3fe2:	d100      	bne.n	c0de3fe6 <processTxInternal+0x4a>
c0de3fe4:	e0eb      	b.n	c0de41be <processTxInternal+0x222>
        if (!context->processingField) {
c0de3fe6:	7c60      	ldrb	r0, [r4, #17]
c0de3fe8:	2800      	cmp	r0, #0
c0de3fea:	d033      	beq.n	c0de4054 <processTxInternal+0xb8>
        if (context->customProcessor != NULL) {
c0de3fec:	6b21      	ldr	r1, [r4, #48]	; 0x30
c0de3fee:	2900      	cmp	r1, #0
c0de3ff0:	d006      	beq.n	c0de4000 <processTxInternal+0x64>
            customStatus = context->customProcessor(context);
c0de3ff2:	4620      	mov	r0, r4
c0de3ff4:	4788      	blx	r1
            switch (customStatus) {
c0de3ff6:	2800      	cmp	r0, #0
c0de3ff8:	d002      	beq.n	c0de4000 <processTxInternal+0x64>
c0de3ffa:	2801      	cmp	r0, #1
c0de3ffc:	d0d8      	beq.n	c0de3fb0 <processTxInternal+0x14>
c0de3ffe:	e0e2      	b.n	c0de41c6 <processTxInternal+0x22a>
            switch (context->txType) {
c0de4000:	7831      	ldrb	r1, [r6, #0]
c0de4002:	2003      	movs	r0, #3
c0de4004:	2901      	cmp	r1, #1
c0de4006:	d054      	beq.n	c0de40b2 <processTxInternal+0x116>
c0de4008:	2902      	cmp	r1, #2
c0de400a:	d03c      	beq.n	c0de4086 <processTxInternal+0xea>
c0de400c:	29c0      	cmp	r1, #192	; 0xc0
c0de400e:	d000      	beq.n	c0de4012 <processTxInternal+0x76>
c0de4010:	e0de      	b.n	c0de41d0 <processTxInternal+0x234>
    switch (context->currentField) {
c0de4012:	7821      	ldrb	r1, [r4, #0]
c0de4014:	460a      	mov	r2, r1
c0de4016:	3a0a      	subs	r2, #10
c0de4018:	2a02      	cmp	r2, #2
c0de401a:	d200      	bcs.n	c0de401e <processTxInternal+0x82>
c0de401c:	e0a0      	b.n	c0de4160 <processTxInternal+0x1c4>
c0de401e:	2909      	cmp	r1, #9
c0de4020:	d100      	bne.n	c0de4024 <processTxInternal+0x88>
c0de4022:	e0a9      	b.n	c0de4178 <processTxInternal+0x1dc>
c0de4024:	2902      	cmp	r1, #2
c0de4026:	d100      	bne.n	c0de402a <processTxInternal+0x8e>
c0de4028:	e082      	b.n	c0de4130 <processTxInternal+0x194>
c0de402a:	2903      	cmp	r1, #3
c0de402c:	d100      	bne.n	c0de4030 <processTxInternal+0x94>
c0de402e:	e083      	b.n	c0de4138 <processTxInternal+0x19c>
c0de4030:	2904      	cmp	r1, #4
c0de4032:	d100      	bne.n	c0de4036 <processTxInternal+0x9a>
c0de4034:	e084      	b.n	c0de4140 <processTxInternal+0x1a4>
c0de4036:	2905      	cmp	r1, #5
c0de4038:	d100      	bne.n	c0de403c <processTxInternal+0xa0>
c0de403a:	e085      	b.n	c0de4148 <processTxInternal+0x1ac>
c0de403c:	2906      	cmp	r1, #6
c0de403e:	d100      	bne.n	c0de4042 <processTxInternal+0xa6>
c0de4040:	e086      	b.n	c0de4150 <processTxInternal+0x1b4>
c0de4042:	2907      	cmp	r1, #7
c0de4044:	d100      	bne.n	c0de4048 <processTxInternal+0xac>
c0de4046:	e087      	b.n	c0de4158 <processTxInternal+0x1bc>
c0de4048:	2908      	cmp	r1, #8
c0de404a:	d145      	bne.n	c0de40d8 <processTxInternal+0x13c>
c0de404c:	4620      	mov	r0, r4
c0de404e:	f000 f9df 	bl	c0de4410 <processData>
c0de4052:	e7ad      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4054:	2001      	movs	r0, #1
    while (context->commandLength != 0) {
c0de4056:	2800      	cmp	r0, #0
c0de4058:	d100      	bne.n	c0de405c <processTxInternal+0xc0>
c0de405a:	e0b0      	b.n	c0de41be <processTxInternal+0x222>
        context->rlpBuffer[context->rlpBufferPos++] = readTxByte(context);
c0de405c:	4620      	mov	r0, r4
c0de405e:	f7ff ff09 	bl	c0de3e74 <readTxByte>
c0de4062:	6a21      	ldr	r1, [r4, #32]
c0de4064:	1c4a      	adds	r2, r1, #1
c0de4066:	6222      	str	r2, [r4, #32]
c0de4068:	1861      	adds	r1, r4, r1
c0de406a:	7608      	strb	r0, [r1, #24]
        if (rlpCanDecode(context->rlpBuffer, context->rlpBufferPos, &valid)) {
c0de406c:	6a21      	ldr	r1, [r4, #32]
c0de406e:	aa01      	add	r2, sp, #4
c0de4070:	4638      	mov	r0, r7
c0de4072:	f000 fa59 	bl	c0de4528 <rlpCanDecode>
c0de4076:	2800      	cmp	r0, #0
c0de4078:	d13c      	bne.n	c0de40f4 <processTxInternal+0x158>
        if (context->rlpBufferPos == sizeof(context->rlpBuffer)) {
c0de407a:	6a20      	ldr	r0, [r4, #32]
c0de407c:	2805      	cmp	r0, #5
c0de407e:	d100      	bne.n	c0de4082 <processTxInternal+0xe6>
c0de4080:	e0a5      	b.n	c0de41ce <processTxInternal+0x232>
    while (context->commandLength != 0) {
c0de4082:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0de4084:	e7e7      	b.n	c0de4056 <processTxInternal+0xba>
    switch (context->currentField) {
c0de4086:	7821      	ldrb	r1, [r4, #0]
c0de4088:	290b      	cmp	r1, #11
c0de408a:	d071      	beq.n	c0de4170 <processTxInternal+0x1d4>
c0de408c:	2902      	cmp	r1, #2
c0de408e:	d04f      	beq.n	c0de4130 <processTxInternal+0x194>
c0de4090:	2903      	cmp	r1, #3
c0de4092:	d069      	beq.n	c0de4168 <processTxInternal+0x1cc>
c0de4094:	2904      	cmp	r1, #4
c0de4096:	d04f      	beq.n	c0de4138 <processTxInternal+0x19c>
c0de4098:	2905      	cmp	r1, #5
c0de409a:	d061      	beq.n	c0de4160 <processTxInternal+0x1c4>
c0de409c:	2906      	cmp	r1, #6
c0de409e:	d04f      	beq.n	c0de4140 <processTxInternal+0x1a4>
c0de40a0:	2907      	cmp	r1, #7
c0de40a2:	d051      	beq.n	c0de4148 <processTxInternal+0x1ac>
c0de40a4:	2908      	cmp	r1, #8
c0de40a6:	d053      	beq.n	c0de4150 <processTxInternal+0x1b4>
c0de40a8:	2909      	cmp	r1, #9
c0de40aa:	d055      	beq.n	c0de4158 <processTxInternal+0x1bc>
c0de40ac:	290a      	cmp	r1, #10
c0de40ae:	d113      	bne.n	c0de40d8 <processTxInternal+0x13c>
c0de40b0:	e7cc      	b.n	c0de404c <processTxInternal+0xb0>
    switch (context->currentField) {
c0de40b2:	7821      	ldrb	r1, [r4, #0]
c0de40b4:	290a      	cmp	r1, #10
c0de40b6:	d05b      	beq.n	c0de4170 <processTxInternal+0x1d4>
c0de40b8:	2902      	cmp	r1, #2
c0de40ba:	d039      	beq.n	c0de4130 <processTxInternal+0x194>
c0de40bc:	2903      	cmp	r1, #3
c0de40be:	d053      	beq.n	c0de4168 <processTxInternal+0x1cc>
c0de40c0:	2904      	cmp	r1, #4
c0de40c2:	d039      	beq.n	c0de4138 <processTxInternal+0x19c>
c0de40c4:	2905      	cmp	r1, #5
c0de40c6:	d03b      	beq.n	c0de4140 <processTxInternal+0x1a4>
c0de40c8:	2906      	cmp	r1, #6
c0de40ca:	d03d      	beq.n	c0de4148 <processTxInternal+0x1ac>
c0de40cc:	2907      	cmp	r1, #7
c0de40ce:	d03f      	beq.n	c0de4150 <processTxInternal+0x1b4>
c0de40d0:	2908      	cmp	r1, #8
c0de40d2:	d041      	beq.n	c0de4158 <processTxInternal+0x1bc>
c0de40d4:	2909      	cmp	r1, #9
c0de40d6:	d0b9      	beq.n	c0de404c <processTxInternal+0xb0>
c0de40d8:	2901      	cmp	r1, #1
c0de40da:	d179      	bne.n	c0de41d0 <processTxInternal+0x234>
c0de40dc:	4620      	mov	r0, r4
c0de40de:	f000 f8ab 	bl	c0de4238 <processContent>
c0de40e2:	202c      	movs	r0, #44	; 0x2c
c0de40e4:	5c20      	ldrb	r0, [r4, r0]
c0de40e6:	07c0      	lsls	r0, r0, #31
c0de40e8:	d065      	beq.n	c0de41b6 <processTxInternal+0x21a>
c0de40ea:	e761      	b.n	c0de3fb0 <processTxInternal+0x14>
            (context->commandLength == 0)) {
c0de40ec:	6aa1      	ldr	r1, [r4, #40]	; 0x28
        if ((context->txType == LEGACY && context->currentField == LEGACY_RLP_V) &&
c0de40ee:	2900      	cmp	r1, #0
c0de40f0:	d06f      	beq.n	c0de41d2 <processTxInternal+0x236>
c0de40f2:	e778      	b.n	c0de3fe6 <processTxInternal+0x4a>
c0de40f4:	a801      	add	r0, sp, #4
            if (!valid) {
c0de40f6:	7800      	ldrb	r0, [r0, #0]
c0de40f8:	2800      	cmp	r0, #0
c0de40fa:	d068      	beq.n	c0de41ce <processTxInternal+0x232>
c0de40fc:	aa02      	add	r2, sp, #8
    if (!rlpDecodeLength(context->rlpBuffer,
c0de40fe:	4638      	mov	r0, r7
c0de4100:	9900      	ldr	r1, [sp, #0]
c0de4102:	462b      	mov	r3, r5
c0de4104:	f000 fa2e 	bl	c0de4564 <rlpDecodeLength>
c0de4108:	2800      	cmp	r0, #0
c0de410a:	d060      	beq.n	c0de41ce <processTxInternal+0x232>
c0de410c:	2000      	movs	r0, #0
    if (offset == 0) {
c0de410e:	9902      	ldr	r1, [sp, #8]
c0de4110:	2900      	cmp	r1, #0
c0de4112:	4601      	mov	r1, r0
c0de4114:	d106      	bne.n	c0de4124 <processTxInternal+0x188>
        context->workBuffer--;
c0de4116:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0de4118:	1e49      	subs	r1, r1, #1
c0de411a:	6261      	str	r1, [r4, #36]	; 0x24
        context->commandLength++;
c0de411c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
c0de411e:	1c49      	adds	r1, r1, #1
c0de4120:	62a1      	str	r1, [r4, #40]	; 0x28
c0de4122:	2101      	movs	r1, #1
    context->rlpBufferPos = 0;
c0de4124:	6220      	str	r0, [r4, #32]
    context->currentFieldPos = 0;
c0de4126:	60e0      	str	r0, [r4, #12]
        context->fieldSingleByte = true;
c0de4128:	74a1      	strb	r1, [r4, #18]
c0de412a:	2001      	movs	r0, #1
    context->processingField = true;
c0de412c:	7460      	strb	r0, [r4, #17]
c0de412e:	e75d      	b.n	c0de3fec <processTxInternal+0x50>
c0de4130:	4620      	mov	r0, r4
c0de4132:	f000 f890 	bl	c0de4256 <processType>
c0de4136:	e73b      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4138:	4620      	mov	r0, r4
c0de413a:	f000 f8ad 	bl	c0de4298 <processNonce>
c0de413e:	e737      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4140:	4620      	mov	r0, r4
c0de4142:	f000 f8ce 	bl	c0de42e2 <processGasprice>
c0de4146:	e733      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4148:	4620      	mov	r0, r4
c0de414a:	f000 f8ef 	bl	c0de432c <processStartGas>
c0de414e:	e72f      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4150:	4620      	mov	r0, r4
c0de4152:	f000 f911 	bl	c0de4378 <processTo>
c0de4156:	e72b      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4158:	4620      	mov	r0, r4
c0de415a:	f000 f933 	bl	c0de43c4 <processValue>
c0de415e:	e727      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4160:	4620      	mov	r0, r4
c0de4162:	f000 f97e 	bl	c0de4462 <processAndDiscard>
c0de4166:	e723      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4168:	4620      	mov	r0, r4
c0de416a:	f000 f999 	bl	c0de44a0 <processChainID>
c0de416e:	e71f      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de4170:	4620      	mov	r0, r4
c0de4172:	f000 f9ba 	bl	c0de44ea <processAccessList>
c0de4176:	e71b      	b.n	c0de3fb0 <processTxInternal+0x14>
    if (context->currentFieldIsList) {
c0de4178:	7828      	ldrb	r0, [r5, #0]
c0de417a:	2800      	cmp	r0, #0
c0de417c:	d12e      	bne.n	c0de41dc <processTxInternal+0x240>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de417e:	68a1      	ldr	r1, [r4, #8]
c0de4180:	68e0      	ldr	r0, [r4, #12]
c0de4182:	4281      	cmp	r1, r0
c0de4184:	d90f      	bls.n	c0de41a6 <processTxInternal+0x20a>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de4186:	1a09      	subs	r1, r1, r0
c0de4188:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de418a:	428a      	cmp	r2, r1
c0de418c:	d300      	bcc.n	c0de4190 <processTxInternal+0x1f4>
c0de418e:	460a      	mov	r2, r1
        copySize = MIN(copySize, sizeof(context->content->v));
c0de4190:	2a08      	cmp	r2, #8
c0de4192:	d300      	bcc.n	c0de4196 <processTxInternal+0x1fa>
c0de4194:	2208      	movs	r2, #8
        copyTxData(context, context->content->v + context->currentFieldPos, copySize);
c0de4196:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de4198:	1809      	adds	r1, r1, r0
c0de419a:	31ba      	adds	r1, #186	; 0xba
c0de419c:	4620      	mov	r0, r4
c0de419e:	f7ff fe9b 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de41a2:	68a1      	ldr	r1, [r4, #8]
c0de41a4:	68e0      	ldr	r0, [r4, #12]
c0de41a6:	4288      	cmp	r0, r1
c0de41a8:	d000      	beq.n	c0de41ac <processTxInternal+0x210>
c0de41aa:	e701      	b.n	c0de3fb0 <processTxInternal+0x14>
        context->content->vLength = context->currentFieldLength;
c0de41ac:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0de41ae:	22c2      	movs	r2, #194	; 0xc2
c0de41b0:	5481      	strb	r1, [r0, r2]
c0de41b2:	2000      	movs	r0, #0
        context->processingField = false;
c0de41b4:	7460      	strb	r0, [r4, #17]
c0de41b6:	7820      	ldrb	r0, [r4, #0]
c0de41b8:	1c40      	adds	r0, r0, #1
c0de41ba:	7020      	strb	r0, [r4, #0]
c0de41bc:	e6f8      	b.n	c0de3fb0 <processTxInternal+0x14>
c0de41be:	2000      	movs	r0, #0
}
c0de41c0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de41c2:	2002      	movs	r0, #2
c0de41c4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            switch (customStatus) {
c0de41c6:	2802      	cmp	r0, #2
c0de41c8:	d101      	bne.n	c0de41ce <processTxInternal+0x232>
c0de41ca:	2001      	movs	r0, #1
}
c0de41cc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de41ce:	2003      	movs	r0, #3
c0de41d0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            context->content->vLength = 0;
c0de41d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de41d4:	22c2      	movs	r2, #194	; 0xc2
c0de41d6:	2300      	movs	r3, #0
c0de41d8:	548b      	strb	r3, [r1, r2]
}
c0de41da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de41dc:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de41de:	f003 f922 	bl	c0de7426 <os_longjmp>

c0de41e2 <continueTx>:
}

parserStatus_e continueTx(txContext_t *context) {
c0de41e2:	b5b0      	push	{r4, r5, r7, lr}
c0de41e4:	b08c      	sub	sp, #48	; 0x30
c0de41e6:	4604      	mov	r4, r0
c0de41e8:	466d      	mov	r5, sp
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0de41ea:	4628      	mov	r0, r5
c0de41ec:	f009 fc60 	bl	c0dedab0 <setjmp>
c0de41f0:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0de41f2:	0400      	lsls	r0, r0, #16
c0de41f4:	d007      	beq.n	c0de4206 <continueTx+0x24>
c0de41f6:	4668      	mov	r0, sp
c0de41f8:	2100      	movs	r1, #0
            result = processTxInternal(context);
        }
        CATCH_OTHER(e) {
c0de41fa:	8581      	strh	r1, [r0, #44]	; 0x2c
c0de41fc:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de41fe:	f005 f8a7 	bl	c0de9350 <try_context_set>
c0de4202:	2403      	movs	r4, #3
c0de4204:	e007      	b.n	c0de4216 <continueTx+0x34>
c0de4206:	4668      	mov	r0, sp
        TRY {
c0de4208:	f005 f8a2 	bl	c0de9350 <try_context_set>
c0de420c:	900a      	str	r0, [sp, #40]	; 0x28
            result = processTxInternal(context);
c0de420e:	4620      	mov	r0, r4
c0de4210:	f7ff fec4 	bl	c0de3f9c <processTxInternal>
c0de4214:	4604      	mov	r4, r0
            result = USTREAM_FAULT;
        }
        FINALLY {
c0de4216:	f005 f891 	bl	c0de933c <try_context_get>
c0de421a:	4669      	mov	r1, sp
c0de421c:	4288      	cmp	r0, r1
c0de421e:	d102      	bne.n	c0de4226 <continueTx+0x44>
c0de4220:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de4222:	f005 f895 	bl	c0de9350 <try_context_set>
c0de4226:	4668      	mov	r0, sp
        }
    }
    END_TRY;
c0de4228:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de422a:	2800      	cmp	r0, #0
c0de422c:	d102      	bne.n	c0de4234 <continueTx+0x52>
    return result;
c0de422e:	4620      	mov	r0, r4
c0de4230:	b00c      	add	sp, #48	; 0x30
c0de4232:	bdb0      	pop	{r4, r5, r7, pc}
    END_TRY;
c0de4234:	f003 f8f7 	bl	c0de7426 <os_longjmp>

c0de4238 <processContent>:
static void processContent(txContext_t *context) {
c0de4238:	b580      	push	{r7, lr}
    if (!context->currentFieldIsList) {
c0de423a:	7c01      	ldrb	r1, [r0, #16]
c0de423c:	2900      	cmp	r1, #0
c0de423e:	d007      	beq.n	c0de4250 <processContent+0x18>
c0de4240:	2100      	movs	r1, #0
    context->processingField = false;
c0de4242:	7441      	strb	r1, [r0, #17]
    context->dataLength = context->currentFieldLength;
c0de4244:	6881      	ldr	r1, [r0, #8]
c0de4246:	6141      	str	r1, [r0, #20]
    context->currentField++;
c0de4248:	7801      	ldrb	r1, [r0, #0]
c0de424a:	1c49      	adds	r1, r1, #1
c0de424c:	7001      	strb	r1, [r0, #0]
}
c0de424e:	bd80      	pop	{r7, pc}
c0de4250:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de4252:	f003 f8e8 	bl	c0de7426 <os_longjmp>

c0de4256 <processType>:
static void processType(txContext_t *context) {
c0de4256:	b510      	push	{r4, lr}
c0de4258:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de425a:	7c00      	ldrb	r0, [r0, #16]
c0de425c:	2800      	cmp	r0, #0
c0de425e:	d118      	bne.n	c0de4292 <processType+0x3c>
    if (context->currentFieldLength > MAX_INT256) {
c0de4260:	68a0      	ldr	r0, [r4, #8]
c0de4262:	2821      	cmp	r0, #33	; 0x21
c0de4264:	d215      	bcs.n	c0de4292 <processType+0x3c>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de4266:	68e1      	ldr	r1, [r4, #12]
c0de4268:	4288      	cmp	r0, r1
c0de426a:	d90a      	bls.n	c0de4282 <processType+0x2c>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de426c:	1a40      	subs	r0, r0, r1
c0de426e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4270:	4282      	cmp	r2, r0
c0de4272:	d300      	bcc.n	c0de4276 <processType+0x20>
c0de4274:	4602      	mov	r2, r0
c0de4276:	2100      	movs	r1, #0
        copyTxData(context, NULL, copySize);
c0de4278:	4620      	mov	r0, r4
c0de427a:	f7ff fe2d 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de427e:	68a0      	ldr	r0, [r4, #8]
c0de4280:	68e1      	ldr	r1, [r4, #12]
c0de4282:	4281      	cmp	r1, r0
c0de4284:	d104      	bne.n	c0de4290 <processType+0x3a>
c0de4286:	2000      	movs	r0, #0
        context->processingField = false;
c0de4288:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de428a:	7820      	ldrb	r0, [r4, #0]
c0de428c:	1c40      	adds	r0, r0, #1
c0de428e:	7020      	strb	r0, [r4, #0]
}
c0de4290:	bd10      	pop	{r4, pc}
c0de4292:	2001      	movs	r0, #1
c0de4294:	f003 f8c7 	bl	c0de7426 <os_longjmp>

c0de4298 <processNonce>:
static void processNonce(txContext_t *context) {
c0de4298:	b510      	push	{r4, lr}
c0de429a:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de429c:	7c00      	ldrb	r0, [r0, #16]
c0de429e:	2800      	cmp	r0, #0
c0de42a0:	d11c      	bne.n	c0de42dc <processNonce+0x44>
    if (context->currentFieldLength > MAX_INT256) {
c0de42a2:	68a0      	ldr	r0, [r4, #8]
c0de42a4:	2821      	cmp	r0, #33	; 0x21
c0de42a6:	d219      	bcs.n	c0de42dc <processNonce+0x44>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de42a8:	68e1      	ldr	r1, [r4, #12]
c0de42aa:	4288      	cmp	r0, r1
c0de42ac:	d90b      	bls.n	c0de42c6 <processNonce+0x2e>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de42ae:	1a40      	subs	r0, r0, r1
c0de42b0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de42b2:	4282      	cmp	r2, r0
c0de42b4:	d300      	bcc.n	c0de42b8 <processNonce+0x20>
c0de42b6:	4602      	mov	r2, r0
        copyTxData(context, context->content->nonce.value, copySize);
c0de42b8:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de42ba:	3163      	adds	r1, #99	; 0x63
c0de42bc:	4620      	mov	r0, r4
c0de42be:	f7ff fe0b 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de42c2:	68a0      	ldr	r0, [r4, #8]
c0de42c4:	68e1      	ldr	r1, [r4, #12]
c0de42c6:	4281      	cmp	r1, r0
c0de42c8:	d107      	bne.n	c0de42da <processNonce+0x42>
        context->content->nonce.length = context->currentFieldLength;
c0de42ca:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de42cc:	2283      	movs	r2, #131	; 0x83
c0de42ce:	5488      	strb	r0, [r1, r2]
c0de42d0:	2000      	movs	r0, #0
        context->processingField = false;
c0de42d2:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de42d4:	7820      	ldrb	r0, [r4, #0]
c0de42d6:	1c40      	adds	r0, r0, #1
c0de42d8:	7020      	strb	r0, [r4, #0]
}
c0de42da:	bd10      	pop	{r4, pc}
c0de42dc:	2001      	movs	r0, #1
c0de42de:	f003 f8a2 	bl	c0de7426 <os_longjmp>

c0de42e2 <processGasprice>:
static void processGasprice(txContext_t *context) {
c0de42e2:	b510      	push	{r4, lr}
c0de42e4:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de42e6:	7c00      	ldrb	r0, [r0, #16]
c0de42e8:	2800      	cmp	r0, #0
c0de42ea:	d11c      	bne.n	c0de4326 <processGasprice+0x44>
    if (context->currentFieldLength > MAX_INT256) {
c0de42ec:	68a0      	ldr	r0, [r4, #8]
c0de42ee:	2821      	cmp	r0, #33	; 0x21
c0de42f0:	d219      	bcs.n	c0de4326 <processGasprice+0x44>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de42f2:	68e2      	ldr	r2, [r4, #12]
c0de42f4:	4290      	cmp	r0, r2
c0de42f6:	d90b      	bls.n	c0de4310 <processGasprice+0x2e>
        copyTxData(context, context->content->gasprice.value + context->currentFieldPos, copySize);
c0de42f8:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de42fa:	1889      	adds	r1, r1, r2
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de42fc:	1a80      	subs	r0, r0, r2
c0de42fe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4300:	4282      	cmp	r2, r0
c0de4302:	d300      	bcc.n	c0de4306 <processGasprice+0x24>
c0de4304:	4602      	mov	r2, r0
        copyTxData(context, context->content->gasprice.value + context->currentFieldPos, copySize);
c0de4306:	4620      	mov	r0, r4
c0de4308:	f7ff fde6 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de430c:	68a0      	ldr	r0, [r4, #8]
c0de430e:	68e2      	ldr	r2, [r4, #12]
c0de4310:	4282      	cmp	r2, r0
c0de4312:	d107      	bne.n	c0de4324 <processGasprice+0x42>
        context->content->gasprice.length = context->currentFieldLength;
c0de4314:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de4316:	2220      	movs	r2, #32
c0de4318:	5488      	strb	r0, [r1, r2]
c0de431a:	2000      	movs	r0, #0
        context->processingField = false;
c0de431c:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de431e:	7820      	ldrb	r0, [r4, #0]
c0de4320:	1c40      	adds	r0, r0, #1
c0de4322:	7020      	strb	r0, [r4, #0]
}
c0de4324:	bd10      	pop	{r4, pc}
c0de4326:	2001      	movs	r0, #1
c0de4328:	f003 f87d 	bl	c0de7426 <os_longjmp>

c0de432c <processStartGas>:
static void processStartGas(txContext_t *context) {
c0de432c:	b510      	push	{r4, lr}
c0de432e:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de4330:	7c00      	ldrb	r0, [r0, #16]
c0de4332:	2800      	cmp	r0, #0
c0de4334:	d11d      	bne.n	c0de4372 <processStartGas+0x46>
    if (context->currentFieldLength > MAX_INT256) {
c0de4336:	68a0      	ldr	r0, [r4, #8]
c0de4338:	2821      	cmp	r0, #33	; 0x21
c0de433a:	d21a      	bcs.n	c0de4372 <processStartGas+0x46>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de433c:	68e1      	ldr	r1, [r4, #12]
c0de433e:	4288      	cmp	r0, r1
c0de4340:	d90c      	bls.n	c0de435c <processStartGas+0x30>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de4342:	1a40      	subs	r0, r0, r1
c0de4344:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4346:	4282      	cmp	r2, r0
c0de4348:	d300      	bcc.n	c0de434c <processStartGas+0x20>
c0de434a:	4602      	mov	r2, r0
        copyTxData(context, context->content->startgas.value + context->currentFieldPos, copySize);
c0de434c:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0de434e:	1841      	adds	r1, r0, r1
c0de4350:	3121      	adds	r1, #33	; 0x21
c0de4352:	4620      	mov	r0, r4
c0de4354:	f7ff fdc0 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de4358:	68a0      	ldr	r0, [r4, #8]
c0de435a:	68e1      	ldr	r1, [r4, #12]
c0de435c:	4281      	cmp	r1, r0
c0de435e:	d107      	bne.n	c0de4370 <processStartGas+0x44>
        context->content->startgas.length = context->currentFieldLength;
c0de4360:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de4362:	2241      	movs	r2, #65	; 0x41
c0de4364:	5488      	strb	r0, [r1, r2]
c0de4366:	2000      	movs	r0, #0
        context->processingField = false;
c0de4368:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de436a:	7820      	ldrb	r0, [r4, #0]
c0de436c:	1c40      	adds	r0, r0, #1
c0de436e:	7020      	strb	r0, [r4, #0]
}
c0de4370:	bd10      	pop	{r4, pc}
c0de4372:	2001      	movs	r0, #1
c0de4374:	f003 f857 	bl	c0de7426 <os_longjmp>

c0de4378 <processTo>:
static void processTo(txContext_t *context) {
c0de4378:	b510      	push	{r4, lr}
c0de437a:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de437c:	7c00      	ldrb	r0, [r0, #16]
c0de437e:	2800      	cmp	r0, #0
c0de4380:	d11d      	bne.n	c0de43be <processTo+0x46>
    if (context->currentFieldLength > MAX_ADDRESS) {
c0de4382:	68a0      	ldr	r0, [r4, #8]
c0de4384:	2815      	cmp	r0, #21
c0de4386:	d21a      	bcs.n	c0de43be <processTo+0x46>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de4388:	68e1      	ldr	r1, [r4, #12]
c0de438a:	4288      	cmp	r0, r1
c0de438c:	d90c      	bls.n	c0de43a8 <processTo+0x30>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de438e:	1a40      	subs	r0, r0, r1
c0de4390:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4392:	4282      	cmp	r2, r0
c0de4394:	d300      	bcc.n	c0de4398 <processTo+0x20>
c0de4396:	4602      	mov	r2, r0
        copyTxData(context, context->content->destination + context->currentFieldPos, copySize);
c0de4398:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0de439a:	1841      	adds	r1, r0, r1
c0de439c:	31a5      	adds	r1, #165	; 0xa5
c0de439e:	4620      	mov	r0, r4
c0de43a0:	f7ff fd9a 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de43a4:	68a0      	ldr	r0, [r4, #8]
c0de43a6:	68e1      	ldr	r1, [r4, #12]
c0de43a8:	4281      	cmp	r1, r0
c0de43aa:	d107      	bne.n	c0de43bc <processTo+0x44>
        context->content->destinationLength = context->currentFieldLength;
c0de43ac:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de43ae:	22b9      	movs	r2, #185	; 0xb9
c0de43b0:	5488      	strb	r0, [r1, r2]
c0de43b2:	2000      	movs	r0, #0
        context->processingField = false;
c0de43b4:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de43b6:	7820      	ldrb	r0, [r4, #0]
c0de43b8:	1c40      	adds	r0, r0, #1
c0de43ba:	7020      	strb	r0, [r4, #0]
}
c0de43bc:	bd10      	pop	{r4, pc}
c0de43be:	2001      	movs	r0, #1
c0de43c0:	f003 f831 	bl	c0de7426 <os_longjmp>

c0de43c4 <processValue>:
static void processValue(txContext_t *context) {
c0de43c4:	b510      	push	{r4, lr}
c0de43c6:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de43c8:	7c00      	ldrb	r0, [r0, #16]
c0de43ca:	2800      	cmp	r0, #0
c0de43cc:	d11d      	bne.n	c0de440a <processValue+0x46>
    if (context->currentFieldLength > MAX_INT256) {
c0de43ce:	68a0      	ldr	r0, [r4, #8]
c0de43d0:	2821      	cmp	r0, #33	; 0x21
c0de43d2:	d21a      	bcs.n	c0de440a <processValue+0x46>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de43d4:	68e1      	ldr	r1, [r4, #12]
c0de43d6:	4288      	cmp	r0, r1
c0de43d8:	d90c      	bls.n	c0de43f4 <processValue+0x30>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de43da:	1a40      	subs	r0, r0, r1
c0de43dc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de43de:	4282      	cmp	r2, r0
c0de43e0:	d300      	bcc.n	c0de43e4 <processValue+0x20>
c0de43e2:	4602      	mov	r2, r0
        copyTxData(context, context->content->value.value + context->currentFieldPos, copySize);
c0de43e4:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0de43e6:	1841      	adds	r1, r0, r1
c0de43e8:	3142      	adds	r1, #66	; 0x42
c0de43ea:	4620      	mov	r0, r4
c0de43ec:	f7ff fd74 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de43f0:	68a0      	ldr	r0, [r4, #8]
c0de43f2:	68e1      	ldr	r1, [r4, #12]
c0de43f4:	4281      	cmp	r1, r0
c0de43f6:	d107      	bne.n	c0de4408 <processValue+0x44>
        context->content->value.length = context->currentFieldLength;
c0de43f8:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de43fa:	2262      	movs	r2, #98	; 0x62
c0de43fc:	5488      	strb	r0, [r1, r2]
c0de43fe:	2000      	movs	r0, #0
        context->processingField = false;
c0de4400:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de4402:	7820      	ldrb	r0, [r4, #0]
c0de4404:	1c40      	adds	r0, r0, #1
c0de4406:	7020      	strb	r0, [r4, #0]
}
c0de4408:	bd10      	pop	{r4, pc}
c0de440a:	2001      	movs	r0, #1
c0de440c:	f003 f80b 	bl	c0de7426 <os_longjmp>

c0de4410 <processData>:
static void processData(txContext_t *context) {
c0de4410:	b510      	push	{r4, lr}
c0de4412:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de4414:	7c00      	ldrb	r0, [r0, #16]
c0de4416:	2800      	cmp	r0, #0
c0de4418:	d120      	bne.n	c0de445c <processData+0x4c>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de441a:	68a0      	ldr	r0, [r4, #8]
c0de441c:	68e1      	ldr	r1, [r4, #12]
c0de441e:	4288      	cmp	r0, r1
c0de4420:	d914      	bls.n	c0de444c <processData+0x3c>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de4422:	1a40      	subs	r0, r0, r1
c0de4424:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4426:	4282      	cmp	r2, r0
c0de4428:	d300      	bcc.n	c0de442c <processData+0x1c>
c0de442a:	4602      	mov	r2, r0
        if (copySize == 1 && *context->workBuffer == 0x00) {
c0de442c:	2a01      	cmp	r2, #1
c0de442e:	d107      	bne.n	c0de4440 <processData+0x30>
c0de4430:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de4432:	7800      	ldrb	r0, [r0, #0]
c0de4434:	2800      	cmp	r0, #0
c0de4436:	d103      	bne.n	c0de4440 <processData+0x30>
            context->content->dataPresent = false;
c0de4438:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0de443a:	21c3      	movs	r1, #195	; 0xc3
c0de443c:	2300      	movs	r3, #0
c0de443e:	5443      	strb	r3, [r0, r1]
c0de4440:	2100      	movs	r1, #0
        copyTxData(context, NULL, copySize);
c0de4442:	4620      	mov	r0, r4
c0de4444:	f7ff fd48 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de4448:	68a0      	ldr	r0, [r4, #8]
c0de444a:	68e1      	ldr	r1, [r4, #12]
c0de444c:	4281      	cmp	r1, r0
c0de444e:	d104      	bne.n	c0de445a <processData+0x4a>
c0de4450:	2000      	movs	r0, #0
        context->processingField = false;
c0de4452:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de4454:	7820      	ldrb	r0, [r4, #0]
c0de4456:	1c40      	adds	r0, r0, #1
c0de4458:	7020      	strb	r0, [r4, #0]
}
c0de445a:	bd10      	pop	{r4, pc}
c0de445c:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de445e:	f002 ffe2 	bl	c0de7426 <os_longjmp>

c0de4462 <processAndDiscard>:
static void processAndDiscard(txContext_t *context) {
c0de4462:	b510      	push	{r4, lr}
c0de4464:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de4466:	7c00      	ldrb	r0, [r0, #16]
c0de4468:	2800      	cmp	r0, #0
c0de446a:	d116      	bne.n	c0de449a <processAndDiscard+0x38>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de446c:	68a0      	ldr	r0, [r4, #8]
c0de446e:	68e1      	ldr	r1, [r4, #12]
c0de4470:	4288      	cmp	r0, r1
c0de4472:	d90a      	bls.n	c0de448a <processAndDiscard+0x28>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de4474:	1a40      	subs	r0, r0, r1
c0de4476:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4478:	4282      	cmp	r2, r0
c0de447a:	d300      	bcc.n	c0de447e <processAndDiscard+0x1c>
c0de447c:	4602      	mov	r2, r0
c0de447e:	2100      	movs	r1, #0
        copyTxData(context, NULL, copySize);
c0de4480:	4620      	mov	r0, r4
c0de4482:	f7ff fd29 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de4486:	68a0      	ldr	r0, [r4, #8]
c0de4488:	68e1      	ldr	r1, [r4, #12]
c0de448a:	4281      	cmp	r1, r0
c0de448c:	d104      	bne.n	c0de4498 <processAndDiscard+0x36>
c0de448e:	2000      	movs	r0, #0
        context->processingField = false;
c0de4490:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de4492:	7820      	ldrb	r0, [r4, #0]
c0de4494:	1c40      	adds	r0, r0, #1
c0de4496:	7020      	strb	r0, [r4, #0]
}
c0de4498:	bd10      	pop	{r4, pc}
c0de449a:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de449c:	f002 ffc3 	bl	c0de7426 <os_longjmp>

c0de44a0 <processChainID>:
static void processChainID(txContext_t *context) {
c0de44a0:	b510      	push	{r4, lr}
c0de44a2:	4604      	mov	r4, r0
    if (context->currentFieldIsList) {
c0de44a4:	7c00      	ldrb	r0, [r0, #16]
c0de44a6:	2800      	cmp	r0, #0
c0de44a8:	d11c      	bne.n	c0de44e4 <processChainID+0x44>
    if (context->currentFieldLength > MAX_INT256) {
c0de44aa:	68a0      	ldr	r0, [r4, #8]
c0de44ac:	2821      	cmp	r0, #33	; 0x21
c0de44ae:	d219      	bcs.n	c0de44e4 <processChainID+0x44>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de44b0:	68e1      	ldr	r1, [r4, #12]
c0de44b2:	4288      	cmp	r0, r1
c0de44b4:	d90b      	bls.n	c0de44ce <processChainID+0x2e>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de44b6:	1a40      	subs	r0, r0, r1
c0de44b8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de44ba:	4282      	cmp	r2, r0
c0de44bc:	d300      	bcc.n	c0de44c0 <processChainID+0x20>
c0de44be:	4602      	mov	r2, r0
        copyTxData(context, context->content->chainID.value, copySize);
c0de44c0:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de44c2:	3184      	adds	r1, #132	; 0x84
c0de44c4:	4620      	mov	r0, r4
c0de44c6:	f7ff fd07 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de44ca:	68a0      	ldr	r0, [r4, #8]
c0de44cc:	68e1      	ldr	r1, [r4, #12]
c0de44ce:	4281      	cmp	r1, r0
c0de44d0:	d107      	bne.n	c0de44e2 <processChainID+0x42>
        context->content->chainID.length = context->currentFieldLength;
c0de44d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de44d4:	22a4      	movs	r2, #164	; 0xa4
c0de44d6:	5488      	strb	r0, [r1, r2]
c0de44d8:	2000      	movs	r0, #0
        context->processingField = false;
c0de44da:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de44dc:	7820      	ldrb	r0, [r4, #0]
c0de44de:	1c40      	adds	r0, r0, #1
c0de44e0:	7020      	strb	r0, [r4, #0]
}
c0de44e2:	bd10      	pop	{r4, pc}
c0de44e4:	2001      	movs	r0, #1
c0de44e6:	f002 ff9e 	bl	c0de7426 <os_longjmp>

c0de44ea <processAccessList>:
static void processAccessList(txContext_t *context) {
c0de44ea:	b510      	push	{r4, lr}
c0de44ec:	4604      	mov	r4, r0
    if (!context->currentFieldIsList) {
c0de44ee:	7c00      	ldrb	r0, [r0, #16]
c0de44f0:	2800      	cmp	r0, #0
c0de44f2:	d016      	beq.n	c0de4522 <processAccessList+0x38>
    if (context->currentFieldPos < context->currentFieldLength) {
c0de44f4:	68a0      	ldr	r0, [r4, #8]
c0de44f6:	68e1      	ldr	r1, [r4, #12]
c0de44f8:	4288      	cmp	r0, r1
c0de44fa:	d90a      	bls.n	c0de4512 <processAccessList+0x28>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0de44fc:	1a40      	subs	r0, r0, r1
c0de44fe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de4500:	4282      	cmp	r2, r0
c0de4502:	d300      	bcc.n	c0de4506 <processAccessList+0x1c>
c0de4504:	4602      	mov	r2, r0
c0de4506:	2100      	movs	r1, #0
        copyTxData(context, NULL, copySize);
c0de4508:	4620      	mov	r0, r4
c0de450a:	f7ff fce5 	bl	c0de3ed8 <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0de450e:	68a0      	ldr	r0, [r4, #8]
c0de4510:	68e1      	ldr	r1, [r4, #12]
c0de4512:	4281      	cmp	r1, r0
c0de4514:	d104      	bne.n	c0de4520 <processAccessList+0x36>
c0de4516:	2000      	movs	r0, #0
        context->processingField = false;
c0de4518:	7460      	strb	r0, [r4, #17]
        context->currentField++;
c0de451a:	7820      	ldrb	r0, [r4, #0]
c0de451c:	1c40      	adds	r0, r0, #1
c0de451e:	7020      	strb	r0, [r4, #0]
}
c0de4520:	bd10      	pop	{r4, pc}
c0de4522:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0de4524:	f002 ff7f 	bl	c0de7426 <os_longjmp>

c0de4528 <rlpCanDecode>:
#include "ethUtils.h"
#include "chainConfig.h"
#include "ethUstream.h"

bool rlpCanDecode(uint8_t *buffer, uint32_t bufferLength, bool *valid) {
    if (*buffer <= 0x7f) {
c0de4528:	7800      	ldrb	r0, [r0, #0]
c0de452a:	08c3      	lsrs	r3, r0, #3
c0de452c:	2b17      	cmp	r3, #23
c0de452e:	d316      	bcc.n	c0de455e <rlpCanDecode+0x36>
    } else if (*buffer <= 0xb7) {
    } else if (*buffer <= 0xbf) {
c0de4530:	28bf      	cmp	r0, #191	; 0xbf
c0de4532:	d806      	bhi.n	c0de4542 <rlpCanDecode+0x1a>
        if (bufferLength < (1 + (*buffer - 0xb7))) {
c0de4534:	4603      	mov	r3, r0
c0de4536:	3bb6      	subs	r3, #182	; 0xb6
c0de4538:	428b      	cmp	r3, r1
c0de453a:	d808      	bhi.n	c0de454e <rlpCanDecode+0x26>
            return false;
        }
        if (*buffer > 0xbb) {
c0de453c:	28bc      	cmp	r0, #188	; 0xbc
c0de453e:	d20a      	bcs.n	c0de4556 <rlpCanDecode+0x2e>
c0de4540:	e00d      	b.n	c0de455e <rlpCanDecode+0x36>
            *valid = false;  // arbitrary 32 bits length limitation
            return true;
        }
    } else if (*buffer <= 0xf7) {
c0de4542:	28f8      	cmp	r0, #248	; 0xf8
c0de4544:	d30b      	bcc.n	c0de455e <rlpCanDecode+0x36>
    } else {
        if (bufferLength < (1 + (*buffer - 0xf7))) {
c0de4546:	4603      	mov	r3, r0
c0de4548:	3bf6      	subs	r3, #246	; 0xf6
c0de454a:	428b      	cmp	r3, r1
c0de454c:	d901      	bls.n	c0de4552 <rlpCanDecode+0x2a>
c0de454e:	2000      	movs	r0, #0
            return true;
        }
    }
    *valid = true;
    return true;
}
c0de4550:	4770      	bx	lr
        if (*buffer > 0xfb) {
c0de4552:	28fc      	cmp	r0, #252	; 0xfc
c0de4554:	d303      	bcc.n	c0de455e <rlpCanDecode+0x36>
c0de4556:	2000      	movs	r0, #0
c0de4558:	7010      	strb	r0, [r2, #0]
c0de455a:	2001      	movs	r0, #1
}
c0de455c:	4770      	bx	lr
c0de455e:	2001      	movs	r0, #1
    *valid = true;
c0de4560:	7010      	strb	r0, [r2, #0]
}
c0de4562:	4770      	bx	lr

c0de4564 <rlpDecodeLength>:

bool rlpDecodeLength(uint8_t *buffer, uint32_t *fieldLength, uint32_t *offset, bool *list) {
c0de4564:	b5b0      	push	{r4, r5, r7, lr}
c0de4566:	4604      	mov	r4, r0
    if (*buffer <= 0x7f) {
c0de4568:	7800      	ldrb	r0, [r0, #0]
c0de456a:	b240      	sxtb	r0, r0
c0de456c:	2800      	cmp	r0, #0
c0de456e:	d405      	bmi.n	c0de457c <rlpDecodeLength+0x18>
c0de4570:	2000      	movs	r0, #0
        *offset = 0;
c0de4572:	6010      	str	r0, [r2, #0]
        *fieldLength = 1;
        *list = false;
c0de4574:	7018      	strb	r0, [r3, #0]
c0de4576:	2001      	movs	r0, #1
        *fieldLength = 1;
c0de4578:	6008      	str	r0, [r1, #0]
                return false;  // arbitrary 32 bits length limitation
        }
    }

    return true;
}
c0de457a:	bdb0      	pop	{r4, r5, r7, pc}
c0de457c:	b2c5      	uxtb	r5, r0
    } else if (*buffer <= 0xb7) {
c0de457e:	2db7      	cmp	r5, #183	; 0xb7
c0de4580:	d807      	bhi.n	c0de4592 <rlpDecodeLength+0x2e>
c0de4582:	2001      	movs	r0, #1
        *offset = 1;
c0de4584:	6010      	str	r0, [r2, #0]
        *fieldLength = *buffer - 0x80;
c0de4586:	7822      	ldrb	r2, [r4, #0]
c0de4588:	2400      	movs	r4, #0
        *list = false;
c0de458a:	701c      	strb	r4, [r3, #0]
        *fieldLength = *buffer - 0x80;
c0de458c:	3a80      	subs	r2, #128	; 0x80
c0de458e:	600a      	str	r2, [r1, #0]
}
c0de4590:	bdb0      	pop	{r4, r5, r7, pc}
    } else if (*buffer <= 0xbf) {
c0de4592:	2dbf      	cmp	r5, #191	; 0xbf
c0de4594:	d80e      	bhi.n	c0de45b4 <rlpDecodeLength+0x50>
c0de4596:	2000      	movs	r0, #0
        *list = false;
c0de4598:	7018      	strb	r0, [r3, #0]
        *offset = 1 + (*buffer - 0xb7);
c0de459a:	3db6      	subs	r5, #182	; 0xb6
c0de459c:	6015      	str	r5, [r2, #0]
        switch (*buffer) {
c0de459e:	7822      	ldrb	r2, [r4, #0]
c0de45a0:	2abb      	cmp	r2, #187	; 0xbb
c0de45a2:	d01d      	beq.n	c0de45e0 <rlpDecodeLength+0x7c>
c0de45a4:	2ab9      	cmp	r2, #185	; 0xb9
c0de45a6:	d025      	beq.n	c0de45f4 <rlpDecodeLength+0x90>
c0de45a8:	2aba      	cmp	r2, #186	; 0xba
c0de45aa:	d028      	beq.n	c0de45fe <rlpDecodeLength+0x9a>
c0de45ac:	2ab8      	cmp	r2, #184	; 0xb8
c0de45ae:	d1ef      	bne.n	c0de4590 <rlpDecodeLength+0x2c>
                *fieldLength = *(buffer + 1);
c0de45b0:	7860      	ldrb	r0, [r4, #1]
c0de45b2:	e02b      	b.n	c0de460c <rlpDecodeLength+0xa8>
c0de45b4:	2001      	movs	r0, #1
    } else if (*buffer <= 0xf7) {
c0de45b6:	2df7      	cmp	r5, #247	; 0xf7
c0de45b8:	d804      	bhi.n	c0de45c4 <rlpDecodeLength+0x60>
        *offset = 1;
c0de45ba:	6010      	str	r0, [r2, #0]
        *fieldLength = *buffer - 0xc0;
c0de45bc:	7822      	ldrb	r2, [r4, #0]
        *list = true;
c0de45be:	7018      	strb	r0, [r3, #0]
        *fieldLength = *buffer - 0xc0;
c0de45c0:	3ac0      	subs	r2, #192	; 0xc0
c0de45c2:	e7e4      	b.n	c0de458e <rlpDecodeLength+0x2a>
        *list = true;
c0de45c4:	7018      	strb	r0, [r3, #0]
        *offset = 1 + (*buffer - 0xf7);
c0de45c6:	3df6      	subs	r5, #246	; 0xf6
c0de45c8:	6015      	str	r5, [r2, #0]
        switch (*buffer) {
c0de45ca:	7822      	ldrb	r2, [r4, #0]
c0de45cc:	2afb      	cmp	r2, #251	; 0xfb
c0de45ce:	d020      	beq.n	c0de4612 <rlpDecodeLength+0xae>
c0de45d0:	2af9      	cmp	r2, #249	; 0xf9
c0de45d2:	d028      	beq.n	c0de4626 <rlpDecodeLength+0xc2>
c0de45d4:	2afa      	cmp	r2, #250	; 0xfa
c0de45d6:	d02b      	beq.n	c0de4630 <rlpDecodeLength+0xcc>
c0de45d8:	2af8      	cmp	r2, #248	; 0xf8
c0de45da:	d131      	bne.n	c0de4640 <rlpDecodeLength+0xdc>
                *fieldLength = *(buffer + 1);
c0de45dc:	7862      	ldrb	r2, [r4, #1]
c0de45de:	e7d6      	b.n	c0de458e <rlpDecodeLength+0x2a>
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0de45e0:	7860      	ldrb	r0, [r4, #1]
c0de45e2:	0600      	lsls	r0, r0, #24
c0de45e4:	78a2      	ldrb	r2, [r4, #2]
c0de45e6:	0412      	lsls	r2, r2, #16
c0de45e8:	1810      	adds	r0, r2, r0
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0de45ea:	78e2      	ldrb	r2, [r4, #3]
c0de45ec:	0212      	lsls	r2, r2, #8
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0de45ee:	1880      	adds	r0, r0, r2
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0de45f0:	7922      	ldrb	r2, [r4, #4]
c0de45f2:	e00a      	b.n	c0de460a <rlpDecodeLength+0xa6>
                *fieldLength = (*(buffer + 1) << 8) + *(buffer + 2);
c0de45f4:	78a0      	ldrb	r0, [r4, #2]
c0de45f6:	7862      	ldrb	r2, [r4, #1]
c0de45f8:	0212      	lsls	r2, r2, #8
c0de45fa:	1810      	adds	r0, r2, r0
c0de45fc:	e006      	b.n	c0de460c <rlpDecodeLength+0xa8>
                *fieldLength = (*(buffer + 1) << 16) + (*(buffer + 2) << 8) + *(buffer + 3);
c0de45fe:	7860      	ldrb	r0, [r4, #1]
c0de4600:	0400      	lsls	r0, r0, #16
c0de4602:	78a2      	ldrb	r2, [r4, #2]
c0de4604:	0212      	lsls	r2, r2, #8
c0de4606:	1810      	adds	r0, r2, r0
c0de4608:	78e2      	ldrb	r2, [r4, #3]
c0de460a:	1880      	adds	r0, r0, r2
c0de460c:	6008      	str	r0, [r1, #0]
c0de460e:	2001      	movs	r0, #1
}
c0de4610:	bdb0      	pop	{r4, r5, r7, pc}
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0de4612:	7862      	ldrb	r2, [r4, #1]
c0de4614:	0612      	lsls	r2, r2, #24
c0de4616:	78a3      	ldrb	r3, [r4, #2]
c0de4618:	041b      	lsls	r3, r3, #16
c0de461a:	189a      	adds	r2, r3, r2
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0de461c:	78e3      	ldrb	r3, [r4, #3]
c0de461e:	021b      	lsls	r3, r3, #8
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0de4620:	18d2      	adds	r2, r2, r3
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0de4622:	7923      	ldrb	r3, [r4, #4]
c0de4624:	e00a      	b.n	c0de463c <rlpDecodeLength+0xd8>
                *fieldLength = (*(buffer + 1) << 8) + *(buffer + 2);
c0de4626:	78a2      	ldrb	r2, [r4, #2]
c0de4628:	7863      	ldrb	r3, [r4, #1]
c0de462a:	021b      	lsls	r3, r3, #8
c0de462c:	189a      	adds	r2, r3, r2
c0de462e:	e7ae      	b.n	c0de458e <rlpDecodeLength+0x2a>
                *fieldLength = (*(buffer + 1) << 16) + (*(buffer + 2) << 8) + *(buffer + 3);
c0de4630:	7862      	ldrb	r2, [r4, #1]
c0de4632:	0412      	lsls	r2, r2, #16
c0de4634:	78a3      	ldrb	r3, [r4, #2]
c0de4636:	021b      	lsls	r3, r3, #8
c0de4638:	189a      	adds	r2, r3, r2
c0de463a:	78e3      	ldrb	r3, [r4, #3]
c0de463c:	18d2      	adds	r2, r2, r3
c0de463e:	e7a6      	b.n	c0de458e <rlpDecodeLength+0x2a>
c0de4640:	2000      	movs	r0, #0
}
c0de4642:	bdb0      	pop	{r4, r5, r7, pc}

c0de4644 <getEthAddressFromKey>:

void getEthAddressFromKey(cx_ecfp_public_key_t *publicKey, uint8_t *out, cx_sha3_t *sha3Context) {
c0de4644:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de4646:	b089      	sub	sp, #36	; 0x24
c0de4648:	4615      	mov	r5, r2
c0de464a:	460c      	mov	r4, r1
c0de464c:	4606      	mov	r6, r0
    uint8_t hashAddress[INT256_LENGTH];
    cx_keccak_init(sha3Context, 256);
c0de464e:	4610      	mov	r0, r2
c0de4650:	f000 f810 	bl	c0de4674 <cx_keccak_init>
    cx_hash((cx_hash_t *) sha3Context, CX_LAST, publicKey->W + 1, 64, hashAddress, 32);
c0de4654:	3609      	adds	r6, #9
c0de4656:	2240      	movs	r2, #64	; 0x40
c0de4658:	af01      	add	r7, sp, #4
c0de465a:	4628      	mov	r0, r5
c0de465c:	4631      	mov	r1, r6
c0de465e:	463b      	mov	r3, r7
c0de4660:	f000 f812 	bl	c0de4688 <cx_hash>
    memmove(out, hashAddress + 12, 20);
c0de4664:	370c      	adds	r7, #12
c0de4666:	2214      	movs	r2, #20
c0de4668:	4620      	mov	r0, r4
c0de466a:	4639      	mov	r1, r7
c0de466c:	f009 f8d8 	bl	c0ded820 <__aeabi_memcpy>
}
c0de4670:	b009      	add	sp, #36	; 0x24
c0de4672:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0de4674 <cx_keccak_init>:
{
c0de4674:	b580      	push	{r7, lr}
c0de4676:	2101      	movs	r1, #1
c0de4678:	0209      	lsls	r1, r1, #8
  CX_THROW(cx_keccak_init_no_throw(hash, size));
c0de467a:	f7fe fd11 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de467e:	2800      	cmp	r0, #0
c0de4680:	d100      	bne.n	c0de4684 <cx_keccak_init+0x10>
c0de4682:	bd80      	pop	{r7, pc}
c0de4684:	f002 fecf 	bl	c0de7426 <os_longjmp>

c0de4688 <cx_hash>:
{
c0de4688:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0de468a:	4615      	mov	r5, r2
c0de468c:	460a      	mov	r2, r1
c0de468e:	4604      	mov	r4, r0
c0de4690:	2020      	movs	r0, #32
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de4692:	9300      	str	r3, [sp, #0]
c0de4694:	9001      	str	r0, [sp, #4]
c0de4696:	2101      	movs	r1, #1
c0de4698:	4620      	mov	r0, r4
c0de469a:	462b      	mov	r3, r5
c0de469c:	f7fe fcee 	bl	c0de307c <cx_hash_no_throw>
c0de46a0:	2800      	cmp	r0, #0
c0de46a2:	d103      	bne.n	c0de46ac <cx_hash+0x24>
  return cx_hash_get_size(hash);
c0de46a4:	4620      	mov	r0, r4
c0de46a6:	f7fe fce3 	bl	c0de3070 <cx_hash_get_size>
c0de46aa:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de46ac:	f002 febb 	bl	c0de7426 <os_longjmp>

c0de46b0 <getEthAddressStringFromKey>:

void getEthAddressStringFromKey(cx_ecfp_public_key_t *publicKey,
                                char *out,
                                cx_sha3_t *sha3Context,
                                uint64_t chainId) {
c0de46b0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de46b2:	b08b      	sub	sp, #44	; 0x2c
c0de46b4:	4614      	mov	r4, r2
c0de46b6:	460d      	mov	r5, r1
c0de46b8:	4606      	mov	r6, r0
    uint8_t hashAddress[INT256_LENGTH];
    cx_keccak_init(sha3Context, 256);
c0de46ba:	4610      	mov	r0, r2
c0de46bc:	f7ff ffda 	bl	c0de4674 <cx_keccak_init>
    cx_hash((cx_hash_t *) sha3Context, CX_LAST, publicKey->W + 1, 64, hashAddress, 32);
c0de46c0:	3609      	adds	r6, #9
c0de46c2:	2240      	movs	r2, #64	; 0x40
c0de46c4:	af03      	add	r7, sp, #12
c0de46c6:	4620      	mov	r0, r4
c0de46c8:	4631      	mov	r1, r6
c0de46ca:	463b      	mov	r3, r7
c0de46cc:	f7ff ffdc 	bl	c0de4688 <cx_hash>
c0de46d0:	9811      	ldr	r0, [sp, #68]	; 0x44
    getEthAddressStringFromBinary(hashAddress + 12, out, sha3Context, chainId);
c0de46d2:	9001      	str	r0, [sp, #4]
c0de46d4:	9810      	ldr	r0, [sp, #64]	; 0x40
c0de46d6:	9000      	str	r0, [sp, #0]
c0de46d8:	370c      	adds	r7, #12
c0de46da:	4638      	mov	r0, r7
c0de46dc:	4629      	mov	r1, r5
c0de46de:	4622      	mov	r2, r4
c0de46e0:	f000 f802 	bl	c0de46e8 <getEthAddressStringFromBinary>
}
c0de46e4:	b00b      	add	sp, #44	; 0x2c
c0de46e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0de46e8 <getEthAddressStringFromBinary>:
}

void getEthAddressStringFromBinary(uint8_t *address,
                                   char *out,
                                   cx_sha3_t *sha3Context,
                                   uint64_t chainId) {
c0de46e8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de46ea:	b091      	sub	sp, #68	; 0x44
c0de46ec:	9202      	str	r2, [sp, #8]
c0de46ee:	9103      	str	r1, [sp, #12]
c0de46f0:	4605      	mov	r5, r0
c0de46f2:	2601      	movs	r6, #1
c0de46f4:	9816      	ldr	r0, [sp, #88]	; 0x58
    } locals_union;

    uint8_t i;
    bool eip1191 = false;
    uint32_t offset = 0;
    switch (chainId) {
c0de46f6:	4601      	mov	r1, r0
c0de46f8:	43b1      	bics	r1, r6
c0de46fa:	221e      	movs	r2, #30
c0de46fc:	404a      	eors	r2, r1
c0de46fe:	9917      	ldr	r1, [sp, #92]	; 0x5c
c0de4700:	430a      	orrs	r2, r1
c0de4702:	2400      	movs	r4, #0
        case 30:
        case 31:
            eip1191 = true;
            break;
    }
    if (eip1191) {
c0de4704:	2a00      	cmp	r2, #0
c0de4706:	4622      	mov	r2, r4
c0de4708:	d116      	bne.n	c0de4738 <getEthAddressStringFromBinary+0x50>
c0de470a:	aa04      	add	r2, sp, #16
c0de470c:	9201      	str	r2, [sp, #4]
c0de470e:	2733      	movs	r7, #51	; 0x33
        u64_to_string(chainId, (char *) locals_union.tmp, sizeof(locals_union.tmp));
c0de4710:	463b      	mov	r3, r7
c0de4712:	f000 f857 	bl	c0de47c4 <u64_to_string>
        offset = strnlen((char *) locals_union.tmp, sizeof(locals_union.tmp));
c0de4716:	9801      	ldr	r0, [sp, #4]
c0de4718:	4639      	mov	r1, r7
c0de471a:	f009 faff 	bl	c0dedd1c <strnlen>
        strlcat((char *) locals_union.tmp + offset, "0x", sizeof(locals_union.tmp) - offset);
c0de471e:	9901      	ldr	r1, [sp, #4]
c0de4720:	180b      	adds	r3, r1, r0
c0de4722:	1a3a      	subs	r2, r7, r0
c0de4724:	4925      	ldr	r1, [pc, #148]	; (c0de47bc <getEthAddressStringFromBinary+0xd4>)
c0de4726:	4479      	add	r1, pc
c0de4728:	4618      	mov	r0, r3
c0de472a:	f009 fa1f 	bl	c0dedb6c <strlcat>
        offset = strnlen((char *) locals_union.tmp, sizeof(locals_union.tmp));
c0de472e:	9801      	ldr	r0, [sp, #4]
c0de4730:	4639      	mov	r1, r7
c0de4732:	f009 faf3 	bl	c0dedd1c <strnlen>
c0de4736:	4602      	mov	r2, r0
c0de4738:	a804      	add	r0, sp, #16
c0de473a:	9201      	str	r2, [sp, #4]
    }
    for (i = 0; i < 20; i++) {
c0de473c:	1880      	adds	r0, r0, r2
c0de473e:	4f20      	ldr	r7, [pc, #128]	; (c0de47c0 <getEthAddressStringFromBinary+0xd8>)
c0de4740:	447f      	add	r7, pc
c0de4742:	2c14      	cmp	r4, #20
c0de4744:	d00a      	beq.n	c0de475c <getEthAddressStringFromBinary+0x74>
        uint8_t digit = address[i];
c0de4746:	5d29      	ldrb	r1, [r5, r4]
c0de4748:	220f      	movs	r2, #15
        locals_union.tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
        locals_union.tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
c0de474a:	400a      	ands	r2, r1
c0de474c:	5cba      	ldrb	r2, [r7, r2]
c0de474e:	7042      	strb	r2, [r0, #1]
        locals_union.tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0de4750:	0909      	lsrs	r1, r1, #4
c0de4752:	5c79      	ldrb	r1, [r7, r1]
c0de4754:	7001      	strb	r1, [r0, #0]
    for (i = 0; i < 20; i++) {
c0de4756:	1c80      	adds	r0, r0, #2
c0de4758:	1c64      	adds	r4, r4, #1
c0de475a:	e7f2      	b.n	c0de4742 <getEthAddressStringFromBinary+0x5a>
c0de475c:	9c02      	ldr	r4, [sp, #8]
    }
    cx_keccak_init(sha3Context, 256);
c0de475e:	4620      	mov	r0, r4
c0de4760:	f7ff ff88 	bl	c0de4674 <cx_keccak_init>
c0de4764:	9a01      	ldr	r2, [sp, #4]
    cx_hash((cx_hash_t *) sha3Context,
            CX_LAST,
            locals_union.tmp,
            offset + 40,
c0de4766:	3228      	adds	r2, #40	; 0x28
c0de4768:	a904      	add	r1, sp, #16
    cx_hash((cx_hash_t *) sha3Context,
c0de476a:	4620      	mov	r0, r4
c0de476c:	460b      	mov	r3, r1
c0de476e:	f7ff ff8b 	bl	c0de4688 <cx_hash>
c0de4772:	2000      	movs	r0, #0
            locals_union.hashChecksum,
            32);
    for (i = 0; i < 40; i++) {
c0de4774:	2828      	cmp	r0, #40	; 0x28
c0de4776:	d01b      	beq.n	c0de47b0 <getEthAddressStringFromBinary+0xc8>
        uint8_t digit = address[i / 2];
        if ((i % 2) == 0) {
c0de4778:	4602      	mov	r2, r0
c0de477a:	4032      	ands	r2, r6
        uint8_t digit = address[i / 2];
c0de477c:	0843      	lsrs	r3, r0, #1
c0de477e:	5ce9      	ldrb	r1, [r5, r3]
        if ((i % 2) == 0) {
c0de4780:	2a00      	cmp	r2, #0
c0de4782:	d002      	beq.n	c0de478a <getEthAddressStringFromBinary+0xa2>
c0de4784:	240f      	movs	r4, #15
c0de4786:	4021      	ands	r1, r4
c0de4788:	e000      	b.n	c0de478c <getEthAddressStringFromBinary+0xa4>
c0de478a:	0909      	lsrs	r1, r1, #4
            digit = (digit >> 4) & 0x0f;
        } else {
            digit = digit & 0x0f;
        }
        if (digit < 10) {
c0de478c:	2909      	cmp	r1, #9
c0de478e:	d801      	bhi.n	c0de4794 <getEthAddressStringFromBinary+0xac>
            out[i] = HEXDIGITS[digit];
c0de4790:	5c79      	ldrb	r1, [r7, r1]
c0de4792:	e009      	b.n	c0de47a8 <getEthAddressStringFromBinary+0xc0>
c0de4794:	ac04      	add	r4, sp, #16
        } else {
            int v = (locals_union.hashChecksum[i / 2] >> (4 * (1 - i % 2))) & 0x0f;
c0de4796:	5ce3      	ldrb	r3, [r4, r3]
c0de4798:	0092      	lsls	r2, r2, #2
c0de479a:	2404      	movs	r4, #4
c0de479c:	4054      	eors	r4, r2
            if (v >= 8) {
c0de479e:	40e3      	lsrs	r3, r4
c0de47a0:	071a      	lsls	r2, r3, #28
c0de47a2:	5c79      	ldrb	r1, [r7, r1]
c0de47a4:	d500      	bpl.n	c0de47a8 <getEthAddressStringFromBinary+0xc0>
c0de47a6:	3920      	subs	r1, #32
c0de47a8:	9a03      	ldr	r2, [sp, #12]
c0de47aa:	5411      	strb	r1, [r2, r0]
    for (i = 0; i < 40; i++) {
c0de47ac:	1c40      	adds	r0, r0, #1
c0de47ae:	e7e1      	b.n	c0de4774 <getEthAddressStringFromBinary+0x8c>
c0de47b0:	2028      	movs	r0, #40	; 0x28
c0de47b2:	2100      	movs	r1, #0
            } else {
                out[i] = HEXDIGITS[digit];
            }
        }
    }
    out[40] = '\0';
c0de47b4:	9a03      	ldr	r2, [sp, #12]
c0de47b6:	5411      	strb	r1, [r2, r0]
}
c0de47b8:	b011      	add	sp, #68	; 0x44
c0de47ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de47bc:	000099dd 	.word	0x000099dd
c0de47c0:	0000999e 	.word	0x0000999e

c0de47c4 <u64_to_string>:
void u64_to_string(uint64_t src, char *dst, uint8_t dst_size) {
c0de47c4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de47c6:	b087      	sub	sp, #28
c0de47c8:	9301      	str	r3, [sp, #4]
c0de47ca:	460b      	mov	r3, r1
c0de47cc:	4605      	mov	r5, r0
c0de47ce:	2400      	movs	r4, #0
c0de47d0:	9202      	str	r2, [sp, #8]
        if (i + 1 >= dst_size) {
c0de47d2:	b2e7      	uxtb	r7, r4
c0de47d4:	1c78      	adds	r0, r7, #1
c0de47d6:	9901      	ldr	r1, [sp, #4]
c0de47d8:	4288      	cmp	r0, r1
c0de47da:	d229      	bcs.n	c0de4830 <u64_to_string+0x6c>
c0de47dc:	220a      	movs	r2, #10
c0de47de:	9203      	str	r2, [sp, #12]
c0de47e0:	2600      	movs	r6, #0
        src /= 10;
c0de47e2:	4628      	mov	r0, r5
c0de47e4:	4619      	mov	r1, r3
c0de47e6:	9306      	str	r3, [sp, #24]
c0de47e8:	4633      	mov	r3, r6
c0de47ea:	f008 fecd 	bl	c0ded588 <__aeabi_uldivmod>
c0de47ee:	9005      	str	r0, [sp, #20]
c0de47f0:	9104      	str	r1, [sp, #16]
c0de47f2:	9a03      	ldr	r2, [sp, #12]
c0de47f4:	4633      	mov	r3, r6
c0de47f6:	f008 fee7 	bl	c0ded5c8 <__aeabi_lmul>
c0de47fa:	1a28      	subs	r0, r5, r0
c0de47fc:	2130      	movs	r1, #48	; 0x30
        dst[i] = src % 10 + '0';
c0de47fe:	4301      	orrs	r1, r0
c0de4800:	9a02      	ldr	r2, [sp, #8]
c0de4802:	55d1      	strb	r1, [r2, r7]
        i++;
c0de4804:	1c64      	adds	r4, r4, #1
c0de4806:	2009      	movs	r0, #9
    } while (src);
c0de4808:	1b40      	subs	r0, r0, r5
c0de480a:	4630      	mov	r0, r6
c0de480c:	9906      	ldr	r1, [sp, #24]
c0de480e:	4188      	sbcs	r0, r1
c0de4810:	9d05      	ldr	r5, [sp, #20]
c0de4812:	9b04      	ldr	r3, [sp, #16]
c0de4814:	d3dd      	bcc.n	c0de47d2 <u64_to_string+0xe>
    dst[i] = '\0';
c0de4816:	b2e0      	uxtb	r0, r4
c0de4818:	5416      	strb	r6, [r2, r0]
    while (j < i) {
c0de481a:	42be      	cmp	r6, r7
c0de481c:	d206      	bcs.n	c0de482c <u64_to_string+0x68>
        char tmp = dst[i];
c0de481e:	5dd0      	ldrb	r0, [r2, r7]
        dst[i] = dst[j];
c0de4820:	5d91      	ldrb	r1, [r2, r6]
c0de4822:	55d1      	strb	r1, [r2, r7]
        dst[j] = tmp;
c0de4824:	5590      	strb	r0, [r2, r6]
        i--;
c0de4826:	1e7f      	subs	r7, r7, #1
        j++;
c0de4828:	1c76      	adds	r6, r6, #1
c0de482a:	e7f6      	b.n	c0de481a <u64_to_string+0x56>
}
c0de482c:	b007      	add	sp, #28
c0de482e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de4830:	4801      	ldr	r0, [pc, #4]	; (c0de4838 <u64_to_string+0x74>)
            THROW(0x6502);
c0de4832:	f002 fdf8 	bl	c0de7426 <os_longjmp>
c0de4836:	46c0      	nop			; (mov r8, r8)
c0de4838:	00006502 	.word	0x00006502

c0de483c <getEthDisplayableAddress>:
`sha3` context doesn't have have to be initialized prior to call.*/
void getEthDisplayableAddress(uint8_t *in,
                              char *out,
                              size_t out_len,
                              cx_sha3_t *sha3,
                              uint64_t chainId) {
c0de483c:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
    if (out_len < 43) {
c0de483e:	2a2a      	cmp	r2, #42	; 0x2a
c0de4840:	d806      	bhi.n	c0de4850 <getEthDisplayableAddress+0x14>
        strlcpy(out, "ERROR", out_len);
c0de4842:	4b0a      	ldr	r3, [pc, #40]	; (c0de486c <getEthDisplayableAddress+0x30>)
c0de4844:	447b      	add	r3, pc
c0de4846:	4608      	mov	r0, r1
c0de4848:	4619      	mov	r1, r3
c0de484a:	f009 f9c3 	bl	c0dedbd4 <strlcpy>
        return;
    }
    out[0] = '0';
    out[1] = 'x';
    getEthAddressStringFromBinary(in, out + 2, sha3, chainId);
}
c0de484e:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0de4850:	9a07      	ldr	r2, [sp, #28]
c0de4852:	9c06      	ldr	r4, [sp, #24]
c0de4854:	2578      	movs	r5, #120	; 0x78
    out[1] = 'x';
c0de4856:	704d      	strb	r5, [r1, #1]
c0de4858:	2530      	movs	r5, #48	; 0x30
    out[0] = '0';
c0de485a:	700d      	strb	r5, [r1, #0]
    getEthAddressStringFromBinary(in, out + 2, sha3, chainId);
c0de485c:	9400      	str	r4, [sp, #0]
c0de485e:	9201      	str	r2, [sp, #4]
c0de4860:	1c89      	adds	r1, r1, #2
c0de4862:	461a      	mov	r2, r3
c0de4864:	f7ff ff40 	bl	c0de46e8 <getEthAddressStringFromBinary>
}
c0de4868:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0de486a:	46c0      	nop			; (mov r8, r8)
c0de486c:	000098ab 	.word	0x000098ab

c0de4870 <adjustDecimals>:

bool adjustDecimals(const char *src,
                    size_t srcLength,
                    char *target,
                    size_t targetLength,
                    uint8_t decimals) {
c0de4870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t startOffset;
    uint32_t lastZeroOffset = 0;
    uint32_t offset = 0;
    if ((srcLength == 1) && (*src == '0')) {
c0de4872:	2901      	cmp	r1, #1
c0de4874:	d10a      	bne.n	c0de488c <adjustDecimals+0x1c>
c0de4876:	7804      	ldrb	r4, [r0, #0]
c0de4878:	2c30      	cmp	r4, #48	; 0x30
c0de487a:	d107      	bne.n	c0de488c <adjustDecimals+0x1c>
        if (targetLength < 2) {
c0de487c:	2b02      	cmp	r3, #2
c0de487e:	d31a      	bcc.n	c0de48b6 <adjustDecimals+0x46>
c0de4880:	2000      	movs	r0, #0
            return false;
        }
        target[0] = '0';
        target[1] = '\0';
c0de4882:	7050      	strb	r0, [r2, #1]
c0de4884:	2030      	movs	r0, #48	; 0x30
        target[0] = '0';
c0de4886:	7010      	strb	r0, [r2, #0]
c0de4888:	2001      	movs	r0, #1
        if (target[lastZeroOffset - 1] == '.') {
            target[lastZeroOffset - 1] = '\0';
        }
    }
    return true;
}
c0de488a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de488c:	9f06      	ldr	r7, [sp, #24]
    if (srcLength <= decimals) {
c0de488e:	428f      	cmp	r7, r1
c0de4890:	d20e      	bcs.n	c0de48b0 <adjustDecimals+0x40>
        if (targetLength < srcLength + 1 + 1) {
c0de4892:	1c8d      	adds	r5, r1, #2
c0de4894:	429d      	cmp	r5, r3
c0de4896:	d80e      	bhi.n	c0de48b6 <adjustDecimals+0x46>
c0de4898:	1bcd      	subs	r5, r1, r7
c0de489a:	4613      	mov	r3, r2
c0de489c:	4606      	mov	r6, r0
c0de489e:	9700      	str	r7, [sp, #0]
        while (offset < delta) {
c0de48a0:	42b9      	cmp	r1, r7
c0de48a2:	d00a      	beq.n	c0de48ba <adjustDecimals+0x4a>
            target[offset++] = src[sourceOffset++];
c0de48a4:	7834      	ldrb	r4, [r6, #0]
c0de48a6:	701c      	strb	r4, [r3, #0]
        while (offset < delta) {
c0de48a8:	1c5b      	adds	r3, r3, #1
c0de48aa:	1c76      	adds	r6, r6, #1
c0de48ac:	1c7f      	adds	r7, r7, #1
c0de48ae:	e7f7      	b.n	c0de48a0 <adjustDecimals+0x30>
        if (targetLength < srcLength + 1 + 2 + delta) {
c0de48b0:	1cfd      	adds	r5, r7, #3
c0de48b2:	429d      	cmp	r5, r3
c0de48b4:	d912      	bls.n	c0de48dc <adjustDecimals+0x6c>
c0de48b6:	2000      	movs	r0, #0
}
c0de48b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (decimals != 0) {
c0de48ba:	9b00      	ldr	r3, [sp, #0]
c0de48bc:	2b00      	cmp	r3, #0
c0de48be:	462b      	mov	r3, r5
c0de48c0:	d002      	beq.n	c0de48c8 <adjustDecimals+0x58>
c0de48c2:	232e      	movs	r3, #46	; 0x2e
            target[offset++] = '.';
c0de48c4:	5553      	strb	r3, [r2, r5]
c0de48c6:	1c6b      	adds	r3, r5, #1
        while (sourceOffset < srcLength) {
c0de48c8:	1940      	adds	r0, r0, r5
c0de48ca:	18d6      	adds	r6, r2, r3
c0de48cc:	2400      	movs	r4, #0
c0de48ce:	192f      	adds	r7, r5, r4
c0de48d0:	428f      	cmp	r7, r1
c0de48d2:	d211      	bcs.n	c0de48f8 <adjustDecimals+0x88>
            target[offset++] = src[sourceOffset++];
c0de48d4:	5d07      	ldrb	r7, [r0, r4]
c0de48d6:	5537      	strb	r7, [r6, r4]
        while (sourceOffset < srcLength) {
c0de48d8:	1c64      	adds	r4, r4, #1
c0de48da:	e7f8      	b.n	c0de48ce <adjustDecimals+0x5e>
c0de48dc:	232e      	movs	r3, #46	; 0x2e
        target[offset++] = '.';
c0de48de:	7053      	strb	r3, [r2, #1]
c0de48e0:	2530      	movs	r5, #48	; 0x30
        target[offset++] = '0';
c0de48e2:	7015      	strb	r5, [r2, #0]
c0de48e4:	463c      	mov	r4, r7
        for (uint32_t i = 0; i < delta; i++) {
c0de48e6:	1a7e      	subs	r6, r7, r1
c0de48e8:	1cb3      	adds	r3, r6, #2
c0de48ea:	1c97      	adds	r7, r2, #2
c0de48ec:	2e00      	cmp	r6, #0
c0de48ee:	d005      	beq.n	c0de48fc <adjustDecimals+0x8c>
            target[offset++] = '0';
c0de48f0:	703d      	strb	r5, [r7, #0]
        for (uint32_t i = 0; i < delta; i++) {
c0de48f2:	1c7f      	adds	r7, r7, #1
c0de48f4:	1e76      	subs	r6, r6, #1
c0de48f6:	e7f9      	b.n	c0de48ec <adjustDecimals+0x7c>
c0de48f8:	1918      	adds	r0, r3, r4
c0de48fa:	e00a      	b.n	c0de4912 <adjustDecimals+0xa2>
        for (uint32_t i = 0; i < srcLength; i++) {
c0de48fc:	1915      	adds	r5, r2, r4
c0de48fe:	2602      	movs	r6, #2
c0de4900:	1a71      	subs	r1, r6, r1
c0de4902:	2902      	cmp	r1, #2
c0de4904:	d004      	beq.n	c0de4910 <adjustDecimals+0xa0>
            target[offset++] = src[i];
c0de4906:	7806      	ldrb	r6, [r0, #0]
c0de4908:	546e      	strb	r6, [r5, r1]
        for (uint32_t i = 0; i < srcLength; i++) {
c0de490a:	1c40      	adds	r0, r0, #1
c0de490c:	1c49      	adds	r1, r1, #1
c0de490e:	e7f8      	b.n	c0de4902 <adjustDecimals+0x92>
c0de4910:	1860      	adds	r0, r4, r1
c0de4912:	2100      	movs	r1, #0
c0de4914:	5411      	strb	r1, [r2, r0]
    for (uint32_t i = startOffset; i < offset; i++) {
c0de4916:	4283      	cmp	r3, r0
c0de4918:	d20a      	bcs.n	c0de4930 <adjustDecimals+0xc0>
        if (target[i] == '0') {
c0de491a:	5cd5      	ldrb	r5, [r2, r3]
c0de491c:	2900      	cmp	r1, #0
c0de491e:	461c      	mov	r4, r3
c0de4920:	d000      	beq.n	c0de4924 <adjustDecimals+0xb4>
c0de4922:	460c      	mov	r4, r1
c0de4924:	2d30      	cmp	r5, #48	; 0x30
c0de4926:	d000      	beq.n	c0de492a <adjustDecimals+0xba>
c0de4928:	2400      	movs	r4, #0
    for (uint32_t i = startOffset; i < offset; i++) {
c0de492a:	1c5b      	adds	r3, r3, #1
c0de492c:	4621      	mov	r1, r4
c0de492e:	e7f2      	b.n	c0de4916 <adjustDecimals+0xa6>
c0de4930:	2001      	movs	r0, #1
    if (lastZeroOffset != 0) {
c0de4932:	2900      	cmp	r1, #0
c0de4934:	d006      	beq.n	c0de4944 <adjustDecimals+0xd4>
c0de4936:	2300      	movs	r3, #0
        target[lastZeroOffset] = '\0';
c0de4938:	5453      	strb	r3, [r2, r1]
        if (target[lastZeroOffset - 1] == '.') {
c0de493a:	1e49      	subs	r1, r1, #1
c0de493c:	5c54      	ldrb	r4, [r2, r1]
c0de493e:	2c2e      	cmp	r4, #46	; 0x2e
c0de4940:	d100      	bne.n	c0de4944 <adjustDecimals+0xd4>
            target[lastZeroOffset - 1] = '\0';
c0de4942:	5453      	strb	r3, [r2, r1]
}
c0de4944:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0de4946 <eth_plugin_prepare_init>:
#include "eth_plugin_internal.h"
#include "shared_context.h"
#include "network.h"
#include "ethUtils.h"

void eth_plugin_prepare_init(ethPluginInitContract_t *init, uint8_t *selector, uint32_t dataSize) {
c0de4946:	b570      	push	{r4, r5, r6, lr}
c0de4948:	4614      	mov	r4, r2
c0de494a:	460d      	mov	r5, r1
c0de494c:	4606      	mov	r6, r0
c0de494e:	2120      	movs	r1, #32
    memset((uint8_t *) init, 0, sizeof(ethPluginInitContract_t));
c0de4950:	f008 ff60 	bl	c0ded814 <__aeabi_memclr>
    init->selector = selector;
c0de4954:	6175      	str	r5, [r6, #20]
    init->dataSize = dataSize;
c0de4956:	61b4      	str	r4, [r6, #24]
}
c0de4958:	bd70      	pop	{r4, r5, r6, pc}

c0de495a <eth_plugin_prepare_provide_parameter>:

void eth_plugin_prepare_provide_parameter(ethPluginProvideParameter_t *provideParameter,
                                          uint8_t *parameter,
                                          uint32_t parameterOffset) {
c0de495a:	b570      	push	{r4, r5, r6, lr}
c0de495c:	4614      	mov	r4, r2
c0de495e:	460d      	mov	r5, r1
c0de4960:	4606      	mov	r6, r0
c0de4962:	2118      	movs	r1, #24
    memset((uint8_t *) provideParameter, 0, sizeof(ethPluginProvideParameter_t));
c0de4964:	f008 ff56 	bl	c0ded814 <__aeabi_memclr>
    provideParameter->parameter = parameter;
c0de4968:	60f5      	str	r5, [r6, #12]
    provideParameter->parameterOffset = parameterOffset;
c0de496a:	6134      	str	r4, [r6, #16]
}
c0de496c:	bd70      	pop	{r4, r5, r6, pc}

c0de496e <eth_plugin_prepare_finalize>:

void eth_plugin_prepare_finalize(ethPluginFinalize_t *finalize) {
c0de496e:	b580      	push	{r7, lr}
c0de4970:	2120      	movs	r1, #32
    memset((uint8_t *) finalize, 0, sizeof(ethPluginFinalize_t));
c0de4972:	f008 ff4f 	bl	c0ded814 <__aeabi_memclr>
}
c0de4976:	bd80      	pop	{r7, pc}

c0de4978 <eth_plugin_prepare_provide_info>:

void eth_plugin_prepare_provide_info(ethPluginProvideInfo_t *provideToken) {
c0de4978:	b580      	push	{r7, lr}
c0de497a:	2118      	movs	r1, #24
    memset((uint8_t *) provideToken, 0, sizeof(ethPluginProvideInfo_t));
c0de497c:	f008 ff4a 	bl	c0ded814 <__aeabi_memclr>
}
c0de4980:	bd80      	pop	{r7, pc}

c0de4982 <eth_plugin_prepare_query_contract_ID>:

void eth_plugin_prepare_query_contract_ID(ethQueryContractID_t *queryContractID,
                                          char *name,
                                          uint32_t nameLength,
                                          char *version,
                                          uint32_t versionLength) {
c0de4982:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de4984:	461c      	mov	r4, r3
c0de4986:	4615      	mov	r5, r2
c0de4988:	460e      	mov	r6, r1
c0de498a:	4607      	mov	r7, r0
c0de498c:	2120      	movs	r1, #32
    memset((uint8_t *) queryContractID, 0, sizeof(ethQueryContractID_t));
c0de498e:	f008 ff41 	bl	c0ded814 <__aeabi_memclr>
c0de4992:	9806      	ldr	r0, [sp, #24]
    queryContractID->name = name;
c0de4994:	60fe      	str	r6, [r7, #12]
    queryContractID->nameLength = nameLength;
c0de4996:	613d      	str	r5, [r7, #16]
    queryContractID->version = version;
c0de4998:	617c      	str	r4, [r7, #20]
    queryContractID->versionLength = versionLength;
c0de499a:	61b8      	str	r0, [r7, #24]
}
c0de499c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de499e:	d4d4      	bmi.n	c0de494a <eth_plugin_prepare_init+0x4>

c0de49a0 <eth_plugin_prepare_query_contract_UI>:
void eth_plugin_prepare_query_contract_UI(ethQueryContractUI_t *queryContractUI,
                                          uint8_t screenIndex,
                                          char *title,
                                          uint32_t titleLength,
                                          char *msg,
                                          uint32_t msgLength) {
c0de49a0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de49a2:	9301      	str	r3, [sp, #4]
c0de49a4:	9202      	str	r2, [sp, #8]
c0de49a6:	9100      	str	r1, [sp, #0]
c0de49a8:	4606      	mov	r6, r0
c0de49aa:	2138      	movs	r1, #56	; 0x38
    memset((uint8_t *) queryContractUI, 0, sizeof(ethQueryContractUI_t));
c0de49ac:	f008 ff32 	bl	c0ded814 <__aeabi_memclr>

    // If no extra information was found, set the pointer to NULL
    if (NO_EXTRA_INFO(tmpCtx, 1)) {
c0de49b0:	4818      	ldr	r0, [pc, #96]	; (c0de4a14 <eth_plugin_prepare_query_contract_UI+0x74>)
c0de49b2:	4649      	mov	r1, r9
c0de49b4:	180d      	adds	r5, r1, r0
c0de49b6:	462c      	mov	r4, r5
c0de49b8:	34a7      	adds	r4, #167	; 0xa7
c0de49ba:	4620      	mov	r0, r4
c0de49bc:	f000 f82c 	bl	c0de4a18 <allzeroes>
c0de49c0:	2700      	movs	r7, #0
c0de49c2:	2800      	cmp	r0, #0
c0de49c4:	d000      	beq.n	c0de49c8 <eth_plugin_prepare_query_contract_UI+0x28>
c0de49c6:	463c      	mov	r4, r7
c0de49c8:	60b4      	str	r4, [r6, #8]
c0de49ca:	354c      	adds	r5, #76	; 0x4c
    } else {
        queryContractUI->item1 = &tmpCtx.transactionContext.extraInfo[1];
    }

    // If no extra information was found, set the pointer to NULL
    if (NO_EXTRA_INFO(tmpCtx, 0)) {
c0de49cc:	4628      	mov	r0, r5
c0de49ce:	f000 f823 	bl	c0de4a18 <allzeroes>
c0de49d2:	2800      	cmp	r0, #0
c0de49d4:	d000      	beq.n	c0de49d8 <eth_plugin_prepare_query_contract_UI+0x38>
c0de49d6:	463d      	mov	r5, r7
c0de49d8:	60f5      	str	r5, [r6, #12]
        queryContractUI->item2 = NULL;
    } else {
        queryContractUI->item2 = &tmpCtx.transactionContext.extraInfo[0];
    }

    strlcpy(queryContractUI->network_ticker, get_network_ticker(), MAX_TICKER_LEN);
c0de49da:	f002 fd0f 	bl	c0de73fc <get_network_ticker>
c0de49de:	4601      	mov	r1, r0
c0de49e0:	4634      	mov	r4, r6
c0de49e2:	3410      	adds	r4, #16
c0de49e4:	250c      	movs	r5, #12
c0de49e6:	4620      	mov	r0, r4
c0de49e8:	462a      	mov	r2, r5
c0de49ea:	f009 f8f3 	bl	c0dedbd4 <strlcpy>
c0de49ee:	2020      	movs	r0, #32

    queryContractUI->screenIndex = screenIndex;
c0de49f0:	9900      	ldr	r1, [sp, #0]
c0de49f2:	5431      	strb	r1, [r6, r0]
    strlcpy(queryContractUI->network_ticker,
            get_network_ticker(),
c0de49f4:	f002 fd02 	bl	c0de73fc <get_network_ticker>
c0de49f8:	4601      	mov	r1, r0
    strlcpy(queryContractUI->network_ticker,
c0de49fa:	4620      	mov	r0, r4
c0de49fc:	462a      	mov	r2, r5
c0de49fe:	f009 f8e9 	bl	c0dedbd4 <strlcpy>
c0de4a02:	9809      	ldr	r0, [sp, #36]	; 0x24
            sizeof(queryContractUI->network_ticker));
    queryContractUI->title = title;
    queryContractUI->titleLength = titleLength;
    queryContractUI->msg = msg;
    queryContractUI->msgLength = msgLength;
c0de4a04:	6330      	str	r0, [r6, #48]	; 0x30
c0de4a06:	9808      	ldr	r0, [sp, #32]
    queryContractUI->msg = msg;
c0de4a08:	62f0      	str	r0, [r6, #44]	; 0x2c
    queryContractUI->titleLength = titleLength;
c0de4a0a:	9801      	ldr	r0, [sp, #4]
c0de4a0c:	62b0      	str	r0, [r6, #40]	; 0x28
    queryContractUI->title = title;
c0de4a0e:	9802      	ldr	r0, [sp, #8]
c0de4a10:	6270      	str	r0, [r6, #36]	; 0x24
}
c0de4a12:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de4a14:	00000124 	.word	0x00000124

c0de4a18 <allzeroes>:
static __attribute__((no_instrument_function)) inline int allzeroes(void *buf, size_t n) {
c0de4a18:	2100      	movs	r1, #0
    for (size_t i = 0; i < n; ++i) {
c0de4a1a:	295b      	cmp	r1, #91	; 0x5b
c0de4a1c:	d005      	beq.n	c0de4a2a <allzeroes+0x12>
        if (p[i]) {
c0de4a1e:	5c42      	ldrb	r2, [r0, r1]
    for (size_t i = 0; i < n; ++i) {
c0de4a20:	1c49      	adds	r1, r1, #1
        if (p[i]) {
c0de4a22:	2a00      	cmp	r2, #0
c0de4a24:	d0f9      	beq.n	c0de4a1a <allzeroes+0x2>
c0de4a26:	2000      	movs	r0, #0
}
c0de4a28:	4770      	bx	lr
c0de4a2a:	2001      	movs	r0, #1
c0de4a2c:	4770      	bx	lr
c0de4a2e:	d4d4      	bmi.n	c0de49da <eth_plugin_prepare_query_contract_UI+0x3a>

c0de4a30 <eth_plugin_perform_init>:

    return false;
}

eth_plugin_result_t eth_plugin_perform_init(uint8_t *contractAddress,
                                            ethPluginInitContract_t *init) {
c0de4a30:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de4a32:	b085      	sub	sp, #20
c0de4a34:	9104      	str	r1, [sp, #16]
c0de4a36:	4605      	mov	r5, r0
    dataContext.tokenContext.pluginStatus = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de4a38:	4c4f      	ldr	r4, [pc, #316]	; (c0de4b78 <eth_plugin_perform_init+0x148>)
c0de4a3a:	4648      	mov	r0, r9
c0de4a3c:	1901      	adds	r1, r0, r4
c0de4a3e:	2201      	movs	r2, #1
c0de4a40:	778a      	strb	r2, [r1, #30]

    PRINTF("Selector %.*H\n", 4, init->selector);
    switch (pluginType) {
c0de4a42:	494e      	ldr	r1, [pc, #312]	; (c0de4b7c <eth_plugin_perform_init+0x14c>)
c0de4a44:	5c40      	ldrb	r0, [r0, r1]
c0de4a46:	2803      	cmp	r0, #3
c0de4a48:	d226      	bcs.n	c0de4a98 <eth_plugin_perform_init+0x68>
    if (memcmp(contractAddress,
c0de4a4a:	4648      	mov	r0, r9
c0de4a4c:	1901      	adds	r1, r0, r4
c0de4a4e:	3144      	adds	r1, #68	; 0x44
c0de4a50:	2214      	movs	r2, #20
c0de4a52:	4628      	mov	r0, r5
c0de4a54:	f008 fefe 	bl	c0ded854 <memcmp>
c0de4a58:	2800      	cmp	r0, #0
c0de4a5a:	d000      	beq.n	c0de4a5e <eth_plugin_perform_init+0x2e>
c0de4a5c:	e088      	b.n	c0de4b70 <eth_plugin_perform_init+0x140>
    if (memcmp(init->selector,
c0de4a5e:	4648      	mov	r0, r9
c0de4a60:	1900      	adds	r0, r0, r4
c0de4a62:	2158      	movs	r1, #88	; 0x58
c0de4a64:	5c41      	ldrb	r1, [r0, r1]
c0de4a66:	3058      	adds	r0, #88	; 0x58
c0de4a68:	7842      	ldrb	r2, [r0, #1]
c0de4a6a:	0212      	lsls	r2, r2, #8
c0de4a6c:	1851      	adds	r1, r2, r1
c0de4a6e:	7882      	ldrb	r2, [r0, #2]
c0de4a70:	78c0      	ldrb	r0, [r0, #3]
c0de4a72:	0200      	lsls	r0, r0, #8
c0de4a74:	1880      	adds	r0, r0, r2
c0de4a76:	0400      	lsls	r0, r0, #16
c0de4a78:	1840      	adds	r0, r0, r1
c0de4a7a:	9904      	ldr	r1, [sp, #16]
c0de4a7c:	6949      	ldr	r1, [r1, #20]
c0de4a7e:	780a      	ldrb	r2, [r1, #0]
c0de4a80:	784b      	ldrb	r3, [r1, #1]
c0de4a82:	021b      	lsls	r3, r3, #8
c0de4a84:	189a      	adds	r2, r3, r2
c0de4a86:	788b      	ldrb	r3, [r1, #2]
c0de4a88:	78c9      	ldrb	r1, [r1, #3]
c0de4a8a:	0209      	lsls	r1, r1, #8
c0de4a8c:	18c9      	adds	r1, r1, r3
c0de4a8e:	0409      	lsls	r1, r1, #16
c0de4a90:	1889      	adds	r1, r1, r2
c0de4a92:	4281      	cmp	r1, r0
c0de4a94:	d04f      	beq.n	c0de4b36 <eth_plugin_perform_init+0x106>
c0de4a96:	e06b      	b.n	c0de4b70 <eth_plugin_perform_init+0x140>
    switch (pluginType) {
c0de4a98:	d16a      	bne.n	c0de4b70 <eth_plugin_perform_init+0x140>
c0de4a9a:	2000      	movs	r0, #0
c0de4a9c:	4a39      	ldr	r2, [pc, #228]	; (c0de4b84 <eth_plugin_perform_init+0x154>)
c0de4a9e:	447a      	add	r2, pc
c0de4aa0:	9200      	str	r2, [sp, #0]
c0de4aa2:	9502      	str	r5, [sp, #8]
c0de4aa4:	9001      	str	r0, [sp, #4]
        selectors = (const uint8_t **) PIC(INTERNAL_ETH_PLUGINS[i].selectors);
c0de4aa6:	b2c0      	uxtb	r0, r0
c0de4aa8:	2118      	movs	r1, #24
c0de4aaa:	4341      	muls	r1, r0
c0de4aac:	1854      	adds	r4, r2, r1
c0de4aae:	6860      	ldr	r0, [r4, #4]
c0de4ab0:	f003 fbc8 	bl	c0de8244 <pic>
        if (selectors == NULL) {
c0de4ab4:	2800      	cmp	r0, #0
c0de4ab6:	d04f      	beq.n	c0de4b58 <eth_plugin_perform_init+0x128>
c0de4ab8:	4607      	mov	r7, r0
c0de4aba:	7a20      	ldrb	r0, [r4, #8]
c0de4abc:	9003      	str	r0, [sp, #12]
c0de4abe:	2600      	movs	r6, #0
c0de4ac0:	4621      	mov	r1, r4
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0de4ac2:	2d00      	cmp	r5, #0
c0de4ac4:	d02c      	beq.n	c0de4b20 <eth_plugin_perform_init+0xf0>
c0de4ac6:	9803      	ldr	r0, [sp, #12]
c0de4ac8:	4286      	cmp	r6, r0
c0de4aca:	d229      	bcs.n	c0de4b20 <eth_plugin_perform_init+0xf0>
            if (memcmp(init->selector, (const void *) PIC(selectors[j]), SELECTOR_SIZE) == 0) {
c0de4acc:	9804      	ldr	r0, [sp, #16]
c0de4ace:	6945      	ldr	r5, [r0, #20]
c0de4ad0:	6838      	ldr	r0, [r7, #0]
c0de4ad2:	460c      	mov	r4, r1
c0de4ad4:	f003 fbb6 	bl	c0de8244 <pic>
c0de4ad8:	7801      	ldrb	r1, [r0, #0]
c0de4ada:	7842      	ldrb	r2, [r0, #1]
c0de4adc:	0212      	lsls	r2, r2, #8
c0de4ade:	1851      	adds	r1, r2, r1
c0de4ae0:	7882      	ldrb	r2, [r0, #2]
c0de4ae2:	78c0      	ldrb	r0, [r0, #3]
c0de4ae4:	0200      	lsls	r0, r0, #8
c0de4ae6:	1880      	adds	r0, r0, r2
c0de4ae8:	0400      	lsls	r0, r0, #16
c0de4aea:	1840      	adds	r0, r0, r1
c0de4aec:	7829      	ldrb	r1, [r5, #0]
c0de4aee:	786a      	ldrb	r2, [r5, #1]
c0de4af0:	0212      	lsls	r2, r2, #8
c0de4af2:	1851      	adds	r1, r2, r1
c0de4af4:	78aa      	ldrb	r2, [r5, #2]
c0de4af6:	78eb      	ldrb	r3, [r5, #3]
c0de4af8:	021b      	lsls	r3, r3, #8
c0de4afa:	189a      	adds	r2, r3, r2
c0de4afc:	0412      	lsls	r2, r2, #16
c0de4afe:	1851      	adds	r1, r2, r1
c0de4b00:	4281      	cmp	r1, r0
c0de4b02:	4621      	mov	r1, r4
c0de4b04:	d108      	bne.n	c0de4b18 <eth_plugin_perform_init+0xe8>
                if ((INTERNAL_ETH_PLUGINS[i].availableCheck == NULL) ||
c0de4b06:	6808      	ldr	r0, [r1, #0]
c0de4b08:	2800      	cmp	r0, #0
c0de4b0a:	d00d      	beq.n	c0de4b28 <eth_plugin_perform_init+0xf8>
                    ((PluginAvailableCheck) PIC(INTERNAL_ETH_PLUGINS[i].availableCheck)) ()) {
c0de4b0c:	f003 fb9a 	bl	c0de8244 <pic>
c0de4b10:	4780      	blx	r0
c0de4b12:	4621      	mov	r1, r4
                if ((INTERNAL_ETH_PLUGINS[i].availableCheck == NULL) ||
c0de4b14:	2800      	cmp	r0, #0
c0de4b16:	d107      	bne.n	c0de4b28 <eth_plugin_perform_init+0xf8>
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0de4b18:	1d3f      	adds	r7, r7, #4
             j++) {
c0de4b1a:	1c76      	adds	r6, r6, #1
c0de4b1c:	9d02      	ldr	r5, [sp, #8]
c0de4b1e:	e7d0      	b.n	c0de4ac2 <eth_plugin_perform_init+0x92>
c0de4b20:	9801      	ldr	r0, [sp, #4]
    for (i = 0;; i++) {
c0de4b22:	1c40      	adds	r0, r0, #1
c0de4b24:	9a00      	ldr	r2, [sp, #0]
c0de4b26:	e7bd      	b.n	c0de4aa4 <eth_plugin_perform_init+0x74>
                    strlcpy(dataContext.tokenContext.pluginName,
c0de4b28:	4648      	mov	r0, r9
c0de4b2a:	4c13      	ldr	r4, [pc, #76]	; (c0de4b78 <eth_plugin_perform_init+0x148>)
c0de4b2c:	1900      	adds	r0, r0, r4
                            INTERNAL_ETH_PLUGINS[i].alias,
c0de4b2e:	3109      	adds	r1, #9
c0de4b30:	221e      	movs	r2, #30
                    strlcpy(dataContext.tokenContext.pluginName,
c0de4b32:	f009 f84f 	bl	c0dedbd4 <strlcpy>
c0de4b36:	4648      	mov	r0, r9
c0de4b38:	1900      	adds	r0, r0, r4
c0de4b3a:	2104      	movs	r1, #4
c0de4b3c:	7781      	strb	r1, [r0, #30]
c0de4b3e:	20ff      	movs	r0, #255	; 0xff
c0de4b40:	3002      	adds	r0, #2
        return status;
    }

    PRINTF("eth_plugin_init\n");
    PRINTF("Trying plugin %s\n", dataContext.tokenContext.pluginName);
    status = eth_plugin_call(ETH_PLUGIN_INIT_CONTRACT, (void *) init);
c0de4b42:	9904      	ldr	r1, [sp, #16]
c0de4b44:	f000 f820 	bl	c0de4b88 <eth_plugin_call>

    if (status <= ETH_PLUGIN_RESULT_UNSUCCESSFUL) {
c0de4b48:	2803      	cmp	r0, #3
c0de4b4a:	d303      	bcc.n	c0de4b54 <eth_plugin_perform_init+0x124>
        return status;
    }
    PRINTF("eth_plugin_init ok %s\n", dataContext.tokenContext.pluginName);
    dataContext.tokenContext.pluginStatus = ETH_PLUGIN_RESULT_OK;
c0de4b4c:	4648      	mov	r0, r9
c0de4b4e:	1901      	adds	r1, r0, r4
c0de4b50:	2004      	movs	r0, #4
c0de4b52:	7788      	strb	r0, [r1, #30]
    return ETH_PLUGIN_RESULT_OK;
}
c0de4b54:	b005      	add	sp, #20
c0de4b56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (called_from_swap && (contractAddress != NULL)) {
c0de4b58:	4809      	ldr	r0, [pc, #36]	; (c0de4b80 <eth_plugin_perform_init+0x150>)
c0de4b5a:	4649      	mov	r1, r9
c0de4b5c:	5c08      	ldrb	r0, [r1, r0]
c0de4b5e:	4241      	negs	r1, r0
c0de4b60:	4141      	adcs	r1, r0
c0de4b62:	4268      	negs	r0, r5
c0de4b64:	4168      	adcs	r0, r5
c0de4b66:	2d00      	cmp	r5, #0
c0de4b68:	4c03      	ldr	r4, [pc, #12]	; (c0de4b78 <eth_plugin_perform_init+0x148>)
c0de4b6a:	d0e8      	beq.n	c0de4b3e <eth_plugin_perform_init+0x10e>
c0de4b6c:	4308      	orrs	r0, r1
c0de4b6e:	e7f1      	b.n	c0de4b54 <eth_plugin_perform_init+0x124>
c0de4b70:	2000      	movs	r0, #0
c0de4b72:	f004 fbb7 	bl	c0de92e4 <os_sched_exit>
c0de4b76:	46c0      	nop			; (mov r8, r8)
c0de4b78:	00000594 	.word	0x00000594
c0de4b7c:	0000011e 	.word	0x0000011e
c0de4b80:	0000011d 	.word	0x0000011d
c0de4b84:	0000b036 	.word	0x0000b036

c0de4b88 <eth_plugin_call>:

eth_plugin_result_t eth_plugin_call(int method, void *parameter) {
c0de4b88:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de4b8a:	b095      	sub	sp, #84	; 0x54
c0de4b8c:	4606      	mov	r6, r0
    ethPluginSharedRW_t pluginRW;
    ethPluginSharedRO_t pluginRO;
    char *alias;
    uint8_t i;

    pluginRW.sha3 = &global_sha3;
c0de4b8e:	487c      	ldr	r0, [pc, #496]	; (c0de4d80 <eth_plugin_call+0x1f8>)
c0de4b90:	464a      	mov	r2, r9
c0de4b92:	1810      	adds	r0, r2, r0
c0de4b94:	9014      	str	r0, [sp, #80]	; 0x50
    pluginRO.txContent = &tmpContent.txContent;
c0de4b96:	487b      	ldr	r0, [pc, #492]	; (c0de4d84 <eth_plugin_call+0x1fc>)
c0de4b98:	1810      	adds	r0, r2, r0
c0de4b9a:	9013      	str	r0, [sp, #76]	; 0x4c

    if (dataContext.tokenContext.pluginStatus <= ETH_PLUGIN_RESULT_UNSUCCESSFUL) {
c0de4b9c:	4d7a      	ldr	r5, [pc, #488]	; (c0de4d88 <eth_plugin_call+0x200>)
c0de4b9e:	1950      	adds	r0, r2, r5
c0de4ba0:	7f84      	ldrb	r4, [r0, #30]
c0de4ba2:	2c03      	cmp	r4, #3
c0de4ba4:	d202      	bcs.n	c0de4bac <eth_plugin_call+0x24>
        default:
            return ETH_PLUGIN_RESULT_UNAVAILABLE;
    }

    return ETH_PLUGIN_RESULT_OK;
}
c0de4ba6:	4620      	mov	r0, r4
c0de4ba8:	b015      	add	sp, #84	; 0x54
c0de4baa:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de4bac:	2083      	movs	r0, #131	; 0x83
c0de4bae:	0043      	lsls	r3, r0, #1
c0de4bb0:	2401      	movs	r4, #1
    switch (method) {
c0de4bb2:	429e      	cmp	r6, r3
c0de4bb4:	d040      	beq.n	c0de4c38 <eth_plugin_call+0xb0>
c0de4bb6:	2081      	movs	r0, #129	; 0x81
c0de4bb8:	0040      	lsls	r0, r0, #1
c0de4bba:	4286      	cmp	r6, r0
c0de4bbc:	d031      	beq.n	c0de4c22 <eth_plugin_call+0x9a>
c0de4bbe:	20ff      	movs	r0, #255	; 0xff
c0de4bc0:	4602      	mov	r2, r0
c0de4bc2:	3204      	adds	r2, #4
c0de4bc4:	4296      	cmp	r6, r2
c0de4bc6:	d017      	beq.n	c0de4bf8 <eth_plugin_call+0x70>
c0de4bc8:	2241      	movs	r2, #65	; 0x41
c0de4bca:	0092      	lsls	r2, r2, #2
c0de4bcc:	4296      	cmp	r6, r2
c0de4bce:	d021      	beq.n	c0de4c14 <eth_plugin_call+0x8c>
c0de4bd0:	4602      	mov	r2, r0
c0de4bd2:	3206      	adds	r2, #6
c0de4bd4:	4296      	cmp	r6, r2
c0de4bd6:	d016      	beq.n	c0de4c06 <eth_plugin_call+0x7e>
c0de4bd8:	3002      	adds	r0, #2
c0de4bda:	4286      	cmp	r6, r0
c0de4bdc:	d1e3      	bne.n	c0de4ba6 <eth_plugin_call+0x1e>
c0de4bde:	20a0      	movs	r0, #160	; 0xa0
            ((ethPluginInitContract_t *) parameter)->pluginContextLength =
c0de4be0:	6108      	str	r0, [r1, #16]
c0de4be2:	a813      	add	r0, sp, #76	; 0x4c
            ((ethPluginInitContract_t *) parameter)->pluginSharedRO = &pluginRO;
c0de4be4:	6088      	str	r0, [r1, #8]
c0de4be6:	a814      	add	r0, sp, #80	; 0x50
            ((ethPluginInitContract_t *) parameter)->pluginSharedRW = &pluginRW;
c0de4be8:	6048      	str	r0, [r1, #4]
            ((ethPluginInitContract_t *) parameter)->interfaceVersion =
c0de4bea:	800a      	strh	r2, [r1, #0]
            ((ethPluginInitContract_t *) parameter)->pluginContext =
c0de4bec:	4648      	mov	r0, r9
c0de4bee:	1940      	adds	r0, r0, r5
c0de4bf0:	4602      	mov	r2, r0
c0de4bf2:	3244      	adds	r2, #68	; 0x44
c0de4bf4:	60ca      	str	r2, [r1, #12]
c0de4bf6:	e026      	b.n	c0de4c46 <eth_plugin_call+0xbe>
c0de4bf8:	a813      	add	r0, sp, #76	; 0x4c
            ((ethPluginFinalize_t *) parameter)->pluginSharedRO = &pluginRO;
c0de4bfa:	6048      	str	r0, [r1, #4]
c0de4bfc:	a814      	add	r0, sp, #80	; 0x50
            ((ethPluginFinalize_t *) parameter)->pluginSharedRW = &pluginRW;
c0de4bfe:	6008      	str	r0, [r1, #0]
c0de4c00:	2001      	movs	r0, #1
            ((ethPluginFinalize_t *) parameter)->result = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de4c02:	7788      	strb	r0, [r1, #30]
c0de4c04:	e013      	b.n	c0de4c2e <eth_plugin_call+0xa6>
c0de4c06:	a813      	add	r0, sp, #76	; 0x4c
            ((ethQueryContractID_t *) parameter)->pluginSharedRO = &pluginRO;
c0de4c08:	6048      	str	r0, [r1, #4]
c0de4c0a:	a814      	add	r0, sp, #80	; 0x50
            ((ethQueryContractID_t *) parameter)->pluginSharedRW = &pluginRW;
c0de4c0c:	6008      	str	r0, [r1, #0]
c0de4c0e:	2001      	movs	r0, #1
            ((ethQueryContractID_t *) parameter)->result = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de4c10:	7708      	strb	r0, [r1, #28]
c0de4c12:	e00c      	b.n	c0de4c2e <eth_plugin_call+0xa6>
c0de4c14:	a813      	add	r0, sp, #76	; 0x4c
            ((ethPluginProvideInfo_t *) parameter)->pluginSharedRO = &pluginRO;
c0de4c16:	6048      	str	r0, [r1, #4]
c0de4c18:	a814      	add	r0, sp, #80	; 0x50
            ((ethPluginProvideInfo_t *) parameter)->pluginSharedRW = &pluginRW;
c0de4c1a:	6008      	str	r0, [r1, #0]
c0de4c1c:	2001      	movs	r0, #1
            ((ethPluginProvideInfo_t *) parameter)->result = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de4c1e:	7548      	strb	r0, [r1, #21]
c0de4c20:	e005      	b.n	c0de4c2e <eth_plugin_call+0xa6>
c0de4c22:	a813      	add	r0, sp, #76	; 0x4c
            ((ethPluginProvideParameter_t *) parameter)->pluginSharedRO = &pluginRO;
c0de4c24:	6048      	str	r0, [r1, #4]
c0de4c26:	a814      	add	r0, sp, #80	; 0x50
            ((ethPluginProvideParameter_t *) parameter)->pluginSharedRW = &pluginRW;
c0de4c28:	6008      	str	r0, [r1, #0]
c0de4c2a:	2001      	movs	r0, #1
            ((ethPluginProvideParameter_t *) parameter)->result = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de4c2c:	7508      	strb	r0, [r1, #20]
c0de4c2e:	4648      	mov	r0, r9
c0de4c30:	1940      	adds	r0, r0, r5
c0de4c32:	3044      	adds	r0, #68	; 0x44
c0de4c34:	2208      	movs	r2, #8
c0de4c36:	e007      	b.n	c0de4c48 <eth_plugin_call+0xc0>
c0de4c38:	a813      	add	r0, sp, #76	; 0x4c
            ((ethQueryContractUI_t *) parameter)->pluginSharedRO = &pluginRO;
c0de4c3a:	6048      	str	r0, [r1, #4]
c0de4c3c:	a814      	add	r0, sp, #80	; 0x50
            ((ethQueryContractUI_t *) parameter)->pluginSharedRW = &pluginRW;
c0de4c3e:	6008      	str	r0, [r1, #0]
c0de4c40:	4648      	mov	r0, r9
c0de4c42:	1940      	adds	r0, r0, r5
c0de4c44:	3044      	adds	r0, #68	; 0x44
c0de4c46:	221c      	movs	r2, #28
c0de4c48:	5088      	str	r0, [r1, r2]
    switch (pluginType) {
c0de4c4a:	4850      	ldr	r0, [pc, #320]	; (c0de4d8c <eth_plugin_call+0x204>)
c0de4c4c:	464a      	mov	r2, r9
c0de4c4e:	5c10      	ldrb	r0, [r2, r0]
c0de4c50:	2800      	cmp	r0, #0
c0de4c52:	9403      	str	r4, [sp, #12]
c0de4c54:	9301      	str	r3, [sp, #4]
c0de4c56:	d02c      	beq.n	c0de4cb2 <eth_plugin_call+0x12a>
c0de4c58:	2801      	cmp	r0, #1
c0de4c5a:	d020      	beq.n	c0de4c9e <eth_plugin_call+0x116>
c0de4c5c:	2802      	cmp	r0, #2
c0de4c5e:	d023      	beq.n	c0de4ca8 <eth_plugin_call+0x120>
c0de4c60:	2803      	cmp	r0, #3
c0de4c62:	d13a      	bne.n	c0de4cda <eth_plugin_call+0x152>
c0de4c64:	9102      	str	r1, [sp, #8]
c0de4c66:	2700      	movs	r7, #0
c0de4c68:	4c49      	ldr	r4, [pc, #292]	; (c0de4d90 <eth_plugin_call+0x208>)
c0de4c6a:	447c      	add	r4, pc
                if (INTERNAL_ETH_PLUGINS[i].alias[0] == 0) {
c0de4c6c:	b2f8      	uxtb	r0, r7
c0de4c6e:	2118      	movs	r1, #24
c0de4c70:	4341      	muls	r1, r0
c0de4c72:	1865      	adds	r5, r4, r1
c0de4c74:	7a68      	ldrb	r0, [r5, #9]
c0de4c76:	2800      	cmp	r0, #0
c0de4c78:	d044      	beq.n	c0de4d04 <eth_plugin_call+0x17c>
c0de4c7a:	4629      	mov	r1, r5
c0de4c7c:	3109      	adds	r1, #9
                if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0de4c7e:	4648      	mov	r0, r9
c0de4c80:	4a41      	ldr	r2, [pc, #260]	; (c0de4d88 <eth_plugin_call+0x200>)
c0de4c82:	1880      	adds	r0, r0, r2
c0de4c84:	f008 ff2e 	bl	c0dedae4 <strcmp>
            for (i = 0;; i++) {
c0de4c88:	1c7f      	adds	r7, r7, #1
                if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0de4c8a:	2800      	cmp	r0, #0
c0de4c8c:	d1ee      	bne.n	c0de4c6c <eth_plugin_call+0xe4>
                    ((PluginCall) PIC(INTERNAL_ETH_PLUGINS[i].impl))(method, parameter);
c0de4c8e:	6968      	ldr	r0, [r5, #20]
c0de4c90:	f003 fad8 	bl	c0de8244 <pic>
c0de4c94:	4602      	mov	r2, r0
c0de4c96:	4630      	mov	r0, r6
c0de4c98:	9902      	ldr	r1, [sp, #8]
c0de4c9a:	4790      	blx	r2
c0de4c9c:	e032      	b.n	c0de4d04 <eth_plugin_call+0x17c>
            erc721_plugin_call(method, parameter);
c0de4c9e:	4630      	mov	r0, r6
c0de4ca0:	9102      	str	r1, [sp, #8]
c0de4ca2:	f7fe fde9 	bl	c0de3878 <erc721_plugin_call>
c0de4ca6:	e02d      	b.n	c0de4d04 <eth_plugin_call+0x17c>
            erc1155_plugin_call(method, parameter);
c0de4ca8:	4630      	mov	r0, r6
c0de4caa:	9102      	str	r1, [sp, #8]
c0de4cac:	f7fe fa32 	bl	c0de3114 <erc1155_plugin_call>
c0de4cb0:	e028      	b.n	c0de4d04 <eth_plugin_call+0x17c>
c0de4cb2:	9102      	str	r1, [sp, #8]
            params[2] = (uint32_t) parameter;
c0de4cb4:	9112      	str	r1, [sp, #72]	; 0x48
            params[1] = method;
c0de4cb6:	9611      	str	r6, [sp, #68]	; 0x44
            params[0] = (uint32_t) alias;
c0de4cb8:	4648      	mov	r0, r9
c0de4cba:	1940      	adds	r0, r0, r5
c0de4cbc:	9010      	str	r0, [sp, #64]	; 0x40
c0de4cbe:	af04      	add	r7, sp, #16
                TRY {
c0de4cc0:	4638      	mov	r0, r7
c0de4cc2:	f008 fef5 	bl	c0dedab0 <setjmp>
c0de4cc6:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0de4cc8:	0400      	lsls	r0, r0, #16
c0de4cca:	d008      	beq.n	c0de4cde <eth_plugin_call+0x156>
c0de4ccc:	a804      	add	r0, sp, #16
c0de4cce:	2100      	movs	r1, #0
                CATCH_OTHER(e) {
c0de4cd0:	8581      	strh	r1, [r0, #44]	; 0x2c
c0de4cd2:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de4cd4:	f004 fb3c 	bl	c0de9350 <try_context_set>
c0de4cd8:	e008      	b.n	c0de4cec <eth_plugin_call+0x164>
c0de4cda:	2400      	movs	r4, #0
c0de4cdc:	e763      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
c0de4cde:	a804      	add	r0, sp, #16
                TRY {
c0de4ce0:	f004 fb36 	bl	c0de9350 <try_context_set>
c0de4ce4:	900e      	str	r0, [sp, #56]	; 0x38
c0de4ce6:	a810      	add	r0, sp, #64	; 0x40
                    os_lib_call(params);
c0de4ce8:	f004 fab8 	bl	c0de925c <os_lib_call>
                FINALLY {
c0de4cec:	f004 fb26 	bl	c0de933c <try_context_get>
c0de4cf0:	a904      	add	r1, sp, #16
c0de4cf2:	4288      	cmp	r0, r1
c0de4cf4:	d102      	bne.n	c0de4cfc <eth_plugin_call+0x174>
c0de4cf6:	980e      	ldr	r0, [sp, #56]	; 0x38
c0de4cf8:	f004 fb2a 	bl	c0de9350 <try_context_set>
c0de4cfc:	a804      	add	r0, sp, #16
            END_TRY;
c0de4cfe:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de4d00:	2800      	cmp	r0, #0
c0de4d02:	d13b      	bne.n	c0de4d7c <eth_plugin_call+0x1f4>
    switch (method) {
c0de4d04:	9801      	ldr	r0, [sp, #4]
c0de4d06:	4286      	cmp	r6, r0
c0de4d08:	d02f      	beq.n	c0de4d6a <eth_plugin_call+0x1e2>
c0de4d0a:	2081      	movs	r0, #129	; 0x81
c0de4d0c:	0040      	lsls	r0, r0, #1
c0de4d0e:	4286      	cmp	r6, r0
c0de4d10:	9c03      	ldr	r4, [sp, #12]
c0de4d12:	9a02      	ldr	r2, [sp, #8]
c0de4d14:	d01f      	beq.n	c0de4d56 <eth_plugin_call+0x1ce>
c0de4d16:	20ff      	movs	r0, #255	; 0xff
c0de4d18:	4601      	mov	r1, r0
c0de4d1a:	3104      	adds	r1, #4
c0de4d1c:	428e      	cmp	r6, r1
c0de4d1e:	d012      	beq.n	c0de4d46 <eth_plugin_call+0x1be>
c0de4d20:	2141      	movs	r1, #65	; 0x41
c0de4d22:	0089      	lsls	r1, r1, #2
c0de4d24:	428e      	cmp	r6, r1
c0de4d26:	d014      	beq.n	c0de4d52 <eth_plugin_call+0x1ca>
c0de4d28:	4601      	mov	r1, r0
c0de4d2a:	3106      	adds	r1, #6
c0de4d2c:	428e      	cmp	r6, r1
c0de4d2e:	d00c      	beq.n	c0de4d4a <eth_plugin_call+0x1c2>
c0de4d30:	3002      	adds	r0, #2
c0de4d32:	4286      	cmp	r6, r0
c0de4d34:	d000      	beq.n	c0de4d38 <eth_plugin_call+0x1b0>
c0de4d36:	e736      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
            switch (((ethPluginInitContract_t *) parameter)->result) {
c0de4d38:	7850      	ldrb	r0, [r2, #1]
c0de4d3a:	1e41      	subs	r1, r0, #1
c0de4d3c:	4604      	mov	r4, r0
c0de4d3e:	418c      	sbcs	r4, r1
c0de4d40:	2804      	cmp	r0, #4
c0de4d42:	d010      	beq.n	c0de4d66 <eth_plugin_call+0x1de>
c0de4d44:	e72f      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
            switch (((ethPluginFinalize_t *) parameter)->result) {
c0de4d46:	7f90      	ldrb	r0, [r2, #30]
c0de4d48:	e006      	b.n	c0de4d58 <eth_plugin_call+0x1d0>
            if (((ethQueryContractID_t *) parameter)->result <= ETH_PLUGIN_RESULT_UNSUCCESSFUL) {
c0de4d4a:	7f10      	ldrb	r0, [r2, #28]
c0de4d4c:	2803      	cmp	r0, #3
c0de4d4e:	d213      	bcs.n	c0de4d78 <eth_plugin_call+0x1f0>
c0de4d50:	e729      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
            switch (((ethPluginProvideInfo_t *) parameter)->result) {
c0de4d52:	7d50      	ldrb	r0, [r2, #21]
c0de4d54:	e000      	b.n	c0de4d58 <eth_plugin_call+0x1d0>
            switch (((ethPluginProvideParameter_t *) parameter)->result) {
c0de4d56:	7d10      	ldrb	r0, [r2, #20]
c0de4d58:	2800      	cmp	r0, #0
c0de4d5a:	d004      	beq.n	c0de4d66 <eth_plugin_call+0x1de>
c0de4d5c:	2804      	cmp	r0, #4
c0de4d5e:	d00b      	beq.n	c0de4d78 <eth_plugin_call+0x1f0>
c0de4d60:	2806      	cmp	r0, #6
c0de4d62:	d009      	beq.n	c0de4d78 <eth_plugin_call+0x1f0>
c0de4d64:	e71f      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
c0de4d66:	4604      	mov	r4, r0
c0de4d68:	e71d      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
c0de4d6a:	2034      	movs	r0, #52	; 0x34
            if (((ethQueryContractUI_t *) parameter)->result <= ETH_PLUGIN_RESULT_UNSUCCESSFUL) {
c0de4d6c:	9902      	ldr	r1, [sp, #8]
c0de4d6e:	5c08      	ldrb	r0, [r1, r0]
c0de4d70:	2803      	cmp	r0, #3
c0de4d72:	9c03      	ldr	r4, [sp, #12]
c0de4d74:	d200      	bcs.n	c0de4d78 <eth_plugin_call+0x1f0>
c0de4d76:	e716      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
c0de4d78:	2404      	movs	r4, #4
c0de4d7a:	e714      	b.n	c0de4ba6 <eth_plugin_call+0x1e>
            END_TRY;
c0de4d7c:	f002 fb53 	bl	c0de7426 <os_longjmp>
c0de4d80:	000007e8 	.word	0x000007e8
c0de4d84:	0000026c 	.word	0x0000026c
c0de4d88:	00000594 	.word	0x00000594
c0de4d8c:	0000011e 	.word	0x0000011e
c0de4d90:	0000ae6a 	.word	0x0000ae6a

c0de4d94 <copy_address>:
bool erc20_plugin_available_check(void);

void erc20_plugin_call(int message, void* parameters);
void compound_plugin_call(int message, void* parameters);

void copy_address(uint8_t* dst, const uint8_t* parameter, uint8_t dst_size) {
c0de4d94:	b580      	push	{r7, lr}
    uint8_t copy_size = MIN(dst_size, ADDRESS_LENGTH);
c0de4d96:	2a14      	cmp	r2, #20
c0de4d98:	d300      	bcc.n	c0de4d9c <copy_address+0x8>
c0de4d9a:	2214      	movs	r2, #20
    memmove(dst, parameter + PARAMETER_LENGTH - copy_size, copy_size);
c0de4d9c:	1a89      	subs	r1, r1, r2
c0de4d9e:	3120      	adds	r1, #32
c0de4da0:	f008 fd42 	bl	c0ded828 <__aeabi_memmove>
}
c0de4da4:	bd80      	pop	{r7, pc}

c0de4da6 <copy_parameter>:

void copy_parameter(uint8_t* dst, const uint8_t* parameter, uint8_t dst_size) {
c0de4da6:	b580      	push	{r7, lr}
    uint8_t copy_size = MIN(dst_size, PARAMETER_LENGTH);
c0de4da8:	2a20      	cmp	r2, #32
c0de4daa:	d300      	bcc.n	c0de4dae <copy_parameter+0x8>
c0de4dac:	2220      	movs	r2, #32
    memmove(dst, parameter, copy_size);
c0de4dae:	f008 fd3b 	bl	c0ded828 <__aeabi_memmove>
}
c0de4db2:	bd80      	pop	{r7, pc}

c0de4db4 <plugin_ui_start>:
#include "ui_callbacks.h"
#include "eth_plugin_handler.h"
#include "ux.h"
#include "feature_signTx.h"

void plugin_ui_start() {
c0de4db4:	b580      	push	{r7, lr}
    dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0de4db6:	4806      	ldr	r0, [pc, #24]	; (c0de4dd0 <plugin_ui_start+0x1c>)
c0de4db8:	4649      	mov	r1, r9
c0de4dba:	1809      	adds	r1, r1, r0
c0de4dbc:	2042      	movs	r0, #66	; 0x42
c0de4dbe:	2200      	movs	r2, #0
    dataContext.tokenContext.pluginUiCurrentItem = 0;
c0de4dc0:	540a      	strb	r2, [r1, r0]
c0de4dc2:	2243      	movs	r2, #67	; 0x43
c0de4dc4:	2001      	movs	r0, #1
    dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0de4dc6:	5488      	strb	r0, [r1, r2]

    ux_approve_tx(true);
c0de4dc8:	f005 fcae 	bl	c0dea728 <ux_approve_tx>
}
c0de4dcc:	bd80      	pop	{r7, pc}
c0de4dce:	46c0      	nop			; (mov r8, r8)
c0de4dd0:	00000594 	.word	0x00000594

c0de4dd4 <handle_check_address>:
#include "ethUtils.h"
#include "string.h"

#define ZERO(x) memset(&x, 0, sizeof(x))

int handle_check_address(check_address_parameters_t* params, chain_config_t* chain_config) {
c0de4dd4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de4dd6:	b0ff      	sub	sp, #508	; 0x1fc
c0de4dd8:	b090      	sub	sp, #64	; 0x40
c0de4dda:	4604      	mov	r4, r0
    PRINTF("Params on the address %d\n", (unsigned int) params);
    PRINTF("Address to check %s\n", params->address_to_check);
    PRINTF("Inside handle_check_address\n");
    if (params->address_to_check == 0) {
c0de4ddc:	6900      	ldr	r0, [r0, #16]
c0de4dde:	2800      	cmp	r0, #0
c0de4de0:	d01e      	beq.n	c0de4e20 <handle_check_address+0x4c>
        PRINTF("Address to check == 0\n");
        return 0;
    }

    uint8_t i;
    const uint8_t* bip32_path_ptr = params->address_parameters;
c0de4de2:	68a6      	ldr	r6, [r4, #8]
    uint8_t bip32PathLength = *(bip32_path_ptr++);
c0de4de4:	7832      	ldrb	r2, [r6, #0]
    union group2 {
        uint8_t privateKeyData[32];
        cx_ecfp_public_key_t publicKey;
    } locals_union2;

    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH) ||
c0de4de6:	1e53      	subs	r3, r2, #1
c0de4de8:	2000      	movs	r0, #0
c0de4dea:	2b09      	cmp	r3, #9
c0de4dec:	d860      	bhi.n	c0de4eb0 <handle_check_address+0xdc>
        (bip32PathLength * 4 != params->address_parameters_length - 1)) {
c0de4dee:	0093      	lsls	r3, r2, #2
c0de4df0:	7b25      	ldrb	r5, [r4, #12]
c0de4df2:	1e6d      	subs	r5, r5, #1
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH) ||
c0de4df4:	429d      	cmp	r5, r3
c0de4df6:	d15b      	bne.n	c0de4eb0 <handle_check_address+0xdc>
c0de4df8:	9103      	str	r1, [sp, #12]
    uint8_t bip32PathLength = *(bip32_path_ptr++);
c0de4dfa:	1c70      	adds	r0, r6, #1
c0de4dfc:	a917      	add	r1, sp, #92	; 0x5c
c0de4dfe:	4613      	mov	r3, r2
        PRINTF("Invalid path\n");
        return 0;
    }
    for (i = 0; i < bip32PathLength; i++) {
c0de4e00:	2b00      	cmp	r3, #0
c0de4e02:	d00f      	beq.n	c0de4e24 <handle_check_address+0x50>
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de4e04:	7805      	ldrb	r5, [r0, #0]
c0de4e06:	062d      	lsls	r5, r5, #24
c0de4e08:	7846      	ldrb	r6, [r0, #1]
c0de4e0a:	0436      	lsls	r6, r6, #16
c0de4e0c:	1975      	adds	r5, r6, r5
         (buf[off + 2] << 8) | buf[off + 3];
c0de4e0e:	7886      	ldrb	r6, [r0, #2]
c0de4e10:	0236      	lsls	r6, r6, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de4e12:	19ad      	adds	r5, r5, r6
         (buf[off + 2] << 8) | buf[off + 3];
c0de4e14:	78c6      	ldrb	r6, [r0, #3]
c0de4e16:	19ad      	adds	r5, r5, r6
        locals_union1.bip32Path[i] = U4BE(bip32_path_ptr, 0);
c0de4e18:	c120      	stmia	r1!, {r5}
    for (i = 0; i < bip32PathLength; i++) {
c0de4e1a:	1d00      	adds	r0, r0, #4
c0de4e1c:	1e5b      	subs	r3, r3, #1
c0de4e1e:	e7ef      	b.n	c0de4e00 <handle_check_address+0x2c>
c0de4e20:	2000      	movs	r0, #0
c0de4e22:	e045      	b.n	c0de4eb0 <handle_check_address+0xdc>
c0de4e24:	2000      	movs	r0, #0
        bip32_path_ptr += 4;
    }
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de4e26:	9000      	str	r0, [sp, #0]
c0de4e28:	2721      	movs	r7, #33	; 0x21
c0de4e2a:	ae17      	add	r6, sp, #92	; 0x5c
c0de4e2c:	ad04      	add	r5, sp, #16
c0de4e2e:	4638      	mov	r0, r7
c0de4e30:	4631      	mov	r1, r6
c0de4e32:	462b      	mov	r3, r5
c0de4e34:	f004 f9de 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0de4e38:	2134      	movs	r1, #52	; 0x34
                               locals_union1.bip32Path,
                               bip32PathLength,
                               locals_union2.privateKeyData,
                               NULL);
    ZERO(locals_union1);
c0de4e3a:	4630      	mov	r0, r6
c0de4e3c:	f008 fcea 	bl	c0ded814 <__aeabi_memclr>
c0de4e40:	2220      	movs	r2, #32
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de4e42:	4638      	mov	r0, r7
c0de4e44:	4629      	mov	r1, r5
c0de4e46:	4633      	mov	r3, r6
c0de4e48:	f7fe f900 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de4e4c:	2800      	cmp	r0, #0
c0de4e4e:	d132      	bne.n	c0de4eb6 <handle_check_address+0xe2>
c0de4e50:	ad04      	add	r5, sp, #16
c0de4e52:	214c      	movs	r1, #76	; 0x4c
    cx_ecfp_init_private_key(CX_CURVE_256K1,
                             locals_union2.privateKeyData,
                             32,
                             &locals_union1.privateKey);
    ZERO(locals_union2);
c0de4e54:	4628      	mov	r0, r5
c0de4e56:	f008 fcdd 	bl	c0ded814 <__aeabi_memclr>
c0de4e5a:	2021      	movs	r0, #33	; 0x21
c0de4e5c:	aa17      	add	r2, sp, #92	; 0x5c
c0de4e5e:	2301      	movs	r3, #1
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de4e60:	4629      	mov	r1, r5
c0de4e62:	f7fe f8ed 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de4e66:	2800      	cmp	r0, #0
c0de4e68:	d125      	bne.n	c0de4eb6 <handle_check_address+0xe2>
c0de4e6a:	ae17      	add	r6, sp, #92	; 0x5c
c0de4e6c:	2134      	movs	r1, #52	; 0x34
    cx_ecfp_generate_pair(CX_CURVE_256K1, &locals_union2.publicKey, &locals_union1.privateKey, 1);
    ZERO(locals_union1);
c0de4e6e:	4630      	mov	r0, r6
c0de4e70:	f008 fcd0 	bl	c0ded814 <__aeabi_memclr>
c0de4e74:	9903      	ldr	r1, [sp, #12]
    getEthAddressStringFromKey(&locals_union2.publicKey,
                               locals_union1.address,
                               &local_sha3,
                               chain_config->chainId);
c0de4e76:	6908      	ldr	r0, [r1, #16]
c0de4e78:	6949      	ldr	r1, [r1, #20]
    getEthAddressStringFromKey(&locals_union2.publicKey,
c0de4e7a:	9000      	str	r0, [sp, #0]
c0de4e7c:	9101      	str	r1, [sp, #4]
c0de4e7e:	ad04      	add	r5, sp, #16
c0de4e80:	aa24      	add	r2, sp, #144	; 0x90
c0de4e82:	4628      	mov	r0, r5
c0de4e84:	4631      	mov	r1, r6
c0de4e86:	f7ff fc13 	bl	c0de46b0 <getEthAddressStringFromKey>
c0de4e8a:	214c      	movs	r1, #76	; 0x4c
    ZERO(locals_union2);
c0de4e8c:	4628      	mov	r0, r5
c0de4e8e:	f008 fcc1 	bl	c0ded814 <__aeabi_memclr>

    uint8_t offset_0x = 0;
    if (memcmp(params->address_to_check, "0x", 2) == 0) {
c0de4e92:	6921      	ldr	r1, [r4, #16]
c0de4e94:	7808      	ldrb	r0, [r1, #0]
c0de4e96:	784a      	ldrb	r2, [r1, #1]
c0de4e98:	0212      	lsls	r2, r2, #8
c0de4e9a:	1810      	adds	r0, r2, r0
c0de4e9c:	4a07      	ldr	r2, [pc, #28]	; (c0de4ebc <handle_check_address+0xe8>)
        offset_0x = 2;
    }

    if (strcmp(locals_union1.address, params->address_to_check + offset_0x) != 0) {
c0de4e9e:	4290      	cmp	r0, r2
c0de4ea0:	d100      	bne.n	c0de4ea4 <handle_check_address+0xd0>
c0de4ea2:	1c89      	adds	r1, r1, #2
c0de4ea4:	4630      	mov	r0, r6
c0de4ea6:	f008 fe1d 	bl	c0dedae4 <strcmp>
c0de4eaa:	4601      	mov	r1, r0
c0de4eac:	4240      	negs	r0, r0
c0de4eae:	4148      	adcs	r0, r1
        PRINTF("Addresses don't match\n");
        return 0;
    }
    PRINTF("Addresses  match\n");
    return 1;
}
c0de4eb0:	b07f      	add	sp, #508	; 0x1fc
c0de4eb2:	b010      	add	sp, #64	; 0x40
c0de4eb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de4eb6:	f002 fab6 	bl	c0de7426 <os_longjmp>
c0de4eba:	46c0      	nop			; (mov r8, r8)
c0de4ebc:	00007830 	.word	0x00007830

c0de4ec0 <handle_get_printable_amount>:
#include "uint256.h"
#include "string.h"
#include <stdint.h>
#include <os.h>

int handle_get_printable_amount(get_printable_amount_parameters_t* params, chain_config_t* config) {
c0de4ec0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de4ec2:	b089      	sub	sp, #36	; 0x24
c0de4ec4:	460e      	mov	r6, r1
c0de4ec6:	4605      	mov	r5, r0
    uint8_t decimals;
    char ticker[MAX_TICKER_LEN];
    memset(params->printable_amount, 0, sizeof(params->printable_amount));
c0de4ec8:	4604      	mov	r4, r0
c0de4eca:	340e      	adds	r4, #14
c0de4ecc:	2132      	movs	r1, #50	; 0x32
c0de4ece:	4620      	mov	r0, r4
c0de4ed0:	9104      	str	r1, [sp, #16]
c0de4ed2:	f008 fc9f 	bl	c0ded814 <__aeabi_memclr>
    if (params->amount_length > 32) {
c0de4ed6:	7b28      	ldrb	r0, [r5, #12]
c0de4ed8:	2700      	movs	r7, #0
c0de4eda:	2820      	cmp	r0, #32
c0de4edc:	d82a      	bhi.n	c0de4f34 <handle_get_printable_amount+0x74>
        PRINTF("Amount is too big, 32 bytes max but buffer has %u bytes", params->amount_length);
        return 0;
    }

    // If the amount is a fee, its value is nominated in ETH even if we're doing an ERC20 swap
    if (params->is_fee) {
c0de4ede:	7b68      	ldrb	r0, [r5, #13]
c0de4ee0:	2800      	cmp	r0, #0
c0de4ee2:	d014      	beq.n	c0de4f0e <handle_get_printable_amount+0x4e>
c0de4ee4:	210a      	movs	r1, #10
        uint8_t ticker_len = strnlen(config->coinName, sizeof(config->coinName));
c0de4ee6:	9603      	str	r6, [sp, #12]
c0de4ee8:	4630      	mov	r0, r6
c0de4eea:	f008 ff17 	bl	c0dedd1c <strnlen>
        memcpy(ticker, config->coinName, ticker_len);
c0de4eee:	b2c7      	uxtb	r7, r0
c0de4ef0:	ae05      	add	r6, sp, #20
c0de4ef2:	4630      	mov	r0, r6
c0de4ef4:	9903      	ldr	r1, [sp, #12]
c0de4ef6:	463a      	mov	r2, r7
c0de4ef8:	f008 fc92 	bl	c0ded820 <__aeabi_memcpy>
c0de4efc:	2020      	movs	r0, #32
        ticker[ticker_len] = ' ';
c0de4efe:	55f0      	strb	r0, [r6, r7]
c0de4f00:	19f0      	adds	r0, r6, r7
c0de4f02:	2100      	movs	r1, #0
        ticker[ticker_len + 1] = '\0';
c0de4f04:	7041      	strb	r1, [r0, #1]
c0de4f06:	a808      	add	r0, sp, #32
c0de4f08:	2212      	movs	r2, #18
        decimals = WEI_TO_ETHER;
c0de4f0a:	7002      	strb	r2, [r0, #0]
c0de4f0c:	e009      	b.n	c0de4f22 <handle_get_printable_amount+0x62>
    } else {
        // If the amount is *not* a fee, decimals and ticker are built from the given config
        if (!parse_swap_config(params->coin_configuration,
                               params->coin_configuration_length,
c0de4f0e:	7929      	ldrb	r1, [r5, #4]
        if (!parse_swap_config(params->coin_configuration,
c0de4f10:	6828      	ldr	r0, [r5, #0]
c0de4f12:	aa05      	add	r2, sp, #20
c0de4f14:	ab08      	add	r3, sp, #32
c0de4f16:	f007 fb6a 	bl	c0dec5ee <parse_swap_config>
c0de4f1a:	2800      	cmp	r0, #0
c0de4f1c:	d00a      	beq.n	c0de4f34 <handle_get_printable_amount+0x74>
c0de4f1e:	a808      	add	r0, sp, #32
        }
    }

    amountToString(params->amount,
                   params->amount_length,
                   decimals,
c0de4f20:	7802      	ldrb	r2, [r0, #0]
                   params->amount_length,
c0de4f22:	7b29      	ldrb	r1, [r5, #12]
    amountToString(params->amount,
c0de4f24:	68a8      	ldr	r0, [r5, #8]
c0de4f26:	9400      	str	r4, [sp, #0]
c0de4f28:	9b04      	ldr	r3, [sp, #16]
c0de4f2a:	9301      	str	r3, [sp, #4]
c0de4f2c:	ab05      	add	r3, sp, #20
c0de4f2e:	f007 fb20 	bl	c0dec572 <amountToString>
c0de4f32:	2701      	movs	r7, #1
                   ticker,
                   params->printable_amount,
                   sizeof(params->printable_amount));
    return 1;
}
c0de4f34:	4638      	mov	r0, r7
c0de4f36:	b009      	add	sp, #36	; 0x24
c0de4f38:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de4f3a:	d4d4      	bmi.n	c0de4ee6 <handle_get_printable_amount+0x26>

c0de4f3c <copy_transaction_parameters>:
#include "handle_swap_sign_transaction.h"
#include "shared_context.h"
#include "utils.h"

bool copy_transaction_parameters(create_transaction_parameters_t* sign_transaction_params,
                                 chain_config_t* config) {
c0de4f3c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de4f3e:	b0d1      	sub	sp, #324	; 0x144
c0de4f40:	460e      	mov	r6, r1
c0de4f42:	4605      	mov	r5, r0
c0de4f44:	24ff      	movs	r4, #255	; 0xff
c0de4f46:	3420      	adds	r4, #32
c0de4f48:	af09      	add	r7, sp, #36	; 0x24
    // first copy parameters to stack, and then to global data.
    // We need this "trick" as the input data position can overlap with app-ethereum globals
    txStringProperties_t stack_data;
    memset(&stack_data, 0, sizeof(stack_data));
c0de4f4a:	4638      	mov	r0, r7
c0de4f4c:	4621      	mov	r1, r4
c0de4f4e:	f008 fc61 	bl	c0ded814 <__aeabi_memclr>
    strlcpy(stack_data.fullAddress,
            sign_transaction_params->destination_address,
c0de4f52:	69a9      	ldr	r1, [r5, #24]
c0de4f54:	2235      	movs	r2, #53	; 0x35
    strlcpy(stack_data.fullAddress,
c0de4f56:	4638      	mov	r0, r7
c0de4f58:	f008 fe3c 	bl	c0dedbd4 <strlcpy>
c0de4f5c:	2034      	movs	r0, #52	; 0x34
            sizeof(stack_data.fullAddress));
    if ((stack_data.fullAddress[sizeof(stack_data.fullAddress) - 1] != '\0') ||
c0de4f5e:	5c39      	ldrb	r1, [r7, r0]
c0de4f60:	2000      	movs	r0, #0
c0de4f62:	2900      	cmp	r1, #0
c0de4f64:	d139      	bne.n	c0de4fda <copy_transaction_parameters+0x9e>
        (sign_transaction_params->amount_length > 32) ||
c0de4f66:	7b29      	ldrb	r1, [r5, #12]
c0de4f68:	2920      	cmp	r1, #32
c0de4f6a:	d836      	bhi.n	c0de4fda <copy_transaction_parameters+0x9e>
        (sign_transaction_params->fee_amount_length > 8)) {
c0de4f6c:	7d29      	ldrb	r1, [r5, #20]
    if ((stack_data.fullAddress[sizeof(stack_data.fullAddress) - 1] != '\0') ||
c0de4f6e:	2908      	cmp	r1, #8
c0de4f70:	d833      	bhi.n	c0de4fda <copy_transaction_parameters+0x9e>
    }

    uint8_t decimals;
    char ticker[MAX_TICKER_LEN];
    if (!parse_swap_config(sign_transaction_params->coin_configuration,
                           sign_transaction_params->coin_configuration_length,
c0de4f72:	7929      	ldrb	r1, [r5, #4]
    if (!parse_swap_config(sign_transaction_params->coin_configuration,
c0de4f74:	6828      	ldr	r0, [r5, #0]
c0de4f76:	aa05      	add	r2, sp, #20
c0de4f78:	ab08      	add	r3, sp, #32
c0de4f7a:	f007 fb38 	bl	c0dec5ee <parse_swap_config>
c0de4f7e:	2800      	cmp	r0, #0
c0de4f80:	d02a      	beq.n	c0de4fd8 <copy_transaction_parameters+0x9c>
c0de4f82:	a808      	add	r0, sp, #32
        PRINTF("Error while parsing config\n");
        return false;
    }
    amountToString(sign_transaction_params->amount,
                   sign_transaction_params->amount_length,
                   decimals,
c0de4f84:	9004      	str	r0, [sp, #16]
c0de4f86:	7802      	ldrb	r2, [r0, #0]
                   sign_transaction_params->amount_length,
c0de4f88:	7b29      	ldrb	r1, [r5, #12]
    amountToString(sign_transaction_params->amount,
c0de4f8a:	68a8      	ldr	r0, [r5, #8]
c0de4f8c:	234f      	movs	r3, #79	; 0x4f
c0de4f8e:	9301      	str	r3, [sp, #4]
c0de4f90:	ab09      	add	r3, sp, #36	; 0x24
                   ticker,
                   stack_data.fullAmount,
c0de4f92:	9303      	str	r3, [sp, #12]
c0de4f94:	3335      	adds	r3, #53	; 0x35
    amountToString(sign_transaction_params->amount,
c0de4f96:	9300      	str	r3, [sp, #0]
c0de4f98:	af05      	add	r7, sp, #20
c0de4f9a:	463b      	mov	r3, r7
c0de4f9c:	f007 fae9 	bl	c0dec572 <amountToString>
c0de4fa0:	220c      	movs	r2, #12
                   sizeof(stack_data.fullAmount));

    // If the amount is a fee, its value is nominated in ETH even if we're doing an ERC20 swap
    strlcpy(ticker, config->coinName, MAX_TICKER_LEN);
c0de4fa2:	4638      	mov	r0, r7
c0de4fa4:	4631      	mov	r1, r6
c0de4fa6:	f008 fe15 	bl	c0dedbd4 <strlcpy>
c0de4faa:	2212      	movs	r2, #18
    decimals = WEI_TO_ETHER;
c0de4fac:	9804      	ldr	r0, [sp, #16]
c0de4fae:	7002      	strb	r2, [r0, #0]
    amountToString(sign_transaction_params->fee_amount,
c0de4fb0:	6928      	ldr	r0, [r5, #16]
                   sign_transaction_params->fee_amount_length,
c0de4fb2:	7d29      	ldrb	r1, [r5, #20]
c0de4fb4:	2332      	movs	r3, #50	; 0x32
c0de4fb6:	9e03      	ldr	r6, [sp, #12]
                   decimals,
                   ticker,
                   stack_data.maxFee,
c0de4fb8:	4635      	mov	r5, r6
c0de4fba:	3584      	adds	r5, #132	; 0x84
    amountToString(sign_transaction_params->fee_amount,
c0de4fbc:	9500      	str	r5, [sp, #0]
c0de4fbe:	9301      	str	r3, [sp, #4]
c0de4fc0:	463b      	mov	r3, r7
c0de4fc2:	f007 fad6 	bl	c0dec572 <amountToString>
                   sizeof(stack_data.maxFee));

    memcpy(&strings.common, &stack_data, sizeof(stack_data));
c0de4fc6:	4806      	ldr	r0, [pc, #24]	; (c0de4fe0 <copy_transaction_parameters+0xa4>)
c0de4fc8:	4649      	mov	r1, r9
c0de4fca:	1808      	adds	r0, r1, r0
c0de4fcc:	4631      	mov	r1, r6
c0de4fce:	4622      	mov	r2, r4
c0de4fd0:	f008 fc26 	bl	c0ded820 <__aeabi_memcpy>
c0de4fd4:	2001      	movs	r0, #1
c0de4fd6:	e000      	b.n	c0de4fda <copy_transaction_parameters+0x9e>
c0de4fd8:	2000      	movs	r0, #0
    return true;
}
c0de4fda:	b051      	add	sp, #324	; 0x144
c0de4fdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de4fde:	46c0      	nop			; (mov r8, r8)
c0de4fe0:	000006ba 	.word	0x000006ba

c0de4fe4 <handle_swap_sign_transaction>:

void handle_swap_sign_transaction(chain_config_t* config) {
c0de4fe4:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    chainConfig = config;
c0de4fe6:	4920      	ldr	r1, [pc, #128]	; (c0de5068 <handle_swap_sign_transaction+0x84>)
c0de4fe8:	464c      	mov	r4, r9
c0de4fea:	5060      	str	r0, [r4, r1]
    reset_app_context();
c0de4fec:	f001 fb3a 	bl	c0de6664 <reset_app_context>
    called_from_swap = true;
c0de4ff0:	481e      	ldr	r0, [pc, #120]	; (c0de506c <handle_swap_sign_transaction+0x88>)
c0de4ff2:	2501      	movs	r5, #1
c0de4ff4:	5425      	strb	r5, [r4, r0]
    io_seproxyhal_init();
c0de4ff6:	f002 fb6d 	bl	c0de76d4 <io_seproxyhal_init>

    if (N_storage.initialized != 0x01) {
c0de4ffa:	481f      	ldr	r0, [pc, #124]	; (c0de5078 <handle_swap_sign_transaction+0x94>)
c0de4ffc:	4478      	add	r0, pc
c0de4ffe:	f003 f921 	bl	c0de8244 <pic>
c0de5002:	7900      	ldrb	r0, [r0, #4]
c0de5004:	2801      	cmp	r0, #1
c0de5006:	d00b      	beq.n	c0de5020 <handle_swap_sign_transaction+0x3c>
c0de5008:	466c      	mov	r4, sp
        internalStorage_t storage;
        storage.dataAllowed = 0x00;
        storage.contractDetails = 0x00;
        storage.initialized = 0x01;
c0de500a:	7125      	strb	r5, [r4, #4]
c0de500c:	2000      	movs	r0, #0
        storage.dataAllowed = 0x00;
c0de500e:	9000      	str	r0, [sp, #0]
        storage.displayNonce = 0x00;
        storage.contractDetails = 0x00;
        storage.requireOracle = 0x00;
        nvm_write((void*) &N_storage, (void*) &storage, sizeof(internalStorage_t));
c0de5010:	481a      	ldr	r0, [pc, #104]	; (c0de507c <handle_swap_sign_transaction+0x98>)
c0de5012:	4478      	add	r0, pc
c0de5014:	f003 f916 	bl	c0de8244 <pic>
c0de5018:	2205      	movs	r2, #5
c0de501a:	4621      	mov	r1, r4
c0de501c:	f004 f8c6 	bl	c0de91ac <nvm_write>
    }

    UX_INIT();
c0de5020:	4813      	ldr	r0, [pc, #76]	; (c0de5070 <handle_swap_sign_transaction+0x8c>)
c0de5022:	464e      	mov	r6, r9
c0de5024:	1830      	adds	r0, r6, r0
c0de5026:	2145      	movs	r1, #69	; 0x45
c0de5028:	0089      	lsls	r1, r1, #2
c0de502a:	f008 fbf3 	bl	c0ded814 <__aeabi_memclr>
c0de502e:	2400      	movs	r4, #0
    USB_power(0);
c0de5030:	4620      	mov	r0, r4
c0de5032:	f007 f94d 	bl	c0dec2d0 <USB_power>
c0de5036:	2501      	movs	r5, #1
    USB_power(1);
c0de5038:	4628      	mov	r0, r5
c0de503a:	f007 f949 	bl	c0dec2d0 <USB_power>
c0de503e:	2006      	movs	r0, #6
    // ui_idle();
    PRINTF("USB power ON/OFF\n");
#ifdef TARGET_NANOX
    // grab the current plane mode setting
    G_io_app.plane_mode = os_setting_get(OS_SETTING_PLANEMODE, NULL, 0);
c0de5040:	4621      	mov	r1, r4
c0de5042:	4622      	mov	r2, r4
c0de5044:	f004 f936 	bl	c0de92b4 <os_setting_get>
c0de5048:	490a      	ldr	r1, [pc, #40]	; (c0de5074 <handle_swap_sign_transaction+0x90>)
c0de504a:	1871      	adds	r1, r6, r1
c0de504c:	61c8      	str	r0, [r1, #28]
#endif  // TARGET_NANOX
#ifdef HAVE_BLE
    BLE_power(0, NULL);
c0de504e:	4620      	mov	r0, r4
c0de5050:	4621      	mov	r1, r4
c0de5052:	f000 fcc5 	bl	c0de59e0 <BLE_power>
    BLE_power(1, "Nano X");
c0de5056:	490a      	ldr	r1, [pc, #40]	; (c0de5080 <handle_swap_sign_transaction+0x9c>)
c0de5058:	4479      	add	r1, pc
c0de505a:	4628      	mov	r0, r5
c0de505c:	f000 fcc0 	bl	c0de59e0 <BLE_power>
#endif  // HAVE_BLE
    app_main();
c0de5060:	f001 fd88 	bl	c0de6b74 <app_main>
}
c0de5064:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
c0de5066:	46c0      	nop			; (mov r8, r8)
c0de5068:	00000590 	.word	0x00000590
c0de506c:	0000011d 	.word	0x0000011d
c0de5070:	00000330 	.word	0x00000330
c0de5074:	00000ae4 	.word	0x00000ae4
c0de5078:	0000c700 	.word	0x0000c700
c0de507c:	0000c6ea 	.word	0x0000c6ea
c0de5080:	00009112 	.word	0x00009112

c0de5084 <LEDGER_BLE_init>:
	configure_advertising_mngr(0);
}

/* Exported functions --------------------------------------------------------*/
void LEDGER_BLE_init(void)
{
c0de5084:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
	G_io_app.enabling_advertising  = 0;
c0de5086:	4820      	ldr	r0, [pc, #128]	; (c0de5108 <LEDGER_BLE_init+0x84>)
c0de5088:	464c      	mov	r4, r9
c0de508a:	1820      	adds	r0, r4, r0
c0de508c:	2100      	movs	r1, #0
c0de508e:	9100      	str	r1, [sp, #0]
c0de5090:	8441      	strh	r1, [r0, #34]	; 0x22
	G_io_app.disabling_advertising = 0;

	ledger_ble_data.pairing_in_progress = 0;

	memset(&ledger_ble_data, 0, sizeof(ledger_ble_data));
c0de5092:	481e      	ldr	r0, [pc, #120]	; (c0de510c <LEDGER_BLE_init+0x88>)
c0de5094:	1825      	adds	r5, r4, r0
c0de5096:	2154      	movs	r1, #84	; 0x54
c0de5098:	4628      	mov	r0, r5
c0de509a:	f008 fbbb 	bl	c0ded814 <__aeabi_memclr>
c0de509e:	ae01      	add	r6, sp, #4
c0de50a0:	2108      	movs	r1, #8
	LEDGER_BLE_get_mac_address(ledger_ble_data.random_address);
c0de50a2:	4630      	mov	r0, r6
c0de50a4:	f004 f8fa 	bl	c0de929c <os_serial>
c0de50a8:	2704      	movs	r7, #4
c0de50aa:	4630      	mov	r0, r6
c0de50ac:	4639      	mov	r1, r7
c0de50ae:	f7fd ffa9 	bl	c0de3004 <cx_crc16>
c0de50b2:	75e8      	strb	r0, [r5, #23]
c0de50b4:	0a00      	lsrs	r0, r0, #8
c0de50b6:	7628      	strb	r0, [r5, #24]
c0de50b8:	1d30      	adds	r0, r6, #4
c0de50ba:	4639      	mov	r1, r7
c0de50bc:	f7fd ffa2 	bl	c0de3004 <cx_crc16>
c0de50c0:	9e00      	ldr	r6, [sp, #0]
	ledger_ble_data.hci_cmd_opcode = 0xFFFF;
	ledger_ble_data.state          = BLE_STATE_INITIALIZING;
c0de50c2:	4912      	ldr	r1, [pc, #72]	; (c0de510c <LEDGER_BLE_init+0x88>)
c0de50c4:	5466      	strb	r6, [r4, r1]
c0de50c6:	21de      	movs	r1, #222	; 0xde
	LEDGER_BLE_get_mac_address(ledger_ble_data.random_address);
c0de50c8:	83a9      	strh	r1, [r5, #28]
c0de50ca:	21f1      	movs	r1, #241	; 0xf1
c0de50cc:	76e9      	strb	r1, [r5, #27]
c0de50ce:	7668      	strb	r0, [r5, #25]
c0de50d0:	0a00      	lsrs	r0, r0, #8
c0de50d2:	76a8      	strb	r0, [r5, #26]
c0de50d4:	480e      	ldr	r0, [pc, #56]	; (c0de5110 <LEDGER_BLE_init+0x8c>)
	ledger_ble_data.hci_cmd_opcode = 0xFFFF;
c0de50d6:	8428      	strh	r0, [r5, #32]
	ledger_ble_data.init_step      = BLE_INIT_STEP_IDLE;

	memset(&ledger_protocol_data, 0, sizeof(ledger_protocol_data));
c0de50d8:	480e      	ldr	r0, [pc, #56]	; (c0de5114 <LEDGER_BLE_init+0x90>)
c0de50da:	1825      	adds	r5, r4, r0
c0de50dc:	21c0      	movs	r1, #192	; 0xc0
c0de50de:	4628      	mov	r0, r5
c0de50e0:	f008 fb98 	bl	c0ded814 <__aeabi_memclr>
c0de50e4:	20ff      	movs	r0, #255	; 0xff
c0de50e6:	3052      	adds	r0, #82	; 0x52
c0de50e8:	21b0      	movs	r1, #176	; 0xb0
	ledger_protocol_data.rx_apdu_buffer            = G_io_apdu_buffer;
	ledger_protocol_data.rx_apdu_buffer_max_length = sizeof(G_io_apdu_buffer);
c0de50ea:	5268      	strh	r0, [r5, r1]
	ledger_protocol_data.rx_apdu_buffer            = G_io_apdu_buffer;
c0de50ec:	480a      	ldr	r0, [pc, #40]	; (c0de5118 <LEDGER_BLE_init+0x94>)
c0de50ee:	1820      	adds	r0, r4, r0
c0de50f0:	21ac      	movs	r1, #172	; 0xac
c0de50f2:	5068      	str	r0, [r5, r1]
	LEDGER_PROTOCOL_init(&ledger_protocol_data);
c0de50f4:	4628      	mov	r0, r5
c0de50f6:	f000 fd8d 	bl	c0de5c14 <LEDGER_PROTOCOL_init>
c0de50fa:	4630      	mov	r0, r6

	init_mngr(0, NULL, 0);
c0de50fc:	4631      	mov	r1, r6
c0de50fe:	4632      	mov	r2, r6
c0de5100:	f000 f80c 	bl	c0de511c <init_mngr>
}
c0de5104:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de5106:	46c0      	nop			; (mov r8, r8)
c0de5108:	00000ae4 	.word	0x00000ae4
c0de510c:	00000004 	.word	0x00000004
c0de5110:	0000ffff 	.word	0x0000ffff
c0de5114:	00000058 	.word	0x00000058
c0de5118:	00000990 	.word	0x00000990

c0de511c <init_mngr>:
{
c0de511c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de511e:	b087      	sub	sp, #28
c0de5120:	4604      	mov	r4, r0
	if (  (ledger_ble_data.hci_cmd_opcode != 0xFFFF)
c0de5122:	4d94      	ldr	r5, [pc, #592]	; (c0de5374 <init_mngr+0x258>)
c0de5124:	4648      	mov	r0, r9
c0de5126:	1940      	adds	r0, r0, r5
c0de5128:	8c00      	ldrh	r0, [r0, #32]
c0de512a:	4e93      	ldr	r6, [pc, #588]	; (c0de5378 <init_mngr+0x25c>)
	    &&(opcode != ledger_ble_data.hci_cmd_opcode)
c0de512c:	42b0      	cmp	r0, r6
c0de512e:	d001      	beq.n	c0de5134 <init_mngr+0x18>
c0de5130:	42a0      	cmp	r0, r4
c0de5132:	d173      	bne.n	c0de521c <init_mngr+0x100>
	if (ledger_ble_data.init_step == BLE_INIT_STEP_IDLE) {
c0de5134:	4648      	mov	r0, r9
c0de5136:	1940      	adds	r0, r0, r5
c0de5138:	7f40      	ldrb	r0, [r0, #29]
c0de513a:	2800      	cmp	r0, #0
c0de513c:	d01f      	beq.n	c0de517e <init_mngr+0x62>
	         &&(ledger_ble_data.init_step == BLE_INIT_STEP_GAP_INIT)
c0de513e:	2a06      	cmp	r2, #6
c0de5140:	d324      	bcc.n	c0de518c <init_mngr+0x70>
c0de5142:	2804      	cmp	r0, #4
c0de5144:	d122      	bne.n	c0de518c <init_mngr+0x70>
		ledger_ble_data.gap_service_handle                    = U2LE(buffer, 1);
c0de5146:	4648      	mov	r0, r9
c0de5148:	1940      	adds	r0, r0, r5
}
static inline uint16_t U2LE(const uint8_t *buf, size_t off) {
  return (buf[off + 1] << 8) | buf[off];
c0de514a:	784a      	ldrb	r2, [r1, #1]
c0de514c:	788b      	ldrb	r3, [r1, #2]
c0de514e:	021b      	lsls	r3, r3, #8
c0de5150:	189a      	adds	r2, r3, r2
c0de5152:	8442      	strh	r2, [r0, #34]	; 0x22
c0de5154:	78ca      	ldrb	r2, [r1, #3]
c0de5156:	790b      	ldrb	r3, [r1, #4]
c0de5158:	021b      	lsls	r3, r3, #8
c0de515a:	189a      	adds	r2, r3, r2
		ledger_ble_data.gap_device_name_characteristic_handle = U2LE(buffer, 3);
c0de515c:	8482      	strh	r2, [r0, #36]	; 0x24
c0de515e:	794a      	ldrb	r2, [r1, #5]
c0de5160:	7989      	ldrb	r1, [r1, #6]
c0de5162:	2305      	movs	r3, #5
	ledger_ble_data.init_step++;
c0de5164:	7743      	strb	r3, [r0, #29]
c0de5166:	0209      	lsls	r1, r1, #8
c0de5168:	1889      	adds	r1, r1, r2
		ledger_ble_data.gap_appearance_characteristic_handle  = U2LE(buffer, 5);
c0de516a:	84c1      	strh	r1, [r0, #38]	; 0x26
		ledger_ble_data.hci_cmd_opcode = 0xfc85;
c0de516c:	4648      	mov	r0, r9
c0de516e:	1940      	adds	r0, r0, r5
c0de5170:	4983      	ldr	r1, [pc, #524]	; (c0de5380 <init_mngr+0x264>)
c0de5172:	3179      	adds	r1, #121	; 0x79
c0de5174:	8401      	strh	r1, [r0, #32]
c0de5176:	2001      	movs	r0, #1
		aci_gap_set_io_capability(IO_CAP_DISPLAY_YES_NO);
c0de5178:	f7fb fd64 	bl	c0de0c44 <aci_gap_set_io_capability>
c0de517c:	e04e      	b.n	c0de521c <init_mngr+0x100>
	ledger_ble_data.init_step++;
c0de517e:	4648      	mov	r0, r9
c0de5180:	1940      	adds	r0, r0, r5
c0de5182:	2101      	movs	r1, #1
c0de5184:	7741      	strb	r1, [r0, #29]
		hci_reset();
c0de5186:	f7fc f839 	bl	c0de11fc <hci_reset>
c0de518a:	e047      	b.n	c0de521c <init_mngr+0x100>
	         &&(ledger_ble_data.init_step == BLE_INIT_STEP_ADD_SERVICE)
c0de518c:	2a02      	cmp	r2, #2
c0de518e:	d320      	bcc.n	c0de51d2 <init_mngr+0xb6>
c0de5190:	2807      	cmp	r0, #7
c0de5192:	d11e      	bne.n	c0de51d2 <init_mngr+0xb6>
		ledger_ble_data.ledger_gatt_service_handle = U2LE(buffer, 1);
c0de5194:	4648      	mov	r0, r9
c0de5196:	1940      	adds	r0, r0, r5
c0de5198:	784a      	ldrb	r2, [r1, #1]
c0de519a:	7889      	ldrb	r1, [r1, #2]
c0de519c:	0209      	lsls	r1, r1, #8
c0de519e:	1889      	adds	r1, r1, r2
c0de51a0:	224a      	movs	r2, #74	; 0x4a
c0de51a2:	5281      	strh	r1, [r0, r2]
c0de51a4:	2108      	movs	r1, #8
	ledger_ble_data.init_step++;
c0de51a6:	7741      	strb	r1, [r0, #29]
		ledger_ble_data.hci_cmd_opcode = 0xfd04;
c0de51a8:	4648      	mov	r0, r9
c0de51aa:	1941      	adds	r1, r0, r5
c0de51ac:	4874      	ldr	r0, [pc, #464]	; (c0de5380 <init_mngr+0x264>)
c0de51ae:	30f8      	adds	r0, #248	; 0xf8
c0de51b0:	8408      	strh	r0, [r1, #32]
c0de51b2:	204a      	movs	r0, #74	; 0x4a
		aci_gatt_add_char(ledger_ble_data.ledger_gatt_service_handle,
c0de51b4:	5a08      	ldrh	r0, [r1, r0]
c0de51b6:	314c      	adds	r1, #76	; 0x4c
c0de51b8:	2201      	movs	r2, #1
c0de51ba:	2310      	movs	r3, #16
c0de51bc:	2400      	movs	r4, #0
c0de51be:	9300      	str	r3, [sp, #0]
c0de51c0:	9401      	str	r4, [sp, #4]
c0de51c2:	9402      	str	r4, [sp, #8]
c0de51c4:	9303      	str	r3, [sp, #12]
c0de51c6:	9204      	str	r2, [sp, #16]
c0de51c8:	9105      	str	r1, [sp, #20]
c0de51ca:	2102      	movs	r1, #2
c0de51cc:	4a6d      	ldr	r2, [pc, #436]	; (c0de5384 <init_mngr+0x268>)
c0de51ce:	447a      	add	r2, pc
c0de51d0:	e021      	b.n	c0de5216 <init_mngr+0xfa>
	         &&(ledger_ble_data.init_step == BLE_INIT_STEP_ADD_NOTIFICATION_CHARACTERISTIC)
c0de51d2:	2a02      	cmp	r2, #2
c0de51d4:	d324      	bcc.n	c0de5220 <init_mngr+0x104>
c0de51d6:	2808      	cmp	r0, #8
c0de51d8:	d122      	bne.n	c0de5220 <init_mngr+0x104>
		ledger_ble_data.ledger_gatt_notification_characteristic_handle = U2LE(buffer, 1);
c0de51da:	4648      	mov	r0, r9
c0de51dc:	1940      	adds	r0, r0, r5
c0de51de:	784a      	ldrb	r2, [r1, #1]
c0de51e0:	7889      	ldrb	r1, [r1, #2]
c0de51e2:	0209      	lsls	r1, r1, #8
c0de51e4:	1889      	adds	r1, r1, r2
c0de51e6:	224c      	movs	r2, #76	; 0x4c
c0de51e8:	5281      	strh	r1, [r0, r2]
c0de51ea:	2109      	movs	r1, #9
	ledger_ble_data.init_step++;
c0de51ec:	7741      	strb	r1, [r0, #29]
		ledger_ble_data.hci_cmd_opcode = 0xfd04;
c0de51ee:	4648      	mov	r0, r9
c0de51f0:	1942      	adds	r2, r0, r5
c0de51f2:	4863      	ldr	r0, [pc, #396]	; (c0de5380 <init_mngr+0x264>)
c0de51f4:	30f8      	adds	r0, #248	; 0xf8
c0de51f6:	8410      	strh	r0, [r2, #32]
c0de51f8:	204a      	movs	r0, #74	; 0x4a
		aci_gatt_add_char(ledger_ble_data.ledger_gatt_service_handle,
c0de51fa:	5a10      	ldrh	r0, [r2, r0]
c0de51fc:	324e      	adds	r2, #78	; 0x4e
c0de51fe:	2301      	movs	r3, #1
c0de5200:	2410      	movs	r4, #16
c0de5202:	2102      	movs	r1, #2
c0de5204:	2508      	movs	r5, #8
c0de5206:	9500      	str	r5, [sp, #0]
c0de5208:	9501      	str	r5, [sp, #4]
c0de520a:	9102      	str	r1, [sp, #8]
c0de520c:	9403      	str	r4, [sp, #12]
c0de520e:	9304      	str	r3, [sp, #16]
c0de5210:	9205      	str	r2, [sp, #20]
c0de5212:	4a5d      	ldr	r2, [pc, #372]	; (c0de5388 <init_mngr+0x26c>)
c0de5214:	447a      	add	r2, pc
c0de5216:	239c      	movs	r3, #156	; 0x9c
c0de5218:	f7fb fe92 	bl	c0de0f40 <aci_gatt_add_char>
}
c0de521c:	b007      	add	sp, #28
c0de521e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	         &&(ledger_ble_data.init_step == BLE_INIT_STEP_ADD_WRITE_CHARACTERISTIC)
c0de5220:	2a02      	cmp	r2, #2
c0de5222:	d315      	bcc.n	c0de5250 <init_mngr+0x134>
c0de5224:	2809      	cmp	r0, #9
c0de5226:	d113      	bne.n	c0de5250 <init_mngr+0x134>
		ledger_ble_data.ledger_gatt_write_characteristic_handle = U2LE(buffer, 1);
c0de5228:	4648      	mov	r0, r9
c0de522a:	1940      	adds	r0, r0, r5
c0de522c:	784a      	ldrb	r2, [r1, #1]
c0de522e:	7889      	ldrb	r1, [r1, #2]
c0de5230:	0209      	lsls	r1, r1, #8
c0de5232:	1889      	adds	r1, r1, r2
c0de5234:	224e      	movs	r2, #78	; 0x4e
c0de5236:	5281      	strh	r1, [r0, r2]
c0de5238:	210a      	movs	r1, #10
	ledger_ble_data.init_step++;
c0de523a:	7741      	strb	r1, [r0, #29]
		ledger_ble_data.hci_cmd_opcode = 0xfc0f;
c0de523c:	4648      	mov	r0, r9
c0de523e:	1940      	adds	r0, r0, r5
c0de5240:	494f      	ldr	r1, [pc, #316]	; (c0de5380 <init_mngr+0x264>)
c0de5242:	1cc9      	adds	r1, r1, #3
c0de5244:	8401      	strh	r1, [r0, #32]
c0de5246:	2001      	movs	r0, #1
c0de5248:	2107      	movs	r1, #7
		aci_hal_set_tx_power_level(1,  // High power
c0de524a:	f7fb ffb3 	bl	c0de11b4 <aci_hal_set_tx_power_level>
c0de524e:	e7e5      	b.n	c0de521c <init_mngr+0x100>
	else if (ledger_ble_data.init_step == BLE_INIT_STEP_CONFIGURE_ADVERTISING) {
c0de5250:	280b      	cmp	r0, #11
c0de5252:	d112      	bne.n	c0de527a <init_mngr+0x15e>
c0de5254:	2006      	movs	r0, #6
c0de5256:	2100      	movs	r1, #0
		ledger_ble_data.adv_enable = !os_setting_get(OS_SETTING_PLANEMODE, NULL, 0);
c0de5258:	460a      	mov	r2, r1
c0de525a:	f004 f82b 	bl	c0de92b4 <os_setting_get>
c0de525e:	4241      	negs	r1, r0
c0de5260:	4141      	adcs	r1, r0
c0de5262:	4648      	mov	r0, r9
c0de5264:	1947      	adds	r7, r0, r5
c0de5266:	77f9      	strb	r1, [r7, #31]
		configure_advertising_mngr(opcode);
c0de5268:	4620      	mov	r0, r4
c0de526a:	f000 fbbf 	bl	c0de59ec <configure_advertising_mngr>
		if (ledger_ble_data.adv_step != BLE_CONFIG_ADV_STEP_END) {
c0de526e:	7fb8      	ldrb	r0, [r7, #30]
c0de5270:	2806      	cmp	r0, #6
c0de5272:	d1d3      	bne.n	c0de521c <init_mngr+0x100>
	ledger_ble_data.init_step++;
c0de5274:	4648      	mov	r0, r9
c0de5276:	1940      	adds	r0, r0, r5
c0de5278:	7f40      	ldrb	r0, [r0, #29]
c0de527a:	4649      	mov	r1, r9
c0de527c:	1949      	adds	r1, r1, r5
c0de527e:	1c42      	adds	r2, r0, #1
c0de5280:	774a      	strb	r2, [r1, #29]
	switch (ledger_ble_data.init_step) {
c0de5282:	280b      	cmp	r0, #11
c0de5284:	d017      	beq.n	c0de52b6 <init_mngr+0x19a>
c0de5286:	2801      	cmp	r0, #1
c0de5288:	d01d      	beq.n	c0de52c6 <init_mngr+0x1aa>
c0de528a:	2802      	cmp	r0, #2
c0de528c:	d025      	beq.n	c0de52da <init_mngr+0x1be>
c0de528e:	2803      	cmp	r0, #3
c0de5290:	d02b      	beq.n	c0de52ea <init_mngr+0x1ce>
c0de5292:	2804      	cmp	r0, #4
c0de5294:	d100      	bne.n	c0de5298 <init_mngr+0x17c>
c0de5296:	e769      	b.n	c0de516c <init_mngr+0x50>
c0de5298:	2805      	cmp	r0, #5
c0de529a:	d038      	beq.n	c0de530e <init_mngr+0x1f2>
c0de529c:	2806      	cmp	r0, #6
c0de529e:	d049      	beq.n	c0de5334 <init_mngr+0x218>
c0de52a0:	2807      	cmp	r0, #7
c0de52a2:	d081      	beq.n	c0de51a8 <init_mngr+0x8c>
c0de52a4:	2808      	cmp	r0, #8
c0de52a6:	d0a2      	beq.n	c0de51ee <init_mngr+0xd2>
c0de52a8:	2809      	cmp	r0, #9
c0de52aa:	d0c7      	beq.n	c0de523c <init_mngr+0x120>
c0de52ac:	280a      	cmp	r0, #10
c0de52ae:	d050      	beq.n	c0de5352 <init_mngr+0x236>
c0de52b0:	2800      	cmp	r0, #0
c0de52b2:	d1b3      	bne.n	c0de521c <init_mngr+0x100>
c0de52b4:	e767      	b.n	c0de5186 <init_mngr+0x6a>
		G_io_app.ble_ready = 1;
c0de52b6:	4648      	mov	r0, r9
c0de52b8:	2101      	movs	r1, #1
		ledger_ble_data.state = BLE_STATE_INITIALIZED;
c0de52ba:	5541      	strb	r1, [r0, r5]
		G_io_app.ble_ready = 1;
c0de52bc:	4a2f      	ldr	r2, [pc, #188]	; (c0de537c <init_mngr+0x260>)
c0de52be:	1880      	adds	r0, r0, r2
c0de52c0:	2220      	movs	r2, #32
c0de52c2:	5481      	strb	r1, [r0, r2]
c0de52c4:	e7aa      	b.n	c0de521c <init_mngr+0x100>
		ledger_ble_data.hci_cmd_opcode = 0xfc0c;
c0de52c6:	4648      	mov	r0, r9
c0de52c8:	1942      	adds	r2, r0, r5
c0de52ca:	482d      	ldr	r0, [pc, #180]	; (c0de5380 <init_mngr+0x264>)
c0de52cc:	8410      	strh	r0, [r2, #32]
		aci_hal_write_config_data(CONFIG_DATA_RANDOM_ADDRESS_OFFSET,
c0de52ce:	3217      	adds	r2, #23
c0de52d0:	202e      	movs	r0, #46	; 0x2e
c0de52d2:	2106      	movs	r1, #6
c0de52d4:	f7fb ff42 	bl	c0de115c <aci_hal_write_config_data>
c0de52d8:	e7a0      	b.n	c0de521c <init_mngr+0x100>
		ledger_ble_data.hci_cmd_opcode = 0xfd01;
c0de52da:	4648      	mov	r0, r9
c0de52dc:	1940      	adds	r0, r0, r5
c0de52de:	4928      	ldr	r1, [pc, #160]	; (c0de5380 <init_mngr+0x264>)
c0de52e0:	31f5      	adds	r1, #245	; 0xf5
c0de52e2:	8401      	strh	r1, [r0, #32]
		aci_gatt_init();
c0de52e4:	f7fb fdbc 	bl	c0de0e60 <aci_gatt_init>
c0de52e8:	e798      	b.n	c0de521c <init_mngr+0x100>
		ledger_ble_data.hci_cmd_opcode = 0xfc8a;
c0de52ea:	4648      	mov	r0, r9
c0de52ec:	1943      	adds	r3, r0, r5
c0de52ee:	4824      	ldr	r0, [pc, #144]	; (c0de5380 <init_mngr+0x264>)
c0de52f0:	307e      	adds	r0, #126	; 0x7e
c0de52f2:	8418      	strh	r0, [r3, #32]
		aci_gap_init(GAP_PERIPHERAL_ROLE,
c0de52f4:	4618      	mov	r0, r3
c0de52f6:	3026      	adds	r0, #38	; 0x26
c0de52f8:	4619      	mov	r1, r3
c0de52fa:	3124      	adds	r1, #36	; 0x24
c0de52fc:	9100      	str	r1, [sp, #0]
c0de52fe:	9001      	str	r0, [sp, #4]
c0de5300:	3322      	adds	r3, #34	; 0x22
c0de5302:	2001      	movs	r0, #1
c0de5304:	2100      	movs	r1, #0
c0de5306:	2214      	movs	r2, #20
c0de5308:	f7fb fd1a 	bl	c0de0d40 <aci_gap_init>
c0de530c:	e786      	b.n	c0de521c <init_mngr+0x100>
		ledger_ble_data.hci_cmd_opcode = 0xfc86;
c0de530e:	4648      	mov	r0, r9
c0de5310:	1940      	adds	r0, r0, r5
c0de5312:	491b      	ldr	r1, [pc, #108]	; (c0de5380 <init_mngr+0x264>)
c0de5314:	317a      	adds	r1, #122	; 0x7a
c0de5316:	8401      	strh	r1, [r0, #32]
c0de5318:	2001      	movs	r0, #1
c0de531a:	2300      	movs	r3, #0
c0de531c:	2110      	movs	r1, #16
c0de531e:	2208      	movs	r2, #8
		aci_gap_set_authentication_requirement(BONDING,
c0de5320:	9200      	str	r2, [sp, #0]
c0de5322:	9101      	str	r1, [sp, #4]
c0de5324:	9002      	str	r0, [sp, #8]
c0de5326:	9303      	str	r3, [sp, #12]
c0de5328:	9004      	str	r0, [sp, #16]
c0de532a:	4601      	mov	r1, r0
c0de532c:	4602      	mov	r2, r0
c0de532e:	f7fb fcab 	bl	c0de0c88 <aci_gap_set_authentication_requirement>
c0de5332:	e773      	b.n	c0de521c <init_mngr+0x100>
		ledger_ble_data.hci_cmd_opcode = 0xfd02;
c0de5334:	4648      	mov	r0, r9
c0de5336:	1940      	adds	r0, r0, r5
c0de5338:	4911      	ldr	r1, [pc, #68]	; (c0de5380 <init_mngr+0x264>)
c0de533a:	31f6      	adds	r1, #246	; 0xf6
c0de533c:	8401      	strh	r1, [r0, #32]
		aci_gatt_add_service(UUID_TYPE_128,
c0de533e:	304a      	adds	r0, #74	; 0x4a
c0de5340:	9000      	str	r0, [sp, #0]
c0de5342:	2002      	movs	r0, #2
c0de5344:	4911      	ldr	r1, [pc, #68]	; (c0de538c <init_mngr+0x270>)
c0de5346:	4479      	add	r1, pc
c0de5348:	2201      	movs	r2, #1
c0de534a:	2309      	movs	r3, #9
c0de534c:	f7fb fda6 	bl	c0de0e9c <aci_gatt_add_service>
c0de5350:	e764      	b.n	c0de521c <init_mngr+0x100>
		ledger_ble_data.hci_cmd_opcode = 0xFFFF;
c0de5352:	4648      	mov	r0, r9
c0de5354:	1945      	adds	r5, r0, r5
c0de5356:	2400      	movs	r4, #0
		ledger_ble_data.adv_step       = BLE_CONFIG_ADV_STEP_IDLE;
c0de5358:	77ac      	strb	r4, [r5, #30]
		ledger_ble_data.hci_cmd_opcode = 0xFFFF;
c0de535a:	842e      	strh	r6, [r5, #32]
c0de535c:	2006      	movs	r0, #6
		ledger_ble_data.adv_enable     = !os_setting_get(OS_SETTING_PLANEMODE, NULL, 0);
c0de535e:	4621      	mov	r1, r4
c0de5360:	4622      	mov	r2, r4
c0de5362:	f003 ffa7 	bl	c0de92b4 <os_setting_get>
c0de5366:	4241      	negs	r1, r0
c0de5368:	4141      	adcs	r1, r0
c0de536a:	77e9      	strb	r1, [r5, #31]
		configure_advertising_mngr(0);
c0de536c:	4620      	mov	r0, r4
c0de536e:	f000 fb3d 	bl	c0de59ec <configure_advertising_mngr>
c0de5372:	e753      	b.n	c0de521c <init_mngr+0x100>
c0de5374:	00000004 	.word	0x00000004
c0de5378:	0000ffff 	.word	0x0000ffff
c0de537c:	00000ae4 	.word	0x00000ae4
c0de5380:	fffffc0c 	.word	0xfffffc0c
c0de5384:	0000ab56 	.word	0x0000ab56
c0de5388:	0000ab20 	.word	0x0000ab20
c0de538c:	0000a9ce 	.word	0x0000a9ce

c0de5390 <LEDGER_BLE_send>:

void LEDGER_BLE_send(uint8_t* packet, uint16_t packet_length)
{
c0de5390:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
	LEDGER_PROTOCOL_tx(packet, packet_length);
c0de5392:	f000 fcdd 	bl	c0de5d50 <LEDGER_PROTOCOL_tx>
	if (  (ledger_ble_data.wait_write_resp_ack == 0)
c0de5396:	480f      	ldr	r0, [pc, #60]	; (c0de53d4 <LEDGER_BLE_send+0x44>)
c0de5398:	4649      	mov	r1, r9
c0de539a:	1809      	adds	r1, r1, r0
c0de539c:	2253      	movs	r2, #83	; 0x53
c0de539e:	5c89      	ldrb	r1, [r1, r2]
	    &&(ledger_protocol_data.chunk_length >= 2)
c0de53a0:	2900      	cmp	r1, #0
c0de53a2:	d000      	beq.n	c0de53a6 <LEDGER_BLE_send+0x16>
		                           ledger_ble_data.ledger_gatt_notification_characteristic_handle,
		                           0,
		                           ledger_protocol_data.chunk_length-2,
		                           &ledger_protocol_data.chunk[2]);
	}
}
c0de53a4:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
	    &&(ledger_protocol_data.chunk_length >= 2)
c0de53a6:	4b0c      	ldr	r3, [pc, #48]	; (c0de53d8 <LEDGER_BLE_send+0x48>)
c0de53a8:	4649      	mov	r1, r9
c0de53aa:	18c9      	adds	r1, r1, r3
c0de53ac:	22a8      	movs	r2, #168	; 0xa8
c0de53ae:	5c8a      	ldrb	r2, [r1, r2]
	if (  (ledger_ble_data.wait_write_resp_ack == 0)
c0de53b0:	2a02      	cmp	r2, #2
c0de53b2:	d3f7      	bcc.n	c0de53a4 <LEDGER_BLE_send+0x14>
		aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de53b4:	464c      	mov	r4, r9
c0de53b6:	1820      	adds	r0, r4, r0
c0de53b8:	214c      	movs	r1, #76	; 0x4c
		                           ledger_ble_data.ledger_gatt_notification_characteristic_handle,
c0de53ba:	5a41      	ldrh	r1, [r0, r1]
c0de53bc:	254a      	movs	r5, #74	; 0x4a
		aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de53be:	5b40      	ldrh	r0, [r0, r5]
c0de53c0:	18e3      	adds	r3, r4, r3
c0de53c2:	330c      	adds	r3, #12
c0de53c4:	9300      	str	r3, [sp, #0]
		                           ledger_protocol_data.chunk_length-2,
c0de53c6:	1e92      	subs	r2, r2, #2
		aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de53c8:	b2d3      	uxtb	r3, r2
c0de53ca:	2200      	movs	r2, #0
c0de53cc:	f7fb fe1e 	bl	c0de100c <aci_gatt_update_char_value>
}
c0de53d0:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0de53d2:	46c0      	nop			; (mov r8, r8)
c0de53d4:	00000004 	.word	0x00000004
c0de53d8:	00000058 	.word	0x00000058

c0de53dc <LEDGER_BLE_receive>:

void LEDGER_BLE_receive(void)
{
c0de53dc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de53de:	b08d      	sub	sp, #52	; 0x34
	//uint16_t length = U2BE(G_io_seproxyhal_spi_buffer, 1);

	if (G_io_seproxyhal_spi_buffer[3] == HCI_EVENT_PKT_TYPE) {
c0de53e0:	4ef4      	ldr	r6, [pc, #976]	; (c0de57b4 <LEDGER_BLE_receive+0x3d8>)
c0de53e2:	4648      	mov	r0, r9
c0de53e4:	1980      	adds	r0, r0, r6
c0de53e6:	78c0      	ldrb	r0, [r0, #3]
c0de53e8:	2804      	cmp	r0, #4
c0de53ea:	d000      	beq.n	c0de53ee <LEDGER_BLE_receive+0x12>
c0de53ec:	e0cf      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		switch (G_io_seproxyhal_spi_buffer[4]) {
c0de53ee:	4648      	mov	r0, r9
c0de53f0:	1980      	adds	r0, r0, r6
c0de53f2:	7900      	ldrb	r0, [r0, #4]
c0de53f4:	28ff      	cmp	r0, #255	; 0xff
c0de53f6:	d01a      	beq.n	c0de542e <LEDGER_BLE_receive+0x52>
c0de53f8:	280e      	cmp	r0, #14
c0de53fa:	d053      	beq.n	c0de54a4 <LEDGER_BLE_receive+0xc8>
c0de53fc:	283e      	cmp	r0, #62	; 0x3e
c0de53fe:	d069      	beq.n	c0de54d4 <LEDGER_BLE_receive+0xf8>
c0de5400:	2805      	cmp	r0, #5
c0de5402:	d000      	beq.n	c0de5406 <LEDGER_BLE_receive+0x2a>
c0de5404:	e0c3      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>

		case HCI_DISCONNECTION_COMPLETE_EVT_CODE:
			LOG_BLE("HCI DISCONNECTION COMPLETE code %02X\n", G_io_seproxyhal_spi_buffer[9]);
			ledger_ble_data.connection.connection_handle = 0xFFFF;
c0de5406:	48fc      	ldr	r0, [pc, #1008]	; (c0de57f8 <LEDGER_BLE_receive+0x41c>)
c0de5408:	464a      	mov	r2, r9
c0de540a:	1813      	adds	r3, r2, r0
c0de540c:	2428      	movs	r4, #40	; 0x28
c0de540e:	2100      	movs	r1, #0
			ledger_ble_data.advertising_enabled          = 0;
c0de5410:	5519      	strb	r1, [r3, r4]
c0de5412:	43cc      	mvns	r4, r1
			ledger_ble_data.connection.connection_handle = 0xFFFF;
c0de5414:	855c      	strh	r4, [r3, #42]	; 0x2a
	if (G_io_app.name_changed) {
c0de5416:	4bf9      	ldr	r3, [pc, #996]	; (c0de57fc <LEDGER_BLE_receive+0x420>)
c0de5418:	18d2      	adds	r2, r2, r3
c0de541a:	2421      	movs	r4, #33	; 0x21
c0de541c:	5d15      	ldrb	r5, [r2, r4]
c0de541e:	4af8      	ldr	r2, [pc, #992]	; (c0de5800 <LEDGER_BLE_receive+0x424>)
c0de5420:	2d00      	cmp	r5, #0
c0de5422:	d100      	bne.n	c0de5426 <LEDGER_BLE_receive+0x4a>
c0de5424:	e0a0      	b.n	c0de5568 <LEDGER_BLE_receive+0x18c>
		G_io_app.name_changed = 0;
c0de5426:	464d      	mov	r5, r9
c0de5428:	18eb      	adds	r3, r5, r3
c0de542a:	5519      	strb	r1, [r3, r4]
c0de542c:	e09d      	b.n	c0de556a <LEDGER_BLE_receive+0x18e>
			                    G_io_seproxyhal_spi_buffer[5]);
			break;

		case HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE:
			hci_evt_vendor(&G_io_seproxyhal_spi_buffer[6],
			               G_io_seproxyhal_spi_buffer[5]);
c0de542e:	4648      	mov	r0, r9
c0de5430:	1980      	adds	r0, r0, r6
c0de5432:	7942      	ldrb	r2, [r0, #5]
	if (length < 4) {
c0de5434:	2a04      	cmp	r2, #4
c0de5436:	d200      	bcs.n	c0de543a <LEDGER_BLE_receive+0x5e>
c0de5438:	e0a9      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de543a:	464b      	mov	r3, r9
c0de543c:	1998      	adds	r0, r3, r6
c0de543e:	7a04      	ldrb	r4, [r0, #8]
c0de5440:	7a40      	ldrb	r0, [r0, #9]
c0de5442:	0200      	lsls	r0, r0, #8
c0de5444:	1900      	adds	r0, r0, r4
	if (U2LE(buffer, 2) != ledger_ble_data.connection.connection_handle) {
c0de5446:	4fec      	ldr	r7, [pc, #944]	; (c0de57f8 <LEDGER_BLE_receive+0x41c>)
c0de5448:	19db      	adds	r3, r3, r7
c0de544a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
c0de544c:	4298      	cmp	r0, r3
c0de544e:	d000      	beq.n	c0de5452 <LEDGER_BLE_receive+0x76>
c0de5450:	e09d      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5452:	464b      	mov	r3, r9
c0de5454:	199b      	adds	r3, r3, r6
c0de5456:	799c      	ldrb	r4, [r3, #6]
c0de5458:	79db      	ldrb	r3, [r3, #7]
c0de545a:	021b      	lsls	r3, r3, #8
c0de545c:	191b      	adds	r3, r3, r4
c0de545e:	b29b      	uxth	r3, r3
c0de5460:	4cfd      	ldr	r4, [pc, #1012]	; (c0de5858 <LEDGER_BLE_receive+0x47c>)
	switch (opcode) {
c0de5462:	42a3      	cmp	r3, r4
c0de5464:	d100      	bne.n	c0de5468 <LEDGER_BLE_receive+0x8c>
c0de5466:	e158      	b.n	c0de571a <LEDGER_BLE_receive+0x33e>
c0de5468:	4cfc      	ldr	r4, [pc, #1008]	; (c0de585c <LEDGER_BLE_receive+0x480>)
c0de546a:	42a3      	cmp	r3, r4
c0de546c:	d100      	bne.n	c0de5470 <LEDGER_BLE_receive+0x94>
c0de546e:	e1a3      	b.n	c0de57b8 <LEDGER_BLE_receive+0x3dc>
c0de5470:	4cfb      	ldr	r4, [pc, #1004]	; (c0de5860 <LEDGER_BLE_receive+0x484>)
c0de5472:	42a3      	cmp	r3, r4
c0de5474:	d100      	bne.n	c0de5478 <LEDGER_BLE_receive+0x9c>
c0de5476:	e1c5      	b.n	c0de5804 <LEDGER_BLE_receive+0x428>
c0de5478:	4cfa      	ldr	r4, [pc, #1000]	; (c0de5864 <LEDGER_BLE_receive+0x488>)
c0de547a:	42a3      	cmp	r3, r4
c0de547c:	d100      	bne.n	c0de5480 <LEDGER_BLE_receive+0xa4>
c0de547e:	e1fd      	b.n	c0de587c <LEDGER_BLE_receive+0x4a0>
c0de5480:	4af9      	ldr	r2, [pc, #996]	; (c0de5868 <LEDGER_BLE_receive+0x48c>)
c0de5482:	4293      	cmp	r3, r2
c0de5484:	d100      	bne.n	c0de5488 <LEDGER_BLE_receive+0xac>
c0de5486:	e22e      	b.n	c0de58e6 <LEDGER_BLE_receive+0x50a>
c0de5488:	4af8      	ldr	r2, [pc, #992]	; (c0de586c <LEDGER_BLE_receive+0x490>)
c0de548a:	4293      	cmp	r3, r2
c0de548c:	d100      	bne.n	c0de5490 <LEDGER_BLE_receive+0xb4>
c0de548e:	e22e      	b.n	c0de58ee <LEDGER_BLE_receive+0x512>
c0de5490:	49f7      	ldr	r1, [pc, #988]	; (c0de5870 <LEDGER_BLE_receive+0x494>)
c0de5492:	428b      	cmp	r3, r1
c0de5494:	d100      	bne.n	c0de5498 <LEDGER_BLE_receive+0xbc>
c0de5496:	e23c      	b.n	c0de5912 <LEDGER_BLE_receive+0x536>
c0de5498:	48f6      	ldr	r0, [pc, #984]	; (c0de5874 <LEDGER_BLE_receive+0x498>)
c0de549a:	4283      	cmp	r3, r0
c0de549c:	d177      	bne.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		end_pairing_ux();
c0de549e:	f000 fb5f 	bl	c0de5b60 <end_pairing_ux>
c0de54a2:	e074      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
			                     G_io_seproxyhal_spi_buffer[5]);
c0de54a4:	4648      	mov	r0, r9
c0de54a6:	1980      	adds	r0, r0, r6
c0de54a8:	7942      	ldrb	r2, [r0, #5]
	if (length < 3) {
c0de54aa:	2a03      	cmp	r2, #3
c0de54ac:	d36f      	bcc.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de54ae:	464b      	mov	r3, r9
c0de54b0:	1998      	adds	r0, r3, r6
c0de54b2:	79c4      	ldrb	r4, [r0, #7]
c0de54b4:	7a00      	ldrb	r0, [r0, #8]
c0de54b6:	0200      	lsls	r0, r0, #8
c0de54b8:	1900      	adds	r0, r0, r4
	if (ledger_ble_data.state == BLE_STATE_INITIALIZING) {
c0de54ba:	4ccf      	ldr	r4, [pc, #828]	; (c0de57f8 <LEDGER_BLE_receive+0x41c>)
c0de54bc:	5d1b      	ldrb	r3, [r3, r4]
c0de54be:	2b02      	cmp	r3, #2
c0de54c0:	d067      	beq.n	c0de5592 <LEDGER_BLE_receive+0x1b6>
c0de54c2:	2b00      	cmp	r3, #0
c0de54c4:	d167      	bne.n	c0de5596 <LEDGER_BLE_receive+0x1ba>
		init_mngr(opcode, &buffer[3], length);
c0de54c6:	464b      	mov	r3, r9
c0de54c8:	1999      	adds	r1, r3, r6
c0de54ca:	3109      	adds	r1, #9
c0de54cc:	b280      	uxth	r0, r0
c0de54ce:	f7ff fe25 	bl	c0de511c <init_mngr>
c0de54d2:	e05c      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
			                    G_io_seproxyhal_spi_buffer[5]);
c0de54d4:	4648      	mov	r0, r9
c0de54d6:	1980      	adds	r0, r0, r6
c0de54d8:	7940      	ldrb	r0, [r0, #5]
	if (!length) {
c0de54da:	2800      	cmp	r0, #0
c0de54dc:	d057      	beq.n	c0de558e <LEDGER_BLE_receive+0x1b2>
	switch (buffer[0]) {
c0de54de:	4648      	mov	r0, r9
c0de54e0:	1980      	adds	r0, r0, r6
c0de54e2:	7980      	ldrb	r0, [r0, #6]
c0de54e4:	280c      	cmp	r0, #12
c0de54e6:	d100      	bne.n	c0de54ea <LEDGER_BLE_receive+0x10e>
c0de54e8:	e084      	b.n	c0de55f4 <LEDGER_BLE_receive+0x218>
c0de54ea:	2803      	cmp	r0, #3
c0de54ec:	d100      	bne.n	c0de54f0 <LEDGER_BLE_receive+0x114>
c0de54ee:	e096      	b.n	c0de561e <LEDGER_BLE_receive+0x242>
c0de54f0:	2807      	cmp	r0, #7
c0de54f2:	d100      	bne.n	c0de54f6 <LEDGER_BLE_receive+0x11a>
c0de54f4:	e0ac      	b.n	c0de5650 <LEDGER_BLE_receive+0x274>
c0de54f6:	2801      	cmp	r0, #1
c0de54f8:	d149      	bne.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		ledger_ble_data.connection.connection_handle     = U2LE(buffer, 2);
c0de54fa:	48bf      	ldr	r0, [pc, #764]	; (c0de57f8 <LEDGER_BLE_receive+0x41c>)
c0de54fc:	464f      	mov	r7, r9
c0de54fe:	183c      	adds	r4, r7, r0
c0de5500:	19bd      	adds	r5, r7, r6
		ledger_ble_data.connection.role_slave            = buffer[4];
c0de5502:	7aa8      	ldrb	r0, [r5, #10]
c0de5504:	212c      	movs	r1, #44	; 0x2c
c0de5506:	5460      	strb	r0, [r4, r1]
		ledger_ble_data.connection.peer_address_random   = buffer[5];
c0de5508:	7ae8      	ldrb	r0, [r5, #11]
c0de550a:	212d      	movs	r1, #45	; 0x2d
c0de550c:	5460      	strb	r0, [r4, r1]
c0de550e:	7a28      	ldrb	r0, [r5, #8]
c0de5510:	7a69      	ldrb	r1, [r5, #9]
c0de5512:	0209      	lsls	r1, r1, #8
c0de5514:	1808      	adds	r0, r1, r0
		ledger_ble_data.connection.connection_handle     = U2LE(buffer, 2);
c0de5516:	8560      	strh	r0, [r4, #42]	; 0x2a
		memcpy(ledger_ble_data.connection.peer_address,   &buffer[6], 6);
c0de5518:	4620      	mov	r0, r4
c0de551a:	302e      	adds	r0, #46	; 0x2e
c0de551c:	4629      	mov	r1, r5
c0de551e:	310c      	adds	r1, #12
c0de5520:	2206      	movs	r2, #6
c0de5522:	f008 f97d 	bl	c0ded820 <__aeabi_memcpy>
		ledger_protocol_data.mtu              = ATT_MTU;
c0de5526:	48d4      	ldr	r0, [pc, #848]	; (c0de5878 <LEDGER_BLE_receive+0x49c>)
c0de5528:	1838      	adds	r0, r7, r0
c0de552a:	21ba      	movs	r1, #186	; 0xba
c0de552c:	2217      	movs	r2, #23
c0de552e:	5242      	strh	r2, [r0, r1]
c0de5530:	2152      	movs	r1, #82	; 0x52
c0de5532:	2300      	movs	r3, #0
		ledger_ble_data.notifications_enabled = 0;
c0de5534:	5463      	strb	r3, [r4, r1]
c0de5536:	2150      	movs	r1, #80	; 0x50
		ledger_ble_data.mtu                   = ATT_MTU;
c0de5538:	5262      	strh	r2, [r4, r1]
c0de553a:	2128      	movs	r1, #40	; 0x28
		ledger_ble_data.advertising_enabled   = 0;
c0de553c:	5463      	strb	r3, [r4, r1]
c0de553e:	21bc      	movs	r1, #188	; 0xbc
		ledger_protocol_data.mtu_negotiated   = 0;
c0de5540:	5443      	strb	r3, [r0, r1]
		ledger_ble_data.connection.master_clock_accuracy = buffer[18];
c0de5542:	7e28      	ldrb	r0, [r5, #24]
c0de5544:	213a      	movs	r1, #58	; 0x3a
c0de5546:	5460      	strb	r0, [r4, r1]
c0de5548:	7ca8      	ldrb	r0, [r5, #18]
c0de554a:	7ce9      	ldrb	r1, [r5, #19]
c0de554c:	0209      	lsls	r1, r1, #8
c0de554e:	1808      	adds	r0, r1, r0
		ledger_ble_data.connection.conn_interval         = U2LE(buffer, 12);
c0de5550:	86a0      	strh	r0, [r4, #52]	; 0x34
c0de5552:	7d28      	ldrb	r0, [r5, #20]
c0de5554:	7d69      	ldrb	r1, [r5, #21]
c0de5556:	0209      	lsls	r1, r1, #8
c0de5558:	1808      	adds	r0, r1, r0
		ledger_ble_data.connection.conn_latency          = U2LE(buffer, 14);
c0de555a:	86e0      	strh	r0, [r4, #54]	; 0x36
c0de555c:	7da8      	ldrb	r0, [r5, #22]
c0de555e:	7de9      	ldrb	r1, [r5, #23]
c0de5560:	0209      	lsls	r1, r1, #8
c0de5562:	1808      	adds	r0, r1, r0
		ledger_ble_data.connection.supervision_timeout   = U2LE(buffer, 16);
c0de5564:	8720      	strh	r0, [r4, #56]	; 0x38
c0de5566:	e012      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5568:	2104      	movs	r1, #4
c0de556a:	464b      	mov	r3, r9
c0de556c:	2402      	movs	r4, #2
c0de556e:	541c      	strb	r4, [r3, r0]
c0de5570:	181d      	adds	r5, r3, r0
	ledger_ble_data.hci_cmd_opcode = 0xFFFF;
c0de5572:	842a      	strh	r2, [r5, #32]
c0de5574:	77a9      	strb	r1, [r5, #30]
c0de5576:	2006      	movs	r0, #6
c0de5578:	2400      	movs	r4, #0
	ledger_ble_data.adv_enable     = !os_setting_get(OS_SETTING_PLANEMODE, NULL, 0);
c0de557a:	4621      	mov	r1, r4
c0de557c:	4622      	mov	r2, r4
c0de557e:	f003 fe99 	bl	c0de92b4 <os_setting_get>
c0de5582:	4241      	negs	r1, r0
c0de5584:	4141      	adcs	r1, r0
c0de5586:	77e9      	strb	r1, [r5, #31]
	configure_advertising_mngr(0);
c0de5588:	4620      	mov	r0, r4
c0de558a:	f000 fa2f 	bl	c0de59ec <configure_advertising_mngr>

		default:
			break;
		}
	}
}
c0de558e:	b00d      	add	sp, #52	; 0x34
c0de5590:	bdf0      	pop	{r4, r5, r6, r7, pc}
		configure_advertising_mngr(opcode);
c0de5592:	b280      	uxth	r0, r0
c0de5594:	e7f9      	b.n	c0de558a <LEDGER_BLE_receive+0x1ae>
	else if (opcode == 0xfd26) {
c0de5596:	b280      	uxth	r0, r0
c0de5598:	49f3      	ldr	r1, [pc, #972]	; (c0de5968 <LEDGER_BLE_receive+0x58c>)
c0de559a:	4288      	cmp	r0, r1
c0de559c:	d07e      	beq.n	c0de569c <LEDGER_BLE_receive+0x2c0>
c0de559e:	49f3      	ldr	r1, [pc, #972]	; (c0de596c <LEDGER_BLE_receive+0x590>)
c0de55a0:	4288      	cmp	r0, r1
c0de55a2:	d100      	bne.n	c0de55a6 <LEDGER_BLE_receive+0x1ca>
c0de55a4:	e08c      	b.n	c0de56c0 <LEDGER_BLE_receive+0x2e4>
c0de55a6:	49f2      	ldr	r1, [pc, #968]	; (c0de5970 <LEDGER_BLE_receive+0x594>)
c0de55a8:	4288      	cmp	r0, r1
c0de55aa:	d1f0      	bne.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		if (ledger_ble_data.wait_write_resp_ack != 0) {
c0de55ac:	4648      	mov	r0, r9
c0de55ae:	1901      	adds	r1, r0, r4
c0de55b0:	2053      	movs	r0, #83	; 0x53
c0de55b2:	5c09      	ldrb	r1, [r1, r0]
c0de55b4:	2900      	cmp	r1, #0
c0de55b6:	d0ea      	beq.n	c0de558e <LEDGER_BLE_receive+0x1b2>
			ledger_ble_data.wait_write_resp_ack = 0;
c0de55b8:	4649      	mov	r1, r9
c0de55ba:	190a      	adds	r2, r1, r4
c0de55bc:	2300      	movs	r3, #0
c0de55be:	5413      	strb	r3, [r2, r0]
			if (ledger_protocol_data.chunk_length >= 2) {
c0de55c0:	4be8      	ldr	r3, [pc, #928]	; (c0de5964 <LEDGER_BLE_receive+0x588>)
c0de55c2:	18c8      	adds	r0, r1, r3
c0de55c4:	21a8      	movs	r1, #168	; 0xa8
c0de55c6:	5c42      	ldrb	r2, [r0, r1]
c0de55c8:	2a02      	cmp	r2, #2
c0de55ca:	d3e0      	bcc.n	c0de558e <LEDGER_BLE_receive+0x1b2>
				G_io_app.ble_xfer_timeout = 2000;
c0de55cc:	48e9      	ldr	r0, [pc, #932]	; (c0de5974 <LEDGER_BLE_receive+0x598>)
c0de55ce:	464d      	mov	r5, r9
c0de55d0:	1828      	adds	r0, r5, r0
c0de55d2:	217d      	movs	r1, #125	; 0x7d
c0de55d4:	0109      	lsls	r1, r1, #4
c0de55d6:	8301      	strh	r1, [r0, #24]
				aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de55d8:	1928      	adds	r0, r5, r4
c0de55da:	214c      	movs	r1, #76	; 0x4c
				                           ledger_ble_data.ledger_gatt_notification_characteristic_handle,
c0de55dc:	5a41      	ldrh	r1, [r0, r1]
c0de55de:	244a      	movs	r4, #74	; 0x4a
				aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de55e0:	5b00      	ldrh	r0, [r0, r4]
c0de55e2:	18eb      	adds	r3, r5, r3
c0de55e4:	330c      	adds	r3, #12
c0de55e6:	9300      	str	r3, [sp, #0]
				                           ledger_protocol_data.chunk_length-2,
c0de55e8:	1e92      	subs	r2, r2, #2
				aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de55ea:	b2d3      	uxtb	r3, r2
c0de55ec:	2200      	movs	r2, #0
c0de55ee:	f7fb fd0d 	bl	c0de100c <aci_gatt_update_char_value>
c0de55f2:	e7cc      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de55f4:	464a      	mov	r2, r9
c0de55f6:	1990      	adds	r0, r2, r6
c0de55f8:	7a03      	ldrb	r3, [r0, #8]
c0de55fa:	7a40      	ldrb	r0, [r0, #9]
c0de55fc:	0200      	lsls	r0, r0, #8
c0de55fe:	18c3      	adds	r3, r0, r3
		if (U2LE(buffer, 2) == ledger_ble_data.connection.connection_handle) {
c0de5600:	48d7      	ldr	r0, [pc, #860]	; (c0de5960 <LEDGER_BLE_receive+0x584>)
c0de5602:	1812      	adds	r2, r2, r0
c0de5604:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
c0de5606:	4293      	cmp	r3, r2
c0de5608:	d1c1      	bne.n	c0de558e <LEDGER_BLE_receive+0x1b2>
			ledger_ble_data.connection.tx_phy = buffer[4];
c0de560a:	464a      	mov	r2, r9
c0de560c:	1810      	adds	r0, r2, r0
c0de560e:	1991      	adds	r1, r2, r6
c0de5610:	7a8a      	ldrb	r2, [r1, #10]
c0de5612:	233b      	movs	r3, #59	; 0x3b
c0de5614:	54c2      	strb	r2, [r0, r3]
			ledger_ble_data.connection.rx_phy = buffer[5];
c0de5616:	7ac9      	ldrb	r1, [r1, #11]
c0de5618:	223c      	movs	r2, #60	; 0x3c
c0de561a:	5481      	strb	r1, [r0, r2]
c0de561c:	e7b7      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de561e:	464a      	mov	r2, r9
c0de5620:	1990      	adds	r0, r2, r6
c0de5622:	7a01      	ldrb	r1, [r0, #8]
c0de5624:	7a43      	ldrb	r3, [r0, #9]
c0de5626:	021b      	lsls	r3, r3, #8
c0de5628:	1859      	adds	r1, r3, r1
		ledger_ble_data.connection.connection_handle     = U2LE(buffer, 2);
c0de562a:	4bcd      	ldr	r3, [pc, #820]	; (c0de5960 <LEDGER_BLE_receive+0x584>)
c0de562c:	18d2      	adds	r2, r2, r3
c0de562e:	8551      	strh	r1, [r2, #42]	; 0x2a
c0de5630:	7a81      	ldrb	r1, [r0, #10]
c0de5632:	7ac3      	ldrb	r3, [r0, #11]
c0de5634:	021b      	lsls	r3, r3, #8
c0de5636:	1859      	adds	r1, r3, r1
		ledger_ble_data.connection.conn_interval         = U2LE(buffer, 4);
c0de5638:	8691      	strh	r1, [r2, #52]	; 0x34
c0de563a:	7b01      	ldrb	r1, [r0, #12]
c0de563c:	7b43      	ldrb	r3, [r0, #13]
c0de563e:	021b      	lsls	r3, r3, #8
c0de5640:	1859      	adds	r1, r3, r1
		ledger_ble_data.connection.conn_latency          = U2LE(buffer, 6);
c0de5642:	86d1      	strh	r1, [r2, #54]	; 0x36
c0de5644:	7b81      	ldrb	r1, [r0, #14]
c0de5646:	7bc0      	ldrb	r0, [r0, #15]
c0de5648:	0200      	lsls	r0, r0, #8
c0de564a:	1840      	adds	r0, r0, r1
		ledger_ble_data.connection.supervision_timeout   = U2LE(buffer, 8);
c0de564c:	8710      	strh	r0, [r2, #56]	; 0x38
c0de564e:	e79e      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5650:	4648      	mov	r0, r9
c0de5652:	1982      	adds	r2, r0, r6
c0de5654:	79d3      	ldrb	r3, [r2, #7]
c0de5656:	7a12      	ldrb	r2, [r2, #8]
c0de5658:	0212      	lsls	r2, r2, #8
c0de565a:	18d3      	adds	r3, r2, r3
		if (U2LE(buffer, 1) == ledger_ble_data.connection.connection_handle) {
c0de565c:	4ac0      	ldr	r2, [pc, #768]	; (c0de5960 <LEDGER_BLE_receive+0x584>)
c0de565e:	1880      	adds	r0, r0, r2
c0de5660:	8d40      	ldrh	r0, [r0, #42]	; 0x2a
c0de5662:	4283      	cmp	r3, r0
c0de5664:	d193      	bne.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5666:	464b      	mov	r3, r9
c0de5668:	1998      	adds	r0, r3, r6
c0de566a:	7ac1      	ldrb	r1, [r0, #11]
c0de566c:	7b04      	ldrb	r4, [r0, #12]
c0de566e:	0224      	lsls	r4, r4, #8
c0de5670:	1864      	adds	r4, r4, r1
			ledger_ble_data.connection.max_tx_octets = U2LE(buffer, 3);
c0de5672:	1899      	adds	r1, r3, r2
c0de5674:	2240      	movs	r2, #64	; 0x40
			ledger_ble_data.connection.max_tx_time   = U2LE(buffer, 5);
c0de5676:	528c      	strh	r4, [r1, r2]
c0de5678:	7b42      	ldrb	r2, [r0, #13]
c0de567a:	7b83      	ldrb	r3, [r0, #14]
c0de567c:	021b      	lsls	r3, r3, #8
c0de567e:	189a      	adds	r2, r3, r2
c0de5680:	2342      	movs	r3, #66	; 0x42
			ledger_ble_data.connection.max_rx_octets = U2LE(buffer, 7);
c0de5682:	52ca      	strh	r2, [r1, r3]
c0de5684:	7bc2      	ldrb	r2, [r0, #15]
c0de5686:	7c03      	ldrb	r3, [r0, #16]
c0de5688:	021b      	lsls	r3, r3, #8
c0de568a:	189a      	adds	r2, r3, r2
c0de568c:	2344      	movs	r3, #68	; 0x44
			ledger_ble_data.connection.max_rx_time   = U2LE(buffer, 9);
c0de568e:	52ca      	strh	r2, [r1, r3]
c0de5690:	7a42      	ldrb	r2, [r0, #9]
c0de5692:	7a80      	ldrb	r0, [r0, #10]
c0de5694:	0200      	lsls	r0, r0, #8
c0de5696:	1880      	adds	r0, r0, r2
			ledger_ble_data.connection.max_tx_octets = U2LE(buffer, 3);
c0de5698:	87c8      	strh	r0, [r1, #62]	; 0x3e
c0de569a:	e778      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de569c:	4db5      	ldr	r5, [pc, #724]	; (c0de5974 <LEDGER_BLE_receive+0x598>)
		if (ledger_ble_data.connection.connection_handle != 0xFFFF) {
c0de569e:	4648      	mov	r0, r9
c0de56a0:	1941      	adds	r1, r0, r5
c0de56a2:	2223      	movs	r2, #35	; 0x23
c0de56a4:	5c89      	ldrb	r1, [r1, r2]
c0de56a6:	1900      	adds	r0, r0, r4
c0de56a8:	8d40      	ldrh	r0, [r0, #42]	; 0x2a
c0de56aa:	4ab3      	ldr	r2, [pc, #716]	; (c0de5978 <LEDGER_BLE_receive+0x59c>)
c0de56ac:	4290      	cmp	r0, r2
c0de56ae:	d100      	bne.n	c0de56b2 <LEDGER_BLE_receive+0x2d6>
c0de56b0:	e132      	b.n	c0de5918 <LEDGER_BLE_receive+0x53c>
			if (G_io_app.disabling_advertising) {
c0de56b2:	2900      	cmp	r1, #0
c0de56b4:	d100      	bne.n	c0de56b8 <LEDGER_BLE_receive+0x2dc>
c0de56b6:	e147      	b.n	c0de5948 <LEDGER_BLE_receive+0x56c>
c0de56b8:	2116      	movs	r1, #22
				aci_gap_terminate(ledger_ble_data.connection.connection_handle,
c0de56ba:	f7fb fb87 	bl	c0de0dcc <aci_gap_terminate>
c0de56be:	e143      	b.n	c0de5948 <LEDGER_BLE_receive+0x56c>
		ledger_protocol_data.chunk_length = 0;
c0de56c0:	4da8      	ldr	r5, [pc, #672]	; (c0de5964 <LEDGER_BLE_receive+0x588>)
c0de56c2:	4648      	mov	r0, r9
c0de56c4:	1941      	adds	r1, r0, r5
c0de56c6:	27a8      	movs	r7, #168	; 0xa8
c0de56c8:	2600      	movs	r6, #0
c0de56ca:	55ce      	strb	r6, [r1, r7]
		if (ledger_protocol_data.tx_apdu_buffer) {
c0de56cc:	5940      	ldr	r0, [r0, r5]
c0de56ce:	2800      	cmp	r0, #0
c0de56d0:	d01b      	beq.n	c0de570a <LEDGER_BLE_receive+0x32e>
c0de56d2:	2000      	movs	r0, #0
			LEDGER_PROTOCOL_tx(NULL, 0);
c0de56d4:	4601      	mov	r1, r0
c0de56d6:	f000 fb3b 	bl	c0de5d50 <LEDGER_PROTOCOL_tx>
			if (ledger_protocol_data.chunk_length >= 2) {
c0de56da:	4648      	mov	r0, r9
c0de56dc:	1940      	adds	r0, r0, r5
c0de56de:	5dc2      	ldrb	r2, [r0, r7]
c0de56e0:	2a02      	cmp	r2, #2
c0de56e2:	d30d      	bcc.n	c0de5700 <LEDGER_BLE_receive+0x324>
				aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de56e4:	464b      	mov	r3, r9
c0de56e6:	1918      	adds	r0, r3, r4
c0de56e8:	214c      	movs	r1, #76	; 0x4c
				                           ledger_ble_data.ledger_gatt_notification_characteristic_handle,
c0de56ea:	5a41      	ldrh	r1, [r0, r1]
c0de56ec:	244a      	movs	r4, #74	; 0x4a
				aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de56ee:	5b00      	ldrh	r0, [r0, r4]
c0de56f0:	195b      	adds	r3, r3, r5
c0de56f2:	330c      	adds	r3, #12
c0de56f4:	9300      	str	r3, [sp, #0]
				                           ledger_protocol_data.chunk_length-2,
c0de56f6:	1e92      	subs	r2, r2, #2
				aci_gatt_update_char_value(ledger_ble_data.ledger_gatt_service_handle,
c0de56f8:	b2d3      	uxtb	r3, r2
c0de56fa:	2200      	movs	r2, #0
c0de56fc:	f7fb fc86 	bl	c0de100c <aci_gatt_update_char_value>
		if (!ledger_protocol_data.tx_apdu_buffer) {
c0de5700:	4648      	mov	r0, r9
c0de5702:	5940      	ldr	r0, [r0, r5]
c0de5704:	2800      	cmp	r0, #0
c0de5706:	d000      	beq.n	c0de570a <LEDGER_BLE_receive+0x32e>
c0de5708:	e741      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
			G_io_app.ble_xfer_timeout = 0;
c0de570a:	489a      	ldr	r0, [pc, #616]	; (c0de5974 <LEDGER_BLE_receive+0x598>)
			ledger_protocol_data.chunk_length = 0;
c0de570c:	4649      	mov	r1, r9
			G_io_app.apdu_state = APDU_IDLE;
c0de570e:	540e      	strb	r6, [r1, r0]
			ledger_protocol_data.chunk_length = 0;
c0de5710:	194a      	adds	r2, r1, r5
c0de5712:	55d6      	strb	r6, [r2, r7]
			G_io_app.ble_xfer_timeout = 0;
c0de5714:	1808      	adds	r0, r1, r0
c0de5716:	8306      	strh	r6, [r0, #24]
c0de5718:	e739      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		write_permit_request(&buffer[4], length-4);
c0de571a:	1f13      	subs	r3, r2, #4
c0de571c:	b29b      	uxth	r3, r3
	if (length < 3) {
c0de571e:	2b03      	cmp	r3, #3
c0de5720:	d200      	bcs.n	c0de5724 <LEDGER_BLE_receive+0x348>
c0de5722:	e734      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5724:	464c      	mov	r4, r9
	ledger_ble_data.wait_write_resp_ack = 1;
c0de5726:	19e3      	adds	r3, r4, r7
c0de5728:	2553      	movs	r5, #83	; 0x53
c0de572a:	2701      	movs	r7, #1
c0de572c:	9704      	str	r7, [sp, #16]
c0de572e:	555f      	strb	r7, [r3, r5]
c0de5730:	19a5      	adds	r5, r4, r6
c0de5732:	7aac      	ldrb	r4, [r5, #10]
c0de5734:	7aef      	ldrb	r7, [r5, #11]
c0de5736:	023f      	lsls	r7, r7, #8
c0de5738:	193c      	adds	r4, r7, r4
	if (  (att_handle == ledger_ble_data.ledger_gatt_write_characteristic_handle+1)
c0de573a:	b2a1      	uxth	r1, r4
	uint8_t  data_length = buffer[2];
c0de573c:	7b2d      	ldrb	r5, [r5, #12]
	    &&(ledger_ble_data.notifications_enabled)
c0de573e:	2d00      	cmp	r5, #0
c0de5740:	d100      	bne.n	c0de5744 <LEDGER_BLE_receive+0x368>
c0de5742:	e0f0      	b.n	c0de5926 <LEDGER_BLE_receive+0x54a>
c0de5744:	2752      	movs	r7, #82	; 0x52
c0de5746:	5ddf      	ldrb	r7, [r3, r7]
c0de5748:	2f00      	cmp	r7, #0
c0de574a:	d100      	bne.n	c0de574e <LEDGER_BLE_receive+0x372>
c0de574c:	e0eb      	b.n	c0de5926 <LEDGER_BLE_receive+0x54a>
c0de574e:	274e      	movs	r7, #78	; 0x4e
c0de5750:	5bdb      	ldrh	r3, [r3, r7]
c0de5752:	1c5b      	adds	r3, r3, #1
c0de5754:	428b      	cmp	r3, r1
c0de5756:	d000      	beq.n	c0de575a <LEDGER_BLE_receive+0x37e>
c0de5758:	e0e5      	b.n	c0de5926 <LEDGER_BLE_receive+0x54a>
		LEDGER_PROTOCOL_rx(&buffer[1], length-1);
c0de575a:	464f      	mov	r7, r9
c0de575c:	9103      	str	r1, [sp, #12]
c0de575e:	19bc      	adds	r4, r7, r6
c0de5760:	4620      	mov	r0, r4
c0de5762:	300b      	adds	r0, #11
c0de5764:	1f51      	subs	r1, r2, #5
c0de5766:	b289      	uxth	r1, r1
c0de5768:	f000 fa60 	bl	c0de5c2c <LEDGER_PROTOCOL_rx>
		aci_gatt_write_resp(ledger_ble_data.connection.connection_handle,
c0de576c:	487c      	ldr	r0, [pc, #496]	; (c0de5960 <LEDGER_BLE_receive+0x584>)
c0de576e:	1838      	adds	r0, r7, r0
c0de5770:	8d40      	ldrh	r0, [r0, #42]	; 0x2a
c0de5772:	340d      	adds	r4, #13
c0de5774:	9500      	str	r5, [sp, #0]
c0de5776:	9401      	str	r4, [sp, #4]
c0de5778:	2500      	movs	r5, #0
c0de577a:	9903      	ldr	r1, [sp, #12]
c0de577c:	462a      	mov	r2, r5
c0de577e:	462b      	mov	r3, r5
c0de5780:	f7fb fcbc 	bl	c0de10fc <aci_gatt_write_resp>
		if (ledger_protocol_data.rx_apdu_status == APDU_STATUS_COMPLETE) {
c0de5784:	4877      	ldr	r0, [pc, #476]	; (c0de5964 <LEDGER_BLE_receive+0x588>)
c0de5786:	183a      	adds	r2, r7, r0
c0de5788:	21b2      	movs	r1, #178	; 0xb2
c0de578a:	5c52      	ldrb	r2, [r2, r1]
c0de578c:	2a02      	cmp	r2, #2
c0de578e:	d106      	bne.n	c0de579e <LEDGER_BLE_receive+0x3c2>
			G_io_app.apdu_length = ledger_protocol_data.rx_apdu_length;
c0de5790:	4a78      	ldr	r2, [pc, #480]	; (c0de5974 <LEDGER_BLE_receive+0x598>)
c0de5792:	464b      	mov	r3, r9
c0de5794:	189a      	adds	r2, r3, r2
c0de5796:	181b      	adds	r3, r3, r0
c0de5798:	24b6      	movs	r4, #182	; 0xb6
c0de579a:	5b1b      	ldrh	r3, [r3, r4]
c0de579c:	8053      	strh	r3, [r2, #2]
		G_io_app.apdu_media = IO_APDU_MEDIA_BLE; // for application code
c0de579e:	4a75      	ldr	r2, [pc, #468]	; (c0de5974 <LEDGER_BLE_receive+0x598>)
		ledger_protocol_data.rx_apdu_status = APDU_STATUS_WAITING;
c0de57a0:	464b      	mov	r3, r9
		G_io_app.apdu_state = APDU_BLE; // for next call to io_exchange
c0de57a2:	9c04      	ldr	r4, [sp, #16]
c0de57a4:	549c      	strb	r4, [r3, r2]
		ledger_protocol_data.rx_apdu_status = APDU_STATUS_WAITING;
c0de57a6:	1818      	adds	r0, r3, r0
c0de57a8:	5445      	strb	r5, [r0, r1]
		G_io_app.apdu_media = IO_APDU_MEDIA_BLE; // for application code
c0de57aa:	1898      	adds	r0, r3, r2
c0de57ac:	2102      	movs	r1, #2
c0de57ae:	7181      	strb	r1, [r0, #6]
c0de57b0:	e6ed      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de57b2:	46c0      	nop			; (mov r8, r8)
c0de57b4:	00000444 	.word	0x00000444
c0de57b8:	2500      	movs	r5, #0
c0de57ba:	4971      	ldr	r1, [pc, #452]	; (c0de5980 <LEDGER_BLE_receive+0x5a4>)
	ledger_ble_data.pairing_code = cx_rng_u32_range_func(0, 1000000, cx_rng_u32);
c0de57bc:	4a71      	ldr	r2, [pc, #452]	; (c0de5984 <LEDGER_BLE_receive+0x5a8>)
c0de57be:	447a      	add	r2, pc
c0de57c0:	4628      	mov	r0, r5
c0de57c2:	f7fd fc8b 	bl	c0de30dc <cx_rng_u32_range_func>
c0de57c6:	4639      	mov	r1, r7
c0de57c8:	464f      	mov	r7, r9
c0de57ca:	187e      	adds	r6, r7, r1
c0de57cc:	2146      	movs	r1, #70	; 0x46
c0de57ce:	5270      	strh	r0, [r6, r1]
c0de57d0:	ac05      	add	r4, sp, #20
	ux_params.u.pairing_request.type = BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST_PASSKEY;
c0de57d2:	7225      	strb	r5, [r4, #8]
c0de57d4:	2106      	movs	r1, #6
	ux_params.u.pairing_request.pairing_info_len = 6;
c0de57d6:	9108      	str	r1, [sp, #32]
	SPRINTF(ux_params.u.pairing_request.pairing_info, "%06d", ledger_ble_data.pairing_code);
c0de57d8:	b283      	uxth	r3, r0
c0de57da:	4620      	mov	r0, r4
c0de57dc:	3010      	adds	r0, #16
c0de57de:	2110      	movs	r1, #16
c0de57e0:	4a69      	ldr	r2, [pc, #420]	; (c0de5988 <LEDGER_BLE_receive+0x5ac>)
c0de57e2:	447a      	add	r2, pc
c0de57e4:	f002 fb52 	bl	c0de7e8c <snprintf>
	G_io_asynch_ux_callback.asynchmodal_end_callback = rsp_user_pairing_passkey;
c0de57e8:	4864      	ldr	r0, [pc, #400]	; (c0de597c <LEDGER_BLE_receive+0x5a0>)
c0de57ea:	4968      	ldr	r1, [pc, #416]	; (c0de598c <LEDGER_BLE_receive+0x5b0>)
c0de57ec:	4479      	add	r1, pc
c0de57ee:	5039      	str	r1, [r7, r0]
c0de57f0:	2048      	movs	r0, #72	; 0x48
c0de57f2:	2101      	movs	r1, #1
	ledger_ble_data.pairing_in_progress = 1;
c0de57f4:	5431      	strb	r1, [r6, r0]
c0de57f6:	e027      	b.n	c0de5848 <LEDGER_BLE_receive+0x46c>
c0de57f8:	00000004 	.word	0x00000004
c0de57fc:	00000ae4 	.word	0x00000ae4
c0de5800:	0000ffff 	.word	0x0000ffff
}
static inline uint32_t U4LE(const uint8_t *buf, size_t off) {
  return (((uint32_t)buf[off + 3]) << 24) | (buf[off + 2] << 16) |
c0de5804:	464d      	mov	r5, r9
c0de5806:	19a8      	adds	r0, r5, r6
         (buf[off + 1] << 8) | buf[off];
c0de5808:	7a81      	ldrb	r1, [r0, #10]
c0de580a:	9104      	str	r1, [sp, #16]
c0de580c:	7ac2      	ldrb	r2, [r0, #11]
  return (((uint32_t)buf[off + 3]) << 24) | (buf[off + 2] << 16) |
c0de580e:	7b03      	ldrb	r3, [r0, #12]
c0de5810:	7b40      	ldrb	r0, [r0, #13]
c0de5812:	ac05      	add	r4, sp, #20
c0de5814:	463e      	mov	r6, r7
c0de5816:	2701      	movs	r7, #1
	ux_params.u.pairing_request.type = BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST_NUMCOMP;
c0de5818:	7227      	strb	r7, [r4, #8]
c0de581a:	2106      	movs	r1, #6
	ux_params.u.pairing_request.pairing_info_len = 6;
c0de581c:	9108      	str	r1, [sp, #32]
c0de581e:	0600      	lsls	r0, r0, #24
c0de5820:	0419      	lsls	r1, r3, #16
c0de5822:	1808      	adds	r0, r1, r0
         (buf[off + 1] << 8) | buf[off];
c0de5824:	0211      	lsls	r1, r2, #8
  return (((uint32_t)buf[off + 3]) << 24) | (buf[off + 2] << 16) |
c0de5826:	1840      	adds	r0, r0, r1
         (buf[off + 1] << 8) | buf[off];
c0de5828:	9904      	ldr	r1, [sp, #16]
c0de582a:	1843      	adds	r3, r0, r1
	SPRINTF(ux_params.u.pairing_request.pairing_info, "%06d", code);
c0de582c:	4620      	mov	r0, r4
c0de582e:	3010      	adds	r0, #16
c0de5830:	2110      	movs	r1, #16
c0de5832:	4a57      	ldr	r2, [pc, #348]	; (c0de5990 <LEDGER_BLE_receive+0x5b4>)
c0de5834:	447a      	add	r2, pc
c0de5836:	f002 fb29 	bl	c0de7e8c <snprintf>
	G_io_asynch_ux_callback.asynchmodal_end_callback = rsp_user_pairing_numeric_comparison;
c0de583a:	4850      	ldr	r0, [pc, #320]	; (c0de597c <LEDGER_BLE_receive+0x5a0>)
c0de583c:	4955      	ldr	r1, [pc, #340]	; (c0de5994 <LEDGER_BLE_receive+0x5b8>)
c0de583e:	4479      	add	r1, pc
c0de5840:	5029      	str	r1, [r5, r0]
	ledger_ble_data.pairing_in_progress = 1;
c0de5842:	19a8      	adds	r0, r5, r6
c0de5844:	2148      	movs	r1, #72	; 0x48
c0de5846:	5447      	strb	r7, [r0, r1]
c0de5848:	2023      	movs	r0, #35	; 0x23
c0de584a:	7020      	strb	r0, [r4, #0]
c0de584c:	2018      	movs	r0, #24
c0de584e:	9006      	str	r0, [sp, #24]
c0de5850:	4620      	mov	r0, r4
c0de5852:	f003 fcf7 	bl	c0de9244 <os_ux>
c0de5856:	e69a      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5858:	00000c13 	.word	0x00000c13
c0de585c:	00000402 	.word	0x00000402
c0de5860:	00000409 	.word	0x00000409
c0de5864:	00000c01 	.word	0x00000c01
c0de5868:	00000c02 	.word	0x00000c02
c0de586c:	00000c03 	.word	0x00000c03
c0de5870:	00000c0e 	.word	0x00000c0e
c0de5874:	00000401 	.word	0x00000401
c0de5878:	00000058 	.word	0x00000058
		attribute_modified(&buffer[4], length-4);
c0de587c:	1f12      	subs	r2, r2, #4
c0de587e:	b292      	uxth	r2, r2
	if (length < 6) {
c0de5880:	2a06      	cmp	r2, #6
c0de5882:	d200      	bcs.n	c0de5886 <LEDGER_BLE_receive+0x4aa>
c0de5884:	e683      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
  return (buf[off + 1] << 8) | buf[off];
c0de5886:	464a      	mov	r2, r9
c0de5888:	1993      	adds	r3, r2, r6
c0de588a:	7b1c      	ldrb	r4, [r3, #12]
c0de588c:	7b5d      	ldrb	r5, [r3, #13]
c0de588e:	022d      	lsls	r5, r5, #8
c0de5890:	192c      	adds	r4, r5, r4
c0de5892:	d000      	beq.n	c0de5896 <LEDGER_BLE_receive+0x4ba>
c0de5894:	e67b      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5896:	7b9c      	ldrb	r4, [r3, #14]
c0de5898:	7bdd      	ldrb	r5, [r3, #15]
c0de589a:	022d      	lsls	r5, r5, #8
c0de589c:	192c      	adds	r4, r5, r4
	    &&(att_data_length == 2)
c0de589e:	2c02      	cmp	r4, #2
c0de58a0:	d000      	beq.n	c0de58a4 <LEDGER_BLE_receive+0x4c8>
c0de58a2:	e674      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de58a4:	7a9c      	ldrb	r4, [r3, #10]
c0de58a6:	7adb      	ldrb	r3, [r3, #11]
c0de58a8:	021b      	lsls	r3, r3, #8
c0de58aa:	191b      	adds	r3, r3, r4
c0de58ac:	19d2      	adds	r2, r2, r7
c0de58ae:	244c      	movs	r4, #76	; 0x4c
c0de58b0:	5b12      	ldrh	r2, [r2, r4]
c0de58b2:	1c92      	adds	r2, r2, #2
c0de58b4:	429a      	cmp	r2, r3
c0de58b6:	d000      	beq.n	c0de58ba <LEDGER_BLE_receive+0x4de>
c0de58b8:	e669      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de58ba:	464a      	mov	r2, r9
c0de58bc:	1991      	adds	r1, r2, r6
c0de58be:	7c0a      	ldrb	r2, [r1, #16]
c0de58c0:	7c49      	ldrb	r1, [r1, #17]
c0de58c2:	0209      	lsls	r1, r1, #8
c0de58c4:	1889      	adds	r1, r1, r2
		if (U2LE(buffer, 6) != 0) {
c0de58c6:	d044      	beq.n	c0de5952 <LEDGER_BLE_receive+0x576>
			ledger_ble_data.notifications_enabled = 1;
c0de58c8:	4649      	mov	r1, r9
c0de58ca:	19ca      	adds	r2, r1, r7
c0de58cc:	2352      	movs	r3, #82	; 0x52
c0de58ce:	2401      	movs	r4, #1
c0de58d0:	54d4      	strb	r4, [r2, r3]
			if (!ledger_protocol_data.mtu_negotiated) {
c0de58d2:	4a24      	ldr	r2, [pc, #144]	; (c0de5964 <LEDGER_BLE_receive+0x588>)
c0de58d4:	1889      	adds	r1, r1, r2
c0de58d6:	22bc      	movs	r2, #188	; 0xbc
c0de58d8:	5c89      	ldrb	r1, [r1, r2]
c0de58da:	2900      	cmp	r1, #0
c0de58dc:	d000      	beq.n	c0de58e0 <LEDGER_BLE_receive+0x504>
c0de58de:	e656      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
				aci_gatt_exchange_config(ledger_ble_data.connection.connection_handle);
c0de58e0:	f7fb fbc2 	bl	c0de1068 <aci_gatt_exchange_config>
c0de58e4:	e653      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de58e6:	2116      	movs	r1, #22
		aci_gap_terminate(ledger_ble_data.connection.connection_handle,
c0de58e8:	f7fb fa70 	bl	c0de0dcc <aci_gap_terminate>
c0de58ec:	e64f      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		ledger_protocol_data.mtu            = ledger_ble_data.mtu;
c0de58ee:	481d      	ldr	r0, [pc, #116]	; (c0de5964 <LEDGER_BLE_receive+0x588>)
c0de58f0:	464a      	mov	r2, r9
c0de58f2:	1810      	adds	r0, r2, r0
c0de58f4:	23bc      	movs	r3, #188	; 0xbc
c0de58f6:	2401      	movs	r4, #1
		ledger_protocol_data.mtu_negotiated = 1;
c0de58f8:	54c4      	strb	r4, [r0, r3]
c0de58fa:	1991      	adds	r1, r2, r6
c0de58fc:	7a8b      	ldrb	r3, [r1, #10]
c0de58fe:	7ac9      	ldrb	r1, [r1, #11]
c0de5900:	0209      	lsls	r1, r1, #8
c0de5902:	18c9      	adds	r1, r1, r3
		ledger_ble_data.mtu                 = U2LE(buffer, 4)-3;
c0de5904:	1ec9      	subs	r1, r1, #3
c0de5906:	19d2      	adds	r2, r2, r7
c0de5908:	2350      	movs	r3, #80	; 0x50
c0de590a:	52d1      	strh	r1, [r2, r3]
c0de590c:	22ba      	movs	r2, #186	; 0xba
		ledger_protocol_data.mtu            = ledger_ble_data.mtu;
c0de590e:	5281      	strh	r1, [r0, r2]
c0de5910:	e63d      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
		aci_gatt_confirm_indication(ledger_ble_data.connection.connection_handle);
c0de5912:	f7fb fbcf 	bl	c0de10b4 <aci_gatt_confirm_indication>
c0de5916:	e63a      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5918:	4648      	mov	r0, r9
c0de591a:	1900      	adds	r0, r0, r4
		else if (G_io_app.disabling_advertising) {
c0de591c:	2900      	cmp	r1, #0
c0de591e:	d010      	beq.n	c0de5942 <LEDGER_BLE_receive+0x566>
c0de5920:	2128      	movs	r1, #40	; 0x28
c0de5922:	2200      	movs	r2, #0
c0de5924:	e00f      	b.n	c0de5946 <LEDGER_BLE_receive+0x56a>
		ledger_protocol_data.chunk_length = 0;
c0de5926:	4a0f      	ldr	r2, [pc, #60]	; (c0de5964 <LEDGER_BLE_receive+0x588>)
c0de5928:	464b      	mov	r3, r9
c0de592a:	189c      	adds	r4, r3, r2
c0de592c:	27a8      	movs	r7, #168	; 0xa8
c0de592e:	2200      	movs	r2, #0
c0de5930:	55e2      	strb	r2, [r4, r7]
		aci_gatt_write_resp(ledger_ble_data.connection.connection_handle,
c0de5932:	199b      	adds	r3, r3, r6
c0de5934:	330d      	adds	r3, #13
c0de5936:	9500      	str	r5, [sp, #0]
c0de5938:	9301      	str	r3, [sp, #4]
c0de593a:	4613      	mov	r3, r2
c0de593c:	f7fb fbde 	bl	c0de10fc <aci_gatt_write_resp>
c0de5940:	e625      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de5942:	2128      	movs	r1, #40	; 0x28
c0de5944:	2201      	movs	r2, #1
c0de5946:	5442      	strb	r2, [r0, r1]
		G_io_app.disabling_advertising = 0;
c0de5948:	4648      	mov	r0, r9
c0de594a:	1940      	adds	r0, r0, r5
c0de594c:	2100      	movs	r1, #0
		G_io_app.enabling_advertising  = 0;
c0de594e:	8441      	strh	r1, [r0, #34]	; 0x22
c0de5950:	e61d      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
			ledger_ble_data.notifications_enabled = 0;
c0de5952:	4648      	mov	r0, r9
c0de5954:	19c0      	adds	r0, r0, r7
c0de5956:	2152      	movs	r1, #82	; 0x52
c0de5958:	2200      	movs	r2, #0
c0de595a:	5442      	strb	r2, [r0, r1]
c0de595c:	e617      	b.n	c0de558e <LEDGER_BLE_receive+0x1b2>
c0de595e:	46c0      	nop			; (mov r8, r8)
c0de5960:	00000004 	.word	0x00000004
c0de5964:	00000058 	.word	0x00000058
c0de5968:	0000200a 	.word	0x0000200a
c0de596c:	0000fd06 	.word	0x0000fd06
c0de5970:	0000fd26 	.word	0x0000fd26
c0de5974:	00000ae4 	.word	0x00000ae4
c0de5978:	0000ffff 	.word	0x0000ffff
c0de597c:	00000b94 	.word	0x00000b94
c0de5980:	000f4240 	.word	0x000f4240
c0de5984:	000003d7 	.word	0x000003d7
c0de5988:	0000856d 	.word	0x0000856d
c0de598c:	000003b9 	.word	0x000003b9
c0de5990:	0000851b 	.word	0x0000851b
c0de5994:	000003b3 	.word	0x000003b3

c0de5998 <hci_send_req>:

int hci_send_req(struct hci_request *p_cmd, uint8_t async)
{
c0de5998:	b5b0      	push	{r4, r5, r7, lr}
c0de599a:	4604      	mov	r4, r0
	UNUSED(async);

	uint16_t opcode = ((p_cmd->ocf) & 0x03ff) | ((p_cmd->ogf) << 10);
c0de599c:	8800      	ldrh	r0, [r0, #0]

	G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_BLE_SEND;
c0de599e:	490f      	ldr	r1, [pc, #60]	; (c0de59dc <hci_send_req+0x44>)
c0de59a0:	464a      	mov	r2, r9
c0de59a2:	2338      	movs	r3, #56	; 0x38
c0de59a4:	5453      	strb	r3, [r2, r1]
c0de59a6:	1855      	adds	r5, r2, r1
	uint16_t opcode = ((p_cmd->ocf) & 0x03ff) | ((p_cmd->ogf) << 10);
c0de59a8:	8861      	ldrh	r1, [r4, #2]
	G_io_seproxyhal_spi_buffer[1] = (p_cmd->clen+2)>>8;
	G_io_seproxyhal_spi_buffer[2] = (p_cmd->clen+2);
	G_io_seproxyhal_spi_buffer[3] = opcode >>8;
	G_io_seproxyhal_spi_buffer[4] = opcode;
c0de59aa:	7129      	strb	r1, [r5, #4]
	G_io_seproxyhal_spi_buffer[1] = (p_cmd->clen+2)>>8;
c0de59ac:	68e2      	ldr	r2, [r4, #12]
c0de59ae:	1c93      	adds	r3, r2, #2
	G_io_seproxyhal_spi_buffer[2] = (p_cmd->clen+2);
c0de59b0:	70ab      	strb	r3, [r5, #2]
	G_io_seproxyhal_spi_buffer[1] = (p_cmd->clen+2)>>8;
c0de59b2:	0a1b      	lsrs	r3, r3, #8
c0de59b4:	706b      	strb	r3, [r5, #1]
c0de59b6:	2303      	movs	r3, #3
c0de59b8:	021b      	lsls	r3, r3, #8
	uint16_t opcode = ((p_cmd->ocf) & 0x03ff) | ((p_cmd->ogf) << 10);
c0de59ba:	400b      	ands	r3, r1
c0de59bc:	0280      	lsls	r0, r0, #10
c0de59be:	18c0      	adds	r0, r0, r3
	G_io_seproxyhal_spi_buffer[3] = opcode >>8;
c0de59c0:	0a00      	lsrs	r0, r0, #8
c0de59c2:	70e8      	strb	r0, [r5, #3]
	memmove(G_io_seproxyhal_spi_buffer+5, p_cmd->cparam, p_cmd->clen);
c0de59c4:	1d68      	adds	r0, r5, #5
c0de59c6:	68a1      	ldr	r1, [r4, #8]
c0de59c8:	f007 ff2e 	bl	c0ded828 <__aeabi_memmove>
	io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3+p_cmd->clen+2);
c0de59cc:	89a0      	ldrh	r0, [r4, #12]
c0de59ce:	1d40      	adds	r0, r0, #5
c0de59d0:	b281      	uxth	r1, r0
c0de59d2:	4628      	mov	r0, r5
c0de59d4:	f003 fc92 	bl	c0de92fc <io_seph_send>
c0de59d8:	2000      	movs	r0, #0

	return 0;
c0de59da:	bdb0      	pop	{r4, r5, r7, pc}
c0de59dc:	00000444 	.word	0x00000444

c0de59e0 <BLE_power>:
}

void BLE_power(unsigned char powered, const char *discovered_name) {
c0de59e0:	b580      	push	{r7, lr}
	UNUSED(discovered_name);

	LOG_BLE("BLE_power %d\n", powered);
	if (powered) {
c0de59e2:	2800      	cmp	r0, #0
c0de59e4:	d001      	beq.n	c0de59ea <BLE_power+0xa>
		LEDGER_BLE_init();
c0de59e6:	f7ff fb4d 	bl	c0de5084 <LEDGER_BLE_init>
	}
c0de59ea:	bd80      	pop	{r7, pc}

c0de59ec <configure_advertising_mngr>:
{
c0de59ec:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de59ee:	b08d      	sub	sp, #52	; 0x34
	if (  (ledger_ble_data.hci_cmd_opcode != 0xFFFF)
c0de59f0:	4d56      	ldr	r5, [pc, #344]	; (c0de5b4c <configure_advertising_mngr+0x160>)
c0de59f2:	4649      	mov	r1, r9
c0de59f4:	1949      	adds	r1, r1, r5
c0de59f6:	8c0a      	ldrh	r2, [r1, #32]
c0de59f8:	4955      	ldr	r1, [pc, #340]	; (c0de5b50 <configure_advertising_mngr+0x164>)
	    &&(opcode != ledger_ble_data.hci_cmd_opcode)
c0de59fa:	428a      	cmp	r2, r1
c0de59fc:	d003      	beq.n	c0de5a06 <configure_advertising_mngr+0x1a>
c0de59fe:	4282      	cmp	r2, r0
c0de5a00:	d001      	beq.n	c0de5a06 <configure_advertising_mngr+0x1a>
}
c0de5a02:	b00d      	add	sp, #52	; 0x34
c0de5a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (ledger_ble_data.adv_step == BLE_CONFIG_ADV_STEP_IDLE) {
c0de5a06:	4648      	mov	r0, r9
c0de5a08:	1940      	adds	r0, r0, r5
c0de5a0a:	7f80      	ldrb	r0, [r0, #30]
c0de5a0c:	2805      	cmp	r0, #5
c0de5a0e:	d006      	beq.n	c0de5a1e <configure_advertising_mngr+0x32>
c0de5a10:	2800      	cmp	r0, #0
c0de5a12:	d13f      	bne.n	c0de5a94 <configure_advertising_mngr+0xa8>
		ledger_ble_data.connection.connection_handle = 0xFFFF;
c0de5a14:	464a      	mov	r2, r9
c0de5a16:	1952      	adds	r2, r2, r5
c0de5a18:	8551      	strh	r1, [r2, #42]	; 0x2a
c0de5a1a:	2100      	movs	r1, #0
c0de5a1c:	e000      	b.n	c0de5a20 <configure_advertising_mngr+0x34>
c0de5a1e:	2101      	movs	r1, #1
c0de5a20:	464a      	mov	r2, r9
c0de5a22:	1952      	adds	r2, r2, r5
c0de5a24:	2328      	movs	r3, #40	; 0x28
c0de5a26:	54d1      	strb	r1, [r2, r3]
	ledger_ble_data.adv_step++;
c0de5a28:	1c41      	adds	r1, r0, #1
c0de5a2a:	7791      	strb	r1, [r2, #30]
	switch (ledger_ble_data.adv_step) {
c0de5a2c:	b2c8      	uxtb	r0, r1
c0de5a2e:	2805      	cmp	r0, #5
c0de5a30:	d046      	beq.n	c0de5ac0 <configure_advertising_mngr+0xd4>
c0de5a32:	2802      	cmp	r0, #2
c0de5a34:	d04d      	beq.n	c0de5ad2 <configure_advertising_mngr+0xe6>
c0de5a36:	2803      	cmp	r0, #3
c0de5a38:	d06a      	beq.n	c0de5b10 <configure_advertising_mngr+0x124>
c0de5a3a:	2804      	cmp	r0, #4
c0de5a3c:	d075      	beq.n	c0de5b2a <configure_advertising_mngr+0x13e>
c0de5a3e:	2801      	cmp	r0, #1
c0de5a40:	d136      	bne.n	c0de5ab0 <configure_advertising_mngr+0xc4>
c0de5a42:	ac05      	add	r4, sp, #20
c0de5a44:	2006      	movs	r0, #6
		buffer[index++] = FLAG_BIT_BR_EDR_NOT_SUPPORTED | FLAG_BIT_LE_GENERAL_DISCOVERABLE_MODE;
c0de5a46:	70a0      	strb	r0, [r4, #2]
c0de5a48:	2081      	movs	r0, #129	; 0x81
c0de5a4a:	0040      	lsls	r0, r0, #1
		buffer[index++] = 2;
c0de5a4c:	8020      	strh	r0, [r4, #0]
	memset(ledger_ble_data.device_name, 0,
c0de5a4e:	4648      	mov	r0, r9
c0de5a50:	1940      	adds	r0, r0, r5
c0de5a52:	9004      	str	r0, [sp, #16]
c0de5a54:	1c45      	adds	r5, r0, #1
c0de5a56:	2115      	movs	r1, #21
c0de5a58:	4628      	mov	r0, r5
c0de5a5a:	f007 fedb 	bl	c0ded814 <__aeabi_memclr>
c0de5a5e:	2609      	movs	r6, #9
c0de5a60:	2214      	movs	r2, #20
	ledger_ble_data.device_name_length = os_setting_get(OS_SETTING_DEVICENAME,
c0de5a62:	4630      	mov	r0, r6
c0de5a64:	4629      	mov	r1, r5
c0de5a66:	f003 fc25 	bl	c0de92b4 <os_setting_get>
c0de5a6a:	4607      	mov	r7, r0
c0de5a6c:	9804      	ldr	r0, [sp, #16]
c0de5a6e:	7587      	strb	r7, [r0, #22]
		buffer[index++] = AD_TYPE_COMPLETE_LOCAL_NAME;
c0de5a70:	7126      	strb	r6, [r4, #4]
		buffer[index++] = ledger_ble_data.device_name_length+1;
c0de5a72:	1c78      	adds	r0, r7, #1
c0de5a74:	70e0      	strb	r0, [r4, #3]
		memcpy(&buffer[index], ledger_ble_data.device_name, ledger_ble_data.device_name_length);
c0de5a76:	b2fa      	uxtb	r2, r7
c0de5a78:	1d60      	adds	r0, r4, #5
c0de5a7a:	4629      	mov	r1, r5
c0de5a7c:	f007 fed0 	bl	c0ded820 <__aeabi_memcpy>
c0de5a80:	4834      	ldr	r0, [pc, #208]	; (c0de5b54 <configure_advertising_mngr+0x168>)
		ledger_ble_data.hci_cmd_opcode = 0x2008;
c0de5a82:	1c80      	adds	r0, r0, #2
c0de5a84:	9904      	ldr	r1, [sp, #16]
c0de5a86:	8408      	strh	r0, [r1, #32]
		index += ledger_ble_data.device_name_length;
c0de5a88:	1d78      	adds	r0, r7, #5
		hci_le_set_advertising_data(index, buffer);
c0de5a8a:	b2c0      	uxtb	r0, r0
c0de5a8c:	4621      	mov	r1, r4
c0de5a8e:	f7fb fc05 	bl	c0de129c <hci_le_set_advertising_data>
c0de5a92:	e7b6      	b.n	c0de5a02 <configure_advertising_mngr+0x16>
	ledger_ble_data.adv_step++;
c0de5a94:	4649      	mov	r1, r9
c0de5a96:	194a      	adds	r2, r1, r5
c0de5a98:	1c41      	adds	r1, r0, #1
c0de5a9a:	7791      	strb	r1, [r2, #30]
c0de5a9c:	b2cb      	uxtb	r3, r1
	    &&(!ledger_ble_data.adv_enable)
c0de5a9e:	2b05      	cmp	r3, #5
c0de5aa0:	d1c4      	bne.n	c0de5a2c <configure_advertising_mngr+0x40>
c0de5aa2:	7fd2      	ldrb	r2, [r2, #31]
c0de5aa4:	2a00      	cmp	r2, #0
c0de5aa6:	d1c1      	bne.n	c0de5a2c <configure_advertising_mngr+0x40>
		ledger_ble_data.adv_step++;
c0de5aa8:	4649      	mov	r1, r9
c0de5aaa:	1949      	adds	r1, r1, r5
c0de5aac:	1c80      	adds	r0, r0, #2
c0de5aae:	7788      	strb	r0, [r1, #30]
		if (ledger_ble_data.state == BLE_STATE_CONFIGURE_ADVERTISING) {
c0de5ab0:	4648      	mov	r0, r9
c0de5ab2:	5d40      	ldrb	r0, [r0, r5]
c0de5ab4:	2802      	cmp	r0, #2
c0de5ab6:	d1a4      	bne.n	c0de5a02 <configure_advertising_mngr+0x16>
			ledger_ble_data.state = BLE_STATE_INITIALIZED;
c0de5ab8:	4648      	mov	r0, r9
c0de5aba:	2101      	movs	r1, #1
c0de5abc:	5541      	strb	r1, [r0, r5]
c0de5abe:	e7a0      	b.n	c0de5a02 <configure_advertising_mngr+0x16>
		ledger_ble_data.hci_cmd_opcode = 0x200a;
c0de5ac0:	4648      	mov	r0, r9
c0de5ac2:	1940      	adds	r0, r0, r5
c0de5ac4:	4923      	ldr	r1, [pc, #140]	; (c0de5b54 <configure_advertising_mngr+0x168>)
c0de5ac6:	1d09      	adds	r1, r1, #4
c0de5ac8:	8401      	strh	r1, [r0, #32]
c0de5aca:	2001      	movs	r0, #1
		hci_le_set_advertise_enable(1);
c0de5acc:	f7fb fc36 	bl	c0de133c <hci_le_set_advertise_enable>
c0de5ad0:	e797      	b.n	c0de5a02 <configure_advertising_mngr+0x16>
c0de5ad2:	ac05      	add	r4, sp, #20
c0de5ad4:	2006      	movs	r0, #6
		buffer[index++] = AD_TYPE_128_BIT_SERV_UUID;
c0de5ad6:	7060      	strb	r0, [r4, #1]
c0de5ad8:	2011      	movs	r0, #17
		buffer[index++] = sizeof(service_uuid)+1;
c0de5ada:	7020      	strb	r0, [r4, #0]
		memcpy(&buffer[index], service_uuid, sizeof(service_uuid));
c0de5adc:	1ca0      	adds	r0, r4, #2
c0de5ade:	491f      	ldr	r1, [pc, #124]	; (c0de5b5c <configure_advertising_mngr+0x170>)
c0de5ae0:	4479      	add	r1, pc
c0de5ae2:	2210      	movs	r2, #16
c0de5ae4:	f007 fe9c 	bl	c0ded820 <__aeabi_memcpy>
c0de5ae8:	2100      	movs	r1, #0
		buffer[index++] = 0;
c0de5aea:	75e1      	strb	r1, [r4, #23]
c0de5aec:	2018      	movs	r0, #24
		buffer[index++] = BLE_SLAVE_CONN_INTERVAL_MAX;
c0de5aee:	75a0      	strb	r0, [r4, #22]
		buffer[index++] = 0;
c0de5af0:	7561      	strb	r1, [r4, #21]
c0de5af2:	210c      	movs	r1, #12
		buffer[index++] = BLE_SLAVE_CONN_INTERVAL_MIN;
c0de5af4:	7521      	strb	r1, [r4, #20]
c0de5af6:	2112      	movs	r1, #18
		buffer[index++] = AD_TYPE_SLAVE_CONN_INTERVAL;
c0de5af8:	74e1      	strb	r1, [r4, #19]
c0de5afa:	2105      	movs	r1, #5
		buffer[index++] = 5;
c0de5afc:	74a1      	strb	r1, [r4, #18]
		ledger_ble_data.hci_cmd_opcode = 0x2009;
c0de5afe:	4649      	mov	r1, r9
c0de5b00:	1949      	adds	r1, r1, r5
c0de5b02:	4a14      	ldr	r2, [pc, #80]	; (c0de5b54 <configure_advertising_mngr+0x168>)
c0de5b04:	1cd2      	adds	r2, r2, #3
c0de5b06:	840a      	strh	r2, [r1, #32]
		hci_le_set_scan_response_data(index, buffer);
c0de5b08:	4621      	mov	r1, r4
c0de5b0a:	f7fb fbef 	bl	c0de12ec <hci_le_set_scan_response_data>
c0de5b0e:	e778      	b.n	c0de5a02 <configure_advertising_mngr+0x16>
		ledger_ble_data.hci_cmd_opcode = 0xfd06;
c0de5b10:	4648      	mov	r0, r9
c0de5b12:	1942      	adds	r2, r0, r5
c0de5b14:	4810      	ldr	r0, [pc, #64]	; (c0de5b58 <configure_advertising_mngr+0x16c>)
c0de5b16:	8410      	strh	r0, [r2, #32]
		                           ledger_ble_data.device_name_length,
c0de5b18:	7d93      	ldrb	r3, [r2, #22]
		                           ledger_ble_data.gap_device_name_characteristic_handle,
c0de5b1a:	8c91      	ldrh	r1, [r2, #36]	; 0x24
		aci_gatt_update_char_value(ledger_ble_data.gap_service_handle,
c0de5b1c:	8c50      	ldrh	r0, [r2, #34]	; 0x22
c0de5b1e:	1c52      	adds	r2, r2, #1
c0de5b20:	9200      	str	r2, [sp, #0]
c0de5b22:	2200      	movs	r2, #0
c0de5b24:	f7fb fa72 	bl	c0de100c <aci_gatt_update_char_value>
c0de5b28:	e76b      	b.n	c0de5a02 <configure_advertising_mngr+0x16>
		ledger_ble_data.hci_cmd_opcode = 0x2006;
c0de5b2a:	4648      	mov	r0, r9
c0de5b2c:	1940      	adds	r0, r0, r5
c0de5b2e:	4909      	ldr	r1, [pc, #36]	; (c0de5b54 <configure_advertising_mngr+0x168>)
c0de5b30:	8401      	strh	r1, [r0, #32]
c0de5b32:	2200      	movs	r2, #0
		hci_le_set_advertising_parameters(BLE_ADVERTISING_INTERVAL_MIN,
c0de5b34:	9203      	str	r2, [sp, #12]
c0de5b36:	2007      	movs	r0, #7
c0de5b38:	9002      	str	r0, [sp, #8]
c0de5b3a:	a805      	add	r0, sp, #20
c0de5b3c:	9001      	str	r0, [sp, #4]
c0de5b3e:	9200      	str	r2, [sp, #0]
c0de5b40:	2030      	movs	r0, #48	; 0x30
c0de5b42:	2160      	movs	r1, #96	; 0x60
c0de5b44:	2301      	movs	r3, #1
c0de5b46:	f7fb fb77 	bl	c0de1238 <hci_le_set_advertising_parameters>
c0de5b4a:	e75a      	b.n	c0de5a02 <configure_advertising_mngr+0x16>
c0de5b4c:	00000004 	.word	0x00000004
c0de5b50:	0000ffff 	.word	0x0000ffff
c0de5b54:	00002006 	.word	0x00002006
c0de5b58:	0000fd06 	.word	0x0000fd06
c0de5b5c:	0000a234 	.word	0x0000a234

c0de5b60 <end_pairing_ux>:
{
c0de5b60:	b510      	push	{r4, lr}
c0de5b62:	b088      	sub	sp, #32
	if (ledger_ble_data.pairing_in_progress) {
c0de5b64:	480a      	ldr	r0, [pc, #40]	; (c0de5b90 <end_pairing_ux+0x30>)
c0de5b66:	4649      	mov	r1, r9
c0de5b68:	180a      	adds	r2, r1, r0
c0de5b6a:	2148      	movs	r1, #72	; 0x48
c0de5b6c:	5c52      	ldrb	r2, [r2, r1]
c0de5b6e:	2a00      	cmp	r2, #0
c0de5b70:	d00b      	beq.n	c0de5b8a <end_pairing_ux+0x2a>
		G_io_asynch_ux_callback.asynchmodal_end_callback = NULL;
c0de5b72:	4a08      	ldr	r2, [pc, #32]	; (c0de5b94 <end_pairing_ux+0x34>)
c0de5b74:	464b      	mov	r3, r9
c0de5b76:	2400      	movs	r4, #0
c0de5b78:	509c      	str	r4, [r3, r2]
		ledger_ble_data.pairing_in_progress = 0;
c0de5b7a:	1818      	adds	r0, r3, r0
c0de5b7c:	5444      	strb	r4, [r0, r1]
c0de5b7e:	4668      	mov	r0, sp
c0de5b80:	2124      	movs	r1, #36	; 0x24
		ux_params.ux_id = BOLOS_UX_ASYNCHMODAL_PAIRING_CANCEL;
c0de5b82:	7001      	strb	r1, [r0, #0]
		ux_params.len = 0;
c0de5b84:	9401      	str	r4, [sp, #4]
		os_ux(&ux_params);
c0de5b86:	f003 fb5d 	bl	c0de9244 <os_ux>
}
c0de5b8a:	b008      	add	sp, #32
c0de5b8c:	bd10      	pop	{r4, pc}
c0de5b8e:	46c0      	nop			; (mov r8, r8)
c0de5b90:	00000004 	.word	0x00000004
c0de5b94:	00000b94 	.word	0x00000b94

c0de5b98 <cx_rng_u32>:
/**
 * @brief   Output 32 random bits.
 *
 * @return  A 32-bit random number.
 */
static inline uint32_t cx_rng_u32(void) {
c0de5b98:	b5e0      	push	{r5, r6, r7, lr}
c0de5b9a:	a801      	add	r0, sp, #4
c0de5b9c:	2104      	movs	r1, #4
  uint32_t r;
  cx_rng_no_throw((uint8_t *)&r, sizeof(uint32_t));
c0de5b9e:	f7fd fa97 	bl	c0de30d0 <cx_rng_no_throw>
  return r;
c0de5ba2:	9801      	ldr	r0, [sp, #4]
c0de5ba4:	bd8c      	pop	{r2, r3, r7, pc}
c0de5ba6:	d4d4      	bmi.n	c0de5b52 <configure_advertising_mngr+0x166>

c0de5ba8 <rsp_user_pairing_passkey>:
{
c0de5ba8:	b510      	push	{r4, lr}
c0de5baa:	4604      	mov	r4, r0
	end_pairing_ux();
c0de5bac:	f7ff ffd8 	bl	c0de5b60 <end_pairing_ux>
	if (status != BOLOS_UX_OK) { // BLE_TODO
c0de5bb0:	2caa      	cmp	r4, #170	; 0xaa
c0de5bb2:	d105      	bne.n	c0de5bc0 <rsp_user_pairing_passkey+0x18>
	                      ledger_ble_data.pairing_code);
c0de5bb4:	480d      	ldr	r0, [pc, #52]	; (c0de5bec <rsp_user_pairing_passkey+0x44>)
c0de5bb6:	4649      	mov	r1, r9
c0de5bb8:	1808      	adds	r0, r1, r0
c0de5bba:	2146      	movs	r1, #70	; 0x46
c0de5bbc:	5a40      	ldrh	r0, [r0, r1]
c0de5bbe:	e00a      	b.n	c0de5bd6 <rsp_user_pairing_passkey+0x2e>
c0de5bc0:	2000      	movs	r0, #0
c0de5bc2:	4909      	ldr	r1, [pc, #36]	; (c0de5be8 <rsp_user_pairing_passkey+0x40>)
		ledger_ble_data.pairing_code = cx_rng_u32_range_func(0, 1000000, cx_rng_u32);
c0de5bc4:	4a0a      	ldr	r2, [pc, #40]	; (c0de5bf0 <rsp_user_pairing_passkey+0x48>)
c0de5bc6:	447a      	add	r2, pc
c0de5bc8:	f7fd fa88 	bl	c0de30dc <cx_rng_u32_range_func>
c0de5bcc:	4907      	ldr	r1, [pc, #28]	; (c0de5bec <rsp_user_pairing_passkey+0x44>)
c0de5bce:	464a      	mov	r2, r9
c0de5bd0:	1851      	adds	r1, r2, r1
c0de5bd2:	2246      	movs	r2, #70	; 0x46
c0de5bd4:	5288      	strh	r0, [r1, r2]
	aci_gap_pass_key_resp(ledger_ble_data.connection.connection_handle,
c0de5bd6:	4905      	ldr	r1, [pc, #20]	; (c0de5bec <rsp_user_pairing_passkey+0x44>)
c0de5bd8:	464a      	mov	r2, r9
c0de5bda:	1851      	adds	r1, r2, r1
c0de5bdc:	8d4a      	ldrh	r2, [r1, #42]	; 0x2a
	                      ledger_ble_data.pairing_code);
c0de5bde:	b281      	uxth	r1, r0
	aci_gap_pass_key_resp(ledger_ble_data.connection.connection_handle,
c0de5be0:	4610      	mov	r0, r2
c0de5be2:	f7fb f887 	bl	c0de0cf4 <aci_gap_pass_key_resp>
}
c0de5be6:	bd10      	pop	{r4, pc}
c0de5be8:	000f4240 	.word	0x000f4240
c0de5bec:	00000004 	.word	0x00000004
c0de5bf0:	ffffffcf 	.word	0xffffffcf

c0de5bf4 <rsp_user_pairing_numeric_comparison>:
{
c0de5bf4:	b5b0      	push	{r4, r5, r7, lr}
	if (status == BOLOS_UX_OK) {
c0de5bf6:	38aa      	subs	r0, #170	; 0xaa
c0de5bf8:	4244      	negs	r4, r0
c0de5bfa:	4144      	adcs	r4, r0
c0de5bfc:	4804      	ldr	r0, [pc, #16]	; (c0de5c10 <rsp_user_pairing_numeric_comparison+0x1c>)
c0de5bfe:	4649      	mov	r1, r9
c0de5c00:	180d      	adds	r5, r1, r0
	end_pairing_ux();
c0de5c02:	f7ff ffad 	bl	c0de5b60 <end_pairing_ux>
c0de5c06:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
c0de5c08:	4621      	mov	r1, r4
c0de5c0a:	f7fb f905 	bl	c0de0e18 <aci_gap_numeric_comparison_value_confirm_yesno>
}
c0de5c0e:	bdb0      	pop	{r4, r5, r7, pc}
c0de5c10:	00000004 	.word	0x00000004

c0de5c14 <LEDGER_PROTOCOL_init>:
	}
}

/* Exported functions --------------------------------------------------------*/
void LEDGER_PROTOCOL_init(ledger_protocol_t *data)
{
c0de5c14:	21b2      	movs	r1, #178	; 0xb2
c0de5c16:	2200      	movs	r2, #0
	ledger_protocol = data;
	ledger_protocol->rx_apdu_status          = APDU_STATUS_WAITING;
c0de5c18:	5442      	strb	r2, [r0, r1]
	ledger_protocol = data;
c0de5c1a:	4903      	ldr	r1, [pc, #12]	; (c0de5c28 <LEDGER_PROTOCOL_init+0x14>)
c0de5c1c:	464b      	mov	r3, r9
c0de5c1e:	5058      	str	r0, [r3, r1]
c0de5c20:	30b2      	adds	r0, #178	; 0xb2
	ledger_protocol->rx_apdu_sequence_number = 0;
c0de5c22:	8042      	strh	r2, [r0, #2]
}
c0de5c24:	4770      	bx	lr
c0de5c26:	46c0      	nop			; (mov r8, r8)
c0de5c28:	00000118 	.word	0x00000118

c0de5c2c <LEDGER_PROTOCOL_rx>:

void LEDGER_PROTOCOL_rx(uint8_t  *buffer,
                        uint16_t length)
{
c0de5c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!buffer || length < 3) {
c0de5c2e:	2800      	cmp	r0, #0
c0de5c30:	d002      	beq.n	c0de5c38 <LEDGER_PROTOCOL_rx+0xc>
c0de5c32:	460d      	mov	r5, r1
c0de5c34:	2903      	cmp	r1, #3
c0de5c36:	d200      	bcs.n	c0de5c3a <LEDGER_PROTOCOL_rx+0xe>

	default:
		// Unsupported command
		break;
	}
}
c0de5c38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de5c3a:	4604      	mov	r4, r0
	memset(ledger_protocol->chunk, 0, sizeof(ledger_protocol->chunk));
c0de5c3c:	4843      	ldr	r0, [pc, #268]	; (c0de5d4c <LEDGER_PROTOCOL_rx+0x120>)
c0de5c3e:	4649      	mov	r1, r9
c0de5c40:	580f      	ldr	r7, [r1, r0]
c0de5c42:	463e      	mov	r6, r7
c0de5c44:	360a      	adds	r6, #10
c0de5c46:	219e      	movs	r1, #158	; 0x9e
c0de5c48:	4630      	mov	r0, r6
c0de5c4a:	9100      	str	r1, [sp, #0]
c0de5c4c:	f007 fde2 	bl	c0ded814 <__aeabi_memclr>
	memcpy(ledger_protocol->chunk, buffer, 2); // Copy channel ID
c0de5c50:	7820      	ldrb	r0, [r4, #0]
c0de5c52:	7861      	ldrb	r1, [r4, #1]
c0de5c54:	0209      	lsls	r1, r1, #8
c0de5c56:	1808      	adds	r0, r1, r0
c0de5c58:	8178      	strh	r0, [r7, #10]
	memset(ledger_protocol->chunk, 0, sizeof(ledger_protocol->chunk));
c0de5c5a:	463b      	mov	r3, r7
c0de5c5c:	33a8      	adds	r3, #168	; 0xa8
	switch (buffer[2]) {
c0de5c5e:	78a0      	ldrb	r0, [r4, #2]
c0de5c60:	2808      	cmp	r0, #8
c0de5c62:	d012      	beq.n	c0de5c8a <LEDGER_PROTOCOL_rx+0x5e>
c0de5c64:	2801      	cmp	r0, #1
c0de5c66:	d01a      	beq.n	c0de5c9e <LEDGER_PROTOCOL_rx+0x72>
c0de5c68:	2802      	cmp	r0, #2
c0de5c6a:	d01d      	beq.n	c0de5ca8 <LEDGER_PROTOCOL_rx+0x7c>
c0de5c6c:	2805      	cmp	r0, #5
c0de5c6e:	d025      	beq.n	c0de5cbc <LEDGER_PROTOCOL_rx+0x90>
c0de5c70:	2800      	cmp	r0, #0
c0de5c72:	d1e1      	bne.n	c0de5c38 <LEDGER_PROTOCOL_rx+0xc>
c0de5c74:	4638      	mov	r0, r7
c0de5c76:	300d      	adds	r0, #13
c0de5c78:	2100      	movs	r1, #0
		memcpy(&ledger_protocol->chunk[3],
c0de5c7a:	70c1      	strb	r1, [r0, #3]
c0de5c7c:	7081      	strb	r1, [r0, #2]
c0de5c7e:	7041      	strb	r1, [r0, #1]
c0de5c80:	7001      	strb	r1, [r0, #0]
		ledger_protocol->chunk[2]     = TAG_GET_PROTOCOL_VERSION;
c0de5c82:	7339      	strb	r1, [r7, #12]
c0de5c84:	2007      	movs	r0, #7
		ledger_protocol->chunk_length += 3;
c0de5c86:	7018      	strb	r0, [r3, #0]
}
c0de5c88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de5c8a:	2001      	movs	r0, #1
		ledger_protocol->chunk[6] = 0x01;
c0de5c8c:	7438      	strb	r0, [r7, #16]
c0de5c8e:	2000      	movs	r0, #0
		ledger_protocol->chunk[4] = 0x00;
c0de5c90:	81f8      	strh	r0, [r7, #14]
c0de5c92:	2008      	movs	r0, #8
		ledger_protocol->chunk[2] = TAG_MTU;
c0de5c94:	81b8      	strh	r0, [r7, #12]
		ledger_protocol->chunk_length = 8;
c0de5c96:	7018      	strb	r0, [r3, #0]
		ledger_protocol->chunk[7] = ledger_protocol->mtu;
c0de5c98:	7c98      	ldrb	r0, [r3, #18]
c0de5c9a:	7478      	strb	r0, [r7, #17]
}
c0de5c9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de5c9e:	2003      	movs	r0, #3
		ledger_protocol->chunk_length = 3;
c0de5ca0:	7018      	strb	r0, [r3, #0]
c0de5ca2:	2001      	movs	r0, #1
		ledger_protocol->chunk[2] = TAG_ALLOCATE_CHANNEL;
c0de5ca4:	7338      	strb	r0, [r7, #12]
}
c0de5ca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		ledger_protocol->chunk_length = MIN(sizeof(ledger_protocol->chunk),
c0de5ca8:	2d9e      	cmp	r5, #158	; 0x9e
c0de5caa:	d300      	bcc.n	c0de5cae <LEDGER_PROTOCOL_rx+0x82>
c0de5cac:	9d00      	ldr	r5, [sp, #0]
c0de5cae:	701d      	strb	r5, [r3, #0]
		memcpy(ledger_protocol->chunk,
c0de5cb0:	4630      	mov	r0, r6
c0de5cb2:	4621      	mov	r1, r4
c0de5cb4:	462a      	mov	r2, r5
c0de5cb6:	f007 fdb3 	bl	c0ded820 <__aeabi_memcpy>
}
c0de5cba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		process_apdu_chunk(&buffer[3], length-3);
c0de5cbc:	1ee8      	subs	r0, r5, #3
c0de5cbe:	b281      	uxth	r1, r0
	    || ((uint16_t)U2BE(buffer, 0) != ledger_protocol->rx_apdu_sequence_number)
c0de5cc0:	2902      	cmp	r1, #2
c0de5cc2:	d30a      	bcc.n	c0de5cda <LEDGER_PROTOCOL_rx+0xae>
  return (buf[off] << 8) | buf[off + 1];
c0de5cc4:	7920      	ldrb	r0, [r4, #4]
c0de5cc6:	78e2      	ldrb	r2, [r4, #3]
c0de5cc8:	0212      	lsls	r2, r2, #8
c0de5cca:	1810      	adds	r0, r2, r0
c0de5ccc:	899a      	ldrh	r2, [r3, #12]
	if (   (length < 2)
c0de5cce:	4290      	cmp	r0, r2
c0de5cd0:	d103      	bne.n	c0de5cda <LEDGER_PROTOCOL_rx+0xae>
	    && (ledger_protocol->rx_apdu_sequence_number == 0)
c0de5cd2:	2903      	cmp	r1, #3
c0de5cd4:	d804      	bhi.n	c0de5ce0 <LEDGER_PROTOCOL_rx+0xb4>
c0de5cd6:	2800      	cmp	r0, #0
c0de5cd8:	d102      	bne.n	c0de5ce0 <LEDGER_PROTOCOL_rx+0xb4>
c0de5cda:	2000      	movs	r0, #0
c0de5cdc:	7298      	strb	r0, [r3, #10]
}
c0de5cde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (ledger_protocol->rx_apdu_sequence_number == 0) {
c0de5ce0:	2800      	cmp	r0, #0
c0de5ce2:	d005      	beq.n	c0de5cf0 <LEDGER_PROTOCOL_rx+0xc4>
	if ((ledger_protocol->rx_apdu_offset+length) > ledger_protocol->rx_apdu_length) {
c0de5ce4:	89d8      	ldrh	r0, [r3, #14]
c0de5ce6:	461e      	mov	r6, r3
c0de5ce8:	8a1b      	ldrh	r3, [r3, #16]
		length -= 2;
c0de5cea:	1f6d      	subs	r5, r5, #5
		buffer = &buffer[2];
c0de5cec:	1d61      	adds	r1, r4, #5
c0de5cee:	e010      	b.n	c0de5d12 <LEDGER_PROTOCOL_rx+0xe6>
c0de5cf0:	2001      	movs	r0, #1
		ledger_protocol->rx_apdu_status = APDU_STATUS_NEED_MORE_DATA;
c0de5cf2:	7298      	strb	r0, [r3, #10]
c0de5cf4:	79a0      	ldrb	r0, [r4, #6]
c0de5cf6:	7961      	ldrb	r1, [r4, #5]
c0de5cf8:	0209      	lsls	r1, r1, #8
c0de5cfa:	1808      	adds	r0, r1, r0
		ledger_protocol->rx_apdu_length = (uint16_t)U2BE(buffer, 2);
c0de5cfc:	81d8      	strh	r0, [r3, #14]
c0de5cfe:	b281      	uxth	r1, r0
		if (ledger_protocol->rx_apdu_length > ledger_protocol->rx_apdu_buffer_max_length) {
c0de5d00:	891a      	ldrh	r2, [r3, #8]
c0de5d02:	4291      	cmp	r1, r2
c0de5d04:	d8e9      	bhi.n	c0de5cda <LEDGER_PROTOCOL_rx+0xae>
c0de5d06:	4619      	mov	r1, r3
c0de5d08:	2300      	movs	r3, #0
c0de5d0a:	460e      	mov	r6, r1
		ledger_protocol->rx_apdu_offset = 0;
c0de5d0c:	820b      	strh	r3, [r1, #16]
		length -= 4;
c0de5d0e:	1fed      	subs	r5, r5, #7
		buffer = &buffer[4];
c0de5d10:	1de1      	adds	r1, r4, #7
	if ((ledger_protocol->rx_apdu_offset+length) > ledger_protocol->rx_apdu_length) {
c0de5d12:	b2aa      	uxth	r2, r5
c0de5d14:	18d2      	adds	r2, r2, r3
c0de5d16:	b284      	uxth	r4, r0
c0de5d18:	42a2      	cmp	r2, r4
c0de5d1a:	d900      	bls.n	c0de5d1e <LEDGER_PROTOCOL_rx+0xf2>
c0de5d1c:	1ac5      	subs	r5, r0, r3
	       buffer, length);
c0de5d1e:	b2aa      	uxth	r2, r5
	memcpy(&ledger_protocol->rx_apdu_buffer[ledger_protocol->rx_apdu_offset],
c0de5d20:	6870      	ldr	r0, [r6, #4]
c0de5d22:	18c0      	adds	r0, r0, r3
c0de5d24:	f007 fd7c 	bl	c0ded820 <__aeabi_memcpy>
c0de5d28:	4632      	mov	r2, r6
	ledger_protocol->rx_apdu_offset += length;
c0de5d2a:	8a30      	ldrh	r0, [r6, #16]
c0de5d2c:	1828      	adds	r0, r5, r0
c0de5d2e:	8230      	strh	r0, [r6, #16]
c0de5d30:	b280      	uxth	r0, r0
	if (ledger_protocol->rx_apdu_offset == ledger_protocol->rx_apdu_length) {
c0de5d32:	89f1      	ldrh	r1, [r6, #14]
c0de5d34:	4288      	cmp	r0, r1
c0de5d36:	d103      	bne.n	c0de5d40 <LEDGER_PROTOCOL_rx+0x114>
c0de5d38:	2002      	movs	r0, #2
		ledger_protocol->rx_apdu_status = APDU_STATUS_COMPLETE;
c0de5d3a:	7290      	strb	r0, [r2, #10]
c0de5d3c:	2000      	movs	r0, #0
c0de5d3e:	e003      	b.n	c0de5d48 <LEDGER_PROTOCOL_rx+0x11c>
c0de5d40:	2001      	movs	r0, #1
		ledger_protocol->rx_apdu_status = APDU_STATUS_NEED_MORE_DATA;
c0de5d42:	7290      	strb	r0, [r2, #10]
		ledger_protocol->rx_apdu_sequence_number++;
c0de5d44:	8990      	ldrh	r0, [r2, #12]
c0de5d46:	1c40      	adds	r0, r0, #1
c0de5d48:	8190      	strh	r0, [r2, #12]
}
c0de5d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de5d4c:	00000118 	.word	0x00000118

c0de5d50 <LEDGER_PROTOCOL_tx>:

void LEDGER_PROTOCOL_tx(uint8_t  *buffer,
                        uint16_t length)
{
c0de5d50:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de5d52:	b085      	sub	sp, #20
c0de5d54:	4a21      	ldr	r2, [pc, #132]	; (c0de5ddc <LEDGER_PROTOCOL_tx+0x8c>)
c0de5d56:	464b      	mov	r3, r9
c0de5d58:	589c      	ldr	r4, [r3, r2]
	if (!buffer && !ledger_protocol->tx_apdu_buffer) {
c0de5d5a:	2800      	cmp	r0, #0
c0de5d5c:	d005      	beq.n	c0de5d6a <LEDGER_PROTOCOL_tx+0x1a>
c0de5d5e:	2500      	movs	r5, #0
	if (buffer) {
		PRINTF("FIRST CHUNK");
		ledger_protocol->tx_apdu_buffer          = buffer;
		ledger_protocol->tx_apdu_length          = length;
		ledger_protocol->tx_apdu_sequence_number = 0;
		ledger_protocol->tx_apdu_offset          = 0;
c0de5d60:	8125      	strh	r5, [r4, #8]
		ledger_protocol->tx_apdu_sequence_number = 0;
c0de5d62:	80e5      	strh	r5, [r4, #6]
		ledger_protocol->tx_apdu_length          = length;
c0de5d64:	80a1      	strh	r1, [r4, #4]
		ledger_protocol->tx_apdu_buffer          = buffer;
c0de5d66:	6020      	str	r0, [r4, #0]
c0de5d68:	e003      	b.n	c0de5d72 <LEDGER_PROTOCOL_tx+0x22>
	if (!buffer && !ledger_protocol->tx_apdu_buffer) {
c0de5d6a:	6820      	ldr	r0, [r4, #0]
c0de5d6c:	2800      	cmp	r0, #0
c0de5d6e:	d033      	beq.n	c0de5dd8 <LEDGER_PROTOCOL_tx+0x88>

	ledger_protocol->chunk[chunk_offset++] = TAG_APDU;

	U2BE_ENCODE(ledger_protocol->chunk,
	            chunk_offset,
	            ledger_protocol->tx_apdu_sequence_number);
c0de5d70:	88e5      	ldrh	r5, [r4, #6]
c0de5d72:	4622      	mov	r2, r4
c0de5d74:	32a8      	adds	r2, #168	; 0xa8
}

static inline void U2BE_ENCODE(uint8_t *buf, size_t off, uint32_t value) {
  buf[off + 0] = (value >> 8) & 0xFF;
  buf[off + 1] = value & 0xFF;
c0de5d76:	73a5      	strb	r5, [r4, #14]
c0de5d78:	2705      	movs	r7, #5
	ledger_protocol->chunk[chunk_offset++] = TAG_APDU;
c0de5d7a:	7327      	strb	r7, [r4, #12]
  buf[off + 0] = (value >> 8) & 0xFF;
c0de5d7c:	0a29      	lsrs	r1, r5, #8
c0de5d7e:	7361      	strb	r1, [r4, #13]
c0de5d80:	88a3      	ldrh	r3, [r4, #4]
c0de5d82:	9501      	str	r5, [sp, #4]
	chunk_offset += 2;

	if (ledger_protocol->tx_apdu_sequence_number == 0) {
c0de5d84:	2d00      	cmp	r5, #0
c0de5d86:	d103      	bne.n	c0de5d90 <LEDGER_PROTOCOL_tx+0x40>
  buf[off + 1] = value & 0xFF;
c0de5d88:	7423      	strb	r3, [r4, #16]
  buf[off + 0] = (value >> 8) & 0xFF;
c0de5d8a:	0a19      	lsrs	r1, r3, #8
c0de5d8c:	73e1      	strb	r1, [r4, #15]
c0de5d8e:	2707      	movs	r7, #7
c0de5d90:	9303      	str	r3, [sp, #12]
		U2BE_ENCODE(ledger_protocol->chunk,
		            chunk_offset,
		             ledger_protocol->tx_apdu_length);
		chunk_offset += 2;
	}
	if ((ledger_protocol->tx_apdu_length+chunk_offset) >= (ledger_protocol->mtu+ledger_protocol->tx_apdu_offset)) {
c0de5d92:	18fe      	adds	r6, r7, r3
c0de5d94:	8925      	ldrh	r5, [r4, #8]
c0de5d96:	1941      	adds	r1, r0, r5
c0de5d98:	9204      	str	r2, [sp, #16]
c0de5d9a:	8a52      	ldrh	r2, [r2, #18]
c0de5d9c:	18ab      	adds	r3, r5, r2
c0de5d9e:	19e0      	adds	r0, r4, r7
c0de5da0:	300a      	adds	r0, #10
c0de5da2:	9602      	str	r6, [sp, #8]
c0de5da4:	429e      	cmp	r6, r3
c0de5da6:	d20a      	bcs.n	c0de5dbe <LEDGER_PROTOCOL_tx+0x6e>
c0de5da8:	9e03      	ldr	r6, [sp, #12]
	}
	else {
		// Remaining buffer fits the chunk TODO pad for usb
		memcpy(&ledger_protocol->chunk[chunk_offset],
		       &ledger_protocol->tx_apdu_buffer[ledger_protocol->tx_apdu_offset],
		       ledger_protocol->tx_apdu_length-ledger_protocol->tx_apdu_offset);
c0de5daa:	1b72      	subs	r2, r6, r5
		memcpy(&ledger_protocol->chunk[chunk_offset],
c0de5dac:	f007 fd38 	bl	c0ded820 <__aeabi_memcpy>
		chunk_offset += (ledger_protocol->tx_apdu_length-ledger_protocol->tx_apdu_offset);
		ledger_protocol->tx_apdu_offset = ledger_protocol->tx_apdu_length;
c0de5db0:	8126      	strh	r6, [r4, #8]
c0de5db2:	2000      	movs	r0, #0
		ledger_protocol->tx_apdu_buffer = NULL;
c0de5db4:	6020      	str	r0, [r4, #0]
		chunk_offset += (ledger_protocol->tx_apdu_length-ledger_protocol->tx_apdu_offset);
c0de5db6:	9802      	ldr	r0, [sp, #8]
c0de5db8:	1b40      	subs	r0, r0, r5
c0de5dba:	9904      	ldr	r1, [sp, #16]
c0de5dbc:	e00b      	b.n	c0de5dd6 <LEDGER_PROTOCOL_tx+0x86>
		       ledger_protocol->mtu-chunk_offset);
c0de5dbe:	1bd2      	subs	r2, r2, r7
		memcpy(&ledger_protocol->chunk[chunk_offset],
c0de5dc0:	f007 fd2e 	bl	c0ded820 <__aeabi_memcpy>
		ledger_protocol->tx_apdu_sequence_number++;
c0de5dc4:	9801      	ldr	r0, [sp, #4]
c0de5dc6:	1c40      	adds	r0, r0, #1
c0de5dc8:	80e0      	strh	r0, [r4, #6]
c0de5dca:	9a04      	ldr	r2, [sp, #16]
		ledger_protocol->tx_apdu_offset += ledger_protocol->mtu-chunk_offset;
c0de5dcc:	8a50      	ldrh	r0, [r2, #18]
c0de5dce:	1bc1      	subs	r1, r0, r7
c0de5dd0:	1949      	adds	r1, r1, r5
c0de5dd2:	8121      	strh	r1, [r4, #8]
c0de5dd4:	4611      	mov	r1, r2
	}
	ledger_protocol->chunk_length = chunk_offset;
c0de5dd6:	7008      	strb	r0, [r1, #0]
	PRINTF(" %d\n", ledger_protocol->chunk_length);
c0de5dd8:	b005      	add	sp, #20
c0de5dda:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de5ddc:	00000118 	.word	0x00000118

c0de5de0 <set_result_get_eth2_publicKey>:
#ifdef HAVE_ETH2

#include <string.h>
#include "shared_context.h"

uint32_t set_result_get_eth2_publicKey() {
c0de5de0:	b510      	push	{r4, lr}
    uint32_t tx = 0;
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 48);
c0de5de2:	4806      	ldr	r0, [pc, #24]	; (c0de5dfc <set_result_get_eth2_publicKey+0x1c>)
c0de5de4:	4649      	mov	r1, r9
c0de5de6:	1808      	adds	r0, r1, r0
c0de5de8:	4a05      	ldr	r2, [pc, #20]	; (c0de5e00 <set_result_get_eth2_publicKey+0x20>)
c0de5dea:	1889      	adds	r1, r1, r2
c0de5dec:	3108      	adds	r1, #8
c0de5dee:	2430      	movs	r4, #48	; 0x30
c0de5df0:	4622      	mov	r2, r4
c0de5df2:	f007 fd15 	bl	c0ded820 <__aeabi_memcpy>
    tx += 48;
    return tx;
c0de5df6:	4620      	mov	r0, r4
c0de5df8:	bd10      	pop	{r4, pc}
c0de5dfa:	46c0      	nop			; (mov r8, r8)
c0de5dfc:	00000990 	.word	0x00000990
c0de5e00:	00000124 	.word	0x00000124

c0de5e04 <set_result_get_publicKey>:
#include <string.h>
#include "shared_context.h"

uint32_t set_result_get_publicKey() {
c0de5e04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t tx = 0;
    G_io_apdu_buffer[tx++] = 65;
c0de5e06:	4d12      	ldr	r5, [pc, #72]	; (c0de5e50 <set_result_get_publicKey+0x4c>)
c0de5e08:	4649      	mov	r1, r9
c0de5e0a:	2241      	movs	r2, #65	; 0x41
c0de5e0c:	554a      	strb	r2, [r1, r5]
c0de5e0e:	194c      	adds	r4, r1, r5
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0de5e10:	1c60      	adds	r0, r4, #1
c0de5e12:	4e10      	ldr	r6, [pc, #64]	; (c0de5e54 <set_result_get_publicKey+0x50>)
c0de5e14:	198f      	adds	r7, r1, r6
c0de5e16:	4639      	mov	r1, r7
c0de5e18:	3108      	adds	r1, #8
c0de5e1a:	f007 fd01 	bl	c0ded820 <__aeabi_memcpy>
c0de5e1e:	2042      	movs	r0, #66	; 0x42
c0de5e20:	2228      	movs	r2, #40	; 0x28
    tx += 65;
    G_io_apdu_buffer[tx++] = 40;
c0de5e22:	5422      	strb	r2, [r4, r0]
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.address, 40);
c0de5e24:	3443      	adds	r4, #67	; 0x43
c0de5e26:	4639      	mov	r1, r7
c0de5e28:	314c      	adds	r1, #76	; 0x4c
c0de5e2a:	4620      	mov	r0, r4
c0de5e2c:	f007 fcf8 	bl	c0ded820 <__aeabi_memcpy>
c0de5e30:	2095      	movs	r0, #149	; 0x95
    tx += 40;
    if (tmpCtx.publicKeyContext.getChaincode) {
c0de5e32:	5c38      	ldrb	r0, [r7, r0]
c0de5e34:	2800      	cmp	r0, #0
c0de5e36:	d009      	beq.n	c0de5e4c <set_result_get_publicKey+0x48>
        memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.chainCode, 32);
c0de5e38:	4649      	mov	r1, r9
c0de5e3a:	1948      	adds	r0, r1, r5
c0de5e3c:	306b      	adds	r0, #107	; 0x6b
c0de5e3e:	1989      	adds	r1, r1, r6
c0de5e40:	3175      	adds	r1, #117	; 0x75
c0de5e42:	2220      	movs	r2, #32
c0de5e44:	f007 fcec 	bl	c0ded820 <__aeabi_memcpy>
c0de5e48:	208b      	movs	r0, #139	; 0x8b
        tx += 32;
    }
    return tx;
c0de5e4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de5e4c:	206b      	movs	r0, #107	; 0x6b
c0de5e4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de5e50:	00000990 	.word	0x00000990
c0de5e54:	00000124 	.word	0x00000124

c0de5e58 <set_result_perform_privacy_operation>:
#include "shared_context.h"

uint32_t set_result_perform_privacy_operation() {
c0de5e58:	4807      	ldr	r0, [pc, #28]	; (c0de5e78 <set_result_perform_privacy_operation+0x20>)
c0de5e5a:	4649      	mov	r1, r9
c0de5e5c:	1808      	adds	r0, r1, r0
c0de5e5e:	2128      	movs	r1, #40	; 0x28
c0de5e60:	4a06      	ldr	r2, [pc, #24]	; (c0de5e7c <set_result_perform_privacy_operation+0x24>)
    for (uint8_t i = 0; i < 32; i++) {
c0de5e62:	2908      	cmp	r1, #8
c0de5e64:	d006      	beq.n	c0de5e74 <set_result_perform_privacy_operation+0x1c>
        G_io_apdu_buffer[i] = tmpCtx.publicKeyContext.publicKey.W[32 - i];
c0de5e66:	464b      	mov	r3, r9
c0de5e68:	189b      	adds	r3, r3, r2
c0de5e6a:	5c5b      	ldrb	r3, [r3, r1]
c0de5e6c:	7003      	strb	r3, [r0, #0]
    for (uint8_t i = 0; i < 32; i++) {
c0de5e6e:	1c40      	adds	r0, r0, #1
c0de5e70:	1e49      	subs	r1, r1, #1
c0de5e72:	e7f6      	b.n	c0de5e62 <set_result_perform_privacy_operation+0xa>
c0de5e74:	2020      	movs	r0, #32
    }
    return 32;
c0de5e76:	4770      	bx	lr
c0de5e78:	00000990 	.word	0x00000990
c0de5e7c:	00000124 	.word	0x00000124

c0de5e80 <splitBinaryParameterPart>:
#include "network.h"
#include "ethUtils.h"

#define ERR_SILENT_MODE_CHECK_FAILED 0x6001

uint32_t splitBinaryParameterPart(char *result, uint8_t *parameter) {
c0de5e80:	b510      	push	{r4, lr}
c0de5e82:	2200      	movs	r2, #0
c0de5e84:	2410      	movs	r4, #16
    uint32_t i;
    for (i = 0; i < 8; i++) {
c0de5e86:	2c00      	cmp	r4, #0
c0de5e88:	d005      	beq.n	c0de5e96 <splitBinaryParameterPart+0x16>
        if (parameter[i] != 0x00) {
c0de5e8a:	5c8b      	ldrb	r3, [r1, r2]
c0de5e8c:	2b00      	cmp	r3, #0
c0de5e8e:	d109      	bne.n	c0de5ea4 <splitBinaryParameterPart+0x24>
    for (i = 0; i < 8; i++) {
c0de5e90:	1ea4      	subs	r4, r4, #2
c0de5e92:	1c52      	adds	r2, r2, #1
c0de5e94:	e7f7      	b.n	c0de5e86 <splitBinaryParameterPart+0x6>
c0de5e96:	2100      	movs	r1, #0
        }
    }
    if (i == 8) {
        result[0] = '0';
        result[1] = '0';
        result[2] = '\0';
c0de5e98:	7081      	strb	r1, [r0, #2]
c0de5e9a:	2130      	movs	r1, #48	; 0x30
        result[1] = '0';
c0de5e9c:	7041      	strb	r1, [r0, #1]
        result[0] = '0';
c0de5e9e:	7001      	strb	r1, [r0, #0]
c0de5ea0:	2402      	movs	r4, #2
c0de5ea2:	e004      	b.n	c0de5eae <splitBinaryParameterPart+0x2e>
        return 2;
    } else {
        array_hexstr(result, parameter + i, 8 - i);
c0de5ea4:	1889      	adds	r1, r1, r2
c0de5ea6:	2308      	movs	r3, #8
c0de5ea8:	1a9a      	subs	r2, r3, r2
c0de5eaa:	f006 fab5 	bl	c0dec418 <array_hexstr>
        return ((8 - i) * 2);
    }
}
c0de5eae:	4620      	mov	r0, r4
c0de5eb0:	bd10      	pop	{r4, pc}
c0de5eb2:	d4d4      	bmi.n	c0de5e5e <set_result_perform_privacy_operation+0x6>

c0de5eb4 <customProcessor>:

customStatus_e customProcessor(txContext_t *context) {
c0de5eb4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de5eb6:	b08b      	sub	sp, #44	; 0x2c
c0de5eb8:	4604      	mov	r4, r0
c0de5eba:	203c      	movs	r0, #60	; 0x3c
    if (((context->txType == LEGACY && context->currentField == LEGACY_RLP_DATA) ||
c0de5ebc:	5c20      	ldrb	r0, [r4, r0]
c0de5ebe:	2600      	movs	r6, #0
c0de5ec0:	2801      	cmp	r0, #1
c0de5ec2:	d007      	beq.n	c0de5ed4 <customProcessor+0x20>
c0de5ec4:	2802      	cmp	r0, #2
c0de5ec6:	d009      	beq.n	c0de5edc <customProcessor+0x28>
c0de5ec8:	28c0      	cmp	r0, #192	; 0xc0
c0de5eca:	d17f      	bne.n	c0de5fcc <customProcessor+0x118>
c0de5ecc:	7820      	ldrb	r0, [r4, #0]
c0de5ece:	2808      	cmp	r0, #8
c0de5ed0:	d007      	beq.n	c0de5ee2 <customProcessor+0x2e>
c0de5ed2:	e07b      	b.n	c0de5fcc <customProcessor+0x118>
         (context->txType == EIP2930 && context->currentField == EIP2930_RLP_DATA) ||
c0de5ed4:	7820      	ldrb	r0, [r4, #0]
c0de5ed6:	2809      	cmp	r0, #9
c0de5ed8:	d003      	beq.n	c0de5ee2 <customProcessor+0x2e>
c0de5eda:	e077      	b.n	c0de5fcc <customProcessor+0x118>
         (context->txType == EIP1559 && context->currentField == EIP1559_RLP_DATA)) &&
c0de5edc:	7820      	ldrb	r0, [r4, #0]
c0de5ede:	280a      	cmp	r0, #10
c0de5ee0:	d174      	bne.n	c0de5fcc <customProcessor+0x118>
        (context->currentFieldLength != 0)) {
c0de5ee2:	68a0      	ldr	r0, [r4, #8]
    if (((context->txType == LEGACY && context->currentField == LEGACY_RLP_DATA) ||
c0de5ee4:	2800      	cmp	r0, #0
c0de5ee6:	d071      	beq.n	c0de5fcc <customProcessor+0x118>
        context->content->dataPresent = true;
c0de5ee8:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0de5eea:	22c3      	movs	r2, #195	; 0xc3
c0de5eec:	2301      	movs	r3, #1
c0de5eee:	548b      	strb	r3, [r1, r2]
        // If handling a new contract rather than a function call, abort immediately
        if (tmpContent.txContent.destinationLength == 0) {
c0de5ef0:	2804      	cmp	r0, #4
c0de5ef2:	d36b      	bcc.n	c0de5fcc <customProcessor+0x118>
c0de5ef4:	4986      	ldr	r1, [pc, #536]	; (c0de6110 <customProcessor+0x25c>)
c0de5ef6:	4648      	mov	r0, r9
c0de5ef8:	1840      	adds	r0, r0, r1
c0de5efa:	21b9      	movs	r1, #185	; 0xb9
c0de5efc:	5c40      	ldrb	r0, [r0, r1]
c0de5efe:	2800      	cmp	r0, #0
c0de5f00:	d064      	beq.n	c0de5fcc <customProcessor+0x118>
        }
        // If data field is less than 4 bytes long, do not try to use a plugin.
        if (context->currentFieldLength < 4) {
            return CUSTOM_NOT_HANDLED;
        }
        if (context->currentFieldPos == 0) {
c0de5f02:	68e7      	ldr	r7, [r4, #12]
c0de5f04:	2f00      	cmp	r7, #0
c0de5f06:	d065      	beq.n	c0de5fd4 <customProcessor+0x120>
c0de5f08:	9302      	str	r3, [sp, #8]
c0de5f0a:	4884      	ldr	r0, [pc, #528]	; (c0de611c <customProcessor+0x268>)
c0de5f0c:	4478      	add	r0, pc
c0de5f0e:	f002 f999 	bl	c0de8244 <pic>
            dataContext.tokenContext.fieldIndex = 0;
            dataContext.tokenContext.fieldOffset = 0;
            blockSize = 4;
        } else {
            if (!N_storage.contractDetails &&
                dataContext.tokenContext.pluginStatus <= ETH_PLUGIN_RESULT_UNSUCCESSFUL) {
c0de5f12:	4980      	ldr	r1, [pc, #512]	; (c0de6114 <customProcessor+0x260>)
            if (!N_storage.contractDetails &&
c0de5f14:	7840      	ldrb	r0, [r0, #1]
c0de5f16:	2800      	cmp	r0, #0
c0de5f18:	d105      	bne.n	c0de5f26 <customProcessor+0x72>
c0de5f1a:	4648      	mov	r0, r9
c0de5f1c:	1840      	adds	r0, r0, r1
c0de5f1e:	7f80      	ldrb	r0, [r0, #30]
c0de5f20:	2803      	cmp	r0, #3
c0de5f22:	4635      	mov	r5, r6
c0de5f24:	d353      	bcc.n	c0de5fce <customProcessor+0x11a>
                return CUSTOM_NOT_HANDLED;
            }
            blockSize = 32 - (dataContext.tokenContext.fieldOffset % 32);
c0de5f26:	4648      	mov	r0, r9
c0de5f28:	1840      	adds	r0, r0, r1
c0de5f2a:	2140      	movs	r1, #64	; 0x40
c0de5f2c:	5c40      	ldrb	r0, [r0, r1]
c0de5f2e:	211f      	movs	r1, #31
c0de5f30:	4001      	ands	r1, r0
c0de5f32:	2220      	movs	r2, #32
c0de5f34:	1a51      	subs	r1, r2, r1
c0de5f36:	2200      	movs	r2, #0
c0de5f38:	9201      	str	r2, [sp, #4]
        }

        // If the last parameter is of type `bytes` then we might have an
        // edge case where the data is not a multiple of 32. Set `blockSize` accordingly
        if ((context->currentFieldLength - fieldPos) < blockSize) {
c0de5f3a:	68a2      	ldr	r2, [r4, #8]
c0de5f3c:	1bd5      	subs	r5, r2, r7
c0de5f3e:	428d      	cmp	r5, r1
c0de5f40:	d300      	bcc.n	c0de5f44 <customProcessor+0x90>
c0de5f42:	460d      	mov	r5, r1
            blockSize = context->currentFieldLength - fieldPos;
        }

        copySize = (context->commandLength < blockSize ? context->commandLength : blockSize);
c0de5f44:	6aa6      	ldr	r6, [r4, #40]	; 0x28
c0de5f46:	42ae      	cmp	r6, r5
c0de5f48:	4637      	mov	r7, r6
c0de5f4a:	d300      	bcc.n	c0de5f4e <customProcessor+0x9a>
c0de5f4c:	462f      	mov	r7, r5

        PRINTF("currentFieldPos %d copySize %d\n", context->currentFieldPos, copySize);

        copyTxData(context,
                   dataContext.tokenContext.data + dataContext.tokenContext.fieldOffset,
c0de5f4e:	4a71      	ldr	r2, [pc, #452]	; (c0de6114 <customProcessor+0x260>)
c0de5f50:	4649      	mov	r1, r9
c0de5f52:	1889      	adds	r1, r1, r2
c0de5f54:	1809      	adds	r1, r1, r0
c0de5f56:	311f      	adds	r1, #31
        copyTxData(context,
c0de5f58:	4620      	mov	r0, r4
c0de5f5a:	463a      	mov	r2, r7
c0de5f5c:	f7fd ffbc 	bl	c0de3ed8 <copyTxData>
                   copySize);

        if (context->currentFieldPos == context->currentFieldLength) {
c0de5f60:	68a0      	ldr	r0, [r4, #8]
c0de5f62:	68e1      	ldr	r1, [r4, #12]
c0de5f64:	4281      	cmp	r1, r0
c0de5f66:	d104      	bne.n	c0de5f72 <customProcessor+0xbe>
c0de5f68:	2000      	movs	r0, #0
            PRINTF("\n\nIncrementing one\n");
            context->currentField++;
            context->processingField = false;
c0de5f6a:	7460      	strb	r0, [r4, #17]
            context->currentField++;
c0de5f6c:	7820      	ldrb	r0, [r4, #0]
c0de5f6e:	1c40      	adds	r0, r0, #1
c0de5f70:	7020      	strb	r0, [r4, #0]
        }

        dataContext.tokenContext.fieldOffset += copySize;
c0de5f72:	4648      	mov	r0, r9
c0de5f74:	4a67      	ldr	r2, [pc, #412]	; (c0de6114 <customProcessor+0x260>)
c0de5f76:	1880      	adds	r0, r0, r2
c0de5f78:	2340      	movs	r3, #64	; 0x40
c0de5f7a:	5cc1      	ldrb	r1, [r0, r3]
c0de5f7c:	19c9      	adds	r1, r1, r7
c0de5f7e:	54c1      	strb	r1, [r0, r3]

        if (copySize == blockSize) {
c0de5f80:	42ae      	cmp	r6, r5
c0de5f82:	9d02      	ldr	r5, [sp, #8]
c0de5f84:	d323      	bcc.n	c0de5fce <customProcessor+0x11a>
            // Can process or display
            if (dataContext.tokenContext.pluginStatus >= ETH_PLUGIN_RESULT_SUCCESSFUL) {
c0de5f86:	4648      	mov	r0, r9
c0de5f88:	1880      	adds	r0, r0, r2
c0de5f8a:	7f80      	ldrb	r0, [r0, #30]
c0de5f8c:	2803      	cmp	r0, #3
c0de5f8e:	4617      	mov	r7, r2
c0de5f90:	d336      	bcc.n	c0de6000 <customProcessor+0x14c>
c0de5f92:	461e      	mov	r6, r3
                ethPluginProvideParameter_t pluginProvideParameter;
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
                                                     dataContext.tokenContext.data,
                                                     dataContext.tokenContext.fieldIndex * 32 + 4);
c0de5f94:	4648      	mov	r0, r9
c0de5f96:	19c1      	adds	r1, r0, r7
c0de5f98:	253f      	movs	r5, #63	; 0x3f
c0de5f9a:	5d48      	ldrb	r0, [r1, r5]
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
c0de5f9c:	311f      	adds	r1, #31
                                                     dataContext.tokenContext.fieldIndex * 32 + 4);
c0de5f9e:	0140      	lsls	r0, r0, #5
c0de5fa0:	1d02      	adds	r2, r0, #4
c0de5fa2:	ac03      	add	r4, sp, #12
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
c0de5fa4:	4620      	mov	r0, r4
c0de5fa6:	f7fe fcd8 	bl	c0de495a <eth_plugin_prepare_provide_parameter>
c0de5faa:	2081      	movs	r0, #129	; 0x81
c0de5fac:	0040      	lsls	r0, r0, #1
                if (!eth_plugin_call(ETH_PLUGIN_PROVIDE_PARAMETER,
c0de5fae:	4621      	mov	r1, r4
c0de5fb0:	f7fe fdea 	bl	c0de4b88 <eth_plugin_call>
c0de5fb4:	2800      	cmp	r0, #0
c0de5fb6:	d100      	bne.n	c0de5fba <customProcessor+0x106>
c0de5fb8:	e0a8      	b.n	c0de610c <customProcessor+0x258>
                                     (void *) &pluginProvideParameter)) {
                    PRINTF("Plugin parameter call failed\n");
                    return CUSTOM_FAULT;
                }
                dataContext.tokenContext.fieldIndex++;
c0de5fba:	4648      	mov	r0, r9
c0de5fbc:	19c0      	adds	r0, r0, r7
c0de5fbe:	2100      	movs	r1, #0
                dataContext.tokenContext.fieldOffset = 0;
c0de5fc0:	5581      	strb	r1, [r0, r6]
                dataContext.tokenContext.fieldIndex++;
c0de5fc2:	5d41      	ldrb	r1, [r0, r5]
c0de5fc4:	1c49      	adds	r1, r1, #1
c0de5fc6:	5541      	strb	r1, [r0, r5]
c0de5fc8:	2501      	movs	r5, #1
c0de5fca:	e000      	b.n	c0de5fce <customProcessor+0x11a>
c0de5fcc:	4635      	mov	r5, r6
        }

        return CUSTOM_SUSPENDED;
    }
    return CUSTOM_NOT_HANDLED;
}
c0de5fce:	4628      	mov	r0, r5
c0de5fd0:	b00b      	add	sp, #44	; 0x2c
c0de5fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (context->commandLength < 4) {
c0de5fd4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0de5fd6:	2503      	movs	r5, #3
c0de5fd8:	2804      	cmp	r0, #4
c0de5fda:	d3f8      	bcc.n	c0de5fce <customProcessor+0x11a>
c0de5fdc:	9302      	str	r3, [sp, #8]
            dataContext.tokenContext.pluginStatus = ETH_PLUGIN_RESULT_UNAVAILABLE;
c0de5fde:	4f4d      	ldr	r7, [pc, #308]	; (c0de6114 <customProcessor+0x260>)
c0de5fe0:	4648      	mov	r0, r9
c0de5fe2:	19c0      	adds	r0, r0, r7
c0de5fe4:	2101      	movs	r1, #1
c0de5fe6:	9101      	str	r1, [sp, #4]
c0de5fe8:	7781      	strb	r1, [r0, #30]
            if (!N_storage.contractDetails) {
c0de5fea:	484d      	ldr	r0, [pc, #308]	; (c0de6120 <customProcessor+0x26c>)
c0de5fec:	4478      	add	r0, pc
c0de5fee:	f002 f929 	bl	c0de8244 <pic>
c0de5ff2:	7840      	ldrb	r0, [r0, #1]
c0de5ff4:	2800      	cmp	r0, #0
c0de5ff6:	d015      	beq.n	c0de6024 <customProcessor+0x170>
            eth_plugin_result_t status = dataContext.tokenContext.pluginStatus;
c0de5ff8:	4648      	mov	r0, r9
c0de5ffa:	19c0      	adds	r0, r0, r7
c0de5ffc:	7f80      	ldrb	r0, [r0, #30]
c0de5ffe:	e022      	b.n	c0de6046 <customProcessor+0x192>
            if (fieldPos != 0) {
c0de6000:	9801      	ldr	r0, [sp, #4]
c0de6002:	2800      	cmp	r0, #0
c0de6004:	d050      	beq.n	c0de60a8 <customProcessor+0x1f4>
            dataContext.tokenContext.fieldOffset = 0;
c0de6006:	4648      	mov	r0, r9
c0de6008:	19c1      	adds	r1, r0, r7
c0de600a:	2400      	movs	r4, #0
c0de600c:	54cc      	strb	r4, [r1, r3]
                array_hexstr(strings.tmp.tmp, dataContext.tokenContext.data, 4);
c0de600e:	4a42      	ldr	r2, [pc, #264]	; (c0de6118 <customProcessor+0x264>)
c0de6010:	1880      	adds	r0, r0, r2
c0de6012:	311f      	adds	r1, #31
c0de6014:	2204      	movs	r2, #4
c0de6016:	f006 f9ff 	bl	c0dec418 <array_hexstr>
                ux_flow_init(0, ux_confirm_selector_flow, NULL);
c0de601a:	4944      	ldr	r1, [pc, #272]	; (c0de612c <customProcessor+0x278>)
c0de601c:	4479      	add	r1, pc
c0de601e:	4620      	mov	r0, r4
c0de6020:	4622      	mov	r2, r4
c0de6022:	e06d      	b.n	c0de6100 <customProcessor+0x24c>
                                        context->currentFieldLength);
c0de6024:	68a2      	ldr	r2, [r4, #8]
                                        context->workBuffer,
c0de6026:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0de6028:	a803      	add	r0, sp, #12
                eth_plugin_prepare_init(&pluginInit,
c0de602a:	9000      	str	r0, [sp, #0]
c0de602c:	f7fe fc8b 	bl	c0de4946 <eth_plugin_prepare_init>
                    eth_plugin_perform_init(tmpContent.txContent.destination, &pluginInit);
c0de6030:	464f      	mov	r7, r9
c0de6032:	4837      	ldr	r0, [pc, #220]	; (c0de6110 <customProcessor+0x25c>)
c0de6034:	1838      	adds	r0, r7, r0
c0de6036:	30a5      	adds	r0, #165	; 0xa5
c0de6038:	9900      	ldr	r1, [sp, #0]
c0de603a:	f7fe fcf9 	bl	c0de4a30 <eth_plugin_perform_init>
                dataContext.tokenContext.pluginStatus =
c0de603e:	4935      	ldr	r1, [pc, #212]	; (c0de6114 <customProcessor+0x260>)
c0de6040:	1879      	adds	r1, r7, r1
c0de6042:	4f34      	ldr	r7, [pc, #208]	; (c0de6114 <customProcessor+0x260>)
c0de6044:	7788      	strb	r0, [r1, #30]
            if (status == ETH_PLUGIN_RESULT_ERROR) {
c0de6046:	2800      	cmp	r0, #0
c0de6048:	d0c1      	beq.n	c0de5fce <customProcessor+0x11a>
            } else if (status >= ETH_PLUGIN_RESULT_SUCCESSFUL) {
c0de604a:	2803      	cmp	r0, #3
c0de604c:	d30e      	bcc.n	c0de606c <customProcessor+0x1b8>
                dataContext.tokenContext.fieldIndex = 0;
c0de604e:	4648      	mov	r0, r9
c0de6050:	19c0      	adds	r0, r0, r7
c0de6052:	2140      	movs	r1, #64	; 0x40
c0de6054:	2500      	movs	r5, #0
                dataContext.tokenContext.fieldOffset = 0;
c0de6056:	5445      	strb	r5, [r0, r1]
c0de6058:	213f      	movs	r1, #63	; 0x3f
                dataContext.tokenContext.fieldIndex = 0;
c0de605a:	5445      	strb	r5, [r0, r1]
c0de605c:	2204      	movs	r2, #4
                copyTxData(context, NULL, 4);
c0de605e:	4620      	mov	r0, r4
c0de6060:	4629      	mov	r1, r5
c0de6062:	f7fd ff39 	bl	c0de3ed8 <copyTxData>
                if (context->currentFieldLength == 4) {
c0de6066:	68a0      	ldr	r0, [r4, #8]
c0de6068:	2804      	cmp	r0, #4
c0de606a:	d0b0      	beq.n	c0de5fce <customProcessor+0x11a>
        uint32_t fieldPos = context->currentFieldPos;
c0de606c:	68e7      	ldr	r7, [r4, #12]
c0de606e:	482d      	ldr	r0, [pc, #180]	; (c0de6124 <customProcessor+0x270>)
c0de6070:	4478      	add	r0, pc
c0de6072:	f002 f8e7 	bl	c0de8244 <pic>
        if (fieldPos == 0) {  // not reached if a plugin is available
c0de6076:	2f00      	cmp	r7, #0
c0de6078:	d000      	beq.n	c0de607c <customProcessor+0x1c8>
c0de607a:	e74a      	b.n	c0de5f12 <customProcessor+0x5e>
            if (!N_storage.dataAllowed) {
c0de607c:	7800      	ldrb	r0, [r0, #0]
c0de607e:	2800      	cmp	r0, #0
c0de6080:	d042      	beq.n	c0de6108 <customProcessor+0x254>
            if (!N_storage.contractDetails) {
c0de6082:	4829      	ldr	r0, [pc, #164]	; (c0de6128 <customProcessor+0x274>)
c0de6084:	4478      	add	r0, pc
c0de6086:	f002 f8dd 	bl	c0de8244 <pic>
c0de608a:	7840      	ldrb	r0, [r0, #1]
c0de608c:	2800      	cmp	r0, #0
c0de608e:	4635      	mov	r5, r6
c0de6090:	d09d      	beq.n	c0de5fce <customProcessor+0x11a>
            dataContext.tokenContext.fieldIndex = 0;
c0de6092:	4648      	mov	r0, r9
c0de6094:	491f      	ldr	r1, [pc, #124]	; (c0de6114 <customProcessor+0x260>)
c0de6096:	1841      	adds	r1, r0, r1
c0de6098:	2240      	movs	r2, #64	; 0x40
c0de609a:	2000      	movs	r0, #0
            dataContext.tokenContext.fieldOffset = 0;
c0de609c:	5488      	strb	r0, [r1, r2]
c0de609e:	223f      	movs	r2, #63	; 0x3f
            dataContext.tokenContext.fieldIndex = 0;
c0de60a0:	5488      	strb	r0, [r1, r2]
c0de60a2:	2104      	movs	r1, #4
c0de60a4:	4607      	mov	r7, r0
c0de60a6:	e748      	b.n	c0de5f3a <customProcessor+0x86>
                dataContext.tokenContext.fieldIndex++;
c0de60a8:	4648      	mov	r0, r9
c0de60aa:	19c1      	adds	r1, r0, r7
c0de60ac:	2400      	movs	r4, #0
            dataContext.tokenContext.fieldOffset = 0;
c0de60ae:	54cc      	strb	r4, [r1, r3]
c0de60b0:	223f      	movs	r2, #63	; 0x3f
                dataContext.tokenContext.fieldIndex++;
c0de60b2:	5c8b      	ldrb	r3, [r1, r2]
c0de60b4:	1c5b      	adds	r3, r3, #1
c0de60b6:	548b      	strb	r3, [r1, r2]
                snprintf(strings.tmp.tmp2,
c0de60b8:	4d17      	ldr	r5, [pc, #92]	; (c0de6118 <customProcessor+0x264>)
c0de60ba:	1940      	adds	r0, r0, r5
c0de60bc:	2101      	movs	r1, #1
c0de60be:	0209      	lsls	r1, r1, #8
c0de60c0:	1840      	adds	r0, r0, r1
                         dataContext.tokenContext.fieldIndex);
c0de60c2:	b2db      	uxtb	r3, r3
c0de60c4:	2128      	movs	r1, #40	; 0x28
                snprintf(strings.tmp.tmp2,
c0de60c6:	4a1a      	ldr	r2, [pc, #104]	; (c0de6130 <customProcessor+0x27c>)
c0de60c8:	447a      	add	r2, pc
c0de60ca:	f001 fedf 	bl	c0de7e8c <snprintf>
c0de60ce:	4626      	mov	r6, r4
                for (i = 0; i < 4; i++) {
c0de60d0:	2c20      	cmp	r4, #32
c0de60d2:	d011      	beq.n	c0de60f8 <customProcessor+0x244>
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0de60d4:	4649      	mov	r1, r9
c0de60d6:	1948      	adds	r0, r1, r5
c0de60d8:	1980      	adds	r0, r0, r6
c0de60da:	19c9      	adds	r1, r1, r7
c0de60dc:	1909      	adds	r1, r1, r4
c0de60de:	311f      	adds	r1, #31
c0de60e0:	f7ff fece 	bl	c0de5e80 <splitBinaryParameterPart>
c0de60e4:	1986      	adds	r6, r0, r6
                    if (i != 3) {
c0de60e6:	2c18      	cmp	r4, #24
c0de60e8:	d004      	beq.n	c0de60f4 <customProcessor+0x240>
                        strings.tmp.tmp[offset++] = ':';
c0de60ea:	4648      	mov	r0, r9
c0de60ec:	1940      	adds	r0, r0, r5
c0de60ee:	213a      	movs	r1, #58	; 0x3a
c0de60f0:	5581      	strb	r1, [r0, r6]
c0de60f2:	1c76      	adds	r6, r6, #1
                for (i = 0; i < 4; i++) {
c0de60f4:	3408      	adds	r4, #8
c0de60f6:	e7eb      	b.n	c0de60d0 <customProcessor+0x21c>
                ux_flow_init(0, ux_confirm_parameter_flow, NULL);
c0de60f8:	490e      	ldr	r1, [pc, #56]	; (c0de6134 <customProcessor+0x280>)
c0de60fa:	4479      	add	r1, pc
c0de60fc:	2000      	movs	r0, #0
c0de60fe:	4602      	mov	r2, r0
c0de6100:	f006 fc40 	bl	c0dec984 <ux_flow_init>
c0de6104:	2502      	movs	r5, #2
c0de6106:	e762      	b.n	c0de5fce <customProcessor+0x11a>
                ui_warning_contract_data();
c0de6108:	f000 faf0 	bl	c0de66ec <ui_warning_contract_data>
c0de610c:	2503      	movs	r5, #3
c0de610e:	e75e      	b.n	c0de5fce <customProcessor+0x11a>
c0de6110:	0000026c 	.word	0x0000026c
c0de6114:	00000594 	.word	0x00000594
c0de6118:	000006ba 	.word	0x000006ba
c0de611c:	0000b7f0 	.word	0x0000b7f0
c0de6120:	0000b710 	.word	0x0000b710
c0de6124:	0000b68c 	.word	0x0000b68c
c0de6128:	0000b678 	.word	0x0000b678
c0de612c:	0000a610 	.word	0x0000a610
c0de6130:	000080dd 	.word	0x000080dd
c0de6134:	0000a5da 	.word	0x0000a5da

c0de6138 <to_uppercase>:

void to_uppercase(char *str, unsigned char size) {
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0de6138:	2900      	cmp	r1, #0
c0de613a:	d009      	beq.n	c0de6150 <to_uppercase+0x18>
c0de613c:	7802      	ldrb	r2, [r0, #0]
c0de613e:	2a00      	cmp	r2, #0
c0de6140:	d006      	beq.n	c0de6150 <to_uppercase+0x18>
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
c0de6142:	2a60      	cmp	r2, #96	; 0x60
c0de6144:	d900      	bls.n	c0de6148 <to_uppercase+0x10>
c0de6146:	3a20      	subs	r2, #32
c0de6148:	7002      	strb	r2, [r0, #0]
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0de614a:	1c40      	adds	r0, r0, #1
c0de614c:	1e49      	subs	r1, r1, #1
c0de614e:	e7f3      	b.n	c0de6138 <to_uppercase>
    }
}
c0de6150:	4770      	bx	lr
c0de6152:	d4d4      	bmi.n	c0de60fe <customProcessor+0x24a>

c0de6154 <compareOrCopy>:

void compareOrCopy(char *preapproved_string, size_t size, char *parsed_string, bool silent_mode) {
c0de6154:	b570      	push	{r4, r5, r6, lr}
c0de6156:	4614      	mov	r4, r2
c0de6158:	4605      	mov	r5, r0
    if (silent_mode) {
c0de615a:	2b00      	cmp	r3, #0
c0de615c:	d017      	beq.n	c0de618e <compareOrCopy+0x3a>
        /* ETH address are not fundamentally case sensitive but might
        have some for checksum purpose, so let's get rid of these diffs */
        to_uppercase(preapproved_string, strlen(preapproved_string));
c0de615e:	4e11      	ldr	r6, [pc, #68]	; (c0de61a4 <compareOrCopy+0x50>)
c0de6160:	447e      	add	r6, pc
c0de6162:	4628      	mov	r0, r5
c0de6164:	47b0      	blx	r6
c0de6166:	b2c1      	uxtb	r1, r0
c0de6168:	4628      	mov	r0, r5
c0de616a:	f7ff ffe5 	bl	c0de6138 <to_uppercase>
        to_uppercase(parsed_string, strlen(parsed_string));
c0de616e:	4620      	mov	r0, r4
c0de6170:	47b0      	blx	r6
c0de6172:	b2c1      	uxtb	r1, r0
c0de6174:	4620      	mov	r0, r4
c0de6176:	f7ff ffdf 	bl	c0de6138 <to_uppercase>
        if (memcmp(preapproved_string, parsed_string, strlen(preapproved_string))) {
c0de617a:	4628      	mov	r0, r5
c0de617c:	47b0      	blx	r6
c0de617e:	4602      	mov	r2, r0
c0de6180:	4628      	mov	r0, r5
c0de6182:	4621      	mov	r1, r4
c0de6184:	f007 fb66 	bl	c0ded854 <memcmp>
c0de6188:	2800      	cmp	r0, #0
c0de618a:	d106      	bne.n	c0de619a <compareOrCopy+0x46>
            THROW(ERR_SILENT_MODE_CHECK_FAILED);
        }
    } else {
        strlcpy(preapproved_string, parsed_string, size);
    }
}
c0de618c:	bd70      	pop	{r4, r5, r6, pc}
c0de618e:	460a      	mov	r2, r1
        strlcpy(preapproved_string, parsed_string, size);
c0de6190:	4628      	mov	r0, r5
c0de6192:	4621      	mov	r1, r4
c0de6194:	f007 fd1e 	bl	c0dedbd4 <strlcpy>
}
c0de6198:	bd70      	pop	{r4, r5, r6, pc}
c0de619a:	4801      	ldr	r0, [pc, #4]	; (c0de61a0 <compareOrCopy+0x4c>)
            THROW(ERR_SILENT_MODE_CHECK_FAILED);
c0de619c:	f001 f943 	bl	c0de7426 <os_longjmp>
c0de61a0:	00006001 	.word	0x00006001
c0de61a4:	00007abd 	.word	0x00007abd

c0de61a8 <reportFinalizeError>:

void reportFinalizeError(bool direct) {
c0de61a8:	b510      	push	{r4, lr}
c0de61aa:	4604      	mov	r4, r0
    reset_app_context();
c0de61ac:	f000 fa5a 	bl	c0de6664 <reset_app_context>
c0de61b0:	20d5      	movs	r0, #213	; 0xd5
c0de61b2:	01c0      	lsls	r0, r0, #7
    if (direct) {
c0de61b4:	2c00      	cmp	r4, #0
c0de61b6:	d104      	bne.n	c0de61c2 <reportFinalizeError+0x1a>
        THROW(0x6A80);
    } else {
        io_seproxyhal_send_status(0x6A80);
c0de61b8:	f000 faac 	bl	c0de6714 <io_seproxyhal_send_status>
        ui_idle();
c0de61bc:	f000 fa82 	bl	c0de66c4 <ui_idle>
    }
}
c0de61c0:	bd10      	pop	{r4, pc}
        THROW(0x6A80);
c0de61c2:	f001 f930 	bl	c0de7426 <os_longjmp>
c0de61c6:	d4d4      	bmi.n	c0de6172 <compareOrCopy+0x1e>

c0de61c8 <prepareAndCopyFees>:
// Compute the fees, transform it to a string, prepend a ticker to it and copy everything to
// `displayBuffer`.
void prepareAndCopyFees(txInt256_t *BEGasPrice,
                        txInt256_t *BEGasLimit,
                        char *displayBuffer,
                        uint32_t displayBufferSize) {
c0de61c8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de61ca:	b09f      	sub	sp, #124	; 0x7c
c0de61cc:	9304      	str	r3, [sp, #16]
c0de61ce:	4614      	mov	r4, r2
c0de61d0:	9103      	str	r1, [sp, #12]
c0de61d2:	9002      	str	r0, [sp, #8]
c0de61d4:	a806      	add	r0, sp, #24
c0de61d6:	9005      	str	r0, [sp, #20]
c0de61d8:	2720      	movs	r7, #32
    uint256_t rawFee = {0};
c0de61da:	4639      	mov	r1, r7
c0de61dc:	f007 fb1a 	bl	c0ded814 <__aeabi_memclr>
c0de61e0:	ae16      	add	r6, sp, #88	; 0x58
    uint256_t gasPrice = {0};
c0de61e2:	4630      	mov	r0, r6
c0de61e4:	4639      	mov	r1, r7
c0de61e6:	f007 fb15 	bl	c0ded814 <__aeabi_memclr>
c0de61ea:	ad0e      	add	r5, sp, #56	; 0x38
    uint256_t gasLimit = {0};
c0de61ec:	4628      	mov	r0, r5
c0de61ee:	4639      	mov	r1, r7
c0de61f0:	f007 fb10 	bl	c0ded814 <__aeabi_memclr>
c0de61f4:	9802      	ldr	r0, [sp, #8]
    convertUint256BE(BEgasPrice->value, BEgasPrice->length, &gasPrice);
c0de61f6:	5dc1      	ldrb	r1, [r0, r7]
c0de61f8:	4632      	mov	r2, r6
c0de61fa:	f006 f925 	bl	c0dec448 <convertUint256BE>
c0de61fe:	9803      	ldr	r0, [sp, #12]
    convertUint256BE(BEgasLimit->value, BEgasLimit->length, &gasLimit);
c0de6200:	5dc1      	ldrb	r1, [r0, r7]
c0de6202:	462a      	mov	r2, r5
c0de6204:	f006 f920 	bl	c0dec448 <convertUint256BE>
    mul256(&gasPrice, &gasLimit, output);
c0de6208:	4630      	mov	r0, r6
c0de620a:	4629      	mov	r1, r5
c0de620c:	9a05      	ldr	r2, [sp, #20]
c0de620e:	f004 fff9 	bl	c0deb204 <mul256>
    tostring256(rawFee, 10, (char *) (G_io_apdu_buffer + 100), 100);
c0de6212:	4f1d      	ldr	r7, [pc, #116]	; (c0de6288 <prepareAndCopyFees+0xc0>)
c0de6214:	4648      	mov	r0, r9
c0de6216:	19c0      	adds	r0, r0, r7
c0de6218:	3064      	adds	r0, #100	; 0x64
c0de621a:	9003      	str	r0, [sp, #12]
    const char *feeTicker = get_network_ticker();
c0de621c:	f001 f8ee 	bl	c0de73fc <get_network_ticker>
c0de6220:	4606      	mov	r6, r0
c0de6222:	210a      	movs	r1, #10
c0de6224:	2564      	movs	r5, #100	; 0x64
    tostring256(rawFee, 10, (char *) (G_io_apdu_buffer + 100), 100);
c0de6226:	9805      	ldr	r0, [sp, #20]
c0de6228:	9a03      	ldr	r2, [sp, #12]
c0de622a:	462b      	mov	r3, r5
c0de622c:	f005 f902 	bl	c0deb434 <tostring256>
    while (G_io_apdu_buffer[100 + i]) {
c0de6230:	4648      	mov	r0, r9
c0de6232:	19c0      	adds	r0, r0, r7
c0de6234:	5d40      	ldrb	r0, [r0, r5]
c0de6236:	1c6d      	adds	r5, r5, #1
c0de6238:	2800      	cmp	r0, #0
c0de623a:	d1f9      	bne.n	c0de6230 <prepareAndCopyFees+0x68>
c0de623c:	2012      	movs	r0, #18
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0de623e:	9000      	str	r0, [sp, #0]
c0de6240:	4648      	mov	r0, r9
c0de6242:	19c2      	adds	r2, r0, r7
c0de6244:	4610      	mov	r0, r2
c0de6246:	3064      	adds	r0, #100	; 0x64
c0de6248:	3d65      	subs	r5, #101	; 0x65
c0de624a:	2364      	movs	r3, #100	; 0x64
c0de624c:	4629      	mov	r1, r5
c0de624e:	f7fe fb0f 	bl	c0de4870 <adjustDecimals>
    memset(displayBuffer, 0, displayBufferSize);
c0de6252:	4620      	mov	r0, r4
c0de6254:	9904      	ldr	r1, [sp, #16]
c0de6256:	f007 fadd 	bl	c0ded814 <__aeabi_memclr>
c0de625a:	2000      	movs	r0, #0
    while (feeTicker[tickerOffset]) {
c0de625c:	b2c2      	uxtb	r2, r0
c0de625e:	5cb1      	ldrb	r1, [r6, r2]
c0de6260:	2900      	cmp	r1, #0
c0de6262:	d002      	beq.n	c0de626a <prepareAndCopyFees+0xa2>
        displayBuffer[tickerOffset] = feeTicker[tickerOffset];
c0de6264:	54a1      	strb	r1, [r4, r2]
        tickerOffset++;
c0de6266:	1c40      	adds	r0, r0, #1
c0de6268:	e7f8      	b.n	c0de625c <prepareAndCopyFees+0x94>
c0de626a:	4648      	mov	r0, r9
c0de626c:	19c1      	adds	r1, r0, r7
    while (G_io_apdu_buffer[i]) {
c0de626e:	18a0      	adds	r0, r4, r2
c0de6270:	780a      	ldrb	r2, [r1, #0]
c0de6272:	2a00      	cmp	r2, #0
c0de6274:	d003      	beq.n	c0de627e <prepareAndCopyFees+0xb6>
        displayBuffer[tickerOffset + i] = G_io_apdu_buffer[i];
c0de6276:	7002      	strb	r2, [r0, #0]
    while (G_io_apdu_buffer[i]) {
c0de6278:	1c49      	adds	r1, r1, #1
c0de627a:	1c40      	adds	r0, r0, #1
c0de627c:	e7f8      	b.n	c0de6270 <prepareAndCopyFees+0xa8>
c0de627e:	2100      	movs	r1, #0
    displayBuffer[tickerOffset + i] = '\0';
c0de6280:	7001      	strb	r1, [r0, #0]
    computeFees(BEGasPrice, BEGasLimit, &rawFee);
    feesToString(&rawFee, displayBuffer, displayBufferSize);
}
c0de6282:	b01f      	add	sp, #124	; 0x7c
c0de6284:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de6286:	46c0      	nop			; (mov r8, r8)
c0de6288:	00000990 	.word	0x00000990

c0de628c <prepareFeeDisplay>:

void prepareFeeDisplay() {
c0de628c:	b580      	push	{r7, lr}
    prepareAndCopyFees(&tmpContent.txContent.gasprice,
c0de628e:	4806      	ldr	r0, [pc, #24]	; (c0de62a8 <prepareFeeDisplay+0x1c>)
c0de6290:	464a      	mov	r2, r9
c0de6292:	1810      	adds	r0, r2, r0
c0de6294:	4601      	mov	r1, r0
c0de6296:	3121      	adds	r1, #33	; 0x21
c0de6298:	4b04      	ldr	r3, [pc, #16]	; (c0de62ac <prepareFeeDisplay+0x20>)
c0de629a:	18d2      	adds	r2, r2, r3
c0de629c:	3284      	adds	r2, #132	; 0x84
c0de629e:	2332      	movs	r3, #50	; 0x32
c0de62a0:	f7ff ff92 	bl	c0de61c8 <prepareAndCopyFees>
                       &tmpContent.txContent.startgas,
                       strings.common.maxFee,
                       sizeof(strings.common.maxFee));
}
c0de62a4:	bd80      	pop	{r7, pc}
c0de62a6:	46c0      	nop			; (mov r8, r8)
c0de62a8:	0000026c 	.word	0x0000026c
c0de62ac:	000006ba 	.word	0x000006ba

c0de62b0 <prepareNetworkDisplay>:

void prepareNetworkDisplay() {
c0de62b0:	b510      	push	{r4, lr}
    const char *name = get_network_name();
c0de62b2:	f001 f899 	bl	c0de73e8 <get_network_name>
    if (name == NULL) {
c0de62b6:	2800      	cmp	r0, #0
c0de62b8:	d00a      	beq.n	c0de62d0 <prepareNetworkDisplay+0x20>
c0de62ba:	4601      	mov	r1, r0
        // No network name found so simply copy the chain ID as the network name.
        uint64_t chain_id = get_chain_id();
        u64_to_string(chain_id, strings.common.network_name, sizeof(strings.common.network_name));
    } else {
        // Network name found, simply copy it.
        strlcpy(strings.common.network_name, name, sizeof(strings.common.network_name));
c0de62bc:	480b      	ldr	r0, [pc, #44]	; (c0de62ec <prepareNetworkDisplay+0x3c>)
c0de62be:	464a      	mov	r2, r9
c0de62c0:	1810      	adds	r0, r2, r0
c0de62c2:	22ff      	movs	r2, #255	; 0xff
c0de62c4:	3210      	adds	r2, #16
c0de62c6:	1880      	adds	r0, r0, r2
c0de62c8:	2210      	movs	r2, #16
c0de62ca:	f007 fc83 	bl	c0dedbd4 <strlcpy>
    }
}
c0de62ce:	bd10      	pop	{r4, pc}
        u64_to_string(chain_id, strings.common.network_name, sizeof(strings.common.network_name));
c0de62d0:	4806      	ldr	r0, [pc, #24]	; (c0de62ec <prepareNetworkDisplay+0x3c>)
c0de62d2:	4649      	mov	r1, r9
c0de62d4:	1808      	adds	r0, r1, r0
c0de62d6:	21ff      	movs	r1, #255	; 0xff
c0de62d8:	3110      	adds	r1, #16
c0de62da:	1844      	adds	r4, r0, r1
        uint64_t chain_id = get_chain_id();
c0de62dc:	f001 f848 	bl	c0de7370 <get_chain_id>
c0de62e0:	2310      	movs	r3, #16
        u64_to_string(chain_id, strings.common.network_name, sizeof(strings.common.network_name));
c0de62e2:	4622      	mov	r2, r4
c0de62e4:	f7fe fa6e 	bl	c0de47c4 <u64_to_string>
}
c0de62e8:	bd10      	pop	{r4, pc}
c0de62ea:	46c0      	nop			; (mov r8, r8)
c0de62ec:	000006ba 	.word	0x000006ba

c0de62f0 <finalizeParsing>:
    explicit_bzero(&privateKey, sizeof(privateKey));
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
    getEthAddressFromKey(&publicKey, out, &global_sha3);
}

void finalizeParsing(bool direct) {
c0de62f0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de62f2:	b0bd      	sub	sp, #244	; 0xf4
c0de62f4:	9008      	str	r0, [sp, #32]
    char displayBuffer[50];
    uint8_t decimals = WEI_TO_ETHER;
    const char *ticker = get_network_ticker();
c0de62f6:	f001 f881 	bl	c0de73fc <get_network_ticker>
c0de62fa:	9006      	str	r0, [sp, #24]
    ethPluginFinalize_t pluginFinalize;
    bool genericUI = true;

    // Verify the chain
    if (chainConfig->chainId != ETHEREUM_MAINNET_CHAINID) {
c0de62fc:	4ec7      	ldr	r6, [pc, #796]	; (c0de661c <finalizeParsing+0x32c>)
c0de62fe:	4648      	mov	r0, r9
c0de6300:	5980      	ldr	r0, [r0, r6]
c0de6302:	6901      	ldr	r1, [r0, #16]
c0de6304:	6940      	ldr	r0, [r0, #20]
c0de6306:	2201      	movs	r2, #1
c0de6308:	404a      	eors	r2, r1
c0de630a:	4302      	orrs	r2, r0
c0de630c:	d012      	beq.n	c0de6334 <finalizeParsing+0x44>
        uint64_t id = get_chain_id();
c0de630e:	f001 f82f 	bl	c0de7370 <get_chain_id>

        if (chainConfig->chainId != id) {
c0de6312:	464a      	mov	r2, r9
c0de6314:	5992      	ldr	r2, [r2, r6]
c0de6316:	6913      	ldr	r3, [r2, #16]
c0de6318:	6952      	ldr	r2, [r2, #20]
c0de631a:	404a      	eors	r2, r1
c0de631c:	4043      	eors	r3, r0
c0de631e:	4313      	orrs	r3, r2
c0de6320:	d008      	beq.n	c0de6334 <finalizeParsing+0x44>
            PRINTF("Invalid chainID %u expected %u\n", id, chainConfig->chainId);
            reset_app_context();
c0de6322:	f000 f99f 	bl	c0de6664 <reset_app_context>
c0de6326:	9c08      	ldr	r4, [sp, #32]
            reportFinalizeError(direct);
c0de6328:	4620      	mov	r0, r4
c0de632a:	f7ff ff3d 	bl	c0de61a8 <reportFinalizeError>
            if (!direct) {
c0de632e:	2c00      	cmp	r4, #0
c0de6330:	d100      	bne.n	c0de6334 <finalizeParsing+0x44>
c0de6332:	e134      	b.n	c0de659e <finalizeParsing+0x2ae>
c0de6334:	2020      	movs	r0, #32
c0de6336:	9001      	str	r0, [sp, #4]
c0de6338:	4fb9      	ldr	r7, [pc, #740]	; (c0de6620 <finalizeParsing+0x330>)
c0de633a:	4648      	mov	r0, r9
c0de633c:	19c2      	adds	r2, r0, r7
c0de633e:	322c      	adds	r2, #44	; 0x2c
c0de6340:	9200      	str	r2, [sp, #0]
c0de6342:	4db8      	ldr	r5, [pc, #736]	; (c0de6624 <finalizeParsing+0x334>)
c0de6344:	1940      	adds	r0, r0, r5
c0de6346:	2101      	movs	r1, #1
c0de6348:	2300      	movs	r3, #0
c0de634a:	9109      	str	r1, [sp, #36]	; 0x24
c0de634c:	9307      	str	r3, [sp, #28]
c0de634e:	f7fc fe95 	bl	c0de307c <cx_hash_no_throw>
c0de6352:	2800      	cmp	r0, #0
c0de6354:	d000      	beq.n	c0de6358 <finalizeParsing+0x68>
c0de6356:	e15f      	b.n	c0de6618 <finalizeParsing+0x328>
  return cx_hash_get_size(hash);
c0de6358:	464c      	mov	r4, r9
c0de635a:	1960      	adds	r0, r4, r5
c0de635c:	f7fc fe88 	bl	c0de3070 <cx_hash_get_size>
            0,
            tmpCtx.transactionContext.hash,
            32);

    // Finalize the plugin handling
    if (dataContext.tokenContext.pluginStatus >= ETH_PLUGIN_RESULT_SUCCESSFUL) {
c0de6360:	48b1      	ldr	r0, [pc, #708]	; (c0de6628 <finalizeParsing+0x338>)
c0de6362:	1820      	adds	r0, r4, r0
c0de6364:	7f80      	ldrb	r0, [r0, #30]
c0de6366:	2803      	cmp	r0, #3
c0de6368:	d363      	bcc.n	c0de6432 <finalizeParsing+0x142>
c0de636a:	a80f      	add	r0, sp, #60	; 0x3c
        genericUI = false;
        eth_plugin_prepare_finalize(&pluginFinalize);
c0de636c:	f7fe faff 	bl	c0de496e <eth_plugin_prepare_finalize>
c0de6370:	a80a      	add	r0, sp, #40	; 0x28
c0de6372:	2114      	movs	r1, #20
c0de6374:	9104      	str	r1, [sp, #16]

        uint8_t msg_sender[ADDRESS_LENGTH] = {0};
c0de6376:	f007 fa4d 	bl	c0ded814 <__aeabi_memclr>
c0de637a:	ac35      	add	r4, sp, #212	; 0xd4
c0de637c:	2620      	movs	r6, #32
    uint8_t privateKeyData[INT256_LENGTH] = {0};
c0de637e:	4620      	mov	r0, r4
c0de6380:	4631      	mov	r1, r6
c0de6382:	f007 fa47 	bl	c0ded814 <__aeabi_memclr>
c0de6386:	ad2a      	add	r5, sp, #168	; 0xa8
c0de6388:	2128      	movs	r1, #40	; 0x28
    cx_ecfp_private_key_t privateKey = {0};
c0de638a:	4628      	mov	r0, r5
c0de638c:	f007 fa42 	bl	c0ded814 <__aeabi_memclr>
c0de6390:	a817      	add	r0, sp, #92	; 0x5c
c0de6392:	214c      	movs	r1, #76	; 0x4c
    cx_ecfp_public_key_t publicKey = {0};
c0de6394:	f007 fa3e 	bl	c0ded814 <__aeabi_memclr>
                               tmpCtx.transactionContext.pathLength,
c0de6398:	4648      	mov	r0, r9
c0de639a:	5dc2      	ldrb	r2, [r0, r7]
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de639c:	9907      	ldr	r1, [sp, #28]
c0de639e:	9100      	str	r1, [sp, #0]
                               tmpCtx.transactionContext.pathLength,
c0de63a0:	19c0      	adds	r0, r0, r7
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de63a2:	1d01      	adds	r1, r0, #4
c0de63a4:	2721      	movs	r7, #33	; 0x21
c0de63a6:	4638      	mov	r0, r7
c0de63a8:	4623      	mov	r3, r4
c0de63aa:	f002 ff23 	bl	c0de91f4 <os_perso_derive_node_bip32>
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de63ae:	4638      	mov	r0, r7
c0de63b0:	4621      	mov	r1, r4
c0de63b2:	4632      	mov	r2, r6
c0de63b4:	462b      	mov	r3, r5
c0de63b6:	f7fc fe49 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de63ba:	2800      	cmp	r0, #0
c0de63bc:	d000      	beq.n	c0de63c0 <finalizeParsing+0xd0>
c0de63be:	e12b      	b.n	c0de6618 <finalizeParsing+0x328>
c0de63c0:	2021      	movs	r0, #33	; 0x21
c0de63c2:	a917      	add	r1, sp, #92	; 0x5c
c0de63c4:	aa2a      	add	r2, sp, #168	; 0xa8
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de63c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0de63c8:	f7fc fe3a 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de63cc:	2800      	cmp	r0, #0
c0de63ce:	4c95      	ldr	r4, [pc, #596]	; (c0de6624 <finalizeParsing+0x334>)
c0de63d0:	d000      	beq.n	c0de63d4 <finalizeParsing+0xe4>
c0de63d2:	e121      	b.n	c0de6618 <finalizeParsing+0x328>
c0de63d4:	a82a      	add	r0, sp, #168	; 0xa8
c0de63d6:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de63d8:	f007 fa32 	bl	c0ded840 <explicit_bzero>
c0de63dc:	a835      	add	r0, sp, #212	; 0xd4
c0de63de:	2120      	movs	r1, #32
c0de63e0:	9103      	str	r1, [sp, #12]
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de63e2:	f007 fa2d 	bl	c0ded840 <explicit_bzero>
    getEthAddressFromKey(&publicKey, out, &global_sha3);
c0de63e6:	4648      	mov	r0, r9
c0de63e8:	1902      	adds	r2, r0, r4
c0de63ea:	a817      	add	r0, sp, #92	; 0x5c
c0de63ec:	ac0a      	add	r4, sp, #40	; 0x28
c0de63ee:	4621      	mov	r1, r4
c0de63f0:	f7fe f928 	bl	c0de4644 <getEthAddressFromKey>
        get_public_key(msg_sender, sizeof(msg_sender));
        pluginFinalize.address = msg_sender;
c0de63f4:	9415      	str	r4, [sp, #84]	; 0x54
c0de63f6:	24ff      	movs	r4, #255	; 0xff
c0de63f8:	3404      	adds	r4, #4
c0de63fa:	a90f      	add	r1, sp, #60	; 0x3c

        if (!eth_plugin_call(ETH_PLUGIN_FINALIZE, (void *) &pluginFinalize)) {
c0de63fc:	4620      	mov	r0, r4
c0de63fe:	f7fe fbc3 	bl	c0de4b88 <eth_plugin_call>
c0de6402:	2800      	cmp	r0, #0
c0de6404:	4e85      	ldr	r6, [pc, #532]	; (c0de661c <finalizeParsing+0x32c>)
c0de6406:	9f07      	ldr	r7, [sp, #28]
c0de6408:	d106      	bne.n	c0de6418 <finalizeParsing+0x128>
c0de640a:	9d08      	ldr	r5, [sp, #32]
            PRINTF("Plugin finalize call failed\n");
            reportFinalizeError(direct);
c0de640c:	4628      	mov	r0, r5
c0de640e:	f7ff fecb 	bl	c0de61a8 <reportFinalizeError>
            if (!direct) {
c0de6412:	2d00      	cmp	r5, #0
c0de6414:	d100      	bne.n	c0de6418 <finalizeParsing+0x128>
c0de6416:	e0c2      	b.n	c0de659e <finalizeParsing+0x2ae>
c0de6418:	a817      	add	r0, sp, #92	; 0x5c
                return;
            }
        }
        // Lookup tokens if requested
        ethPluginProvideInfo_t pluginProvideInfo;
        eth_plugin_prepare_provide_info(&pluginProvideInfo);
c0de641a:	f7fe faad 	bl	c0de4978 <eth_plugin_prepare_provide_info>
        if ((pluginFinalize.tokenLookup1 != NULL) || (pluginFinalize.tokenLookup2 != NULL)) {
c0de641e:	9812      	ldr	r0, [sp, #72]	; 0x48
c0de6420:	2800      	cmp	r0, #0
c0de6422:	d009      	beq.n	c0de6438 <finalizeParsing+0x148>
            if (pluginFinalize.tokenLookup1 != NULL) {
                PRINTF("Lookup1: %.*H\n", ADDRESS_LENGTH, pluginFinalize.tokenLookup1);
                pluginProvideInfo.item1 = getKnownToken(pluginFinalize.tokenLookup1);
c0de6424:	f000 f9dc 	bl	c0de67e0 <getKnownToken>
c0de6428:	901a      	str	r0, [sp, #104]	; 0x68
                if (pluginProvideInfo.item1 != NULL) {
                    PRINTF("Token1 ticker: %s\n", pluginProvideInfo.item1->token.ticker);
                }
            }
            if (pluginFinalize.tokenLookup2 != NULL) {
c0de642a:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de642c:	2800      	cmp	r0, #0
c0de642e:	d107      	bne.n	c0de6440 <finalizeParsing+0x150>
c0de6430:	e009      	b.n	c0de6446 <finalizeParsing+0x156>
c0de6432:	2012      	movs	r0, #18
c0de6434:	9005      	str	r0, [sp, #20]
c0de6436:	e01b      	b.n	c0de6470 <finalizeParsing+0x180>
        if ((pluginFinalize.tokenLookup1 != NULL) || (pluginFinalize.tokenLookup2 != NULL)) {
c0de6438:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0de643a:	2800      	cmp	r0, #0
c0de643c:	d100      	bne.n	c0de6440 <finalizeParsing+0x150>
c0de643e:	e0b0      	b.n	c0de65a2 <finalizeParsing+0x2b2>
                PRINTF("Lookup2: %.*H\n", ADDRESS_LENGTH, pluginFinalize.tokenLookup2);
                pluginProvideInfo.item2 = getKnownToken(pluginFinalize.tokenLookup2);
c0de6440:	f000 f9ce 	bl	c0de67e0 <getKnownToken>
c0de6444:	901b      	str	r0, [sp, #108]	; 0x6c
                if (pluginProvideInfo.item2 != NULL) {
                    PRINTF("Token2 ticker: %s\n", pluginProvideInfo.item2->token.ticker);
                }
            }
            if (eth_plugin_call(ETH_PLUGIN_PROVIDE_INFO, (void *) &pluginProvideInfo) <=
c0de6446:	1c60      	adds	r0, r4, #1
c0de6448:	a917      	add	r1, sp, #92	; 0x5c
c0de644a:	f7fe fb9d 	bl	c0de4b88 <eth_plugin_call>
c0de644e:	2802      	cmp	r0, #2
c0de6450:	d806      	bhi.n	c0de6460 <finalizeParsing+0x170>
c0de6452:	9c08      	ldr	r4, [sp, #32]
                ETH_PLUGIN_RESULT_UNSUCCESSFUL) {
                PRINTF("Plugin provide token call failed\n");
                reportFinalizeError(direct);
c0de6454:	4620      	mov	r0, r4
c0de6456:	f7ff fea7 	bl	c0de61a8 <reportFinalizeError>
                if (!direct) {
c0de645a:	2c00      	cmp	r4, #0
c0de645c:	d100      	bne.n	c0de6460 <finalizeParsing+0x170>
c0de645e:	e09e      	b.n	c0de659e <finalizeParsing+0x2ae>
c0de6460:	a817      	add	r0, sp, #92	; 0x5c
                    return;
                }
            }
            pluginFinalize.result = pluginProvideInfo.result;
c0de6462:	7d40      	ldrb	r0, [r0, #21]
c0de6464:	a90f      	add	r1, sp, #60	; 0x3c
c0de6466:	7788      	strb	r0, [r1, #30]
c0de6468:	2112      	movs	r1, #18
        }
        if (pluginFinalize.result != ETH_PLUGIN_RESULT_FALLBACK) {
c0de646a:	2806      	cmp	r0, #6
c0de646c:	9105      	str	r1, [sp, #20]
c0de646e:	d137      	bne.n	c0de64e0 <finalizeParsing+0x1f0>
c0de6470:	9f09      	ldr	r7, [sp, #36]	; 0x24
        } else {
            genericUI = true;
        }
    }

    if (tmpContent.txContent.dataPresent && !N_storage.dataAllowed) {
c0de6472:	4d6e      	ldr	r5, [pc, #440]	; (c0de662c <finalizeParsing+0x33c>)
c0de6474:	4648      	mov	r0, r9
c0de6476:	1940      	adds	r0, r0, r5
c0de6478:	21c3      	movs	r1, #195	; 0xc3
c0de647a:	5c40      	ldrb	r0, [r0, r1]
c0de647c:	2800      	cmp	r0, #0
c0de647e:	d00e      	beq.n	c0de649e <finalizeParsing+0x1ae>
c0de6480:	486d      	ldr	r0, [pc, #436]	; (c0de6638 <finalizeParsing+0x348>)
c0de6482:	4478      	add	r0, pc
c0de6484:	f001 fede 	bl	c0de8244 <pic>
c0de6488:	7800      	ldrb	r0, [r0, #0]
c0de648a:	2800      	cmp	r0, #0
c0de648c:	d107      	bne.n	c0de649e <finalizeParsing+0x1ae>
c0de648e:	9c08      	ldr	r4, [sp, #32]
        reportFinalizeError(direct);
c0de6490:	4620      	mov	r0, r4
c0de6492:	f7ff fe89 	bl	c0de61a8 <reportFinalizeError>
        ui_warning_contract_data();
c0de6496:	f000 f929 	bl	c0de66ec <ui_warning_contract_data>
        if (!direct) {
c0de649a:	2c00      	cmp	r4, #0
c0de649c:	d07f      	beq.n	c0de659e <finalizeParsing+0x2ae>
            return;
        }
    }

    // Prepare destination address to display
    if (genericUI) {
c0de649e:	2f00      	cmp	r7, #0
c0de64a0:	d052      	beq.n	c0de6548 <finalizeParsing+0x258>
        if (tmpContent.txContent.destinationLength != 0) {
c0de64a2:	4648      	mov	r0, r9
c0de64a4:	1940      	adds	r0, r0, r5
c0de64a6:	21b9      	movs	r1, #185	; 0xb9
c0de64a8:	5c40      	ldrb	r0, [r0, r1]
c0de64aa:	2800      	cmp	r0, #0
c0de64ac:	d02e      	beq.n	c0de650c <finalizeParsing+0x21c>
c0de64ae:	4630      	mov	r0, r6
            getEthDisplayableAddress(tmpContent.txContent.destination,
                                     displayBuffer,
                                     sizeof(displayBuffer),
                                     &global_sha3,
                                     chainConfig->chainId);
c0de64b0:	464e      	mov	r6, r9
c0de64b2:	5830      	ldr	r0, [r6, r0]
c0de64b4:	6901      	ldr	r1, [r0, #16]
c0de64b6:	6940      	ldr	r0, [r0, #20]
            getEthDisplayableAddress(tmpContent.txContent.destination,
c0de64b8:	9100      	str	r1, [sp, #0]
c0de64ba:	9001      	str	r0, [sp, #4]
c0de64bc:	4859      	ldr	r0, [pc, #356]	; (c0de6624 <finalizeParsing+0x334>)
c0de64be:	1833      	adds	r3, r6, r0
c0de64c0:	1970      	adds	r0, r6, r5
c0de64c2:	30a5      	adds	r0, #165	; 0xa5
c0de64c4:	ac17      	add	r4, sp, #92	; 0x5c
c0de64c6:	2232      	movs	r2, #50	; 0x32
c0de64c8:	4621      	mov	r1, r4
c0de64ca:	f7fe f9b7 	bl	c0de483c <getEthDisplayableAddress>
            compareOrCopy(strings.common.fullAddress,
                          sizeof(strings.common.fullAddress),
                          displayBuffer,
                          called_from_swap);
c0de64ce:	4858      	ldr	r0, [pc, #352]	; (c0de6630 <finalizeParsing+0x340>)
c0de64d0:	5c33      	ldrb	r3, [r6, r0]
            compareOrCopy(strings.common.fullAddress,
c0de64d2:	4858      	ldr	r0, [pc, #352]	; (c0de6634 <finalizeParsing+0x344>)
c0de64d4:	1830      	adds	r0, r6, r0
c0de64d6:	2135      	movs	r1, #53	; 0x35
c0de64d8:	4622      	mov	r2, r4
c0de64da:	f7ff fe3b 	bl	c0de6154 <compareOrCopy>
c0de64de:	e01d      	b.n	c0de651c <finalizeParsing+0x22c>
c0de64e0:	a80f      	add	r0, sp, #60	; 0x3c
            switch (pluginFinalize.uiType) {
c0de64e2:	7f00      	ldrb	r0, [r0, #28]
c0de64e4:	2801      	cmp	r0, #1
c0de64e6:	d05f      	beq.n	c0de65a8 <finalizeParsing+0x2b8>
c0de64e8:	2802      	cmp	r0, #2
c0de64ea:	d000      	beq.n	c0de64ee <finalizeParsing+0x1fe>
c0de64ec:	e08d      	b.n	c0de660a <finalizeParsing+0x31a>
                    tmpContent.txContent.dataPresent = false;
c0de64ee:	484f      	ldr	r0, [pc, #316]	; (c0de662c <finalizeParsing+0x33c>)
c0de64f0:	4649      	mov	r1, r9
c0de64f2:	1808      	adds	r0, r1, r0
c0de64f4:	22c3      	movs	r2, #195	; 0xc3
c0de64f6:	2700      	movs	r7, #0
c0de64f8:	5487      	strb	r7, [r0, r2]
                    dataContext.tokenContext.pluginUiMaxItems =
c0de64fa:	484b      	ldr	r0, [pc, #300]	; (c0de6628 <finalizeParsing+0x338>)
c0de64fc:	1808      	adds	r0, r1, r0
c0de64fe:	a90f      	add	r1, sp, #60	; 0x3c
                        pluginFinalize.numScreens + pluginProvideInfo.additionalScreens;
c0de6500:	7f49      	ldrb	r1, [r1, #29]
c0de6502:	9a1c      	ldr	r2, [sp, #112]	; 0x70
c0de6504:	1851      	adds	r1, r2, r1
c0de6506:	2241      	movs	r2, #65	; 0x41
                    dataContext.tokenContext.pluginUiMaxItems =
c0de6508:	5481      	strb	r1, [r0, r2]
c0de650a:	e7b2      	b.n	c0de6472 <finalizeParsing+0x182>
        } else {
            strcpy(strings.common.fullAddress, "Contract");
c0de650c:	4849      	ldr	r0, [pc, #292]	; (c0de6634 <finalizeParsing+0x344>)
c0de650e:	4649      	mov	r1, r9
c0de6510:	1808      	adds	r0, r1, r0
c0de6512:	494a      	ldr	r1, [pc, #296]	; (c0de663c <finalizeParsing+0x34c>)
c0de6514:	4479      	add	r1, pc
c0de6516:	2209      	movs	r2, #9
c0de6518:	f007 f982 	bl	c0ded820 <__aeabi_memcpy>
    }

    // Prepare amount to display
    if (genericUI) {
        amountToString(tmpContent.txContent.value.value,
                       tmpContent.txContent.value.length,
c0de651c:	464e      	mov	r6, r9
c0de651e:	1970      	adds	r0, r6, r5
c0de6520:	2162      	movs	r1, #98	; 0x62
c0de6522:	5c41      	ldrb	r1, [r0, r1]
c0de6524:	2232      	movs	r2, #50	; 0x32
        amountToString(tmpContent.txContent.value.value,
c0de6526:	9201      	str	r2, [sp, #4]
c0de6528:	ac17      	add	r4, sp, #92	; 0x5c
c0de652a:	9400      	str	r4, [sp, #0]
c0de652c:	3042      	adds	r0, #66	; 0x42
c0de652e:	9a05      	ldr	r2, [sp, #20]
c0de6530:	9b06      	ldr	r3, [sp, #24]
c0de6532:	f006 f81e 	bl	c0dec572 <amountToString>
                       displayBuffer,
                       sizeof(displayBuffer));
        compareOrCopy(strings.common.fullAmount,
                      sizeof(strings.common.fullAmount),
                      displayBuffer,
                      called_from_swap);
c0de6536:	483e      	ldr	r0, [pc, #248]	; (c0de6630 <finalizeParsing+0x340>)
c0de6538:	5c33      	ldrb	r3, [r6, r0]
        compareOrCopy(strings.common.fullAmount,
c0de653a:	483e      	ldr	r0, [pc, #248]	; (c0de6634 <finalizeParsing+0x344>)
c0de653c:	1830      	adds	r0, r6, r0
c0de653e:	3035      	adds	r0, #53	; 0x35
c0de6540:	214f      	movs	r1, #79	; 0x4f
c0de6542:	4622      	mov	r2, r4
c0de6544:	f7ff fe06 	bl	c0de6154 <compareOrCopy>
    }

    // Prepare nonce to display
    uint256_t nonce;
    convertUint256BE(tmpContent.txContent.nonce.value, tmpContent.txContent.nonce.length, &nonce);
c0de6548:	464e      	mov	r6, r9
c0de654a:	1970      	adds	r0, r6, r5
c0de654c:	2183      	movs	r1, #131	; 0x83
c0de654e:	5c41      	ldrb	r1, [r0, r1]
c0de6550:	3063      	adds	r0, #99	; 0x63
c0de6552:	ac2a      	add	r4, sp, #168	; 0xa8
c0de6554:	4622      	mov	r2, r4
c0de6556:	f005 ff77 	bl	c0dec448 <convertUint256BE>
c0de655a:	210a      	movs	r1, #10
c0de655c:	ad17      	add	r5, sp, #92	; 0x5c
c0de655e:	2332      	movs	r3, #50	; 0x32
    tostring256(&nonce, 10, displayBuffer, sizeof(displayBuffer));
c0de6560:	4620      	mov	r0, r4
c0de6562:	462a      	mov	r2, r5
c0de6564:	f004 ff66 	bl	c0deb434 <tostring256>
    strlcpy(strings.common.nonce, displayBuffer, sizeof(strings.common.nonce));
c0de6568:	4832      	ldr	r0, [pc, #200]	; (c0de6634 <finalizeParsing+0x344>)
c0de656a:	1830      	adds	r0, r6, r0
c0de656c:	30b6      	adds	r0, #182	; 0xb6
c0de656e:	2208      	movs	r2, #8
c0de6570:	4629      	mov	r1, r5
c0de6572:	f007 fb2f 	bl	c0dedbd4 <strlcpy>

    // Compute maximum fee
    prepareFeeDisplay();
c0de6576:	f7ff fe89 	bl	c0de628c <prepareFeeDisplay>
    PRINTF("Fees displayed: %s\n", strings.common.maxFee);

    // Prepare chainID field
    prepareNetworkDisplay();
c0de657a:	f7ff fe99 	bl	c0de62b0 <prepareNetworkDisplay>
    PRINTF("Network: %s\n", strings.common.network_name);

    bool no_consent;

    no_consent = called_from_swap;
c0de657e:	482c      	ldr	r0, [pc, #176]	; (c0de6630 <finalizeParsing+0x340>)
c0de6580:	5c30      	ldrb	r0, [r6, r0]

#ifdef NO_CONSENT
    no_consent = true;
#endif  // NO_CONSENT

    if (no_consent) {
c0de6582:	2800      	cmp	r0, #0
c0de6584:	d003      	beq.n	c0de658e <finalizeParsing+0x29e>
c0de6586:	2000      	movs	r0, #0
        io_seproxyhal_touch_tx_ok(NULL);
c0de6588:	f003 fda0 	bl	c0dea0cc <io_seproxyhal_touch_tx_ok>
c0de658c:	e007      	b.n	c0de659e <finalizeParsing+0x2ae>
    } else {
        if (genericUI) {
c0de658e:	2f00      	cmp	r7, #0
c0de6590:	d003      	beq.n	c0de659a <finalizeParsing+0x2aa>
c0de6592:	2000      	movs	r0, #0
            ux_approve_tx(false);
c0de6594:	f004 f8c8 	bl	c0dea728 <ux_approve_tx>
c0de6598:	e001      	b.n	c0de659e <finalizeParsing+0x2ae>
        } else {
            plugin_ui_start();
c0de659a:	f7fe fc0b 	bl	c0de4db4 <plugin_ui_start>
        }
    }
}
c0de659e:	b03d      	add	sp, #244	; 0xf4
c0de65a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de65a2:	a80f      	add	r0, sp, #60	; 0x3c
        if (pluginFinalize.result != ETH_PLUGIN_RESULT_FALLBACK) {
c0de65a4:	7f80      	ldrb	r0, [r0, #30]
c0de65a6:	e75f      	b.n	c0de6468 <finalizeParsing+0x178>
                    tmpContent.txContent.dataPresent = false;
c0de65a8:	4d20      	ldr	r5, [pc, #128]	; (c0de662c <finalizeParsing+0x33c>)
c0de65aa:	4648      	mov	r0, r9
c0de65ac:	1940      	adds	r0, r0, r5
c0de65ae:	21c3      	movs	r1, #195	; 0xc3
c0de65b0:	2200      	movs	r2, #0
c0de65b2:	5442      	strb	r2, [r0, r1]
                    if ((pluginFinalize.amount == NULL) || (pluginFinalize.address == NULL)) {
c0de65b4:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de65b6:	2900      	cmp	r1, #0
c0de65b8:	d002      	beq.n	c0de65c0 <finalizeParsing+0x2d0>
c0de65ba:	9c15      	ldr	r4, [sp, #84]	; 0x54
c0de65bc:	2c00      	cmp	r4, #0
c0de65be:	d107      	bne.n	c0de65d0 <finalizeParsing+0x2e0>
c0de65c0:	9c08      	ldr	r4, [sp, #32]
                        reportFinalizeError(direct);
c0de65c2:	4620      	mov	r0, r4
c0de65c4:	f7ff fdf0 	bl	c0de61a8 <reportFinalizeError>
                        if (!direct) {
c0de65c8:	2c00      	cmp	r4, #0
c0de65ca:	d0e8      	beq.n	c0de659e <finalizeParsing+0x2ae>
                    memmove(tmpContent.txContent.destination, pluginFinalize.address, 20);
c0de65cc:	9c15      	ldr	r4, [sp, #84]	; 0x54
                    memmove(tmpContent.txContent.value.value, pluginFinalize.amount, 32);
c0de65ce:	9914      	ldr	r1, [sp, #80]	; 0x50
c0de65d0:	4648      	mov	r0, r9
c0de65d2:	1945      	adds	r5, r0, r5
c0de65d4:	4628      	mov	r0, r5
c0de65d6:	3042      	adds	r0, #66	; 0x42
c0de65d8:	9f03      	ldr	r7, [sp, #12]
c0de65da:	463a      	mov	r2, r7
c0de65dc:	f007 f924 	bl	c0ded828 <__aeabi_memmove>
c0de65e0:	2062      	movs	r0, #98	; 0x62
                    tmpContent.txContent.value.length = 32;
c0de65e2:	542f      	strb	r7, [r5, r0]
                    memmove(tmpContent.txContent.destination, pluginFinalize.address, 20);
c0de65e4:	4628      	mov	r0, r5
c0de65e6:	30a5      	adds	r0, #165	; 0xa5
c0de65e8:	4621      	mov	r1, r4
c0de65ea:	9c04      	ldr	r4, [sp, #16]
c0de65ec:	4622      	mov	r2, r4
c0de65ee:	f007 f91b 	bl	c0ded828 <__aeabi_memmove>
c0de65f2:	20b9      	movs	r0, #185	; 0xb9
                    tmpContent.txContent.destinationLength = 20;
c0de65f4:	542c      	strb	r4, [r5, r0]
                    if (pluginProvideInfo.item1 != NULL) {
c0de65f6:	981a      	ldr	r0, [sp, #104]	; 0x68
c0de65f8:	2800      	cmp	r0, #0
c0de65fa:	d100      	bne.n	c0de65fe <finalizeParsing+0x30e>
c0de65fc:	e738      	b.n	c0de6470 <finalizeParsing+0x180>
                        decimals = pluginProvideInfo.item1->token.decimals;
c0de65fe:	5dc1      	ldrb	r1, [r0, r7]
c0de6600:	9105      	str	r1, [sp, #20]
c0de6602:	3014      	adds	r0, #20
c0de6604:	9f09      	ldr	r7, [sp, #36]	; 0x24
c0de6606:	9006      	str	r0, [sp, #24]
c0de6608:	e733      	b.n	c0de6472 <finalizeParsing+0x182>
c0de660a:	9c08      	ldr	r4, [sp, #32]
                    reportFinalizeError(direct);
c0de660c:	4620      	mov	r0, r4
c0de660e:	f7ff fdcb 	bl	c0de61a8 <reportFinalizeError>
                    if (!direct) {
c0de6612:	2c00      	cmp	r4, #0
c0de6614:	d0c3      	beq.n	c0de659e <finalizeParsing+0x2ae>
c0de6616:	e72c      	b.n	c0de6472 <finalizeParsing+0x182>
c0de6618:	f000 ff05 	bl	c0de7426 <os_longjmp>
c0de661c:	00000590 	.word	0x00000590
c0de6620:	00000124 	.word	0x00000124
c0de6624:	000007e8 	.word	0x000007e8
c0de6628:	00000594 	.word	0x00000594
c0de662c:	0000026c 	.word	0x0000026c
c0de6630:	0000011d 	.word	0x0000011d
c0de6634:	000006ba 	.word	0x000006ba
c0de6638:	0000b27a 	.word	0x0000b27a
c0de663c:	00009830 	.word	0x00009830

c0de6640 <set_result_get_stark_publicKey>:

#include <string.h>
#include "shared_context.h"
#include "feature_stark_getPublicKey.h"

uint32_t set_result_get_stark_publicKey() {
c0de6640:	b510      	push	{r4, lr}
    uint32_t tx = 0;
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0de6642:	4806      	ldr	r0, [pc, #24]	; (c0de665c <set_result_get_stark_publicKey+0x1c>)
c0de6644:	4649      	mov	r1, r9
c0de6646:	1808      	adds	r0, r1, r0
c0de6648:	4a05      	ldr	r2, [pc, #20]	; (c0de6660 <set_result_get_stark_publicKey+0x20>)
c0de664a:	1889      	adds	r1, r1, r2
c0de664c:	3108      	adds	r1, #8
c0de664e:	2441      	movs	r4, #65	; 0x41
c0de6650:	4622      	mov	r2, r4
c0de6652:	f007 f8e5 	bl	c0ded820 <__aeabi_memcpy>
    tx += 65;
    return tx;
c0de6656:	4620      	mov	r0, r4
c0de6658:	bd10      	pop	{r4, pc}
c0de665a:	46c0      	nop			; (mov r8, r8)
c0de665c:	00000990 	.word	0x00000990
c0de6660:	00000124 	.word	0x00000124

c0de6664 <reset_app_context>:
void reset_app_context() {
c0de6664:	b510      	push	{r4, lr}
    called_from_swap = false;
c0de6666:	480f      	ldr	r0, [pc, #60]	; (c0de66a4 <reset_app_context+0x40>)
    appState = APP_STATE_IDLE;
c0de6668:	464c      	mov	r4, r9
c0de666a:	2100      	movs	r1, #0
    called_from_swap = false;
c0de666c:	5421      	strb	r1, [r4, r0]
    appState = APP_STATE_IDLE;
c0de666e:	480e      	ldr	r0, [pc, #56]	; (c0de66a8 <reset_app_context+0x44>)
c0de6670:	5421      	strb	r1, [r4, r0]
    pluginType = OLD_INTERNAL;
c0de6672:	480e      	ldr	r0, [pc, #56]	; (c0de66ac <reset_app_context+0x48>)
c0de6674:	2203      	movs	r2, #3
c0de6676:	5422      	strb	r2, [r4, r0]
    quantumSet = false;
c0de6678:	480d      	ldr	r0, [pc, #52]	; (c0de66b0 <reset_app_context+0x4c>)
c0de667a:	5421      	strb	r1, [r4, r0]
    eth2WithdrawalIndex = 0;
c0de667c:	480d      	ldr	r0, [pc, #52]	; (c0de66b4 <reset_app_context+0x50>)
c0de667e:	5021      	str	r1, [r4, r0]
    memset((uint8_t *) &tmpCtx, 0, sizeof(tmpCtx));
c0de6680:	480d      	ldr	r0, [pc, #52]	; (c0de66b8 <reset_app_context+0x54>)
c0de6682:	1820      	adds	r0, r4, r0
c0de6684:	2121      	movs	r1, #33	; 0x21
c0de6686:	00c9      	lsls	r1, r1, #3
c0de6688:	f007 f8c4 	bl	c0ded814 <__aeabi_memclr>
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0de668c:	480b      	ldr	r0, [pc, #44]	; (c0de66bc <reset_app_context+0x58>)
c0de668e:	1820      	adds	r0, r4, r0
c0de6690:	2140      	movs	r1, #64	; 0x40
c0de6692:	f007 f8bf 	bl	c0ded814 <__aeabi_memclr>
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0de6696:	480a      	ldr	r0, [pc, #40]	; (c0de66c0 <reset_app_context+0x5c>)
c0de6698:	1820      	adds	r0, r4, r0
c0de669a:	21c4      	movs	r1, #196	; 0xc4
c0de669c:	f007 f8ba 	bl	c0ded814 <__aeabi_memclr>
}
c0de66a0:	bd10      	pop	{r4, pc}
c0de66a2:	46c0      	nop			; (mov r8, r8)
c0de66a4:	0000011d 	.word	0x0000011d
c0de66a8:	0000011c 	.word	0x0000011c
c0de66ac:	0000011e 	.word	0x0000011e
c0de66b0:	0000011f 	.word	0x0000011f
c0de66b4:	00000120 	.word	0x00000120
c0de66b8:	00000124 	.word	0x00000124
c0de66bc:	0000022c 	.word	0x0000022c
c0de66c0:	0000026c 	.word	0x0000026c

c0de66c4 <ui_idle>:
void ui_idle(void) {
c0de66c4:	b580      	push	{r7, lr}
    if (G_ux.stack_count == 0) {
c0de66c6:	4807      	ldr	r0, [pc, #28]	; (c0de66e4 <ui_idle+0x20>)
c0de66c8:	4649      	mov	r1, r9
c0de66ca:	5c08      	ldrb	r0, [r1, r0]
c0de66cc:	2800      	cmp	r0, #0
c0de66ce:	d101      	bne.n	c0de66d4 <ui_idle+0x10>
        ux_stack_push();
c0de66d0:	f006 fde6 	bl	c0ded2a0 <ux_stack_push>
    ux_flow_init(0, ux_idle_flow, NULL);
c0de66d4:	4904      	ldr	r1, [pc, #16]	; (c0de66e8 <ui_idle+0x24>)
c0de66d6:	4479      	add	r1, pc
c0de66d8:	2000      	movs	r0, #0
c0de66da:	4602      	mov	r2, r0
c0de66dc:	f006 f952 	bl	c0dec984 <ux_flow_init>
}
c0de66e0:	bd80      	pop	{r7, pc}
c0de66e2:	46c0      	nop			; (mov r8, r8)
c0de66e4:	00000330 	.word	0x00000330
c0de66e8:	00009946 	.word	0x00009946

c0de66ec <ui_warning_contract_data>:
void ui_warning_contract_data(void) {
c0de66ec:	b580      	push	{r7, lr}
    ux_flow_init(0, ux_warning_contract_data_flow, NULL);
c0de66ee:	4903      	ldr	r1, [pc, #12]	; (c0de66fc <ui_warning_contract_data+0x10>)
c0de66f0:	4479      	add	r1, pc
c0de66f2:	2000      	movs	r0, #0
c0de66f4:	4602      	mov	r2, r0
c0de66f6:	f006 f945 	bl	c0dec984 <ux_flow_init>
}
c0de66fa:	bd80      	pop	{r7, pc}
c0de66fc:	00009ad4 	.word	0x00009ad4

c0de6700 <ui_warning_oracle_data>:
void ui_warning_oracle_data(void) {
c0de6700:	b580      	push	{r7, lr}
    ux_flow_init(0, ux_warning_oracle_data_flow, NULL);
c0de6702:	4903      	ldr	r1, [pc, #12]	; (c0de6710 <ui_warning_oracle_data+0x10>)
c0de6704:	4479      	add	r1, pc
c0de6706:	2000      	movs	r0, #0
c0de6708:	4602      	mov	r2, r0
c0de670a:	f006 f93b 	bl	c0dec984 <ux_flow_init>
}
c0de670e:	bd80      	pop	{r7, pc}
c0de6710:	00009ac8 	.word	0x00009ac8

c0de6714 <io_seproxyhal_send_status>:
void io_seproxyhal_send_status(uint32_t sw) {
c0de6714:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0de6716:	0a01      	lsrs	r1, r0, #8
c0de6718:	4a04      	ldr	r2, [pc, #16]	; (c0de672c <io_seproxyhal_send_status+0x18>)
c0de671a:	464b      	mov	r3, r9
c0de671c:	5499      	strb	r1, [r3, r2]
c0de671e:	1899      	adds	r1, r3, r2
    G_io_apdu_buffer[1] = (sw & 0xff);
c0de6720:	7048      	strb	r0, [r1, #1]
c0de6722:	2020      	movs	r0, #32
c0de6724:	2102      	movs	r1, #2
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0de6726:	f001 f8b1 	bl	c0de788c <io_exchange>
}
c0de672a:	bd80      	pop	{r7, pc}
c0de672c:	00000990 	.word	0x00000990

c0de6730 <format_signature_out>:
void format_signature_out(const uint8_t *signature) {
c0de6730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de6732:	4604      	mov	r4, r0
    memset(G_io_apdu_buffer + 1, 0x00, 64);
c0de6734:	4817      	ldr	r0, [pc, #92]	; (c0de6794 <format_signature_out+0x64>)
c0de6736:	4649      	mov	r1, r9
c0de6738:	1808      	adds	r0, r1, r0
c0de673a:	9000      	str	r0, [sp, #0]
c0de673c:	1c40      	adds	r0, r0, #1
c0de673e:	2140      	movs	r1, #64	; 0x40
c0de6740:	f007 f868 	bl	c0ded814 <__aeabi_memclr>
    uint8_t xlength = signature[xoffset - 1];
c0de6744:	78e0      	ldrb	r0, [r4, #3]
    if (xlength == 33) {
c0de6746:	2821      	cmp	r0, #33	; 0x21
c0de6748:	d001      	beq.n	c0de674e <format_signature_out+0x1e>
c0de674a:	2704      	movs	r7, #4
c0de674c:	e000      	b.n	c0de6750 <format_signature_out+0x20>
c0de674e:	2705      	movs	r7, #5
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0de6750:	19e1      	adds	r1, r4, r7
c0de6752:	2520      	movs	r5, #32
    if (xlength == 33) {
c0de6754:	2821      	cmp	r0, #33	; 0x21
c0de6756:	462e      	mov	r6, r5
c0de6758:	d000      	beq.n	c0de675c <format_signature_out+0x2c>
c0de675a:	4606      	mov	r6, r0
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0de675c:	9800      	ldr	r0, [sp, #0]
c0de675e:	1b80      	subs	r0, r0, r6
c0de6760:	3021      	adds	r0, #33	; 0x21
c0de6762:	4632      	mov	r2, r6
c0de6764:	f007 f860 	bl	c0ded828 <__aeabi_memmove>
    xoffset += xlength + 2;  // move over rvalue and TagLEn
c0de6768:	1cb8      	adds	r0, r7, #2
c0de676a:	1981      	adds	r1, r0, r6
    xlength = signature[xoffset - 1];
c0de676c:	b2c8      	uxtb	r0, r1
c0de676e:	1900      	adds	r0, r0, r4
c0de6770:	1e40      	subs	r0, r0, #1
c0de6772:	7800      	ldrb	r0, [r0, #0]
    if (xlength == 33) {
c0de6774:	2821      	cmp	r0, #33	; 0x21
c0de6776:	d100      	bne.n	c0de677a <format_signature_out+0x4a>
c0de6778:	1c49      	adds	r1, r1, #1
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0de677a:	b2c9      	uxtb	r1, r1
c0de677c:	1861      	adds	r1, r4, r1
    if (xlength == 33) {
c0de677e:	2821      	cmp	r0, #33	; 0x21
c0de6780:	d000      	beq.n	c0de6784 <format_signature_out+0x54>
c0de6782:	4605      	mov	r5, r0
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0de6784:	9800      	ldr	r0, [sp, #0]
c0de6786:	1b40      	subs	r0, r0, r5
c0de6788:	3041      	adds	r0, #65	; 0x41
c0de678a:	462a      	mov	r2, r5
c0de678c:	f007 f84c 	bl	c0ded828 <__aeabi_memmove>
}
c0de6790:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de6792:	46c0      	nop			; (mov r8, r8)
c0de6794:	00000990 	.word	0x00000990

c0de6798 <io_exchange_al>:
unsigned short io_exchange_al(unsigned char channel, unsigned short tx_len) {
c0de6798:	b5b0      	push	{r4, r5, r7, lr}
c0de679a:	4605      	mov	r5, r0
c0de679c:	2007      	movs	r0, #7
    switch (channel & ~(IO_FLAGS)) {
c0de679e:	4028      	ands	r0, r5
c0de67a0:	2400      	movs	r4, #0
c0de67a2:	2801      	cmp	r0, #1
c0de67a4:	d015      	beq.n	c0de67d2 <io_exchange_al+0x3a>
c0de67a6:	2802      	cmp	r0, #2
c0de67a8:	d115      	bne.n	c0de67d6 <io_exchange_al+0x3e>
                return io_seproxyhal_spi_recv(G_io_apdu_buffer, sizeof(G_io_apdu_buffer), 0);
c0de67aa:	480c      	ldr	r0, [pc, #48]	; (c0de67dc <io_exchange_al+0x44>)
            if (tx_len) {
c0de67ac:	2900      	cmp	r1, #0
c0de67ae:	d008      	beq.n	c0de67c2 <io_exchange_al+0x2a>
                io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0de67b0:	464a      	mov	r2, r9
c0de67b2:	1810      	adds	r0, r2, r0
c0de67b4:	f002 fda2 	bl	c0de92fc <io_seph_send>
                if (channel & IO_RESET_AFTER_REPLIED) {
c0de67b8:	0628      	lsls	r0, r5, #24
c0de67ba:	d50a      	bpl.n	c0de67d2 <io_exchange_al+0x3a>
                    reset();
c0de67bc:	f002 fcec 	bl	c0de9198 <halt>
c0de67c0:	e007      	b.n	c0de67d2 <io_exchange_al+0x3a>
                return io_seproxyhal_spi_recv(G_io_apdu_buffer, sizeof(G_io_apdu_buffer), 0);
c0de67c2:	4649      	mov	r1, r9
c0de67c4:	1808      	adds	r0, r1, r0
c0de67c6:	21ff      	movs	r1, #255	; 0xff
c0de67c8:	3152      	adds	r1, #82	; 0x52
c0de67ca:	2200      	movs	r2, #0
c0de67cc:	f002 fdaa 	bl	c0de9324 <io_seph_recv>
c0de67d0:	4604      	mov	r4, r0
}
c0de67d2:	4620      	mov	r0, r4
c0de67d4:	bdb0      	pop	{r4, r5, r7, pc}
c0de67d6:	2002      	movs	r0, #2
            THROW(INVALID_PARAMETER);
c0de67d8:	f000 fe25 	bl	c0de7426 <os_longjmp>
c0de67dc:	00000990 	.word	0x00000990

c0de67e0 <getKnownToken>:
extraInfo_t *getKnownToken(uint8_t *contractAddress) {
c0de67e0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de67e2:	9002      	str	r0, [sp, #8]
c0de67e4:	20b5      	movs	r0, #181	; 0xb5
c0de67e6:	43c6      	mvns	r6, r0
c0de67e8:	2400      	movs	r4, #0
c0de67ea:	4f10      	ldr	r7, [pc, #64]	; (c0de682c <getKnownToken+0x4c>)
c0de67ec:	9401      	str	r4, [sp, #4]
    for (uint8_t i = 0; i < MAX_ITEMS; i++) {
c0de67ee:	2e00      	cmp	r6, #0
c0de67f0:	d014      	beq.n	c0de681c <getKnownToken+0x3c>
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0de67f2:	4648      	mov	r0, r9
c0de67f4:	19c0      	adds	r0, r0, r7
c0de67f6:	1900      	adds	r0, r0, r4
c0de67f8:	2181      	movs	r1, #129	; 0x81
c0de67fa:	004d      	lsls	r5, r1, #1
c0de67fc:	5d40      	ldrb	r0, [r0, r5]
c0de67fe:	2800      	cmp	r0, #0
c0de6800:	d009      	beq.n	c0de6816 <getKnownToken+0x36>
            (memcmp(currentItem->token.address, contractAddress, ADDRESS_LENGTH) == 0)) {
c0de6802:	4648      	mov	r0, r9
c0de6804:	19c0      	adds	r0, r0, r7
c0de6806:	1980      	adds	r0, r0, r6
c0de6808:	1940      	adds	r0, r0, r5
c0de680a:	2214      	movs	r2, #20
c0de680c:	9902      	ldr	r1, [sp, #8]
c0de680e:	f007 f821 	bl	c0ded854 <memcmp>
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0de6812:	2800      	cmp	r0, #0
c0de6814:	d004      	beq.n	c0de6820 <getKnownToken+0x40>
    for (uint8_t i = 0; i < MAX_ITEMS; i++) {
c0de6816:	365b      	adds	r6, #91	; 0x5b
c0de6818:	1c64      	adds	r4, r4, #1
c0de681a:	e7e8      	b.n	c0de67ee <getKnownToken+0xe>
c0de681c:	9801      	ldr	r0, [sp, #4]
}
c0de681e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0de6820:	4648      	mov	r0, r9
c0de6822:	19c0      	adds	r0, r0, r7
c0de6824:	1980      	adds	r0, r0, r6
c0de6826:	1940      	adds	r0, r0, r5
}
c0de6828:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de682a:	46c0      	nop			; (mov r8, r8)
c0de682c:	00000124 	.word	0x00000124

c0de6830 <handleGetWalletId>:
void handleGetWalletId(volatile unsigned int *tx) {
c0de6830:	b0ae      	sub	sp, #184	; 0xb8
c0de6832:	4604      	mov	r4, r0
c0de6834:	2000      	movs	r0, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1, U_os_perso_seed_cookie, 2, t, NULL);
c0de6836:	9000      	str	r0, [sp, #0]
c0de6838:	2621      	movs	r6, #33	; 0x21
c0de683a:	4915      	ldr	r1, [pc, #84]	; (c0de6890 <handleGetWalletId+0x60>)
c0de683c:	4479      	add	r1, pc
c0de683e:	2202      	movs	r2, #2
c0de6840:	ad1e      	add	r5, sp, #120	; 0x78
c0de6842:	4630      	mov	r0, r6
c0de6844:	462b      	mov	r3, r5
c0de6846:	f002 fcd5 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0de684a:	2220      	movs	r2, #32
c0de684c:	af14      	add	r7, sp, #80	; 0x50
    cx_ecdsa_init_private_key(CX_CURVE_256K1, t, 32, &priv);
c0de684e:	4630      	mov	r0, r6
c0de6850:	4629      	mov	r1, r5
c0de6852:	463b      	mov	r3, r7
c0de6854:	f7fc fbfa 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de6858:	ae01      	add	r6, sp, #4
    cx_ecfp_generate_pair(CX_CURVE_256K1, &pub, &priv, 1);
c0de685a:	4630      	mov	r0, r6
c0de685c:	4639      	mov	r1, r7
c0de685e:	f000 f819 	bl	c0de6894 <cx_ecfp_generate_pair>
    cx_hash_sha512(pub.W, sizeof(pub.W), t, sizeof(t));
c0de6862:	3608      	adds	r6, #8
c0de6864:	2141      	movs	r1, #65	; 0x41
c0de6866:	2740      	movs	r7, #64	; 0x40
c0de6868:	4630      	mov	r0, r6
c0de686a:	462a      	mov	r2, r5
c0de686c:	463b      	mov	r3, r7
c0de686e:	f7fc fc11 	bl	c0de3094 <cx_hash_sha512>
    memmove(G_io_apdu_buffer, t, 64);
c0de6872:	4806      	ldr	r0, [pc, #24]	; (c0de688c <handleGetWalletId+0x5c>)
c0de6874:	4649      	mov	r1, r9
c0de6876:	1808      	adds	r0, r1, r0
c0de6878:	4629      	mov	r1, r5
c0de687a:	463a      	mov	r2, r7
c0de687c:	f006 ffd0 	bl	c0ded820 <__aeabi_memcpy>
    *tx = 64;
c0de6880:	6027      	str	r7, [r4, #0]
c0de6882:	2009      	movs	r0, #9
c0de6884:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0de6886:	f000 fdce 	bl	c0de7426 <os_longjmp>
c0de688a:	46c0      	nop			; (mov r8, r8)
c0de688c:	00000990 	.word	0x00000990
c0de6890:	00009514 	.word	0x00009514

c0de6894 <cx_ecfp_generate_pair>:
{
c0de6894:	b580      	push	{r7, lr}
c0de6896:	460a      	mov	r2, r1
c0de6898:	4601      	mov	r1, r0
c0de689a:	2021      	movs	r0, #33	; 0x21
c0de689c:	2301      	movs	r3, #1
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de689e:	f7fc fbcf 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de68a2:	2800      	cmp	r0, #0
c0de68a4:	d100      	bne.n	c0de68a8 <cx_ecfp_generate_pair+0x14>
c0de68a6:	bd80      	pop	{r7, pc}
c0de68a8:	f000 fdbd 	bl	c0de7426 <os_longjmp>

c0de68ac <handleApdu>:
void handleApdu(unsigned int *flags, unsigned int *tx) {
c0de68ac:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de68ae:	b08f      	sub	sp, #60	; 0x3c
c0de68b0:	460c      	mov	r4, r1
c0de68b2:	4605      	mov	r5, r0
c0de68b4:	af03      	add	r7, sp, #12
        TRY {
c0de68b6:	4638      	mov	r0, r7
c0de68b8:	f007 f8fa 	bl	c0dedab0 <setjmp>
c0de68bc:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0de68be:	b287      	uxth	r7, r0
c0de68c0:	2f00      	cmp	r7, #0
c0de68c2:	d018      	beq.n	c0de68f6 <handleApdu+0x4a>
c0de68c4:	2f05      	cmp	r7, #5
c0de68c6:	d100      	bne.n	c0de68ca <handleApdu+0x1e>
c0de68c8:	e13b      	b.n	c0de6b42 <handleApdu+0x296>
c0de68ca:	4606      	mov	r6, r0
c0de68cc:	a803      	add	r0, sp, #12
c0de68ce:	2100      	movs	r1, #0
        CATCH_OTHER(e) {
c0de68d0:	8581      	strh	r1, [r0, #44]	; 0x2c
c0de68d2:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de68d4:	f002 fd3c 	bl	c0de9350 <try_context_set>
c0de68d8:	200f      	movs	r0, #15
c0de68da:	0300      	lsls	r0, r0, #12
            switch (e & 0xF000) {
c0de68dc:	4030      	ands	r0, r6
c0de68de:	2109      	movs	r1, #9
c0de68e0:	0309      	lsls	r1, r1, #12
c0de68e2:	4288      	cmp	r0, r1
c0de68e4:	d005      	beq.n	c0de68f2 <handleApdu+0x46>
c0de68e6:	2103      	movs	r1, #3
c0de68e8:	0349      	lsls	r1, r1, #13
c0de68ea:	4288      	cmp	r0, r1
c0de68ec:	d15b      	bne.n	c0de69a6 <handleApdu+0xfa>
                    reset_app_context();
c0de68ee:	f7ff feb9 	bl	c0de6664 <reset_app_context>
c0de68f2:	0a38      	lsrs	r0, r7, #8
c0de68f4:	e05c      	b.n	c0de69b0 <handleApdu+0x104>
c0de68f6:	a803      	add	r0, sp, #12
        TRY {
c0de68f8:	f002 fd2a 	bl	c0de9350 <try_context_set>
c0de68fc:	900d      	str	r0, [sp, #52]	; 0x34
            if ((G_io_apdu_buffer[OFFSET_CLA] == COMMON_CLA) &&
c0de68fe:	489b      	ldr	r0, [pc, #620]	; (c0de6b6c <handleApdu+0x2c0>)
c0de6900:	4649      	mov	r1, r9
c0de6902:	5c0a      	ldrb	r2, [r1, r0]
c0de6904:	1809      	adds	r1, r1, r0
                (G_io_apdu_buffer[OFFSET_INS] == COMMON_INS_GET_WALLET_ID)) {
c0de6906:	7849      	ldrb	r1, [r1, #1]
            if ((G_io_apdu_buffer[OFFSET_CLA] == COMMON_CLA) &&
c0de6908:	2ab0      	cmp	r2, #176	; 0xb0
c0de690a:	d102      	bne.n	c0de6912 <handleApdu+0x66>
c0de690c:	2904      	cmp	r1, #4
c0de690e:	d100      	bne.n	c0de6912 <handleApdu+0x66>
c0de6910:	e120      	b.n	c0de6b54 <handleApdu+0x2a8>
            if (G_io_apdu_buffer[OFFSET_CLA] == STARKWARE_CLA) {
c0de6912:	2ae0      	cmp	r2, #224	; 0xe0
c0de6914:	d016      	beq.n	c0de6944 <handleApdu+0x98>
c0de6916:	2af0      	cmp	r2, #240	; 0xf0
c0de6918:	d000      	beq.n	c0de691c <handleApdu+0x70>
c0de691a:	e11e      	b.n	c0de6b5a <handleApdu+0x2ae>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0de691c:	290a      	cmp	r1, #10
c0de691e:	d060      	beq.n	c0de69e2 <handleApdu+0x136>
c0de6920:	2904      	cmp	r1, #4
c0de6922:	d074      	beq.n	c0de6a0e <handleApdu+0x162>
c0de6924:	2908      	cmp	r1, #8
c0de6926:	d067      	beq.n	c0de69f8 <handleApdu+0x14c>
c0de6928:	2902      	cmp	r1, #2
c0de692a:	d000      	beq.n	c0de692e <handleApdu+0x82>
c0de692c:	e119      	b.n	c0de6b62 <handleApdu+0x2b6>
                        handleStarkwareGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0de692e:	4649      	mov	r1, r9
c0de6930:	180a      	adds	r2, r1, r0
                                                    G_io_apdu_buffer[OFFSET_LC],
c0de6932:	7913      	ldrb	r3, [r2, #4]
                                                    G_io_apdu_buffer[OFFSET_P2],
c0de6934:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0de6936:	7890      	ldrb	r0, [r2, #2]
c0de6938:	9500      	str	r5, [sp, #0]
c0de693a:	9401      	str	r4, [sp, #4]
c0de693c:	1d52      	adds	r2, r2, #5
c0de693e:	f7fb fdc3 	bl	c0de24c8 <handleStarkwareGetPublicKey>
c0de6942:	e06e      	b.n	c0de6a22 <handleApdu+0x176>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0de6944:	2918      	cmp	r1, #24
c0de6946:	d071      	beq.n	c0de6a2c <handleApdu+0x180>
c0de6948:	2904      	cmp	r1, #4
c0de694a:	d100      	bne.n	c0de694e <handleApdu+0xa2>
c0de694c:	e09a      	b.n	c0de6a84 <handleApdu+0x1d8>
c0de694e:	2906      	cmp	r1, #6
c0de6950:	d077      	beq.n	c0de6a42 <handleApdu+0x196>
c0de6952:	2908      	cmp	r1, #8
c0de6954:	d100      	bne.n	c0de6958 <handleApdu+0xac>
c0de6956:	e0a0      	b.n	c0de6a9a <handleApdu+0x1ee>
c0de6958:	290a      	cmp	r1, #10
c0de695a:	d07d      	beq.n	c0de6a58 <handleApdu+0x1ac>
c0de695c:	290c      	cmp	r1, #12
c0de695e:	d100      	bne.n	c0de6962 <handleApdu+0xb6>
c0de6960:	e0ac      	b.n	c0de6abc <handleApdu+0x210>
c0de6962:	290e      	cmp	r1, #14
c0de6964:	d100      	bne.n	c0de6968 <handleApdu+0xbc>
c0de6966:	e0ba      	b.n	c0de6ade <handleApdu+0x232>
c0de6968:	2910      	cmp	r1, #16
c0de696a:	d100      	bne.n	c0de696e <handleApdu+0xc2>
c0de696c:	e0c8      	b.n	c0de6b00 <handleApdu+0x254>
c0de696e:	2912      	cmp	r1, #18
c0de6970:	d100      	bne.n	c0de6974 <handleApdu+0xc8>
c0de6972:	e0d0      	b.n	c0de6b16 <handleApdu+0x26a>
c0de6974:	2914      	cmp	r1, #20
c0de6976:	d100      	bne.n	c0de697a <handleApdu+0xce>
c0de6978:	e0d8      	b.n	c0de6b2c <handleApdu+0x280>
c0de697a:	2916      	cmp	r1, #22
c0de697c:	d077      	beq.n	c0de6a6e <handleApdu+0x1c2>
c0de697e:	2902      	cmp	r1, #2
c0de6980:	d000      	beq.n	c0de6984 <handleApdu+0xd8>
c0de6982:	e0ee      	b.n	c0de6b62 <handleApdu+0x2b6>
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_ITEMS);
c0de6984:	497a      	ldr	r1, [pc, #488]	; (c0de6b70 <handleApdu+0x2c4>)
c0de6986:	464a      	mov	r2, r9
c0de6988:	1851      	adds	r1, r2, r1
c0de698a:	2381      	movs	r3, #129	; 0x81
c0de698c:	005b      	lsls	r3, r3, #1
c0de698e:	2600      	movs	r6, #0
c0de6990:	52ce      	strh	r6, [r1, r3]
                    handleGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0de6992:	1812      	adds	r2, r2, r0
                                       G_io_apdu_buffer[OFFSET_LC],
c0de6994:	7913      	ldrb	r3, [r2, #4]
                                       G_io_apdu_buffer[OFFSET_P2],
c0de6996:	78d1      	ldrb	r1, [r2, #3]
                    handleGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0de6998:	7890      	ldrb	r0, [r2, #2]
c0de699a:	9500      	str	r5, [sp, #0]
c0de699c:	9401      	str	r4, [sp, #4]
c0de699e:	1d52      	adds	r2, r2, #5
c0de69a0:	f7fa fdc8 	bl	c0de1534 <handleGetPublicKey>
c0de69a4:	e00f      	b.n	c0de69c6 <handleApdu+0x11a>
                    reset_app_context();
c0de69a6:	f7ff fe5d 	bl	c0de6664 <reset_app_context>
                    break;
c0de69aa:	0570      	lsls	r0, r6, #21
c0de69ac:	0f40      	lsrs	r0, r0, #29
c0de69ae:	3068      	adds	r0, #104	; 0x68
            G_io_apdu_buffer[*tx] = sw >> 8;
c0de69b0:	496e      	ldr	r1, [pc, #440]	; (c0de6b6c <handleApdu+0x2c0>)
c0de69b2:	464a      	mov	r2, r9
c0de69b4:	1851      	adds	r1, r2, r1
c0de69b6:	6822      	ldr	r2, [r4, #0]
c0de69b8:	5488      	strb	r0, [r1, r2]
            G_io_apdu_buffer[*tx + 1] = sw;
c0de69ba:	6820      	ldr	r0, [r4, #0]
c0de69bc:	1840      	adds	r0, r0, r1
c0de69be:	7046      	strb	r6, [r0, #1]
            *tx += 2;
c0de69c0:	6820      	ldr	r0, [r4, #0]
c0de69c2:	1c80      	adds	r0, r0, #2
c0de69c4:	6020      	str	r0, [r4, #0]
        FINALLY {
c0de69c6:	f002 fcb9 	bl	c0de933c <try_context_get>
c0de69ca:	a903      	add	r1, sp, #12
c0de69cc:	4288      	cmp	r0, r1
c0de69ce:	d102      	bne.n	c0de69d6 <handleApdu+0x12a>
c0de69d0:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de69d2:	f002 fcbd 	bl	c0de9350 <try_context_set>
c0de69d6:	a803      	add	r0, sp, #12
    END_TRY;
c0de69d8:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de69da:	2800      	cmp	r0, #0
c0de69dc:	d024      	beq.n	c0de6a28 <handleApdu+0x17c>
c0de69de:	f000 fd22 	bl	c0de7426 <os_longjmp>
                        handleStarkwareUnsafeSign(G_io_apdu_buffer[OFFSET_P1],
c0de69e2:	4649      	mov	r1, r9
c0de69e4:	180a      	adds	r2, r1, r0
                                                  G_io_apdu_buffer[OFFSET_LC],
c0de69e6:	7913      	ldrb	r3, [r2, #4]
                                                  G_io_apdu_buffer[OFFSET_P2],
c0de69e8:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareUnsafeSign(G_io_apdu_buffer[OFFSET_P1],
c0de69ea:	7890      	ldrb	r0, [r2, #2]
c0de69ec:	9500      	str	r5, [sp, #0]
c0de69ee:	9401      	str	r4, [sp, #4]
c0de69f0:	1d52      	adds	r2, r2, #5
c0de69f2:	f7fc f943 	bl	c0de2c7c <handleStarkwareUnsafeSign>
c0de69f6:	e014      	b.n	c0de6a22 <handleApdu+0x176>
                        handleStarkwareProvideQuantum(G_io_apdu_buffer[OFFSET_P1],
c0de69f8:	4649      	mov	r1, r9
c0de69fa:	180a      	adds	r2, r1, r0
                                                      G_io_apdu_buffer[OFFSET_LC],
c0de69fc:	7913      	ldrb	r3, [r2, #4]
                                                      G_io_apdu_buffer[OFFSET_P2],
c0de69fe:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareProvideQuantum(G_io_apdu_buffer[OFFSET_P1],
c0de6a00:	7890      	ldrb	r0, [r2, #2]
c0de6a02:	9500      	str	r5, [sp, #0]
c0de6a04:	9401      	str	r4, [sp, #4]
c0de6a06:	1d52      	adds	r2, r2, #5
c0de6a08:	f7fb fdde 	bl	c0de25c8 <handleStarkwareProvideQuantum>
c0de6a0c:	e009      	b.n	c0de6a22 <handleApdu+0x176>
                        handleStarkwareSignMessage(G_io_apdu_buffer[OFFSET_P1],
c0de6a0e:	4649      	mov	r1, r9
c0de6a10:	180a      	adds	r2, r1, r0
                                                   G_io_apdu_buffer[OFFSET_LC],
c0de6a12:	7913      	ldrb	r3, [r2, #4]
                                                   G_io_apdu_buffer[OFFSET_P2],
c0de6a14:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareSignMessage(G_io_apdu_buffer[OFFSET_P1],
c0de6a16:	7890      	ldrb	r0, [r2, #2]
c0de6a18:	9500      	str	r5, [sp, #0]
c0de6a1a:	9401      	str	r4, [sp, #4]
c0de6a1c:	1d52      	adds	r2, r2, #5
c0de6a1e:	f7fb fe4b 	bl	c0de26b8 <handleStarkwareSignMessage>
                CLOSE_TRY;
c0de6a22:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de6a24:	f002 fc94 	bl	c0de9350 <try_context_set>
}
c0de6a28:	b00f      	add	sp, #60	; 0x3c
c0de6a2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    handlePerformPrivacyOperation(G_io_apdu_buffer[OFFSET_P1],
c0de6a2c:	4649      	mov	r1, r9
c0de6a2e:	180a      	adds	r2, r1, r0
                                                  G_io_apdu_buffer[OFFSET_LC],
c0de6a30:	7913      	ldrb	r3, [r2, #4]
                                                  G_io_apdu_buffer[OFFSET_P2],
c0de6a32:	78d1      	ldrb	r1, [r2, #3]
                    handlePerformPrivacyOperation(G_io_apdu_buffer[OFFSET_P1],
c0de6a34:	7890      	ldrb	r0, [r2, #2]
c0de6a36:	9500      	str	r5, [sp, #0]
c0de6a38:	9401      	str	r4, [sp, #4]
c0de6a3a:	1d52      	adds	r2, r2, #5
c0de6a3c:	f7fa fe46 	bl	c0de16cc <handlePerformPrivacyOperation>
c0de6a40:	e7c1      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleGetAppConfiguration(G_io_apdu_buffer[OFFSET_P1],
c0de6a42:	4649      	mov	r1, r9
c0de6a44:	180a      	adds	r2, r1, r0
                                              G_io_apdu_buffer[OFFSET_LC],
c0de6a46:	7913      	ldrb	r3, [r2, #4]
                                              G_io_apdu_buffer[OFFSET_P2],
c0de6a48:	78d1      	ldrb	r1, [r2, #3]
                    handleGetAppConfiguration(G_io_apdu_buffer[OFFSET_P1],
c0de6a4a:	7890      	ldrb	r0, [r2, #2]
c0de6a4c:	9500      	str	r5, [sp, #0]
c0de6a4e:	9401      	str	r4, [sp, #4]
c0de6a50:	1d52      	adds	r2, r2, #5
c0de6a52:	f7fa fc95 	bl	c0de1380 <handleGetAppConfiguration>
c0de6a56:	e7b6      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleProvideErc20TokenInformation(G_io_apdu_buffer[OFFSET_P1],
c0de6a58:	4649      	mov	r1, r9
c0de6a5a:	180a      	adds	r2, r1, r0
                                                       G_io_apdu_buffer[OFFSET_LC],
c0de6a5c:	7913      	ldrb	r3, [r2, #4]
                                                       G_io_apdu_buffer[OFFSET_P2],
c0de6a5e:	78d1      	ldrb	r1, [r2, #3]
                    handleProvideErc20TokenInformation(G_io_apdu_buffer[OFFSET_P1],
c0de6a60:	7890      	ldrb	r0, [r2, #2]
c0de6a62:	9500      	str	r5, [sp, #0]
c0de6a64:	9401      	str	r4, [sp, #4]
c0de6a66:	1d52      	adds	r2, r2, #5
c0de6a68:	f7fa ffea 	bl	c0de1a40 <handleProvideErc20TokenInformation>
c0de6a6c:	e7ab      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleSetPlugin(G_io_apdu_buffer[OFFSET_P1],
c0de6a6e:	4649      	mov	r1, r9
c0de6a70:	180a      	adds	r2, r1, r0
                                    G_io_apdu_buffer[OFFSET_LC],
c0de6a72:	7913      	ldrb	r3, [r2, #4]
                                    G_io_apdu_buffer[OFFSET_P2],
c0de6a74:	78d1      	ldrb	r1, [r2, #3]
                    handleSetPlugin(G_io_apdu_buffer[OFFSET_P1],
c0de6a76:	7890      	ldrb	r0, [r2, #2]
c0de6a78:	9500      	str	r5, [sp, #0]
c0de6a7a:	9401      	str	r4, [sp, #4]
c0de6a7c:	1d52      	adds	r2, r2, #5
c0de6a7e:	f7fb f927 	bl	c0de1cd0 <handleSetPlugin>
c0de6a82:	e7a0      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleSign(G_io_apdu_buffer[OFFSET_P1],
c0de6a84:	4649      	mov	r1, r9
c0de6a86:	180a      	adds	r2, r1, r0
                               G_io_apdu_buffer[OFFSET_LC],
c0de6a88:	7913      	ldrb	r3, [r2, #4]
                               G_io_apdu_buffer[OFFSET_P2],
c0de6a8a:	78d1      	ldrb	r1, [r2, #3]
                    handleSign(G_io_apdu_buffer[OFFSET_P1],
c0de6a8c:	7890      	ldrb	r0, [r2, #2]
c0de6a8e:	9500      	str	r5, [sp, #0]
c0de6a90:	9401      	str	r4, [sp, #4]
c0de6a92:	1d52      	adds	r2, r2, #5
c0de6a94:	f7fb fbee 	bl	c0de2274 <handleSign>
c0de6a98:	e795      	b.n	c0de69c6 <handleApdu+0x11a>
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_ITEMS);
c0de6a9a:	4935      	ldr	r1, [pc, #212]	; (c0de6b70 <handleApdu+0x2c4>)
c0de6a9c:	464a      	mov	r2, r9
c0de6a9e:	1851      	adds	r1, r2, r1
c0de6aa0:	2381      	movs	r3, #129	; 0x81
c0de6aa2:	005b      	lsls	r3, r3, #1
c0de6aa4:	2600      	movs	r6, #0
c0de6aa6:	52ce      	strh	r6, [r1, r3]
                    handleSignPersonalMessage(G_io_apdu_buffer[OFFSET_P1],
c0de6aa8:	1812      	adds	r2, r2, r0
                                              G_io_apdu_buffer[OFFSET_LC],
c0de6aaa:	7913      	ldrb	r3, [r2, #4]
                                              G_io_apdu_buffer[OFFSET_P2],
c0de6aac:	78d1      	ldrb	r1, [r2, #3]
                    handleSignPersonalMessage(G_io_apdu_buffer[OFFSET_P1],
c0de6aae:	7890      	ldrb	r0, [r2, #2]
c0de6ab0:	9500      	str	r5, [sp, #0]
c0de6ab2:	9401      	str	r4, [sp, #4]
c0de6ab4:	1d52      	adds	r2, r2, #5
c0de6ab6:	f7fb f9d7 	bl	c0de1e68 <handleSignPersonalMessage>
c0de6aba:	e784      	b.n	c0de69c6 <handleApdu+0x11a>
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_ITEMS);
c0de6abc:	492c      	ldr	r1, [pc, #176]	; (c0de6b70 <handleApdu+0x2c4>)
c0de6abe:	464a      	mov	r2, r9
c0de6ac0:	1851      	adds	r1, r2, r1
c0de6ac2:	2381      	movs	r3, #129	; 0x81
c0de6ac4:	005b      	lsls	r3, r3, #1
c0de6ac6:	2600      	movs	r6, #0
c0de6ac8:	52ce      	strh	r6, [r1, r3]
                    handleSignEIP712Message(G_io_apdu_buffer[OFFSET_P1],
c0de6aca:	1812      	adds	r2, r2, r0
                                            G_io_apdu_buffer[OFFSET_LC],
c0de6acc:	7913      	ldrb	r3, [r2, #4]
                                            G_io_apdu_buffer[OFFSET_P2],
c0de6ace:	78d1      	ldrb	r1, [r2, #3]
                    handleSignEIP712Message(G_io_apdu_buffer[OFFSET_P1],
c0de6ad0:	7890      	ldrb	r0, [r2, #2]
c0de6ad2:	9500      	str	r5, [sp, #0]
c0de6ad4:	9401      	str	r4, [sp, #4]
c0de6ad6:	1d52      	adds	r2, r2, #5
c0de6ad8:	f7fb fb6a 	bl	c0de21b0 <handleSignEIP712Message>
c0de6adc:	e773      	b.n	c0de69c6 <handleApdu+0x11a>
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_ITEMS);
c0de6ade:	4924      	ldr	r1, [pc, #144]	; (c0de6b70 <handleApdu+0x2c4>)
c0de6ae0:	464a      	mov	r2, r9
c0de6ae2:	1851      	adds	r1, r2, r1
c0de6ae4:	2381      	movs	r3, #129	; 0x81
c0de6ae6:	005b      	lsls	r3, r3, #1
c0de6ae8:	2600      	movs	r6, #0
c0de6aea:	52ce      	strh	r6, [r1, r3]
                    handleGetEth2PublicKey(G_io_apdu_buffer[OFFSET_P1],
c0de6aec:	1812      	adds	r2, r2, r0
                                           G_io_apdu_buffer[OFFSET_LC],
c0de6aee:	7913      	ldrb	r3, [r2, #4]
                                           G_io_apdu_buffer[OFFSET_P2],
c0de6af0:	78d1      	ldrb	r1, [r2, #3]
                    handleGetEth2PublicKey(G_io_apdu_buffer[OFFSET_P1],
c0de6af2:	7890      	ldrb	r0, [r2, #2]
c0de6af4:	9500      	str	r5, [sp, #0]
c0de6af6:	9401      	str	r4, [sp, #4]
c0de6af8:	1d52      	adds	r2, r2, #5
c0de6afa:	f7fa fcc3 	bl	c0de1484 <handleGetEth2PublicKey>
c0de6afe:	e762      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleSetEth2WithdrawalIndex(G_io_apdu_buffer[OFFSET_P1],
c0de6b00:	4649      	mov	r1, r9
c0de6b02:	180a      	adds	r2, r1, r0
                                                 G_io_apdu_buffer[OFFSET_LC],
c0de6b04:	7913      	ldrb	r3, [r2, #4]
                                                 G_io_apdu_buffer[OFFSET_P2],
c0de6b06:	78d1      	ldrb	r1, [r2, #3]
                    handleSetEth2WithdrawalIndex(G_io_apdu_buffer[OFFSET_P1],
c0de6b08:	7890      	ldrb	r0, [r2, #2]
c0de6b0a:	9500      	str	r5, [sp, #0]
c0de6b0c:	9401      	str	r4, [sp, #4]
c0de6b0e:	1d52      	adds	r2, r2, #5
c0de6b10:	f7fb f82a 	bl	c0de1b68 <handleSetEth2WithdrawalIndex>
c0de6b14:	e757      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleSetExternalPlugin(G_io_apdu_buffer[OFFSET_P1],
c0de6b16:	4649      	mov	r1, r9
c0de6b18:	180a      	adds	r2, r1, r0
                                            G_io_apdu_buffer[OFFSET_LC],
c0de6b1a:	7913      	ldrb	r3, [r2, #4]
                                            G_io_apdu_buffer[OFFSET_P2],
c0de6b1c:	78d1      	ldrb	r1, [r2, #3]
                    handleSetExternalPlugin(G_io_apdu_buffer[OFFSET_P1],
c0de6b1e:	7890      	ldrb	r0, [r2, #2]
c0de6b20:	9500      	str	r5, [sp, #0]
c0de6b22:	9401      	str	r4, [sp, #4]
c0de6b24:	1d52      	adds	r2, r2, #5
c0de6b26:	f7fb f841 	bl	c0de1bac <handleSetExternalPlugin>
c0de6b2a:	e74c      	b.n	c0de69c6 <handleApdu+0x11a>
                    handleProvideNFTInformation(G_io_apdu_buffer[OFFSET_P1],
c0de6b2c:	4649      	mov	r1, r9
c0de6b2e:	180a      	adds	r2, r1, r0
                                                G_io_apdu_buffer[OFFSET_LC],
c0de6b30:	7913      	ldrb	r3, [r2, #4]
                                                G_io_apdu_buffer[OFFSET_P2],
c0de6b32:	78d1      	ldrb	r1, [r2, #3]
                    handleProvideNFTInformation(G_io_apdu_buffer[OFFSET_P1],
c0de6b34:	7890      	ldrb	r0, [r2, #2]
c0de6b36:	9500      	str	r5, [sp, #0]
c0de6b38:	9401      	str	r4, [sp, #4]
c0de6b3a:	1d52      	adds	r2, r2, #5
c0de6b3c:	f7fa feda 	bl	c0de18f4 <handleProvideNFTInformation>
c0de6b40:	e741      	b.n	c0de69c6 <handleApdu+0x11a>
c0de6b42:	a803      	add	r0, sp, #12
c0de6b44:	2100      	movs	r1, #0
        CATCH(EXCEPTION_IO_RESET) {
c0de6b46:	8581      	strh	r1, [r0, #44]	; 0x2c
c0de6b48:	980d      	ldr	r0, [sp, #52]	; 0x34
c0de6b4a:	f002 fc01 	bl	c0de9350 <try_context_set>
c0de6b4e:	2005      	movs	r0, #5
            THROW(EXCEPTION_IO_RESET);
c0de6b50:	f000 fc69 	bl	c0de7426 <os_longjmp>
                handleGetWalletId(tx);
c0de6b54:	4620      	mov	r0, r4
c0de6b56:	f7ff fe6b 	bl	c0de6830 <handleGetWalletId>
c0de6b5a:	2037      	movs	r0, #55	; 0x37
c0de6b5c:	0240      	lsls	r0, r0, #9
                THROW(0x6E00);
c0de6b5e:	f000 fc62 	bl	c0de7426 <os_longjmp>
c0de6b62:	206d      	movs	r0, #109	; 0x6d
c0de6b64:	0200      	lsls	r0, r0, #8
c0de6b66:	f000 fc5e 	bl	c0de7426 <os_longjmp>
c0de6b6a:	46c0      	nop			; (mov r8, r8)
c0de6b6c:	00000990 	.word	0x00000990
c0de6b70:	00000124 	.word	0x00000124

c0de6b74 <app_main>:
void app_main(void) {
c0de6b74:	b08e      	sub	sp, #56	; 0x38
c0de6b76:	2600      	movs	r6, #0
    unsigned int tx = 0;
c0de6b78:	960d      	str	r6, [sp, #52]	; 0x34
    unsigned int flags = 0;
c0de6b7a:	960c      	str	r6, [sp, #48]	; 0x30
c0de6b7c:	466d      	mov	r5, sp
            TRY {
c0de6b7e:	4628      	mov	r0, r5
c0de6b80:	f006 ff96 	bl	c0dedab0 <setjmp>
c0de6b84:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0de6b86:	b285      	uxth	r5, r0
c0de6b88:	2d00      	cmp	r5, #0
c0de6b8a:	d016      	beq.n	c0de6bba <app_main+0x46>
c0de6b8c:	2d05      	cmp	r5, #5
c0de6b8e:	d049      	beq.n	c0de6c24 <app_main+0xb0>
c0de6b90:	4604      	mov	r4, r0
c0de6b92:	4668      	mov	r0, sp
            CATCH_OTHER(e) {
c0de6b94:	8586      	strh	r6, [r0, #44]	; 0x2c
c0de6b96:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de6b98:	f002 fbda 	bl	c0de9350 <try_context_set>
c0de6b9c:	200f      	movs	r0, #15
c0de6b9e:	0300      	lsls	r0, r0, #12
                switch (e & 0xF000) {
c0de6ba0:	4020      	ands	r0, r4
c0de6ba2:	2109      	movs	r1, #9
c0de6ba4:	030f      	lsls	r7, r1, #12
c0de6ba6:	42b8      	cmp	r0, r7
c0de6ba8:	d005      	beq.n	c0de6bb6 <app_main+0x42>
c0de6baa:	2103      	movs	r1, #3
c0de6bac:	0349      	lsls	r1, r1, #13
c0de6bae:	4288      	cmp	r0, r1
c0de6bb0:	d116      	bne.n	c0de6be0 <app_main+0x6c>
                        reset_app_context();
c0de6bb2:	f7ff fd57 	bl	c0de6664 <reset_app_context>
c0de6bb6:	0a28      	lsrs	r0, r5, #8
c0de6bb8:	e017      	b.n	c0de6bea <app_main+0x76>
c0de6bba:	4668      	mov	r0, sp
            TRY {
c0de6bbc:	f002 fbc8 	bl	c0de9350 <try_context_set>
c0de6bc0:	900a      	str	r0, [sp, #40]	; 0x28
c0de6bc2:	a80d      	add	r0, sp, #52	; 0x34
                rx = tx;
c0de6bc4:	8801      	ldrh	r1, [r0, #0]
                tx = 0;  // ensure no race in catch_other if io_exchange throws
c0de6bc6:	960d      	str	r6, [sp, #52]	; 0x34
c0de6bc8:	a80c      	add	r0, sp, #48	; 0x30
                rx = io_exchange(CHANNEL_APDU | flags, rx);
c0de6bca:	7800      	ldrb	r0, [r0, #0]
c0de6bcc:	f000 fe5e 	bl	c0de788c <io_exchange>
                flags = 0;
c0de6bd0:	960c      	str	r6, [sp, #48]	; 0x30
                if (rx == 0) {
c0de6bd2:	2800      	cmp	r0, #0
c0de6bd4:	d02e      	beq.n	c0de6c34 <app_main+0xc0>
c0de6bd6:	a80c      	add	r0, sp, #48	; 0x30
c0de6bd8:	a90d      	add	r1, sp, #52	; 0x34
                handleApdu(&flags, &tx);
c0de6bda:	f7ff fe67 	bl	c0de68ac <handleApdu>
c0de6bde:	e013      	b.n	c0de6c08 <app_main+0x94>
                        reset_app_context();
c0de6be0:	f7ff fd40 	bl	c0de6664 <reset_app_context>
                        break;
c0de6be4:	0560      	lsls	r0, r4, #21
c0de6be6:	0f40      	lsrs	r0, r0, #29
c0de6be8:	3068      	adds	r0, #104	; 0x68
                if (e != 0x9000) {
c0de6bea:	42bd      	cmp	r5, r7
c0de6bec:	d003      	beq.n	c0de6bf6 <app_main+0x82>
c0de6bee:	2110      	movs	r1, #16
                    flags &= ~IO_ASYNCH_REPLY;
c0de6bf0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0de6bf2:	438a      	bics	r2, r1
c0de6bf4:	920c      	str	r2, [sp, #48]	; 0x30
                G_io_apdu_buffer[tx] = sw >> 8;
c0de6bf6:	4649      	mov	r1, r9
c0de6bf8:	4a11      	ldr	r2, [pc, #68]	; (c0de6c40 <app_main+0xcc>)
c0de6bfa:	1889      	adds	r1, r1, r2
c0de6bfc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0de6bfe:	5488      	strb	r0, [r1, r2]
c0de6c00:	1888      	adds	r0, r1, r2
                G_io_apdu_buffer[tx + 1] = sw;
c0de6c02:	7044      	strb	r4, [r0, #1]
                tx += 2;
c0de6c04:	1c90      	adds	r0, r2, #2
c0de6c06:	900d      	str	r0, [sp, #52]	; 0x34
            FINALLY {
c0de6c08:	f002 fb98 	bl	c0de933c <try_context_get>
c0de6c0c:	4669      	mov	r1, sp
c0de6c0e:	4288      	cmp	r0, r1
c0de6c10:	d102      	bne.n	c0de6c18 <app_main+0xa4>
c0de6c12:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de6c14:	f002 fb9c 	bl	c0de9350 <try_context_set>
c0de6c18:	4668      	mov	r0, sp
        END_TRY;
c0de6c1a:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de6c1c:	2800      	cmp	r0, #0
c0de6c1e:	d0ad      	beq.n	c0de6b7c <app_main+0x8>
c0de6c20:	f000 fc01 	bl	c0de7426 <os_longjmp>
c0de6c24:	4668      	mov	r0, sp
            CATCH(EXCEPTION_IO_RESET) {
c0de6c26:	8586      	strh	r6, [r0, #44]	; 0x2c
c0de6c28:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de6c2a:	f002 fb91 	bl	c0de9350 <try_context_set>
c0de6c2e:	2005      	movs	r0, #5
                THROW(EXCEPTION_IO_RESET);
c0de6c30:	f000 fbf9 	bl	c0de7426 <os_longjmp>
c0de6c34:	4801      	ldr	r0, [pc, #4]	; (c0de6c3c <app_main+0xc8>)
                    THROW(0x6982);
c0de6c36:	f000 fbf6 	bl	c0de7426 <os_longjmp>
c0de6c3a:	46c0      	nop			; (mov r8, r8)
c0de6c3c:	00006982 	.word	0x00006982
c0de6c40:	00000990 	.word	0x00000990

c0de6c44 <io_seproxyhal_display>:
void io_seproxyhal_display(const bagl_element_t *element) {
c0de6c44:	b580      	push	{r7, lr}
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de6c46:	f000 fd9a 	bl	c0de777e <io_seproxyhal_display_default>
}
c0de6c4a:	bd80      	pop	{r7, pc}

c0de6c4c <io_event>:
unsigned char io_event(__attribute__((unused)) unsigned char channel) {
c0de6c4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch (G_io_seproxyhal_spi_buffer[0]) {
c0de6c4e:	4df6      	ldr	r5, [pc, #984]	; (c0de7028 <io_event+0x3dc>)
c0de6c50:	4648      	mov	r0, r9
c0de6c52:	5d40      	ldrb	r0, [r0, r5]
c0de6c54:	2815      	cmp	r0, #21
c0de6c56:	d05a      	beq.n	c0de6d0e <io_event+0xc2>
c0de6c58:	280c      	cmp	r0, #12
c0de6c5a:	d100      	bne.n	c0de6c5e <io_event+0x12>
c0de6c5c:	e27b      	b.n	c0de7156 <io_event+0x50a>
c0de6c5e:	280d      	cmp	r0, #13
c0de6c60:	d02b      	beq.n	c0de6cba <io_event+0x6e>
c0de6c62:	2805      	cmp	r0, #5
c0de6c64:	d15f      	bne.n	c0de6d26 <io_event+0xda>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0de6c66:	49f1      	ldr	r1, [pc, #964]	; (c0de702c <io_event+0x3e0>)
c0de6c68:	464e      	mov	r6, r9
c0de6c6a:	2001      	movs	r0, #1
c0de6c6c:	5470      	strb	r0, [r6, r1]
c0de6c6e:	1874      	adds	r4, r6, r1
c0de6c70:	2000      	movs	r0, #0
c0de6c72:	4607      	mov	r7, r0
c0de6c74:	6060      	str	r0, [r4, #4]
c0de6c76:	4620      	mov	r0, r4
c0de6c78:	f002 fae4 	bl	c0de9244 <os_ux>
c0de6c7c:	2007      	movs	r0, #7
c0de6c7e:	f002 fb73 	bl	c0de9368 <os_sched_last_status>
c0de6c82:	6060      	str	r0, [r4, #4]
c0de6c84:	4cea      	ldr	r4, [pc, #936]	; (c0de7030 <io_event+0x3e4>)
c0de6c86:	1931      	adds	r1, r6, r4
c0de6c88:	6849      	ldr	r1, [r1, #4]
c0de6c8a:	2900      	cmp	r1, #0
c0de6c8c:	d100      	bne.n	c0de6c90 <io_event+0x44>
c0de6c8e:	e10b      	b.n	c0de6ea8 <io_event+0x25c>
c0de6c90:	2023      	movs	r0, #35	; 0x23
c0de6c92:	f002 fba9 	bl	c0de93e8 <os_ux_get_status>
c0de6c96:	2800      	cmp	r0, #0
c0de6c98:	d100      	bne.n	c0de6c9c <io_event+0x50>
c0de6c9a:	e101      	b.n	c0de6ea0 <io_event+0x254>
c0de6c9c:	4626      	mov	r6, r4
c0de6c9e:	464c      	mov	r4, r9
c0de6ca0:	19a0      	adds	r0, r4, r6
c0de6ca2:	6845      	ldr	r5, [r0, #4]
c0de6ca4:	6047      	str	r7, [r0, #4]
c0de6ca6:	2023      	movs	r0, #35	; 0x23
c0de6ca8:	f002 fb9e 	bl	c0de93e8 <os_ux_get_status>
c0de6cac:	47a8      	blx	r5
c0de6cae:	48df      	ldr	r0, [pc, #892]	; (c0de702c <io_event+0x3e0>)
c0de6cb0:	1820      	adds	r0, r4, r0
c0de6cb2:	4634      	mov	r4, r6
c0de6cb4:	2169      	movs	r1, #105	; 0x69
c0de6cb6:	6041      	str	r1, [r0, #4]
c0de6cb8:	e0ff      	b.n	c0de6eba <io_event+0x26e>
            UX_DISPLAYED_EVENT({});
c0de6cba:	4fdc      	ldr	r7, [pc, #880]	; (c0de702c <io_event+0x3e0>)
c0de6cbc:	464d      	mov	r5, r9
c0de6cbe:	2001      	movs	r0, #1
c0de6cc0:	55e8      	strb	r0, [r5, r7]
c0de6cc2:	19ec      	adds	r4, r5, r7
c0de6cc4:	2600      	movs	r6, #0
c0de6cc6:	6066      	str	r6, [r4, #4]
c0de6cc8:	4620      	mov	r0, r4
c0de6cca:	f002 fabb 	bl	c0de9244 <os_ux>
c0de6cce:	2007      	movs	r0, #7
c0de6cd0:	f002 fb4a 	bl	c0de9368 <os_sched_last_status>
c0de6cd4:	6060      	str	r0, [r4, #4]
c0de6cd6:	4cd6      	ldr	r4, [pc, #856]	; (c0de7030 <io_event+0x3e4>)
c0de6cd8:	1929      	adds	r1, r5, r4
c0de6cda:	6849      	ldr	r1, [r1, #4]
c0de6cdc:	2900      	cmp	r1, #0
c0de6cde:	d100      	bne.n	c0de6ce2 <io_event+0x96>
c0de6ce0:	e141      	b.n	c0de6f66 <io_event+0x31a>
c0de6ce2:	2023      	movs	r0, #35	; 0x23
c0de6ce4:	f002 fb80 	bl	c0de93e8 <os_ux_get_status>
c0de6ce8:	2800      	cmp	r0, #0
c0de6cea:	d100      	bne.n	c0de6cee <io_event+0xa2>
c0de6cec:	e138      	b.n	c0de6f60 <io_event+0x314>
c0de6cee:	4631      	mov	r1, r6
c0de6cf0:	4626      	mov	r6, r4
c0de6cf2:	464c      	mov	r4, r9
c0de6cf4:	19a0      	adds	r0, r4, r6
c0de6cf6:	6845      	ldr	r5, [r0, #4]
c0de6cf8:	9100      	str	r1, [sp, #0]
c0de6cfa:	6041      	str	r1, [r0, #4]
c0de6cfc:	2023      	movs	r0, #35	; 0x23
c0de6cfe:	f002 fb73 	bl	c0de93e8 <os_ux_get_status>
c0de6d02:	47a8      	blx	r5
c0de6d04:	19e0      	adds	r0, r4, r7
c0de6d06:	4634      	mov	r4, r6
c0de6d08:	2169      	movs	r1, #105	; 0x69
c0de6d0a:	6041      	str	r1, [r0, #4]
c0de6d0c:	e135      	b.n	c0de6f7a <io_event+0x32e>
            if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID &&
c0de6d0e:	48c9      	ldr	r0, [pc, #804]	; (c0de7034 <io_event+0x3e8>)
c0de6d10:	4649      	mov	r1, r9
c0de6d12:	1808      	adds	r0, r1, r0
c0de6d14:	7980      	ldrb	r0, [r0, #6]
c0de6d16:	2801      	cmp	r0, #1
c0de6d18:	d105      	bne.n	c0de6d26 <io_event+0xda>
         (buf[off + 2] << 8) | buf[off + 3];
c0de6d1a:	4648      	mov	r0, r9
c0de6d1c:	1940      	adds	r0, r0, r5
c0de6d1e:	7980      	ldrb	r0, [r0, #6]
c0de6d20:	0700      	lsls	r0, r0, #28
c0de6d22:	d400      	bmi.n	c0de6d26 <io_event+0xda>
c0de6d24:	e21f      	b.n	c0de7166 <io_event+0x51a>
            UX_DEFAULT_EVENT();
c0de6d26:	49c1      	ldr	r1, [pc, #772]	; (c0de702c <io_event+0x3e0>)
c0de6d28:	464d      	mov	r5, r9
c0de6d2a:	2001      	movs	r0, #1
c0de6d2c:	5468      	strb	r0, [r5, r1]
c0de6d2e:	186c      	adds	r4, r5, r1
c0de6d30:	2700      	movs	r7, #0
c0de6d32:	6067      	str	r7, [r4, #4]
c0de6d34:	4620      	mov	r0, r4
c0de6d36:	f002 fa85 	bl	c0de9244 <os_ux>
c0de6d3a:	2007      	movs	r0, #7
c0de6d3c:	f002 fb14 	bl	c0de9368 <os_sched_last_status>
c0de6d40:	6060      	str	r0, [r4, #4]
c0de6d42:	4cbb      	ldr	r4, [pc, #748]	; (c0de7030 <io_event+0x3e4>)
c0de6d44:	1929      	adds	r1, r5, r4
c0de6d46:	6849      	ldr	r1, [r1, #4]
c0de6d48:	2900      	cmp	r1, #0
c0de6d4a:	d015      	beq.n	c0de6d78 <io_event+0x12c>
c0de6d4c:	2023      	movs	r0, #35	; 0x23
c0de6d4e:	f002 fb4b 	bl	c0de93e8 <os_ux_get_status>
c0de6d52:	2800      	cmp	r0, #0
c0de6d54:	d00c      	beq.n	c0de6d70 <io_event+0x124>
c0de6d56:	464d      	mov	r5, r9
c0de6d58:	1928      	adds	r0, r5, r4
c0de6d5a:	6846      	ldr	r6, [r0, #4]
c0de6d5c:	6047      	str	r7, [r0, #4]
c0de6d5e:	2023      	movs	r0, #35	; 0x23
c0de6d60:	f002 fb42 	bl	c0de93e8 <os_ux_get_status>
c0de6d64:	47b0      	blx	r6
c0de6d66:	48b1      	ldr	r0, [pc, #708]	; (c0de702c <io_event+0x3e0>)
c0de6d68:	1828      	adds	r0, r5, r0
c0de6d6a:	2169      	movs	r1, #105	; 0x69
c0de6d6c:	6041      	str	r1, [r0, #4]
c0de6d6e:	e005      	b.n	c0de6d7c <io_event+0x130>
c0de6d70:	4648      	mov	r0, r9
c0de6d72:	49ae      	ldr	r1, [pc, #696]	; (c0de702c <io_event+0x3e0>)
c0de6d74:	1840      	adds	r0, r0, r1
c0de6d76:	6840      	ldr	r0, [r0, #4]
c0de6d78:	2869      	cmp	r0, #105	; 0x69
c0de6d7a:	d152      	bne.n	c0de6e22 <io_event+0x1d6>
c0de6d7c:	4620      	mov	r0, r4
c0de6d7e:	464c      	mov	r4, r9
c0de6d80:	1826      	adds	r6, r4, r0
c0de6d82:	f000 fcd1 	bl	c0de7728 <io_seproxyhal_init_ux>
c0de6d86:	f000 fcd1 	bl	c0de772c <io_seproxyhal_init_button>
c0de6d8a:	25ce      	movs	r5, #206	; 0xce
c0de6d8c:	5377      	strh	r7, [r6, r5]
c0de6d8e:	48f7      	ldr	r0, [pc, #988]	; (c0de716c <io_event+0x520>)
c0de6d90:	1824      	adds	r4, r4, r0
c0de6d92:	2007      	movs	r0, #7
c0de6d94:	f002 fae8 	bl	c0de9368 <os_sched_last_status>
c0de6d98:	6060      	str	r0, [r4, #4]
c0de6d9a:	27d0      	movs	r7, #208	; 0xd0
c0de6d9c:	59f1      	ldr	r1, [r6, r7]
c0de6d9e:	2900      	cmp	r1, #0
c0de6da0:	d100      	bne.n	c0de6da4 <io_event+0x158>
c0de6da2:	e1d8      	b.n	c0de7156 <io_event+0x50a>
c0de6da4:	2800      	cmp	r0, #0
c0de6da6:	d100      	bne.n	c0de6daa <io_event+0x15e>
c0de6da8:	e1d5      	b.n	c0de7156 <io_event+0x50a>
c0de6daa:	2897      	cmp	r0, #151	; 0x97
c0de6dac:	d100      	bne.n	c0de6db0 <io_event+0x164>
c0de6dae:	e1d2      	b.n	c0de7156 <io_event+0x50a>
c0de6db0:	4648      	mov	r0, r9
c0de6db2:	49ef      	ldr	r1, [pc, #956]	; (c0de7170 <io_event+0x524>)
c0de6db4:	1840      	adds	r0, r0, r1
c0de6db6:	26d4      	movs	r6, #212	; 0xd4
c0de6db8:	5d81      	ldrb	r1, [r0, r6]
c0de6dba:	5b40      	ldrh	r0, [r0, r5]
c0de6dbc:	4288      	cmp	r0, r1
c0de6dbe:	d300      	bcc.n	c0de6dc2 <io_event+0x176>
c0de6dc0:	e1c9      	b.n	c0de7156 <io_event+0x50a>
c0de6dc2:	f002 fa0b 	bl	c0de91dc <os_perso_isonboarded>
c0de6dc6:	28aa      	cmp	r0, #170	; 0xaa
c0de6dc8:	d104      	bne.n	c0de6dd4 <io_event+0x188>
c0de6dca:	f002 fa2f 	bl	c0de922c <os_global_pin_is_validated>
c0de6dce:	28aa      	cmp	r0, #170	; 0xaa
c0de6dd0:	d000      	beq.n	c0de6dd4 <io_event+0x188>
c0de6dd2:	e1c0      	b.n	c0de7156 <io_event+0x50a>
c0de6dd4:	4648      	mov	r0, r9
c0de6dd6:	4ce6      	ldr	r4, [pc, #920]	; (c0de7170 <io_event+0x524>)
c0de6dd8:	1900      	adds	r0, r0, r4
c0de6dda:	5b40      	ldrh	r0, [r0, r5]
c0de6ddc:	4649      	mov	r1, r9
c0de6dde:	1909      	adds	r1, r1, r4
c0de6de0:	5d8a      	ldrb	r2, [r1, r6]
c0de6de2:	b281      	uxth	r1, r0
c0de6de4:	4291      	cmp	r1, r2
c0de6de6:	d300      	bcc.n	c0de6dea <io_event+0x19e>
c0de6de8:	e119      	b.n	c0de701e <io_event+0x3d2>
c0de6dea:	4648      	mov	r0, r9
c0de6dec:	1900      	adds	r0, r0, r4
c0de6dee:	22dc      	movs	r2, #220	; 0xdc
c0de6df0:	5883      	ldr	r3, [r0, r2]
c0de6df2:	59c2      	ldr	r2, [r0, r7]
c0de6df4:	0148      	lsls	r0, r1, #5
c0de6df6:	1810      	adds	r0, r2, r0
c0de6df8:	2b00      	cmp	r3, #0
c0de6dfa:	d006      	beq.n	c0de6e0a <io_event+0x1be>
c0de6dfc:	4798      	blx	r3
c0de6dfe:	2800      	cmp	r0, #0
c0de6e00:	d009      	beq.n	c0de6e16 <io_event+0x1ca>
c0de6e02:	4649      	mov	r1, r9
c0de6e04:	190a      	adds	r2, r1, r4
c0de6e06:	5b51      	ldrh	r1, [r2, r5]
c0de6e08:	59d2      	ldr	r2, [r2, r7]
c0de6e0a:	2801      	cmp	r0, #1
c0de6e0c:	d101      	bne.n	c0de6e12 <io_event+0x1c6>
c0de6e0e:	0148      	lsls	r0, r1, #5
c0de6e10:	1810      	adds	r0, r2, r0
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de6e12:	f000 fcb4 	bl	c0de777e <io_seproxyhal_display_default>
            UX_DEFAULT_EVENT();
c0de6e16:	4648      	mov	r0, r9
c0de6e18:	1901      	adds	r1, r0, r4
c0de6e1a:	5b48      	ldrh	r0, [r1, r5]
c0de6e1c:	1c40      	adds	r0, r0, #1
c0de6e1e:	5348      	strh	r0, [r1, r5]
c0de6e20:	e7dc      	b.n	c0de6ddc <io_event+0x190>
c0de6e22:	4648      	mov	r0, r9
c0de6e24:	1900      	adds	r0, r0, r4
c0de6e26:	25d0      	movs	r5, #208	; 0xd0
c0de6e28:	5940      	ldr	r0, [r0, r5]
c0de6e2a:	2800      	cmp	r0, #0
c0de6e2c:	d100      	bne.n	c0de6e30 <io_event+0x1e4>
c0de6e2e:	e188      	b.n	c0de7142 <io_event+0x4f6>
c0de6e30:	4648      	mov	r0, r9
c0de6e32:	1900      	adds	r0, r0, r4
c0de6e34:	26d4      	movs	r6, #212	; 0xd4
c0de6e36:	5d81      	ldrb	r1, [r0, r6]
c0de6e38:	27ce      	movs	r7, #206	; 0xce
c0de6e3a:	5bc0      	ldrh	r0, [r0, r7]
c0de6e3c:	4288      	cmp	r0, r1
c0de6e3e:	d300      	bcc.n	c0de6e42 <io_event+0x1f6>
c0de6e40:	e17f      	b.n	c0de7142 <io_event+0x4f6>
c0de6e42:	f002 f9cb 	bl	c0de91dc <os_perso_isonboarded>
c0de6e46:	28aa      	cmp	r0, #170	; 0xaa
c0de6e48:	d104      	bne.n	c0de6e54 <io_event+0x208>
c0de6e4a:	f002 f9ef 	bl	c0de922c <os_global_pin_is_validated>
c0de6e4e:	28aa      	cmp	r0, #170	; 0xaa
c0de6e50:	d000      	beq.n	c0de6e54 <io_event+0x208>
c0de6e52:	e176      	b.n	c0de7142 <io_event+0x4f6>
c0de6e54:	4648      	mov	r0, r9
c0de6e56:	1900      	adds	r0, r0, r4
c0de6e58:	5bc0      	ldrh	r0, [r0, r7]
c0de6e5a:	4649      	mov	r1, r9
c0de6e5c:	1909      	adds	r1, r1, r4
c0de6e5e:	5d8a      	ldrb	r2, [r1, r6]
c0de6e60:	b281      	uxth	r1, r0
c0de6e62:	4291      	cmp	r1, r2
c0de6e64:	d300      	bcc.n	c0de6e68 <io_event+0x21c>
c0de6e66:	e169      	b.n	c0de713c <io_event+0x4f0>
c0de6e68:	4648      	mov	r0, r9
c0de6e6a:	1900      	adds	r0, r0, r4
c0de6e6c:	22dc      	movs	r2, #220	; 0xdc
c0de6e6e:	5883      	ldr	r3, [r0, r2]
c0de6e70:	5942      	ldr	r2, [r0, r5]
c0de6e72:	0148      	lsls	r0, r1, #5
c0de6e74:	1810      	adds	r0, r2, r0
c0de6e76:	2b00      	cmp	r3, #0
c0de6e78:	d006      	beq.n	c0de6e88 <io_event+0x23c>
c0de6e7a:	4798      	blx	r3
c0de6e7c:	2800      	cmp	r0, #0
c0de6e7e:	d009      	beq.n	c0de6e94 <io_event+0x248>
c0de6e80:	4649      	mov	r1, r9
c0de6e82:	190a      	adds	r2, r1, r4
c0de6e84:	5bd1      	ldrh	r1, [r2, r7]
c0de6e86:	5952      	ldr	r2, [r2, r5]
c0de6e88:	2801      	cmp	r0, #1
c0de6e8a:	d101      	bne.n	c0de6e90 <io_event+0x244>
c0de6e8c:	0148      	lsls	r0, r1, #5
c0de6e8e:	1810      	adds	r0, r2, r0
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de6e90:	f000 fc75 	bl	c0de777e <io_seproxyhal_display_default>
            UX_DEFAULT_EVENT();
c0de6e94:	4648      	mov	r0, r9
c0de6e96:	1901      	adds	r1, r0, r4
c0de6e98:	5bc8      	ldrh	r0, [r1, r7]
c0de6e9a:	1c40      	adds	r0, r0, #1
c0de6e9c:	53c8      	strh	r0, [r1, r7]
c0de6e9e:	e7dc      	b.n	c0de6e5a <io_event+0x20e>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0de6ea0:	4648      	mov	r0, r9
c0de6ea2:	49b2      	ldr	r1, [pc, #712]	; (c0de716c <io_event+0x520>)
c0de6ea4:	1840      	adds	r0, r0, r1
c0de6ea6:	6840      	ldr	r0, [r0, #4]
c0de6ea8:	2800      	cmp	r0, #0
c0de6eaa:	d100      	bne.n	c0de6eae <io_event+0x262>
c0de6eac:	e153      	b.n	c0de7156 <io_event+0x50a>
c0de6eae:	2897      	cmp	r0, #151	; 0x97
c0de6eb0:	d100      	bne.n	c0de6eb4 <io_event+0x268>
c0de6eb2:	e150      	b.n	c0de7156 <io_event+0x50a>
c0de6eb4:	2869      	cmp	r0, #105	; 0x69
c0de6eb6:	d000      	beq.n	c0de6eba <io_event+0x26e>
c0de6eb8:	e0be      	b.n	c0de7038 <io_event+0x3ec>
c0de6eba:	464e      	mov	r6, r9
c0de6ebc:	463d      	mov	r5, r7
c0de6ebe:	4627      	mov	r7, r4
c0de6ec0:	1934      	adds	r4, r6, r4
c0de6ec2:	f000 fc31 	bl	c0de7728 <io_seproxyhal_init_ux>
c0de6ec6:	f000 fc31 	bl	c0de772c <io_seproxyhal_init_button>
c0de6eca:	20ce      	movs	r0, #206	; 0xce
c0de6ecc:	5225      	strh	r5, [r4, r0]
c0de6ece:	4605      	mov	r5, r0
c0de6ed0:	48a6      	ldr	r0, [pc, #664]	; (c0de716c <io_event+0x520>)
c0de6ed2:	1836      	adds	r6, r6, r0
c0de6ed4:	2007      	movs	r0, #7
c0de6ed6:	f002 fa47 	bl	c0de9368 <os_sched_last_status>
c0de6eda:	6070      	str	r0, [r6, #4]
c0de6edc:	26d0      	movs	r6, #208	; 0xd0
c0de6ede:	59a1      	ldr	r1, [r4, r6]
c0de6ee0:	2900      	cmp	r1, #0
c0de6ee2:	d100      	bne.n	c0de6ee6 <io_event+0x29a>
c0de6ee4:	e137      	b.n	c0de7156 <io_event+0x50a>
c0de6ee6:	2800      	cmp	r0, #0
c0de6ee8:	d100      	bne.n	c0de6eec <io_event+0x2a0>
c0de6eea:	e134      	b.n	c0de7156 <io_event+0x50a>
c0de6eec:	2897      	cmp	r0, #151	; 0x97
c0de6eee:	d100      	bne.n	c0de6ef2 <io_event+0x2a6>
c0de6ef0:	e131      	b.n	c0de7156 <io_event+0x50a>
c0de6ef2:	463c      	mov	r4, r7
c0de6ef4:	4648      	mov	r0, r9
c0de6ef6:	19c0      	adds	r0, r0, r7
c0de6ef8:	27d4      	movs	r7, #212	; 0xd4
c0de6efa:	5dc1      	ldrb	r1, [r0, r7]
c0de6efc:	5b40      	ldrh	r0, [r0, r5]
c0de6efe:	4288      	cmp	r0, r1
c0de6f00:	d300      	bcc.n	c0de6f04 <io_event+0x2b8>
c0de6f02:	e128      	b.n	c0de7156 <io_event+0x50a>
c0de6f04:	f002 f96a 	bl	c0de91dc <os_perso_isonboarded>
c0de6f08:	28aa      	cmp	r0, #170	; 0xaa
c0de6f0a:	d104      	bne.n	c0de6f16 <io_event+0x2ca>
c0de6f0c:	f002 f98e 	bl	c0de922c <os_global_pin_is_validated>
c0de6f10:	28aa      	cmp	r0, #170	; 0xaa
c0de6f12:	d000      	beq.n	c0de6f16 <io_event+0x2ca>
c0de6f14:	e11f      	b.n	c0de7156 <io_event+0x50a>
c0de6f16:	4648      	mov	r0, r9
c0de6f18:	1900      	adds	r0, r0, r4
c0de6f1a:	5b40      	ldrh	r0, [r0, r5]
c0de6f1c:	4649      	mov	r1, r9
c0de6f1e:	1909      	adds	r1, r1, r4
c0de6f20:	5dca      	ldrb	r2, [r1, r7]
c0de6f22:	b281      	uxth	r1, r0
c0de6f24:	4291      	cmp	r1, r2
c0de6f26:	d27a      	bcs.n	c0de701e <io_event+0x3d2>
c0de6f28:	4648      	mov	r0, r9
c0de6f2a:	1900      	adds	r0, r0, r4
c0de6f2c:	22dc      	movs	r2, #220	; 0xdc
c0de6f2e:	5883      	ldr	r3, [r0, r2]
c0de6f30:	5982      	ldr	r2, [r0, r6]
c0de6f32:	0148      	lsls	r0, r1, #5
c0de6f34:	1810      	adds	r0, r2, r0
c0de6f36:	2b00      	cmp	r3, #0
c0de6f38:	d006      	beq.n	c0de6f48 <io_event+0x2fc>
c0de6f3a:	4798      	blx	r3
c0de6f3c:	2800      	cmp	r0, #0
c0de6f3e:	d009      	beq.n	c0de6f54 <io_event+0x308>
c0de6f40:	4649      	mov	r1, r9
c0de6f42:	190a      	adds	r2, r1, r4
c0de6f44:	5b51      	ldrh	r1, [r2, r5]
c0de6f46:	5992      	ldr	r2, [r2, r6]
c0de6f48:	2801      	cmp	r0, #1
c0de6f4a:	d101      	bne.n	c0de6f50 <io_event+0x304>
c0de6f4c:	0148      	lsls	r0, r1, #5
c0de6f4e:	1810      	adds	r0, r2, r0
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de6f50:	f000 fc15 	bl	c0de777e <io_seproxyhal_display_default>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0de6f54:	4648      	mov	r0, r9
c0de6f56:	1901      	adds	r1, r0, r4
c0de6f58:	5b48      	ldrh	r0, [r1, r5]
c0de6f5a:	1c40      	adds	r0, r0, #1
c0de6f5c:	5348      	strh	r0, [r1, r5]
c0de6f5e:	e7dd      	b.n	c0de6f1c <io_event+0x2d0>
            UX_DISPLAYED_EVENT({});
c0de6f60:	4648      	mov	r0, r9
c0de6f62:	19c0      	adds	r0, r0, r7
c0de6f64:	6840      	ldr	r0, [r0, #4]
c0de6f66:	2800      	cmp	r0, #0
c0de6f68:	d100      	bne.n	c0de6f6c <io_event+0x320>
c0de6f6a:	e0f4      	b.n	c0de7156 <io_event+0x50a>
c0de6f6c:	2897      	cmp	r0, #151	; 0x97
c0de6f6e:	d100      	bne.n	c0de6f72 <io_event+0x326>
c0de6f70:	e0f1      	b.n	c0de7156 <io_event+0x50a>
c0de6f72:	2869      	cmp	r0, #105	; 0x69
c0de6f74:	9600      	str	r6, [sp, #0]
c0de6f76:	d000      	beq.n	c0de6f7a <io_event+0x32e>
c0de6f78:	e0a5      	b.n	c0de70c6 <io_event+0x47a>
c0de6f7a:	464e      	mov	r6, r9
c0de6f7c:	4627      	mov	r7, r4
c0de6f7e:	1934      	adds	r4, r6, r4
c0de6f80:	f000 fbd2 	bl	c0de7728 <io_seproxyhal_init_ux>
c0de6f84:	f000 fbd2 	bl	c0de772c <io_seproxyhal_init_button>
c0de6f88:	25ce      	movs	r5, #206	; 0xce
c0de6f8a:	9800      	ldr	r0, [sp, #0]
c0de6f8c:	5360      	strh	r0, [r4, r5]
c0de6f8e:	4877      	ldr	r0, [pc, #476]	; (c0de716c <io_event+0x520>)
c0de6f90:	1836      	adds	r6, r6, r0
c0de6f92:	2007      	movs	r0, #7
c0de6f94:	f002 f9e8 	bl	c0de9368 <os_sched_last_status>
c0de6f98:	6070      	str	r0, [r6, #4]
c0de6f9a:	26d0      	movs	r6, #208	; 0xd0
c0de6f9c:	59a1      	ldr	r1, [r4, r6]
c0de6f9e:	2900      	cmp	r1, #0
c0de6fa0:	d100      	bne.n	c0de6fa4 <io_event+0x358>
c0de6fa2:	e0d8      	b.n	c0de7156 <io_event+0x50a>
c0de6fa4:	2800      	cmp	r0, #0
c0de6fa6:	d100      	bne.n	c0de6faa <io_event+0x35e>
c0de6fa8:	e0d5      	b.n	c0de7156 <io_event+0x50a>
c0de6faa:	2897      	cmp	r0, #151	; 0x97
c0de6fac:	d100      	bne.n	c0de6fb0 <io_event+0x364>
c0de6fae:	e0d2      	b.n	c0de7156 <io_event+0x50a>
c0de6fb0:	463c      	mov	r4, r7
c0de6fb2:	4648      	mov	r0, r9
c0de6fb4:	19c0      	adds	r0, r0, r7
c0de6fb6:	27d4      	movs	r7, #212	; 0xd4
c0de6fb8:	5dc1      	ldrb	r1, [r0, r7]
c0de6fba:	5b40      	ldrh	r0, [r0, r5]
c0de6fbc:	4288      	cmp	r0, r1
c0de6fbe:	d300      	bcc.n	c0de6fc2 <io_event+0x376>
c0de6fc0:	e0c9      	b.n	c0de7156 <io_event+0x50a>
c0de6fc2:	f002 f90b 	bl	c0de91dc <os_perso_isonboarded>
c0de6fc6:	28aa      	cmp	r0, #170	; 0xaa
c0de6fc8:	d104      	bne.n	c0de6fd4 <io_event+0x388>
c0de6fca:	f002 f92f 	bl	c0de922c <os_global_pin_is_validated>
c0de6fce:	28aa      	cmp	r0, #170	; 0xaa
c0de6fd0:	d000      	beq.n	c0de6fd4 <io_event+0x388>
c0de6fd2:	e0c0      	b.n	c0de7156 <io_event+0x50a>
c0de6fd4:	4648      	mov	r0, r9
c0de6fd6:	1900      	adds	r0, r0, r4
c0de6fd8:	5b40      	ldrh	r0, [r0, r5]
c0de6fda:	4649      	mov	r1, r9
c0de6fdc:	1909      	adds	r1, r1, r4
c0de6fde:	5dca      	ldrb	r2, [r1, r7]
c0de6fe0:	b281      	uxth	r1, r0
c0de6fe2:	4291      	cmp	r1, r2
c0de6fe4:	d21b      	bcs.n	c0de701e <io_event+0x3d2>
c0de6fe6:	4648      	mov	r0, r9
c0de6fe8:	1900      	adds	r0, r0, r4
c0de6fea:	22dc      	movs	r2, #220	; 0xdc
c0de6fec:	5883      	ldr	r3, [r0, r2]
c0de6fee:	5982      	ldr	r2, [r0, r6]
c0de6ff0:	0148      	lsls	r0, r1, #5
c0de6ff2:	1810      	adds	r0, r2, r0
c0de6ff4:	2b00      	cmp	r3, #0
c0de6ff6:	d006      	beq.n	c0de7006 <io_event+0x3ba>
c0de6ff8:	4798      	blx	r3
c0de6ffa:	2800      	cmp	r0, #0
c0de6ffc:	d009      	beq.n	c0de7012 <io_event+0x3c6>
c0de6ffe:	4649      	mov	r1, r9
c0de7000:	190a      	adds	r2, r1, r4
c0de7002:	5b51      	ldrh	r1, [r2, r5]
c0de7004:	5992      	ldr	r2, [r2, r6]
c0de7006:	2801      	cmp	r0, #1
c0de7008:	d101      	bne.n	c0de700e <io_event+0x3c2>
c0de700a:	0148      	lsls	r0, r1, #5
c0de700c:	1810      	adds	r0, r2, r0
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de700e:	f000 fbb6 	bl	c0de777e <io_seproxyhal_display_default>
            UX_DISPLAYED_EVENT({});
c0de7012:	4648      	mov	r0, r9
c0de7014:	1901      	adds	r1, r0, r4
c0de7016:	5b48      	ldrh	r0, [r1, r5]
c0de7018:	1c40      	adds	r0, r0, #1
c0de701a:	5348      	strh	r0, [r1, r5]
c0de701c:	e7dd      	b.n	c0de6fda <io_event+0x38e>
c0de701e:	d000      	beq.n	c0de7022 <io_event+0x3d6>
c0de7020:	e099      	b.n	c0de7156 <io_event+0x50a>
c0de7022:	f002 f9af 	bl	c0de9384 <screen_update>
c0de7026:	e096      	b.n	c0de7156 <io_event+0x50a>
c0de7028:	00000444 	.word	0x00000444
c0de702c:	00000570 	.word	0x00000570
c0de7030:	00000330 	.word	0x00000330
c0de7034:	00000ae4 	.word	0x00000ae4
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0de7038:	4648      	mov	r0, r9
c0de703a:	1900      	adds	r0, r0, r4
c0de703c:	21e0      	movs	r1, #224	; 0xe0
c0de703e:	5840      	ldr	r0, [r0, r1]
c0de7040:	2800      	cmp	r0, #0
c0de7042:	d005      	beq.n	c0de7050 <io_event+0x404>
c0de7044:	4649      	mov	r1, r9
c0de7046:	1949      	adds	r1, r1, r5
c0de7048:	78c9      	ldrb	r1, [r1, #3]
c0de704a:	0849      	lsrs	r1, r1, #1
c0de704c:	f000 fbbe 	bl	c0de77cc <io_seproxyhal_button_push>
c0de7050:	4648      	mov	r0, r9
c0de7052:	1900      	adds	r0, r0, r4
c0de7054:	25d0      	movs	r5, #208	; 0xd0
c0de7056:	5940      	ldr	r0, [r0, r5]
c0de7058:	2800      	cmp	r0, #0
c0de705a:	d072      	beq.n	c0de7142 <io_event+0x4f6>
c0de705c:	4648      	mov	r0, r9
c0de705e:	1900      	adds	r0, r0, r4
c0de7060:	26d4      	movs	r6, #212	; 0xd4
c0de7062:	5d81      	ldrb	r1, [r0, r6]
c0de7064:	27ce      	movs	r7, #206	; 0xce
c0de7066:	5bc0      	ldrh	r0, [r0, r7]
c0de7068:	4288      	cmp	r0, r1
c0de706a:	d26a      	bcs.n	c0de7142 <io_event+0x4f6>
c0de706c:	f002 f8b6 	bl	c0de91dc <os_perso_isonboarded>
c0de7070:	28aa      	cmp	r0, #170	; 0xaa
c0de7072:	d103      	bne.n	c0de707c <io_event+0x430>
c0de7074:	f002 f8da 	bl	c0de922c <os_global_pin_is_validated>
c0de7078:	28aa      	cmp	r0, #170	; 0xaa
c0de707a:	d162      	bne.n	c0de7142 <io_event+0x4f6>
c0de707c:	4648      	mov	r0, r9
c0de707e:	1900      	adds	r0, r0, r4
c0de7080:	5bc0      	ldrh	r0, [r0, r7]
c0de7082:	4649      	mov	r1, r9
c0de7084:	1909      	adds	r1, r1, r4
c0de7086:	5d8a      	ldrb	r2, [r1, r6]
c0de7088:	b281      	uxth	r1, r0
c0de708a:	4291      	cmp	r1, r2
c0de708c:	d256      	bcs.n	c0de713c <io_event+0x4f0>
c0de708e:	4648      	mov	r0, r9
c0de7090:	1900      	adds	r0, r0, r4
c0de7092:	22dc      	movs	r2, #220	; 0xdc
c0de7094:	5883      	ldr	r3, [r0, r2]
c0de7096:	5942      	ldr	r2, [r0, r5]
c0de7098:	0148      	lsls	r0, r1, #5
c0de709a:	1810      	adds	r0, r2, r0
c0de709c:	2b00      	cmp	r3, #0
c0de709e:	d006      	beq.n	c0de70ae <io_event+0x462>
c0de70a0:	4798      	blx	r3
c0de70a2:	2800      	cmp	r0, #0
c0de70a4:	d009      	beq.n	c0de70ba <io_event+0x46e>
c0de70a6:	4649      	mov	r1, r9
c0de70a8:	190a      	adds	r2, r1, r4
c0de70aa:	5bd1      	ldrh	r1, [r2, r7]
c0de70ac:	5952      	ldr	r2, [r2, r5]
c0de70ae:	2801      	cmp	r0, #1
c0de70b0:	d101      	bne.n	c0de70b6 <io_event+0x46a>
c0de70b2:	0148      	lsls	r0, r1, #5
c0de70b4:	1810      	adds	r0, r2, r0
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de70b6:	f000 fb62 	bl	c0de777e <io_seproxyhal_display_default>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0de70ba:	4648      	mov	r0, r9
c0de70bc:	1901      	adds	r1, r0, r4
c0de70be:	5bc8      	ldrh	r0, [r1, r7]
c0de70c0:	1c40      	adds	r0, r0, #1
c0de70c2:	53c8      	strh	r0, [r1, r7]
c0de70c4:	e7dd      	b.n	c0de7082 <io_event+0x436>
            UX_DISPLAYED_EVENT({});
c0de70c6:	4648      	mov	r0, r9
c0de70c8:	1900      	adds	r0, r0, r4
c0de70ca:	25d0      	movs	r5, #208	; 0xd0
c0de70cc:	5940      	ldr	r0, [r0, r5]
c0de70ce:	2800      	cmp	r0, #0
c0de70d0:	d037      	beq.n	c0de7142 <io_event+0x4f6>
c0de70d2:	4648      	mov	r0, r9
c0de70d4:	1900      	adds	r0, r0, r4
c0de70d6:	26d4      	movs	r6, #212	; 0xd4
c0de70d8:	5d81      	ldrb	r1, [r0, r6]
c0de70da:	27ce      	movs	r7, #206	; 0xce
c0de70dc:	5bc0      	ldrh	r0, [r0, r7]
c0de70de:	4288      	cmp	r0, r1
c0de70e0:	d22f      	bcs.n	c0de7142 <io_event+0x4f6>
c0de70e2:	f002 f87b 	bl	c0de91dc <os_perso_isonboarded>
c0de70e6:	28aa      	cmp	r0, #170	; 0xaa
c0de70e8:	d103      	bne.n	c0de70f2 <io_event+0x4a6>
c0de70ea:	f002 f89f 	bl	c0de922c <os_global_pin_is_validated>
c0de70ee:	28aa      	cmp	r0, #170	; 0xaa
c0de70f0:	d127      	bne.n	c0de7142 <io_event+0x4f6>
c0de70f2:	4648      	mov	r0, r9
c0de70f4:	1900      	adds	r0, r0, r4
c0de70f6:	5bc0      	ldrh	r0, [r0, r7]
c0de70f8:	4649      	mov	r1, r9
c0de70fa:	1909      	adds	r1, r1, r4
c0de70fc:	5d8a      	ldrb	r2, [r1, r6]
c0de70fe:	b281      	uxth	r1, r0
c0de7100:	4291      	cmp	r1, r2
c0de7102:	d21b      	bcs.n	c0de713c <io_event+0x4f0>
c0de7104:	4648      	mov	r0, r9
c0de7106:	1900      	adds	r0, r0, r4
c0de7108:	22dc      	movs	r2, #220	; 0xdc
c0de710a:	5883      	ldr	r3, [r0, r2]
c0de710c:	5942      	ldr	r2, [r0, r5]
c0de710e:	0148      	lsls	r0, r1, #5
c0de7110:	1810      	adds	r0, r2, r0
c0de7112:	2b00      	cmp	r3, #0
c0de7114:	d006      	beq.n	c0de7124 <io_event+0x4d8>
c0de7116:	4798      	blx	r3
c0de7118:	2800      	cmp	r0, #0
c0de711a:	d009      	beq.n	c0de7130 <io_event+0x4e4>
c0de711c:	4649      	mov	r1, r9
c0de711e:	190a      	adds	r2, r1, r4
c0de7120:	5bd1      	ldrh	r1, [r2, r7]
c0de7122:	5952      	ldr	r2, [r2, r5]
c0de7124:	2801      	cmp	r0, #1
c0de7126:	d101      	bne.n	c0de712c <io_event+0x4e0>
c0de7128:	0148      	lsls	r0, r1, #5
c0de712a:	1810      	adds	r0, r2, r0
    io_seproxyhal_display_default((bagl_element_t *) element);
c0de712c:	f000 fb27 	bl	c0de777e <io_seproxyhal_display_default>
            UX_DISPLAYED_EVENT({});
c0de7130:	4648      	mov	r0, r9
c0de7132:	1901      	adds	r1, r0, r4
c0de7134:	5bc8      	ldrh	r0, [r1, r7]
c0de7136:	1c40      	adds	r0, r0, #1
c0de7138:	53c8      	strh	r0, [r1, r7]
c0de713a:	e7dd      	b.n	c0de70f8 <io_event+0x4ac>
c0de713c:	d101      	bne.n	c0de7142 <io_event+0x4f6>
c0de713e:	f002 f921 	bl	c0de9384 <screen_update>
c0de7142:	4648      	mov	r0, r9
c0de7144:	1900      	adds	r0, r0, r4
c0de7146:	21d4      	movs	r1, #212	; 0xd4
c0de7148:	5c41      	ldrb	r1, [r0, r1]
c0de714a:	22ce      	movs	r2, #206	; 0xce
c0de714c:	5a80      	ldrh	r0, [r0, r2]
c0de714e:	4288      	cmp	r0, r1
c0de7150:	d301      	bcc.n	c0de7156 <io_event+0x50a>
c0de7152:	f002 f8dd 	bl	c0de9310 <io_seph_is_status_sent>
    if (!io_seproxyhal_spi_is_status_sent()) {
c0de7156:	f002 f8db 	bl	c0de9310 <io_seph_is_status_sent>
c0de715a:	2800      	cmp	r0, #0
c0de715c:	d101      	bne.n	c0de7162 <io_event+0x516>
        io_seproxyhal_general_status();
c0de715e:	f000 f969 	bl	c0de7434 <io_seproxyhal_general_status>
c0de7162:	2001      	movs	r0, #1
    return 1;
c0de7164:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de7166:	2005      	movs	r0, #5
                THROW(EXCEPTION_IO_RESET);
c0de7168:	f000 f95d 	bl	c0de7426 <os_longjmp>
c0de716c:	00000570 	.word	0x00000570
c0de7170:	00000330 	.word	0x00000330

c0de7174 <app_exit>:
void app_exit() {
c0de7174:	b510      	push	{r4, lr}
c0de7176:	b08c      	sub	sp, #48	; 0x30
c0de7178:	466c      	mov	r4, sp
        TRY_L(exit) {
c0de717a:	4620      	mov	r0, r4
c0de717c:	f006 fc98 	bl	c0dedab0 <setjmp>
c0de7180:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0de7182:	0400      	lsls	r0, r0, #16
c0de7184:	d00d      	beq.n	c0de71a2 <app_exit+0x2e>
        FINALLY_L(exit) {
c0de7186:	f002 f8d9 	bl	c0de933c <try_context_get>
c0de718a:	4669      	mov	r1, sp
c0de718c:	4288      	cmp	r0, r1
c0de718e:	d102      	bne.n	c0de7196 <app_exit+0x22>
c0de7190:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de7192:	f002 f8dd 	bl	c0de9350 <try_context_set>
c0de7196:	4668      	mov	r0, sp
    END_TRY_L(exit);
c0de7198:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de719a:	2800      	cmp	r0, #0
c0de719c:	d108      	bne.n	c0de71b0 <app_exit+0x3c>
}
c0de719e:	b00c      	add	sp, #48	; 0x30
c0de71a0:	bd10      	pop	{r4, pc}
c0de71a2:	4668      	mov	r0, sp
        TRY_L(exit) {
c0de71a4:	f002 f8d4 	bl	c0de9350 <try_context_set>
c0de71a8:	900a      	str	r0, [sp, #40]	; 0x28
c0de71aa:	20ff      	movs	r0, #255	; 0xff
            os_sched_exit(-1);
c0de71ac:	f002 f89a 	bl	c0de92e4 <os_sched_exit>
    END_TRY_L(exit);
c0de71b0:	f000 f939 	bl	c0de7426 <os_longjmp>

c0de71b4 <coin_main>:
void coin_main(chain_config_t *coin_config) {
c0de71b4:	b570      	push	{r4, r5, r6, lr}
c0de71b6:	b096      	sub	sp, #88	; 0x58
c0de71b8:	4604      	mov	r4, r0
    if (coin_config == NULL) {
c0de71ba:	2800      	cmp	r0, #0
c0de71bc:	d10c      	bne.n	c0de71d8 <coin_main+0x24>
c0de71be:	ac0e      	add	r4, sp, #56	; 0x38
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0de71c0:	1d60      	adds	r0, r4, #5
c0de71c2:	211b      	movs	r1, #27
c0de71c4:	f006 fb26 	bl	c0ded814 <__aeabi_memclr>
c0de71c8:	2000      	movs	r0, #0
c0de71ca:	7120      	strb	r0, [r4, #4]
    coin_config->kind = CHAIN_KIND;
c0de71cc:	7620      	strb	r0, [r4, #24]
    coin_config->chainId = CHAIN_ID;
c0de71ce:	9013      	str	r0, [sp, #76]	; 0x4c
c0de71d0:	2001      	movs	r0, #1
c0de71d2:	9012      	str	r0, [sp, #72]	; 0x48
c0de71d4:	4830      	ldr	r0, [pc, #192]	; (c0de7298 <coin_main+0xe4>)
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0de71d6:	900e      	str	r0, [sp, #56]	; 0x38
c0de71d8:	4830      	ldr	r0, [pc, #192]	; (c0de729c <coin_main+0xe8>)
c0de71da:	4649      	mov	r1, r9
c0de71dc:	500c      	str	r4, [r1, r0]
    tmpCtx.transactionContext.currentItemIndex = 0;
c0de71de:	4830      	ldr	r0, [pc, #192]	; (c0de72a0 <coin_main+0xec>)
c0de71e0:	180c      	adds	r4, r1, r0
    reset_app_context();
c0de71e2:	f7ff fa3f 	bl	c0de6664 <reset_app_context>
c0de71e6:	2041      	movs	r0, #65	; 0x41
c0de71e8:	0080      	lsls	r0, r0, #2
c0de71ea:	2500      	movs	r5, #0
    tmpCtx.transactionContext.currentItemIndex = 0;
c0de71ec:	5425      	strb	r5, [r4, r0]
c0de71ee:	4e2d      	ldr	r6, [pc, #180]	; (c0de72a4 <coin_main+0xf0>)
        UX_INIT();
c0de71f0:	4648      	mov	r0, r9
c0de71f2:	1980      	adds	r0, r0, r6
c0de71f4:	2145      	movs	r1, #69	; 0x45
c0de71f6:	0089      	lsls	r1, r1, #2
c0de71f8:	f006 fb0c 	bl	c0ded814 <__aeabi_memclr>
c0de71fc:	ac02      	add	r4, sp, #8
            TRY {
c0de71fe:	4620      	mov	r0, r4
c0de7200:	f006 fc56 	bl	c0dedab0 <setjmp>
c0de7204:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0de7206:	b284      	uxth	r4, r0
c0de7208:	2c00      	cmp	r4, #0
c0de720a:	d00d      	beq.n	c0de7228 <coin_main+0x74>
c0de720c:	a802      	add	r0, sp, #8
c0de720e:	8585      	strh	r5, [r0, #44]	; 0x2c
c0de7210:	980c      	ldr	r0, [sp, #48]	; 0x30
c0de7212:	f002 f89d 	bl	c0de9350 <try_context_set>
c0de7216:	980c      	ldr	r0, [sp, #48]	; 0x30
c0de7218:	f002 f89a 	bl	c0de9350 <try_context_set>
c0de721c:	2c05      	cmp	r4, #5
c0de721e:	d0e7      	beq.n	c0de71f0 <coin_main+0x3c>
    app_exit();
c0de7220:	f7ff ffa8 	bl	c0de7174 <app_exit>
}
c0de7224:	b016      	add	sp, #88	; 0x58
c0de7226:	bd70      	pop	{r4, r5, r6, pc}
c0de7228:	a802      	add	r0, sp, #8
            TRY {
c0de722a:	f002 f891 	bl	c0de9350 <try_context_set>
c0de722e:	900c      	str	r0, [sp, #48]	; 0x30
                io_seproxyhal_init();
c0de7230:	f000 fa50 	bl	c0de76d4 <io_seproxyhal_init>
c0de7234:	2006      	movs	r0, #6
c0de7236:	2400      	movs	r4, #0
                G_io_app.plane_mode = os_setting_get(OS_SETTING_PLANEMODE, NULL, 0);
c0de7238:	4621      	mov	r1, r4
c0de723a:	4622      	mov	r2, r4
c0de723c:	f002 f83a 	bl	c0de92b4 <os_setting_get>
c0de7240:	4919      	ldr	r1, [pc, #100]	; (c0de72a8 <coin_main+0xf4>)
c0de7242:	464a      	mov	r2, r9
c0de7244:	1851      	adds	r1, r2, r1
c0de7246:	61c8      	str	r0, [r1, #28]
                if (N_storage.initialized != 0x01) {
c0de7248:	4818      	ldr	r0, [pc, #96]	; (c0de72ac <coin_main+0xf8>)
c0de724a:	4478      	add	r0, pc
c0de724c:	f000 fffa 	bl	c0de8244 <pic>
c0de7250:	7900      	ldrb	r0, [r0, #4]
c0de7252:	2801      	cmp	r0, #1
c0de7254:	d00b      	beq.n	c0de726e <coin_main+0xba>
c0de7256:	466d      	mov	r5, sp
c0de7258:	2001      	movs	r0, #1
                    storage.initialized = 0x01;
c0de725a:	7128      	strb	r0, [r5, #4]
                    storage.dataAllowed = 0x00;
c0de725c:	9400      	str	r4, [sp, #0]
                    nvm_write((void *) &N_storage, (void *) &storage, sizeof(internalStorage_t));
c0de725e:	4814      	ldr	r0, [pc, #80]	; (c0de72b0 <coin_main+0xfc>)
c0de7260:	4478      	add	r0, pc
c0de7262:	f000 ffef 	bl	c0de8244 <pic>
c0de7266:	2205      	movs	r2, #5
c0de7268:	4629      	mov	r1, r5
c0de726a:	f001 ff9f 	bl	c0de91ac <nvm_write>
c0de726e:	2400      	movs	r4, #0
                USB_power(0);
c0de7270:	4620      	mov	r0, r4
c0de7272:	f005 f82d 	bl	c0dec2d0 <USB_power>
c0de7276:	2501      	movs	r5, #1
                USB_power(1);
c0de7278:	4628      	mov	r0, r5
c0de727a:	f005 f829 	bl	c0dec2d0 <USB_power>
                ui_idle();
c0de727e:	f7ff fa21 	bl	c0de66c4 <ui_idle>
                BLE_power(0, NULL);
c0de7282:	4620      	mov	r0, r4
c0de7284:	4621      	mov	r1, r4
c0de7286:	f7fe fbab 	bl	c0de59e0 <BLE_power>
                BLE_power(1, "Nano X");
c0de728a:	490a      	ldr	r1, [pc, #40]	; (c0de72b4 <coin_main+0x100>)
c0de728c:	4479      	add	r1, pc
c0de728e:	4628      	mov	r0, r5
c0de7290:	f7fe fba6 	bl	c0de59e0 <BLE_power>
                app_main();
c0de7294:	f7ff fc6e 	bl	c0de6b74 <app_main>
c0de7298:	20485445 	.word	0x20485445
c0de729c:	00000590 	.word	0x00000590
c0de72a0:	00000124 	.word	0x00000124
c0de72a4:	00000330 	.word	0x00000330
c0de72a8:	00000ae4 	.word	0x00000ae4
c0de72ac:	0000a4b2 	.word	0x0000a4b2
c0de72b0:	0000a49c 	.word	0x0000a49c
c0de72b4:	00006ede 	.word	0x00006ede

c0de72b8 <library_main>:
void library_main(struct libargs_s *args) {
c0de72b8:	b094      	sub	sp, #80	; 0x50
c0de72ba:	4604      	mov	r4, r0
    if (args->chain_config == NULL) {
c0de72bc:	6880      	ldr	r0, [r0, #8]
c0de72be:	2800      	cmp	r0, #0
c0de72c0:	d10d      	bne.n	c0de72de <library_main+0x26>
c0de72c2:	ad0c      	add	r5, sp, #48	; 0x30
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0de72c4:	1d68      	adds	r0, r5, #5
c0de72c6:	211b      	movs	r1, #27
c0de72c8:	f006 faa4 	bl	c0ded814 <__aeabi_memclr>
c0de72cc:	2000      	movs	r0, #0
c0de72ce:	7128      	strb	r0, [r5, #4]
    coin_config->kind = CHAIN_KIND;
c0de72d0:	7628      	strb	r0, [r5, #24]
        args->chain_config = &coin_config;
c0de72d2:	60a5      	str	r5, [r4, #8]
    coin_config->chainId = CHAIN_ID;
c0de72d4:	9011      	str	r0, [sp, #68]	; 0x44
c0de72d6:	2001      	movs	r0, #1
c0de72d8:	9010      	str	r0, [sp, #64]	; 0x40
c0de72da:	4824      	ldr	r0, [pc, #144]	; (c0de736c <library_main+0xb4>)
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0de72dc:	900c      	str	r0, [sp, #48]	; 0x30
c0de72de:	2600      	movs	r6, #0
c0de72e0:	466d      	mov	r5, sp
            TRY {
c0de72e2:	4628      	mov	r0, r5
c0de72e4:	f006 fbe4 	bl	c0dedab0 <setjmp>
c0de72e8:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0de72ea:	0400      	lsls	r0, r0, #16
c0de72ec:	d107      	bne.n	c0de72fe <library_main+0x46>
c0de72ee:	4668      	mov	r0, sp
c0de72f0:	f002 f82e 	bl	c0de9350 <try_context_set>
c0de72f4:	900a      	str	r0, [sp, #40]	; 0x28
                if (!end) {
c0de72f6:	07f0      	lsls	r0, r6, #31
c0de72f8:	d00f      	beq.n	c0de731a <library_main+0x62>
                os_lib_end();
c0de72fa:	f001 ffbb 	bl	c0de9274 <os_lib_end>
            FINALLY {
c0de72fe:	f002 f81d 	bl	c0de933c <try_context_get>
c0de7302:	4669      	mov	r1, sp
c0de7304:	4288      	cmp	r0, r1
c0de7306:	d102      	bne.n	c0de730e <library_main+0x56>
c0de7308:	980a      	ldr	r0, [sp, #40]	; 0x28
c0de730a:	f002 f821 	bl	c0de9350 <try_context_set>
c0de730e:	4668      	mov	r0, sp
        END_TRY;
c0de7310:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0de7312:	2800      	cmp	r0, #0
c0de7314:	d125      	bne.n	c0de7362 <library_main+0xaa>
c0de7316:	2601      	movs	r6, #1
c0de7318:	e7e2      	b.n	c0de72e0 <library_main+0x28>
// get API level
SYSCALL unsigned int get_api_level(void);

#ifndef HAVE_BOLOS
static inline void check_api_level(unsigned int apiLevel) {
  if (apiLevel < get_api_level()) {
c0de731a:	f001 ff31 	bl	c0de9180 <get_api_level>
c0de731e:	280d      	cmp	r0, #13
c0de7320:	d221      	bcs.n	c0de7366 <library_main+0xae>
    switch (args->command) {
c0de7322:	6860      	ldr	r0, [r4, #4]
c0de7324:	2802      	cmp	r0, #2
c0de7326:	d012      	beq.n	c0de734e <library_main+0x96>
c0de7328:	2804      	cmp	r0, #4
c0de732a:	d00b      	beq.n	c0de7344 <library_main+0x8c>
c0de732c:	2803      	cmp	r0, #3
c0de732e:	d1e4      	bne.n	c0de72fa <library_main+0x42>
            args->check_address->result = 0;
c0de7330:	68e0      	ldr	r0, [r4, #12]
c0de7332:	2100      	movs	r1, #0
c0de7334:	6181      	str	r1, [r0, #24]
                handle_check_address(args->check_address, args->chain_config);
c0de7336:	68a1      	ldr	r1, [r4, #8]
c0de7338:	68e0      	ldr	r0, [r4, #12]
c0de733a:	f7fd fd4b 	bl	c0de4dd4 <handle_check_address>
            args->check_address->result =
c0de733e:	68e1      	ldr	r1, [r4, #12]
c0de7340:	6188      	str	r0, [r1, #24]
c0de7342:	e7da      	b.n	c0de72fa <library_main+0x42>
            handle_get_printable_amount(args->get_printable_amount, args->chain_config);
c0de7344:	68a1      	ldr	r1, [r4, #8]
c0de7346:	68e0      	ldr	r0, [r4, #12]
c0de7348:	f7fd fdba 	bl	c0de4ec0 <handle_get_printable_amount>
c0de734c:	e7d5      	b.n	c0de72fa <library_main+0x42>
            if (copy_transaction_parameters(args->create_transaction, args->chain_config)) {
c0de734e:	68a1      	ldr	r1, [r4, #8]
c0de7350:	68e0      	ldr	r0, [r4, #12]
c0de7352:	f7fd fdf3 	bl	c0de4f3c <copy_transaction_parameters>
c0de7356:	2800      	cmp	r0, #0
c0de7358:	d0cf      	beq.n	c0de72fa <library_main+0x42>
                handle_swap_sign_transaction(args->chain_config);
c0de735a:	68a0      	ldr	r0, [r4, #8]
c0de735c:	f7fd fe42 	bl	c0de4fe4 <handle_swap_sign_transaction>
c0de7360:	e7cb      	b.n	c0de72fa <library_main+0x42>
        END_TRY;
c0de7362:	f000 f860 	bl	c0de7426 <os_longjmp>
c0de7366:	20ff      	movs	r0, #255	; 0xff
    os_sched_exit(-1);
c0de7368:	f001 ffbc 	bl	c0de92e4 <os_sched_exit>
c0de736c:	20485445 	.word	0x20485445

c0de7370 <get_chain_id>:
    {.chain_id = 11297108109, .name = "Palm Network", .ticker = "PALM "},
    {.chain_id = 1818, .name = "Cube", .ticker = "CUBE "},
    {.chain_id = 336, .name = "Shiden", .ticker = "SDN "},
    {.chain_id = 592, .name = "Astar", .ticker = "ASTR "}};

uint64_t get_chain_id(void) {
c0de7370:	b580      	push	{r7, lr}
    uint64_t chain_id = 0;

    switch (txContext.txType) {
c0de7372:	4a0e      	ldr	r2, [pc, #56]	; (c0de73ac <get_chain_id+0x3c>)
c0de7374:	4648      	mov	r0, r9
c0de7376:	1880      	adds	r0, r0, r2
c0de7378:	213c      	movs	r1, #60	; 0x3c
c0de737a:	5c41      	ldrb	r1, [r0, r1]
c0de737c:	1e48      	subs	r0, r1, #1
c0de737e:	2802      	cmp	r0, #2
c0de7380:	d206      	bcs.n	c0de7390 <get_chain_id+0x20>
            chain_id = u64_from_BE(txContext.content->v, txContext.content->vLength);
            break;
        case EIP2930:
        case EIP1559:
            chain_id = u64_from_BE(tmpContent.txContent.chainID.value,
                                   tmpContent.txContent.chainID.length);
c0de7382:	480b      	ldr	r0, [pc, #44]	; (c0de73b0 <get_chain_id+0x40>)
c0de7384:	4649      	mov	r1, r9
c0de7386:	1808      	adds	r0, r1, r0
c0de7388:	21a4      	movs	r1, #164	; 0xa4
c0de738a:	5c41      	ldrb	r1, [r0, r1]
            chain_id = u64_from_BE(tmpContent.txContent.chainID.value,
c0de738c:	3084      	adds	r0, #132	; 0x84
c0de738e:	e009      	b.n	c0de73a4 <get_chain_id+0x34>
c0de7390:	2000      	movs	r0, #0
    switch (txContext.txType) {
c0de7392:	29c0      	cmp	r1, #192	; 0xc0
c0de7394:	4601      	mov	r1, r0
c0de7396:	d107      	bne.n	c0de73a8 <get_chain_id+0x38>
            chain_id = u64_from_BE(txContext.content->v, txContext.content->vLength);
c0de7398:	4648      	mov	r0, r9
c0de739a:	1880      	adds	r0, r0, r2
c0de739c:	6b40      	ldr	r0, [r0, #52]	; 0x34
c0de739e:	21c2      	movs	r1, #194	; 0xc2
c0de73a0:	5c41      	ldrb	r1, [r0, r1]
c0de73a2:	30ba      	adds	r0, #186	; 0xba
c0de73a4:	f005 f866 	bl	c0dec474 <u64_from_BE>
            break;
        default:
            PRINTF("Txtype `%d` not supported while generating chainID\n", txContext.txType);
            break;
    }
    return chain_id;
c0de73a8:	bd80      	pop	{r7, pc}
c0de73aa:	46c0      	nop			; (mov r8, r8)
c0de73ac:	0000022c 	.word	0x0000022c
c0de73b0:	0000026c 	.word	0x0000026c

c0de73b4 <get_network>:
}

const network_info_t *get_network(void) {
c0de73b4:	b5b0      	push	{r4, r5, r7, lr}
c0de73b6:	4c0b      	ldr	r4, [pc, #44]	; (c0de73e4 <get_network+0x30>)
c0de73b8:	447c      	add	r4, pc
c0de73ba:	2513      	movs	r5, #19
    uint64_t chain_id = get_chain_id();
c0de73bc:	f7ff ffd8 	bl	c0de7370 <get_chain_id>
    for (size_t i = 0; i < sizeof(NETWORK_MAPPING) / sizeof(*NETWORK_MAPPING); i++) {
c0de73c0:	2d00      	cmp	r5, #0
c0de73c2:	d008      	beq.n	c0de73d6 <get_network+0x22>
        if (NETWORK_MAPPING[i].chain_id == chain_id) {
c0de73c4:	69a2      	ldr	r2, [r4, #24]
c0de73c6:	69e3      	ldr	r3, [r4, #28]
c0de73c8:	404b      	eors	r3, r1
c0de73ca:	4042      	eors	r2, r0
c0de73cc:	431a      	orrs	r2, r3
c0de73ce:	d004      	beq.n	c0de73da <get_network+0x26>
    for (size_t i = 0; i < sizeof(NETWORK_MAPPING) / sizeof(*NETWORK_MAPPING); i++) {
c0de73d0:	1e6d      	subs	r5, r5, #1
c0de73d2:	3420      	adds	r4, #32
c0de73d4:	e7f4      	b.n	c0de73c0 <get_network+0xc>
c0de73d6:	2000      	movs	r0, #0
            return (const network_info_t *) PIC(&NETWORK_MAPPING[i]);
        }
    }
    return NULL;
}
c0de73d8:	bdb0      	pop	{r4, r5, r7, pc}
            return (const network_info_t *) PIC(&NETWORK_MAPPING[i]);
c0de73da:	4620      	mov	r0, r4
c0de73dc:	f000 ff32 	bl	c0de8244 <pic>
}
c0de73e0:	bdb0      	pop	{r4, r5, r7, pc}
c0de73e2:	46c0      	nop			; (mov r8, r8)
c0de73e4:	0000a074 	.word	0x0000a074

c0de73e8 <get_network_name>:

const char *get_network_name(void) {
c0de73e8:	b580      	push	{r7, lr}
    const network_info_t *network = get_network();
c0de73ea:	f7ff ffe3 	bl	c0de73b4 <get_network>
    if (network == NULL) {
c0de73ee:	2800      	cmp	r0, #0
c0de73f0:	d002      	beq.n	c0de73f8 <get_network_name+0x10>
        return NULL;
    } else {
        return (const char *) PIC(network->name);
c0de73f2:	f000 ff27 	bl	c0de8244 <pic>
    }
}
c0de73f6:	bd80      	pop	{r7, pc}
c0de73f8:	2000      	movs	r0, #0
c0de73fa:	bd80      	pop	{r7, pc}

c0de73fc <get_network_ticker>:

const char *get_network_ticker(void) {
c0de73fc:	b580      	push	{r7, lr}
    const network_info_t *network = get_network();
c0de73fe:	f7ff ffd9 	bl	c0de73b4 <get_network>
    if (network == NULL) {
c0de7402:	2800      	cmp	r0, #0
c0de7404:	d003      	beq.n	c0de740e <get_network_ticker+0x12>
        return chainConfig->coinName;
    } else {
        return (char *) PIC(network->ticker);
c0de7406:	3010      	adds	r0, #16
c0de7408:	f000 ff1c 	bl	c0de8244 <pic>
    }
}
c0de740c:	bd80      	pop	{r7, pc}
        return chainConfig->coinName;
c0de740e:	4802      	ldr	r0, [pc, #8]	; (c0de7418 <get_network_ticker+0x1c>)
c0de7410:	4649      	mov	r1, r9
c0de7412:	5808      	ldr	r0, [r1, r0]
}
c0de7414:	bd80      	pop	{r7, pc}
c0de7416:	46c0      	nop			; (mov r8, r8)
c0de7418:	00000590 	.word	0x00000590

c0de741c <os_boot>:

// apdu buffer must hold a complete apdu to avoid troubles
unsigned char G_io_apdu_buffer[IO_APDU_BUFFER_SIZE];

#ifndef BOLOS_OS_UPGRADER_APP
void os_boot(void) {
c0de741c:	b580      	push	{r7, lr}
c0de741e:	2000      	movs	r0, #0
  // // TODO patch entry point when romming (f)
  // // set the default try context to nothing
#ifndef HAVE_BOLOS
  try_context_set(NULL);
c0de7420:	f001 ff96 	bl	c0de9350 <try_context_set>
#endif // HAVE_BOLOS
}
c0de7424:	bd80      	pop	{r7, pc}

c0de7426 <os_longjmp>:
  }
  return xoracc;
}

#ifndef HAVE_BOLOS
void os_longjmp(unsigned int exception) {
c0de7426:	4604      	mov	r4, r0
#ifdef HAVE_PRINTF  
  unsigned int lr_val;
  __asm volatile("mov %0, lr" :"=r"(lr_val));
  PRINTF("exception[%d]: LR=0x%08X\n", exception, lr_val);
#endif // HAVE_PRINTF
  longjmp(try_context_get()->jmp_buf, exception);
c0de7428:	f001 ff88 	bl	c0de933c <try_context_get>
c0de742c:	4621      	mov	r1, r4
c0de742e:	f006 fb4b 	bl	c0dedac8 <longjmp>
c0de7432:	d4d4      	bmi.n	c0de73de <get_network+0x2a>

c0de7434 <io_seproxyhal_general_status>:
  0,
  2,
  SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND>>8,
  SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND,
};
void io_seproxyhal_general_status(void) {
c0de7434:	b580      	push	{r7, lr}
  // send the general status
  io_seproxyhal_spi_send(seph_io_general_status, sizeof(seph_io_general_status));
c0de7436:	4803      	ldr	r0, [pc, #12]	; (c0de7444 <io_seproxyhal_general_status+0x10>)
c0de7438:	4478      	add	r0, pc
c0de743a:	2105      	movs	r1, #5
c0de743c:	f001 ff5e 	bl	c0de92fc <io_seph_send>
}
c0de7440:	bd80      	pop	{r7, pc}
c0de7442:	46c0      	nop			; (mov r8, r8)
c0de7444:	00008920 	.word	0x00008920

c0de7448 <io_seproxyhal_handle_usb_event>:
}

#ifdef HAVE_IO_USB
#ifdef HAVE_L4_USBLIB

void io_seproxyhal_handle_usb_event(void) {
c0de7448:	b5b0      	push	{r4, r5, r7, lr}
  switch(G_io_seproxyhal_spi_buffer[3]) {
c0de744a:	481b      	ldr	r0, [pc, #108]	; (c0de74b8 <io_seproxyhal_handle_usb_event+0x70>)
c0de744c:	4649      	mov	r1, r9
c0de744e:	1808      	adds	r0, r1, r0
c0de7450:	78c0      	ldrb	r0, [r0, #3]
c0de7452:	2808      	cmp	r0, #8
c0de7454:	d027      	beq.n	c0de74a6 <io_seproxyhal_handle_usb_event+0x5e>
c0de7456:	2802      	cmp	r0, #2
c0de7458:	d019      	beq.n	c0de748e <io_seproxyhal_handle_usb_event+0x46>
c0de745a:	2804      	cmp	r0, #4
c0de745c:	d01d      	beq.n	c0de749a <io_seproxyhal_handle_usb_event+0x52>
c0de745e:	2801      	cmp	r0, #1
c0de7460:	d126      	bne.n	c0de74b0 <io_seproxyhal_handle_usb_event+0x68>
    case SEPROXYHAL_TAG_USB_EVENT_RESET:
      USBD_LL_SetSpeed(&USBD_Device, USBD_SPEED_FULL);
c0de7462:	4816      	ldr	r0, [pc, #88]	; (c0de74bc <io_seproxyhal_handle_usb_event+0x74>)
c0de7464:	464d      	mov	r5, r9
c0de7466:	182c      	adds	r4, r5, r0
c0de7468:	2101      	movs	r1, #1
c0de746a:	4620      	mov	r0, r4
c0de746c:	f004 fac9 	bl	c0deba02 <USBD_LL_SetSpeed>
      USBD_LL_Reset(&USBD_Device);
c0de7470:	4620      	mov	r0, r4
c0de7472:	f004 faa6 	bl	c0deb9c2 <USBD_LL_Reset>
      // ongoing APDU detected, throw a reset, even if not the media. to avoid potential troubles.
      if (G_io_app.apdu_media != IO_APDU_MEDIA_NONE) {
c0de7476:	4812      	ldr	r0, [pc, #72]	; (c0de74c0 <io_seproxyhal_handle_usb_event+0x78>)
c0de7478:	1829      	adds	r1, r5, r0
c0de747a:	7989      	ldrb	r1, [r1, #6]
c0de747c:	2900      	cmp	r1, #0
c0de747e:	d118      	bne.n	c0de74b2 <io_seproxyhal_handle_usb_event+0x6a>
        THROW(EXCEPTION_IO_RESET);
      }
      memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
c0de7480:	4649      	mov	r1, r9
c0de7482:	1808      	adds	r0, r1, r0
c0de7484:	2100      	movs	r1, #0
c0de7486:	60c1      	str	r1, [r0, #12]
      memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
c0de7488:	6101      	str	r1, [r0, #16]
c0de748a:	6141      	str	r1, [r0, #20]
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
      break;
  }
}
c0de748c:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_SOF(&USBD_Device);
c0de748e:	480b      	ldr	r0, [pc, #44]	; (c0de74bc <io_seproxyhal_handle_usb_event+0x74>)
c0de7490:	4649      	mov	r1, r9
c0de7492:	1808      	adds	r0, r1, r0
c0de7494:	f004 fabc 	bl	c0deba10 <USBD_LL_SOF>
}
c0de7498:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_Suspend(&USBD_Device);
c0de749a:	4808      	ldr	r0, [pc, #32]	; (c0de74bc <io_seproxyhal_handle_usb_event+0x74>)
c0de749c:	4649      	mov	r1, r9
c0de749e:	1808      	adds	r0, r1, r0
c0de74a0:	f004 fab2 	bl	c0deba08 <USBD_LL_Suspend>
}
c0de74a4:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_Resume(&USBD_Device);
c0de74a6:	4805      	ldr	r0, [pc, #20]	; (c0de74bc <io_seproxyhal_handle_usb_event+0x74>)
c0de74a8:	4649      	mov	r1, r9
c0de74aa:	1808      	adds	r0, r1, r0
c0de74ac:	f004 faae 	bl	c0deba0c <USBD_LL_Resume>
}
c0de74b0:	bdb0      	pop	{r4, r5, r7, pc}
c0de74b2:	2005      	movs	r0, #5
        THROW(EXCEPTION_IO_RESET);
c0de74b4:	f7ff ffb7 	bl	c0de7426 <os_longjmp>
c0de74b8:	00000444 	.word	0x00000444
c0de74bc:	00000bf0 	.word	0x00000bf0
c0de74c0:	00000ae4 	.word	0x00000ae4

c0de74c4 <io_seproxyhal_get_ep_rx_size>:

uint16_t io_seproxyhal_get_ep_rx_size(uint8_t epnum) {
c0de74c4:	217f      	movs	r1, #127	; 0x7f
  if ((epnum & 0x7F) < IO_USB_MAX_ENDPOINTS) {
c0de74c6:	4001      	ands	r1, r0
c0de74c8:	2903      	cmp	r1, #3
c0de74ca:	d805      	bhi.n	c0de74d8 <io_seproxyhal_get_ep_rx_size+0x14>
    return G_io_app.usb_ep_xfer_len[epnum&0x7F];
c0de74cc:	4803      	ldr	r0, [pc, #12]	; (c0de74dc <io_seproxyhal_get_ep_rx_size+0x18>)
c0de74ce:	464a      	mov	r2, r9
c0de74d0:	1810      	adds	r0, r2, r0
c0de74d2:	1840      	adds	r0, r0, r1
c0de74d4:	7b00      	ldrb	r0, [r0, #12]
  }
  return 0;
}
c0de74d6:	4770      	bx	lr
c0de74d8:	2000      	movs	r0, #0
c0de74da:	4770      	bx	lr
c0de74dc:	00000ae4 	.word	0x00000ae4

c0de74e0 <io_seproxyhal_handle_usb_ep_xfer_event>:

void io_seproxyhal_handle_usb_ep_xfer_event(void) {
c0de74e0:	b510      	push	{r4, lr}
  uint8_t epnum;

  epnum = G_io_seproxyhal_spi_buffer[3] & 0x7F;
c0de74e2:	4a1a      	ldr	r2, [pc, #104]	; (c0de754c <io_seproxyhal_handle_usb_ep_xfer_event+0x6c>)
c0de74e4:	4648      	mov	r0, r9
c0de74e6:	1880      	adds	r0, r0, r2
c0de74e8:	78c3      	ldrb	r3, [r0, #3]
c0de74ea:	217f      	movs	r1, #127	; 0x7f
c0de74ec:	4019      	ands	r1, r3

  switch(G_io_seproxyhal_spi_buffer[4]) {
c0de74ee:	7900      	ldrb	r0, [r0, #4]
c0de74f0:	2804      	cmp	r0, #4
c0de74f2:	d01b      	beq.n	c0de752c <io_seproxyhal_handle_usb_ep_xfer_event+0x4c>
c0de74f4:	2802      	cmp	r0, #2
c0de74f6:	d009      	beq.n	c0de750c <io_seproxyhal_handle_usb_ep_xfer_event+0x2c>
c0de74f8:	2801      	cmp	r0, #1
c0de74fa:	d125      	bne.n	c0de7548 <io_seproxyhal_handle_usb_ep_xfer_event+0x68>
    /* This event is received when a new SETUP token had been received on a control endpoint */
    case SEPROXYHAL_TAG_USB_EP_XFER_SETUP:
      // assume length of setup packet, and that it is on endpoint 0
      USBD_LL_SetupStage(&USBD_Device, &G_io_seproxyhal_spi_buffer[6]);
c0de74fc:	4815      	ldr	r0, [pc, #84]	; (c0de7554 <io_seproxyhal_handle_usb_ep_xfer_event+0x74>)
c0de74fe:	4649      	mov	r1, r9
c0de7500:	1808      	adds	r0, r1, r0
c0de7502:	1889      	adds	r1, r1, r2
c0de7504:	1d89      	adds	r1, r1, #6
c0de7506:	f004 f967 	bl	c0deb7d8 <USBD_LL_SetupStage>
        // prepare reception
        USBD_LL_DataOutStage(&USBD_Device, epnum, &G_io_seproxyhal_spi_buffer[6]);
      }
      break;
  }
}
c0de750a:	bd10      	pop	{r4, pc}
      if (epnum < IO_USB_MAX_ENDPOINTS) {
c0de750c:	2903      	cmp	r1, #3
c0de750e:	d81b      	bhi.n	c0de7548 <io_seproxyhal_handle_usb_ep_xfer_event+0x68>
        G_io_app.usb_ep_timeouts[epnum].timeout = 0;
c0de7510:	480f      	ldr	r0, [pc, #60]	; (c0de7550 <io_seproxyhal_handle_usb_ep_xfer_event+0x70>)
c0de7512:	464b      	mov	r3, r9
c0de7514:	1818      	adds	r0, r3, r0
c0de7516:	004c      	lsls	r4, r1, #1
c0de7518:	1900      	adds	r0, r0, r4
c0de751a:	2400      	movs	r4, #0
c0de751c:	8204      	strh	r4, [r0, #16]
        USBD_LL_DataInStage(&USBD_Device, epnum, &G_io_seproxyhal_spi_buffer[6]);
c0de751e:	480d      	ldr	r0, [pc, #52]	; (c0de7554 <io_seproxyhal_handle_usb_ep_xfer_event+0x74>)
c0de7520:	1818      	adds	r0, r3, r0
c0de7522:	189a      	adds	r2, r3, r2
c0de7524:	1d92      	adds	r2, r2, #6
c0de7526:	f004 f9db 	bl	c0deb8e0 <USBD_LL_DataInStage>
}
c0de752a:	bd10      	pop	{r4, pc}
      if (epnum < IO_USB_MAX_ENDPOINTS) {
c0de752c:	2903      	cmp	r1, #3
c0de752e:	d80b      	bhi.n	c0de7548 <io_seproxyhal_handle_usb_ep_xfer_event+0x68>
        G_io_app.usb_ep_xfer_len[epnum] = G_io_seproxyhal_spi_buffer[5];
c0de7530:	4807      	ldr	r0, [pc, #28]	; (c0de7550 <io_seproxyhal_handle_usb_ep_xfer_event+0x70>)
c0de7532:	464b      	mov	r3, r9
c0de7534:	1818      	adds	r0, r3, r0
c0de7536:	1840      	adds	r0, r0, r1
c0de7538:	189a      	adds	r2, r3, r2
c0de753a:	7954      	ldrb	r4, [r2, #5]
c0de753c:	7304      	strb	r4, [r0, #12]
        USBD_LL_DataOutStage(&USBD_Device, epnum, &G_io_seproxyhal_spi_buffer[6]);
c0de753e:	4805      	ldr	r0, [pc, #20]	; (c0de7554 <io_seproxyhal_handle_usb_ep_xfer_event+0x74>)
c0de7540:	1818      	adds	r0, r3, r0
c0de7542:	1d92      	adds	r2, r2, #6
c0de7544:	f004 f976 	bl	c0deb834 <USBD_LL_DataOutStage>
}
c0de7548:	bd10      	pop	{r4, pc}
c0de754a:	46c0      	nop			; (mov r8, r8)
c0de754c:	00000444 	.word	0x00000444
c0de7550:	00000ae4 	.word	0x00000ae4
c0de7554:	00000bf0 	.word	0x00000bf0

c0de7558 <io_usb_send_ep>:
#endif // HAVE_L4_USBLIB

// TODO, refactor this using the USB DataIn event like for the U2F tunnel
// TODO add a blocking parameter, for HID KBD sending, or use a USB busy flag per channel to know if
// the transfer has been processed or not. and move on to the next transfer on the same endpoint
void io_usb_send_ep(unsigned int ep, unsigned char* buffer, unsigned short length, unsigned int timeout) {
c0de7558:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (timeout) {
    timeout++;
  }

  // won't send if overflowing seproxyhal buffer format
  if (length > 255) {
c0de755a:	2aff      	cmp	r2, #255	; 0xff
c0de755c:	d820      	bhi.n	c0de75a0 <io_usb_send_ep+0x48>
c0de755e:	4615      	mov	r5, r2
c0de7560:	460e      	mov	r6, r1
c0de7562:	4604      	mov	r4, r0
    return;
  }

  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0de7564:	480f      	ldr	r0, [pc, #60]	; (c0de75a4 <io_usb_send_ep+0x4c>)
c0de7566:	464f      	mov	r7, r9
c0de7568:	2150      	movs	r1, #80	; 0x50
c0de756a:	5439      	strb	r1, [r7, r0]
c0de756c:	1838      	adds	r0, r7, r0
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
  G_io_seproxyhal_spi_buffer[2] = (3+length);
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
  G_io_seproxyhal_spi_buffer[5] = length;
c0de756e:	7142      	strb	r2, [r0, #5]
c0de7570:	2120      	movs	r1, #32
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0de7572:	7101      	strb	r1, [r0, #4]
c0de7574:	2180      	movs	r1, #128	; 0x80
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
c0de7576:	4321      	orrs	r1, r4
c0de7578:	70c1      	strb	r1, [r0, #3]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0de757a:	1cd1      	adds	r1, r2, #3
  G_io_seproxyhal_spi_buffer[2] = (3+length);
c0de757c:	7081      	strb	r1, [r0, #2]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0de757e:	0a09      	lsrs	r1, r1, #8
c0de7580:	7041      	strb	r1, [r0, #1]
c0de7582:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 6);
c0de7584:	f001 feba 	bl	c0de92fc <io_seph_send>
  io_seproxyhal_spi_send(buffer, length);
c0de7588:	4630      	mov	r0, r6
c0de758a:	4629      	mov	r1, r5
c0de758c:	f001 feb6 	bl	c0de92fc <io_seph_send>
  // setup timeout of the endpoint
  G_io_app.usb_ep_timeouts[ep&0x7F].timeout = IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0de7590:	4805      	ldr	r0, [pc, #20]	; (c0de75a8 <io_usb_send_ep+0x50>)
c0de7592:	1838      	adds	r0, r7, r0
c0de7594:	0661      	lsls	r1, r4, #25
c0de7596:	0e09      	lsrs	r1, r1, #24
c0de7598:	1840      	adds	r0, r0, r1
c0de759a:	217d      	movs	r1, #125	; 0x7d
c0de759c:	0109      	lsls	r1, r1, #4
c0de759e:	8201      	strh	r1, [r0, #16]
}
c0de75a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de75a2:	46c0      	nop			; (mov r8, r8)
c0de75a4:	00000444 	.word	0x00000444
c0de75a8:	00000ae4 	.word	0x00000ae4

c0de75ac <io_usb_send_apdu_data>:

void io_usb_send_apdu_data(unsigned char* buffer, unsigned short length) {
c0de75ac:	b580      	push	{r7, lr}
c0de75ae:	460a      	mov	r2, r1
c0de75b0:	4601      	mov	r1, r0
c0de75b2:	2082      	movs	r0, #130	; 0x82
c0de75b4:	2314      	movs	r3, #20
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x82, buffer, length, 20);
c0de75b6:	f7ff ffcf 	bl	c0de7558 <io_usb_send_ep>
}
c0de75ba:	bd80      	pop	{r7, pc}

c0de75bc <io_usb_send_apdu_data_ep0x83>:

#ifdef HAVE_WEBUSB
void io_usb_send_apdu_data_ep0x83(unsigned char* buffer, unsigned short length) {
c0de75bc:	b580      	push	{r7, lr}
c0de75be:	460a      	mov	r2, r1
c0de75c0:	4601      	mov	r1, r0
c0de75c2:	2083      	movs	r0, #131	; 0x83
c0de75c4:	2314      	movs	r3, #20
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x83, buffer, length, 20);
c0de75c6:	f7ff ffc7 	bl	c0de7558 <io_usb_send_ep>
}
c0de75ca:	bd80      	pop	{r7, pc}

c0de75cc <io_seproxyhal_handle_capdu_event>:
#endif // HAVE_WEBUSB

#endif // HAVE_IO_USB

void io_seproxyhal_handle_capdu_event(void) {
c0de75cc:	b510      	push	{r4, lr}
  if (G_io_app.apdu_state == APDU_IDLE) {
c0de75ce:	490f      	ldr	r1, [pc, #60]	; (c0de760c <io_seproxyhal_handle_capdu_event+0x40>)
c0de75d0:	4648      	mov	r0, r9
c0de75d2:	5c40      	ldrb	r0, [r0, r1]
c0de75d4:	2800      	cmp	r0, #0
c0de75d6:	d000      	beq.n	c0de75da <io_seproxyhal_handle_capdu_event+0xe>
    G_io_app.apdu_state = APDU_RAW; // for next call to io_exchange
    G_io_app.apdu_length = MIN(size, max);
    // copy apdu to apdu buffer
    memcpy(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_app.apdu_length);
  }
}
c0de75d8:	bd10      	pop	{r4, pc}
  return (buf[off] << 8) | buf[off + 1];
c0de75da:	4648      	mov	r0, r9
c0de75dc:	220a      	movs	r2, #10
    G_io_app.apdu_state = APDU_RAW; // for next call to io_exchange
c0de75de:	5442      	strb	r2, [r0, r1]
    G_io_app.apdu_media = IO_APDU_MEDIA_RAW; // for application code
c0de75e0:	1841      	adds	r1, r0, r1
c0de75e2:	2206      	movs	r2, #6
c0de75e4:	718a      	strb	r2, [r1, #6]
c0de75e6:	4a0a      	ldr	r2, [pc, #40]	; (c0de7610 <io_seproxyhal_handle_capdu_event+0x44>)
c0de75e8:	1883      	adds	r3, r0, r2
c0de75ea:	789a      	ldrb	r2, [r3, #2]
c0de75ec:	785c      	ldrb	r4, [r3, #1]
c0de75ee:	0224      	lsls	r4, r4, #8
c0de75f0:	18a2      	adds	r2, r4, r2
c0de75f2:	24ff      	movs	r4, #255	; 0xff
c0de75f4:	342a      	adds	r4, #42	; 0x2a
    G_io_app.apdu_length = MIN(size, max);
c0de75f6:	42a2      	cmp	r2, r4
c0de75f8:	d300      	bcc.n	c0de75fc <io_seproxyhal_handle_capdu_event+0x30>
c0de75fa:	4622      	mov	r2, r4
c0de75fc:	804a      	strh	r2, [r1, #2]
    memcpy(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_app.apdu_length);
c0de75fe:	4905      	ldr	r1, [pc, #20]	; (c0de7614 <io_seproxyhal_handle_capdu_event+0x48>)
c0de7600:	1840      	adds	r0, r0, r1
c0de7602:	1cd9      	adds	r1, r3, #3
c0de7604:	f006 f90c 	bl	c0ded820 <__aeabi_memcpy>
}
c0de7608:	bd10      	pop	{r4, pc}
c0de760a:	46c0      	nop			; (mov r8, r8)
c0de760c:	00000ae4 	.word	0x00000ae4
c0de7610:	00000444 	.word	0x00000444
c0de7614:	00000990 	.word	0x00000990

c0de7618 <io_seproxyhal_handle_event>:

unsigned int io_seproxyhal_handle_event(void) {
c0de7618:	b510      	push	{r4, lr}
c0de761a:	492c      	ldr	r1, [pc, #176]	; (c0de76cc <io_seproxyhal_handle_event+0xb4>)
c0de761c:	464a      	mov	r2, r9
#if defined(HAVE_IO_USB) || defined(HAVE_BLE)
  unsigned int rx_len = U2BE(G_io_seproxyhal_spi_buffer, 1);
#endif

  switch(G_io_seproxyhal_spi_buffer[0]) {
c0de761e:	5c50      	ldrb	r0, [r2, r1]
c0de7620:	280e      	cmp	r0, #14
c0de7622:	d01b      	beq.n	c0de765c <io_seproxyhal_handle_event+0x44>
c0de7624:	2818      	cmp	r0, #24
c0de7626:	d00f      	beq.n	c0de7648 <io_seproxyhal_handle_event+0x30>
c0de7628:	1851      	adds	r1, r2, r1
c0de762a:	788a      	ldrb	r2, [r1, #2]
c0de762c:	7849      	ldrb	r1, [r1, #1]
c0de762e:	0209      	lsls	r1, r1, #8
c0de7630:	1889      	adds	r1, r1, r2
c0de7632:	2810      	cmp	r0, #16
c0de7634:	d00b      	beq.n	c0de764e <io_seproxyhal_handle_event+0x36>
c0de7636:	2816      	cmp	r0, #22
c0de7638:	d00d      	beq.n	c0de7656 <io_seproxyhal_handle_event+0x3e>
c0de763a:	280f      	cmp	r0, #15
c0de763c:	d137      	bne.n	c0de76ae <io_seproxyhal_handle_event+0x96>
  #ifdef HAVE_IO_USB
    case SEPROXYHAL_TAG_USB_EVENT:
      if (rx_len != 1) {
c0de763e:	2901      	cmp	r1, #1
c0de7640:	d107      	bne.n	c0de7652 <io_seproxyhal_handle_event+0x3a>
        return 0;
      }
      io_seproxyhal_handle_usb_event();
c0de7642:	f7ff ff01 	bl	c0de7448 <io_seproxyhal_handle_usb_event>
c0de7646:	e038      	b.n	c0de76ba <io_seproxyhal_handle_event+0xa2>
      return 1;
  #endif // HAVE_IO_USB

  #ifdef HAVE_BLE
    case SEPROXYHAL_TAG_BLE_RECV_EVENT:
      LEDGER_BLE_receive();
c0de7648:	f7fd fec8 	bl	c0de53dc <LEDGER_BLE_receive>
c0de764c:	e035      	b.n	c0de76ba <io_seproxyhal_handle_event+0xa2>
      if (rx_len < 3) {
c0de764e:	2903      	cmp	r1, #3
c0de7650:	d231      	bcs.n	c0de76b6 <io_seproxyhal_handle_event+0x9e>
c0de7652:	2000      	movs	r0, #0
    default:
      return io_event(CHANNEL_SPI);
  }
  // defaultly return as not processed
  return 0;
}
c0de7654:	bd10      	pop	{r4, pc}
      io_seproxyhal_handle_capdu_event();
c0de7656:	f7ff ffb9 	bl	c0de75cc <io_seproxyhal_handle_capdu_event>
c0de765a:	e02e      	b.n	c0de76ba <io_seproxyhal_handle_event+0xa2>
      G_io_app.ms += 100; // value is by default, don't change the ticker configuration
c0de765c:	481c      	ldr	r0, [pc, #112]	; (c0de76d0 <io_seproxyhal_handle_event+0xb8>)
c0de765e:	4649      	mov	r1, r9
c0de7660:	1809      	adds	r1, r1, r0
c0de7662:	688a      	ldr	r2, [r1, #8]
c0de7664:	3264      	adds	r2, #100	; 0x64
c0de7666:	608a      	str	r2, [r1, #8]
c0de7668:	2116      	movs	r1, #22
        while(i--) {
c0de766a:	290e      	cmp	r1, #14
c0de766c:	d010      	beq.n	c0de7690 <io_seproxyhal_handle_event+0x78>
          if (G_io_app.usb_ep_timeouts[i].timeout) {
c0de766e:	464a      	mov	r2, r9
c0de7670:	1812      	adds	r2, r2, r0
c0de7672:	5a52      	ldrh	r2, [r2, r1]
c0de7674:	2a00      	cmp	r2, #0
c0de7676:	d009      	beq.n	c0de768c <io_seproxyhal_handle_event+0x74>
            G_io_app.usb_ep_timeouts[i].timeout-=MIN(G_io_app.usb_ep_timeouts[i].timeout, 100);
c0de7678:	464b      	mov	r3, r9
c0de767a:	181b      	adds	r3, r3, r0
c0de767c:	2a64      	cmp	r2, #100	; 0x64
c0de767e:	4614      	mov	r4, r2
c0de7680:	d800      	bhi.n	c0de7684 <io_seproxyhal_handle_event+0x6c>
c0de7682:	2464      	movs	r4, #100	; 0x64
c0de7684:	3c64      	subs	r4, #100	; 0x64
c0de7686:	525c      	strh	r4, [r3, r1]
            if (!G_io_app.usb_ep_timeouts[i].timeout) {
c0de7688:	2a65      	cmp	r2, #101	; 0x65
c0de768a:	d318      	bcc.n	c0de76be <io_seproxyhal_handle_event+0xa6>
c0de768c:	1e89      	subs	r1, r1, #2
c0de768e:	e7ec      	b.n	c0de766a <io_seproxyhal_handle_event+0x52>
        if (G_io_app.ble_xfer_timeout) {
c0de7690:	4649      	mov	r1, r9
c0de7692:	1809      	adds	r1, r1, r0
c0de7694:	8b09      	ldrh	r1, [r1, #24]
c0de7696:	2900      	cmp	r1, #0
c0de7698:	d009      	beq.n	c0de76ae <io_seproxyhal_handle_event+0x96>
          G_io_app.ble_xfer_timeout -= MIN(G_io_app.ble_xfer_timeout, 100);
c0de769a:	464a      	mov	r2, r9
c0de769c:	1812      	adds	r2, r2, r0
c0de769e:	2964      	cmp	r1, #100	; 0x64
c0de76a0:	460b      	mov	r3, r1
c0de76a2:	d800      	bhi.n	c0de76a6 <io_seproxyhal_handle_event+0x8e>
c0de76a4:	2364      	movs	r3, #100	; 0x64
c0de76a6:	3b64      	subs	r3, #100	; 0x64
c0de76a8:	8313      	strh	r3, [r2, #24]
          if (!G_io_app.ble_xfer_timeout) {
c0de76aa:	2964      	cmp	r1, #100	; 0x64
c0de76ac:	d907      	bls.n	c0de76be <io_seproxyhal_handle_event+0xa6>
c0de76ae:	2002      	movs	r0, #2
      return io_event(CHANNEL_SPI);
c0de76b0:	f7ff facc 	bl	c0de6c4c <io_event>
}
c0de76b4:	bd10      	pop	{r4, pc}
      io_seproxyhal_handle_usb_ep_xfer_event();
c0de76b6:	f7ff ff13 	bl	c0de74e0 <io_seproxyhal_handle_usb_ep_xfer_event>
c0de76ba:	2001      	movs	r0, #1
}
c0de76bc:	bd10      	pop	{r4, pc}
c0de76be:	4649      	mov	r1, r9
c0de76c0:	2200      	movs	r2, #0
c0de76c2:	540a      	strb	r2, [r1, r0]
c0de76c4:	2005      	movs	r0, #5
c0de76c6:	f7ff feae 	bl	c0de7426 <os_longjmp>
c0de76ca:	46c0      	nop			; (mov r8, r8)
c0de76cc:	00000444 	.word	0x00000444
c0de76d0:	00000ae4 	.word	0x00000ae4

c0de76d4 <io_seproxyhal_init>:
  1,
  SEPROXYHAL_TAG_MCU_TYPE_PROTECT,
};
#endif // (!defined(HAVE_BOLOS) && defined(HAVE_MCU_PROTECT))

void io_seproxyhal_init(void) {
c0de76d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (apiLevel < get_api_level()) {
c0de76d6:	f001 fd53 	bl	c0de9180 <get_api_level>
c0de76da:	280d      	cmp	r0, #13
c0de76dc:	d21a      	bcs.n	c0de7714 <io_seproxyhal_init+0x40>
  // Enforce OS compatibility
  check_api_level(CX_COMPAT_APILEVEL);

#ifdef HAVE_MCU_PROTECT
  // engage RDP2 on MCU
  io_seproxyhal_spi_send(seph_io_mcu_protect, sizeof(seph_io_mcu_protect));
c0de76de:	4811      	ldr	r0, [pc, #68]	; (c0de7724 <io_seproxyhal_init+0x50>)
c0de76e0:	4478      	add	r0, pc
c0de76e2:	2104      	movs	r1, #4
c0de76e4:	f001 fe0a 	bl	c0de92fc <io_seph_send>
  app_stack_canary = APP_STACK_CANARY_MAGIC;
#endif // HAVE_BOLOS_APP_STACK_CANARY

  // wipe the io structure before it's used
#ifdef HAVE_BLE
  unsigned int plane = G_io_app.plane_mode;
c0de76e8:	480c      	ldr	r0, [pc, #48]	; (c0de771c <io_seproxyhal_init+0x48>)
c0de76ea:	464d      	mov	r5, r9
c0de76ec:	182c      	adds	r4, r5, r0
c0de76ee:	69e7      	ldr	r7, [r4, #28]
c0de76f0:	2124      	movs	r1, #36	; 0x24
#endif // HAVE_BLE
  memset(&G_io_app, 0, sizeof(G_io_app));
c0de76f2:	4620      	mov	r0, r4
c0de76f4:	f006 f88e 	bl	c0ded814 <__aeabi_memclr>
c0de76f8:	2600      	movs	r6, #0
#ifdef HAVE_BLE
  G_io_app.plane_mode = plane;
#endif // HAVE_BLE

  G_io_app.apdu_state = APDU_IDLE;
c0de76fa:	4808      	ldr	r0, [pc, #32]	; (c0de771c <io_seproxyhal_init+0x48>)
c0de76fc:	542e      	strb	r6, [r5, r0]
  G_io_app.apdu_length = 0;
  G_io_app.apdu_media = IO_APDU_MEDIA_NONE;

  G_io_app.ms = 0;
c0de76fe:	60a6      	str	r6, [r4, #8]
  G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0de7700:	71a6      	strb	r6, [r4, #6]
  G_io_app.apdu_length = 0;
c0de7702:	8066      	strh	r6, [r4, #2]
  G_io_app.plane_mode = plane;
c0de7704:	61e7      	str	r7, [r4, #28]
  #ifdef DEBUG_APDU
  debug_apdus_offset = 0;
  #endif // DEBUG_APDU

  #ifdef HAVE_USB_APDU
  io_usb_hid_init();
c0de7706:	f000 fb29 	bl	c0de7d5c <io_usb_hid_init>
#endif // TARGET_BLUE
}

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_ux_os.button_mask = 0;
c0de770a:	4805      	ldr	r0, [pc, #20]	; (c0de7720 <io_seproxyhal_init+0x4c>)
c0de770c:	502e      	str	r6, [r5, r0]
c0de770e:	1828      	adds	r0, r5, r0
  G_ux_os.button_same_mask_counter = 0;
c0de7710:	6046      	str	r6, [r0, #4]
}
c0de7712:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de7714:	20ff      	movs	r0, #255	; 0xff
    os_sched_exit(-1);
c0de7716:	f001 fde5 	bl	c0de92e4 <os_sched_exit>
c0de771a:	46c0      	nop			; (mov r8, r8)
c0de771c:	00000ae4 	.word	0x00000ae4
c0de7720:	00000b08 	.word	0x00000b08
c0de7724:	0000867d 	.word	0x0000867d

c0de7728 <io_seproxyhal_init_ux>:
}
c0de7728:	4770      	bx	lr
c0de772a:	d4d4      	bmi.n	c0de76d6 <io_seproxyhal_init+0x2>

c0de772c <io_seproxyhal_init_button>:
  G_ux_os.button_mask = 0;
c0de772c:	4803      	ldr	r0, [pc, #12]	; (c0de773c <io_seproxyhal_init_button+0x10>)
c0de772e:	4649      	mov	r1, r9
c0de7730:	2200      	movs	r2, #0
c0de7732:	500a      	str	r2, [r1, r0]
c0de7734:	1808      	adds	r0, r1, r0
  G_ux_os.button_same_mask_counter = 0;
c0de7736:	6042      	str	r2, [r0, #4]
}
c0de7738:	4770      	bx	lr
c0de773a:	46c0      	nop			; (mov r8, r8)
c0de773c:	00000b08 	.word	0x00000b08

c0de7740 <io_seproxyhal_display_icon>:
  // remaining length of bitmap bits to be displayed
  return len;
}
#endif // SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS

void io_seproxyhal_display_icon(bagl_component_t* icon_component, bagl_icon_details_t* icon_det) {
c0de7740:	b5b0      	push	{r4, r5, r7, lr}
c0de7742:	b088      	sub	sp, #32
c0de7744:	4605      	mov	r5, r0
  bagl_component_t icon_component_mod;
  const bagl_icon_details_t* icon_details = (bagl_icon_details_t*)PIC(icon_det);
c0de7746:	4608      	mov	r0, r1
c0de7748:	f000 fd7c 	bl	c0de8244 <pic>

  if (icon_details && icon_details->bitmap) {
c0de774c:	2800      	cmp	r0, #0
c0de774e:	d014      	beq.n	c0de777a <io_seproxyhal_display_icon+0x3a>
c0de7750:	4604      	mov	r4, r0
c0de7752:	6900      	ldr	r0, [r0, #16]
c0de7754:	2800      	cmp	r0, #0
c0de7756:	d010      	beq.n	c0de777a <io_seproxyhal_display_icon+0x3a>
    // ensure not being out of bounds in the icon component agianst the declared icon real size
    memcpy(&icon_component_mod, (void *)PIC(icon_component), sizeof(bagl_component_t));
c0de7758:	4628      	mov	r0, r5
c0de775a:	f000 fd73 	bl	c0de8244 <pic>
c0de775e:	4601      	mov	r1, r0
c0de7760:	ad01      	add	r5, sp, #4
c0de7762:	221c      	movs	r2, #28
c0de7764:	4628      	mov	r0, r5
c0de7766:	f006 f85b 	bl	c0ded820 <__aeabi_memcpy>
    icon_component_mod.width = icon_details->width;
c0de776a:	6820      	ldr	r0, [r4, #0]
c0de776c:	80e8      	strh	r0, [r5, #6]
    icon_component_mod.height = icon_details->height;
c0de776e:	6860      	ldr	r0, [r4, #4]
c0de7770:	8128      	strh	r0, [r5, #8]
      icon_len -= len;
      icon_off += len;
    }
#else // !SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS
#ifdef HAVE_SE_SCREEN
    bagl_draw_glyph(&icon_component_mod, icon_details);
c0de7772:	4628      	mov	r0, r5
c0de7774:	4621      	mov	r1, r4
c0de7776:	f7f9 fa3c 	bl	c0de0bf2 <bagl_draw_glyph>
    io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->colors), h);
    io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->bitmap), w);
#endif // !HAVE_SE_SCREEN || (HAVE_SE_SCREEN && HAVE_PRINTF)
#endif // !SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS
  }
}
c0de777a:	b008      	add	sp, #32
c0de777c:	bdb0      	pop	{r4, r5, r7, pc}

c0de777e <io_seproxyhal_display_default>:

void io_seproxyhal_display_default(const bagl_element_t* element) {
c0de777e:	b5b0      	push	{r4, r5, r7, lr}

  const bagl_element_t* el = (const bagl_element_t*) PIC(element);
c0de7780:	f000 fd60 	bl	c0de8244 <pic>
c0de7784:	4604      	mov	r4, r0
  const char* txt = (const char*)PIC(el->text);
c0de7786:	69c0      	ldr	r0, [r0, #28]
c0de7788:	f000 fd5c 	bl	c0de8244 <pic>
c0de778c:	4605      	mov	r5, r0
  // process automagically address from rom and from ram
  unsigned int type = (el->component.type & ~(BAGL_FLAG_TOUCHABLE));
c0de778e:	7821      	ldrb	r1, [r4, #0]
c0de7790:	207f      	movs	r0, #127	; 0x7f
c0de7792:	4008      	ands	r0, r1

  if (type != BAGL_NONE) {
c0de7794:	d014      	beq.n	c0de77c0 <io_seproxyhal_display_default+0x42>
    if (txt != NULL) {
c0de7796:	2d00      	cmp	r5, #0
c0de7798:	d00c      	beq.n	c0de77b4 <io_seproxyhal_display_default+0x36>
      // consider an icon details descriptor is pointed by the context
      if (type == BAGL_ICON && el->component.icon_id == 0) {
c0de779a:	2805      	cmp	r0, #5
c0de779c:	d102      	bne.n	c0de77a4 <io_seproxyhal_display_default+0x26>
c0de779e:	7ea0      	ldrb	r0, [r4, #26]
c0de77a0:	2800      	cmp	r0, #0
c0de77a2:	d00e      	beq.n	c0de77c2 <io_seproxyhal_display_default+0x44>
        //           belonging in the syscall dispatch
        io_seproxyhal_display_icon((bagl_component_t*)&el->component, (bagl_icon_details_t*)txt);
      }
      else {
#ifdef HAVE_SE_SCREEN
        bagl_draw_with_context(&el->component, txt, strlen(txt), BAGL_ENCODING_LATIN1);
c0de77a4:	4628      	mov	r0, r5
c0de77a6:	f006 fa3b 	bl	c0dedc20 <strlen>
c0de77aa:	b282      	uxth	r2, r0
c0de77ac:	2300      	movs	r3, #0
c0de77ae:	4620      	mov	r0, r4
c0de77b0:	4629      	mov	r1, r5
c0de77b2:	e003      	b.n	c0de77bc <io_seproxyhal_display_default+0x3e>
c0de77b4:	2100      	movs	r1, #0
#endif // !HAVE_SE_SCREEN || (HAVE_SE_SCREEN && HAVE_PRINTF)
      }
    }
    else {
#ifdef HAVE_SE_SCREEN
      bagl_draw_with_context(&el->component, NULL, 0, 0);
c0de77b6:	4620      	mov	r0, r4
c0de77b8:	460a      	mov	r2, r1
c0de77ba:	460b      	mov	r3, r1
c0de77bc:	f7f8 fc3c 	bl	c0de0038 <bagl_draw_with_context>
      io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
      io_seproxyhal_spi_send((unsigned char*)&el->component, sizeof(bagl_component_t));
#endif // !HAVE_SE_SCREEN || (HAVE_SE_SCREEN && HAVE_PRINTF)
    }
  }
}
c0de77c0:	bdb0      	pop	{r4, r5, r7, pc}
        io_seproxyhal_display_icon((bagl_component_t*)&el->component, (bagl_icon_details_t*)txt);
c0de77c2:	4620      	mov	r0, r4
c0de77c4:	4629      	mov	r1, r5
c0de77c6:	f7ff ffbb 	bl	c0de7740 <io_seproxyhal_display_icon>
}
c0de77ca:	bdb0      	pop	{r4, r5, r7, pc}

c0de77cc <io_seproxyhal_button_push>:

  // compute scrolled text length
  return 2*(textlen - e->component.width)*1000/e->component.icon_id + 2*(e->component.stroke & ~(0x80))*100;
}

void io_seproxyhal_button_push(button_push_callback_t button_callback, unsigned int new_button_mask) {
c0de77cc:	b570      	push	{r4, r5, r6, lr}
  if (button_callback) {
c0de77ce:	2800      	cmp	r0, #0
c0de77d0:	d030      	beq.n	c0de7834 <io_seproxyhal_button_push+0x68>
c0de77d2:	4604      	mov	r4, r0
    unsigned int button_mask;
    unsigned int button_same_mask_counter;
    // enable speeded up long push
    if (new_button_mask == G_ux_os.button_mask) {
c0de77d4:	4818      	ldr	r0, [pc, #96]	; (c0de7838 <io_seproxyhal_button_push+0x6c>)
c0de77d6:	464a      	mov	r2, r9
c0de77d8:	5815      	ldr	r5, [r2, r0]
c0de77da:	1812      	adds	r2, r2, r0
c0de77dc:	6856      	ldr	r6, [r2, #4]
c0de77de:	428d      	cmp	r5, r1
c0de77e0:	d103      	bne.n	c0de77ea <io_seproxyhal_button_push+0x1e>
      // each 100ms ~
      G_ux_os.button_same_mask_counter++;
c0de77e2:	464a      	mov	r2, r9
c0de77e4:	1812      	adds	r2, r2, r0
c0de77e6:	1c76      	adds	r6, r6, #1
c0de77e8:	6056      	str	r6, [r2, #4]
    }

    // when new_button_mask is 0 and

    // append the button mask
    button_mask = G_ux_os.button_mask | new_button_mask;
c0de77ea:	430d      	orrs	r5, r1

    // pre reset variable due to os_sched_exit
    button_same_mask_counter = G_ux_os.button_same_mask_counter;

    // reset button mask
    if (new_button_mask == 0) {
c0de77ec:	2900      	cmp	r1, #0
c0de77ee:	d003      	beq.n	c0de77f8 <io_seproxyhal_button_push+0x2c>

      // notify button released event
      button_mask |= BUTTON_EVT_RELEASED;
    }
    else {
      G_ux_os.button_mask = button_mask;
c0de77f0:	464a      	mov	r2, r9
c0de77f2:	5015      	str	r5, [r2, r0]
    }

    // reset counter when button mask changes
    if (new_button_mask != G_ux_os.button_mask) {
c0de77f4:	462a      	mov	r2, r5
c0de77f6:	e007      	b.n	c0de7808 <io_seproxyhal_button_push+0x3c>
      G_ux_os.button_mask = 0;
c0de77f8:	464b      	mov	r3, r9
c0de77fa:	2200      	movs	r2, #0
c0de77fc:	501a      	str	r2, [r3, r0]
c0de77fe:	181b      	adds	r3, r3, r0
      G_ux_os.button_same_mask_counter=0;
c0de7800:	605a      	str	r2, [r3, #4]
c0de7802:	4b0e      	ldr	r3, [pc, #56]	; (c0de783c <io_seproxyhal_button_push+0x70>)
      button_mask |= BUTTON_EVT_RELEASED;
c0de7804:	1c5b      	adds	r3, r3, #1
c0de7806:	431d      	orrs	r5, r3
    if (new_button_mask != G_ux_os.button_mask) {
c0de7808:	428a      	cmp	r2, r1
c0de780a:	d003      	beq.n	c0de7814 <io_seproxyhal_button_push+0x48>
      G_ux_os.button_same_mask_counter=0;
c0de780c:	4649      	mov	r1, r9
c0de780e:	1808      	adds	r0, r1, r0
c0de7810:	2100      	movs	r1, #0
c0de7812:	6041      	str	r1, [r0, #4]
    }

    if (button_same_mask_counter >= BUTTON_FAST_THRESHOLD_CS) {
c0de7814:	2e08      	cmp	r6, #8
c0de7816:	d30a      	bcc.n	c0de782e <io_seproxyhal_button_push+0x62>
c0de7818:	2103      	movs	r1, #3
      // fast bit when pressing and timing is right
      if ((button_same_mask_counter%BUTTON_FAST_ACTION_CS) == 0) {
c0de781a:	4630      	mov	r0, r6
c0de781c:	f005 fe96 	bl	c0ded54c <__aeabi_uidivmod>
c0de7820:	2001      	movs	r0, #1
c0de7822:	2900      	cmp	r1, #0
c0de7824:	d101      	bne.n	c0de782a <io_seproxyhal_button_push+0x5e>
c0de7826:	0781      	lsls	r1, r0, #30
c0de7828:	430d      	orrs	r5, r1
c0de782a:	07c0      	lsls	r0, r0, #31
      }
      */

      // discard the release event after a fastskip has been detected, to avoid strange at release behavior
      // and also to enable user to cancel an operation by starting triggering the fast skip
      button_mask &= ~BUTTON_EVT_RELEASED;
c0de782c:	4385      	bics	r5, r0
    }

    // indicate if button have been released
    button_callback(button_mask, button_same_mask_counter);
c0de782e:	4628      	mov	r0, r5
c0de7830:	4631      	mov	r1, r6
c0de7832:	47a0      	blx	r4

  }
}
c0de7834:	bd70      	pop	{r4, r5, r6, pc}
c0de7836:	46c0      	nop			; (mov r8, r8)
c0de7838:	00000b08 	.word	0x00000b08
c0de783c:	7fffffff 	.word	0x7fffffff

c0de7840 <os_io_seproxyhal_get_app_name_and_version>:
#ifdef HAVE_IO_U2F
u2f_service_t G_io_u2f;
#endif // HAVE_IO_U2F

unsigned int os_io_seproxyhal_get_app_name_and_version(void) __attribute__((weak));
unsigned int os_io_seproxyhal_get_app_name_and_version(void) {
c0de7840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned int tx_len, len;
  // build the get app name and version reply
  tx_len = 0;
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0de7842:	4a11      	ldr	r2, [pc, #68]	; (c0de7888 <os_io_seproxyhal_get_app_name_and_version+0x48>)
c0de7844:	4649      	mov	r1, r9
c0de7846:	2001      	movs	r0, #1
c0de7848:	9000      	str	r0, [sp, #0]
c0de784a:	5488      	strb	r0, [r1, r2]
c0de784c:	188e      	adds	r6, r1, r2

#ifndef HAVE_BOLOS
  // append app name
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPNAME, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0de784e:	1cb1      	adds	r1, r6, #2
c0de7850:	22a7      	movs	r2, #167	; 0xa7
c0de7852:	0057      	lsls	r7, r2, #1
c0de7854:	1c7a      	adds	r2, r7, #1
c0de7856:	f001 fd39 	bl	c0de92cc <os_registry_get_current_app_tag>
c0de785a:	4605      	mov	r5, r0
  G_io_apdu_buffer[tx_len++] = len;
c0de785c:	7070      	strb	r0, [r6, #1]
  tx_len += len;
c0de785e:	1984      	adds	r4, r0, r6
  // append app version
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0de7860:	1ce1      	adds	r1, r4, #3
c0de7862:	1a3a      	subs	r2, r7, r0
c0de7864:	2002      	movs	r0, #2
c0de7866:	f001 fd31 	bl	c0de92cc <os_registry_get_current_app_tag>
  G_io_apdu_buffer[tx_len++] = len;
c0de786a:	70a0      	strb	r0, [r4, #2]
c0de786c:	182c      	adds	r4, r5, r0
  tx_len += len;
c0de786e:	19a5      	adds	r5, r4, r6
#endif // HAVE_BOLOS

#if !defined(HAVE_IO_TASK) || !defined(HAVE_BOLOS)
  // to be fixed within io tasks
  // return OS flags to notify of platform's global state (pin lock etc)
  G_io_apdu_buffer[tx_len++] = 1; // flags length
c0de7870:	9800      	ldr	r0, [sp, #0]
c0de7872:	70e8      	strb	r0, [r5, #3]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0de7874:	f001 fd08 	bl	c0de9288 <os_flags>
c0de7878:	2100      	movs	r1, #0
#endif // !defined(HAVE_IO_TASK) || !defined(HAVE_BOLOS)

  // status words
  G_io_apdu_buffer[tx_len++] = 0x90;
  G_io_apdu_buffer[tx_len++] = 0x00;
c0de787a:	71a9      	strb	r1, [r5, #6]
c0de787c:	2190      	movs	r1, #144	; 0x90
  G_io_apdu_buffer[tx_len++] = 0x90;
c0de787e:	7169      	strb	r1, [r5, #5]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0de7880:	7128      	strb	r0, [r5, #4]
  G_io_apdu_buffer[tx_len++] = 0x00;
c0de7882:	1de0      	adds	r0, r4, #7
  return tx_len;
c0de7884:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de7886:	46c0      	nop			; (mov r8, r8)
c0de7888:	00000990 	.word	0x00000990

c0de788c <io_exchange>:
  return processed;
}

#endif // HAVE_BOLOS_NO_DEFAULT_APDU

unsigned short io_exchange(unsigned char channel, unsigned short tx_len) {
c0de788c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de788e:	b087      	sub	sp, #28
c0de7890:	460e      	mov	r6, r1
c0de7892:	4604      	mov	r4, r0
c0de7894:	204b      	movs	r0, #75	; 0x4b
c0de7896:	0085      	lsls	r5, r0, #2
c0de7898:	4bab      	ldr	r3, [pc, #684]	; (c0de7b48 <io_exchange+0x2bc>)
c0de789a:	4faa      	ldr	r7, [pc, #680]	; (c0de7b44 <io_exchange+0x2b8>)
    }
  }
#endif // DEBUG_APDU

reply_apdu:
  switch(channel&~(IO_FLAGS)) {
c0de789c:	b2e0      	uxtb	r0, r4
c0de789e:	0761      	lsls	r1, r4, #29
c0de78a0:	d000      	beq.n	c0de78a4 <io_exchange+0x18>
c0de78a2:	e137      	b.n	c0de7b14 <io_exchange+0x288>
c0de78a4:	2210      	movs	r2, #16
  case CHANNEL_APDU:
    // TODO work up the spi state machine over the HAL proxy until an APDU is available

    if (tx_len && !(channel&IO_ASYNCH_REPLY)) {
c0de78a6:	4002      	ands	r2, r0
c0de78a8:	0431      	lsls	r1, r6, #16
c0de78aa:	d100      	bne.n	c0de78ae <io_exchange+0x22>
c0de78ac:	e0d7      	b.n	c0de7a5e <io_exchange+0x1d2>
c0de78ae:	2a00      	cmp	r2, #0
c0de78b0:	d000      	beq.n	c0de78b4 <io_exchange+0x28>
c0de78b2:	e0d4      	b.n	c0de7a5e <io_exchange+0x1d2>
c0de78b4:	9203      	str	r2, [sp, #12]
c0de78b6:	9006      	str	r0, [sp, #24]
      // ensure it's our turn to send a command/status, could lag a bit before sending the reply
      while (io_seproxyhal_spi_is_status_sent()) {
c0de78b8:	f001 fd2a 	bl	c0de9310 <io_seph_is_status_sent>
c0de78bc:	2800      	cmp	r0, #0
c0de78be:	d009      	beq.n	c0de78d4 <io_exchange+0x48>
        io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0de78c0:	4648      	mov	r0, r9
c0de78c2:	19c0      	adds	r0, r0, r7
c0de78c4:	2200      	movs	r2, #0
c0de78c6:	4629      	mov	r1, r5
c0de78c8:	f001 fd2c 	bl	c0de9324 <io_seph_recv>
c0de78cc:	2001      	movs	r0, #1
        // process without sending status on tickers etc, to ensure keeping the hand
        os_io_seph_recv_and_process(1);
c0de78ce:	f000 f945 	bl	c0de7b5c <os_io_seph_recv_and_process>
c0de78d2:	e7f1      	b.n	c0de78b8 <io_exchange+0x2c>
c0de78d4:	9605      	str	r6, [sp, #20]
      }

      // reinit sending timeout for APDU replied within io_exchange
      timeout_ms = G_io_app.ms + IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0de78d6:	4649      	mov	r1, r9
c0de78d8:	4a9b      	ldr	r2, [pc, #620]	; (c0de7b48 <io_exchange+0x2bc>)

      // until the whole RAPDU is transmitted, send chunks using the current mode for communication
      for (;;) {
        switch(G_io_app.apdu_state) {
c0de78da:	5c88      	ldrb	r0, [r1, r2]
      timeout_ms = G_io_app.ms + IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0de78dc:	1889      	adds	r1, r1, r2
c0de78de:	6889      	ldr	r1, [r1, #8]
c0de78e0:	227d      	movs	r2, #125	; 0x7d
c0de78e2:	0112      	lsls	r2, r2, #4
c0de78e4:	188e      	adds	r6, r1, r2
        switch(G_io_app.apdu_state) {
c0de78e6:	2801      	cmp	r0, #1
c0de78e8:	9404      	str	r4, [sp, #16]
c0de78ea:	d05a      	beq.n	c0de79a2 <io_exchange+0x116>
c0de78ec:	2807      	cmp	r0, #7
c0de78ee:	d060      	beq.n	c0de79b2 <io_exchange+0x126>
c0de78f0:	2809      	cmp	r0, #9
c0de78f2:	d00f      	beq.n	c0de7914 <io_exchange+0x88>
c0de78f4:	280a      	cmp	r0, #10
c0de78f6:	d037      	beq.n	c0de7968 <io_exchange+0xdc>
c0de78f8:	280b      	cmp	r0, #11
c0de78fa:	d02e      	beq.n	c0de795a <io_exchange+0xce>
c0de78fc:	2800      	cmp	r0, #0
c0de78fe:	d100      	bne.n	c0de7902 <io_exchange+0x76>
c0de7900:	e119      	b.n	c0de7b36 <io_exchange+0x2aa>
          default:
            // delegate to the hal in case of not generic transport mode (or asynch)
            if (io_exchange_al(channel, tx_len) == 0) {
c0de7902:	9805      	ldr	r0, [sp, #20]
c0de7904:	b281      	uxth	r1, r0
c0de7906:	9806      	ldr	r0, [sp, #24]
c0de7908:	f7fe ff46 	bl	c0de6798 <io_exchange_al>
c0de790c:	2800      	cmp	r0, #0
c0de790e:	d100      	bne.n	c0de7912 <io_exchange+0x86>
c0de7910:	e08f      	b.n	c0de7a32 <io_exchange+0x1a6>
c0de7912:	e110      	b.n	c0de7b36 <io_exchange+0x2aa>
          // case to handle U2F channels. u2f apdu to be dispatched in the upper layers
          case APDU_U2F:
            // prepare reply, the remaining segments will be pumped during USB/BLE events handling while waiting for the next APDU

            // the reply has been prepared by the application, stop sending anti timeouts
            u2f_message_set_autoreply_wait_user_presence(&G_io_u2f, false);
c0de7914:	4648      	mov	r0, r9
c0de7916:	498d      	ldr	r1, [pc, #564]	; (c0de7b4c <io_exchange+0x2c0>)
c0de7918:	1840      	adds	r0, r0, r1
c0de791a:	2100      	movs	r1, #0
c0de791c:	9101      	str	r1, [sp, #4]
c0de791e:	f002 f9f2 	bl	c0de9d06 <u2f_message_set_autoreply_wait_user_presence>

            // continue processing currently received command until completely received.
            while(!u2f_message_repliable(&G_io_u2f)) {
c0de7922:	4648      	mov	r0, r9
c0de7924:	4989      	ldr	r1, [pc, #548]	; (c0de7b4c <io_exchange+0x2c0>)
c0de7926:	1840      	adds	r0, r0, r1
c0de7928:	f001 ff88 	bl	c0de983c <u2f_message_repliable>
c0de792c:	2800      	cmp	r0, #0
c0de792e:	d147      	bne.n	c0de79c0 <io_exchange+0x134>

              io_seproxyhal_general_status();
c0de7930:	f7ff fd80 	bl	c0de7434 <io_seproxyhal_general_status>
              do {
                io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0de7934:	464c      	mov	r4, r9
c0de7936:	19e0      	adds	r0, r4, r7
c0de7938:	2200      	movs	r2, #0
c0de793a:	4629      	mov	r1, r5
c0de793c:	f001 fcf2 	bl	c0de9324 <io_seph_recv>
                // check for reply timeout
                if (G_io_app.ms >= timeout_ms) {
c0de7940:	4881      	ldr	r0, [pc, #516]	; (c0de7b48 <io_exchange+0x2bc>)
c0de7942:	1820      	adds	r0, r4, r0
c0de7944:	6880      	ldr	r0, [r0, #8]
c0de7946:	42b0      	cmp	r0, r6
c0de7948:	d300      	bcc.n	c0de794c <io_exchange+0xc0>
c0de794a:	e0ee      	b.n	c0de7b2a <io_exchange+0x29e>
                  THROW(EXCEPTION_IO_RESET);
                }
                // avoid a general status to be replied
                io_seproxyhal_handle_event();
c0de794c:	f7ff fe64 	bl	c0de7618 <io_seproxyhal_handle_event>
              } while (io_seproxyhal_spi_is_status_sent());
c0de7950:	f001 fcde 	bl	c0de9310 <io_seph_is_status_sent>
c0de7954:	2800      	cmp	r0, #0
c0de7956:	d1ed      	bne.n	c0de7934 <io_exchange+0xa8>
c0de7958:	e7e3      	b.n	c0de7922 <io_exchange+0x96>
            io_usb_hid_send(io_usb_send_apdu_data_ep0x83, tx_len);
c0de795a:	9805      	ldr	r0, [sp, #20]
c0de795c:	b281      	uxth	r1, r0
c0de795e:	487e      	ldr	r0, [pc, #504]	; (c0de7b58 <io_exchange+0x2cc>)
c0de7960:	4478      	add	r0, pc
c0de7962:	f000 fa77 	bl	c0de7e54 <io_usb_hid_send>
c0de7966:	e064      	b.n	c0de7a32 <io_exchange+0x1a6>
            if (tx_len > sizeof(G_io_apdu_buffer)) {
c0de7968:	4628      	mov	r0, r5
c0de796a:	3025      	adds	r0, #37	; 0x25
c0de796c:	9905      	ldr	r1, [sp, #20]
c0de796e:	b28c      	uxth	r4, r1
c0de7970:	4284      	cmp	r4, r0
c0de7972:	d900      	bls.n	c0de7976 <io_exchange+0xea>
c0de7974:	e0e2      	b.n	c0de7b3c <io_exchange+0x2b0>
            G_io_seproxyhal_spi_buffer[0]  = SEPROXYHAL_TAG_RAPDU;
c0de7976:	464a      	mov	r2, r9
c0de7978:	9202      	str	r2, [sp, #8]
c0de797a:	2053      	movs	r0, #83	; 0x53
c0de797c:	55d0      	strb	r0, [r2, r7]
c0de797e:	19d0      	adds	r0, r2, r7
            G_io_seproxyhal_spi_buffer[2]  = (tx_len);
c0de7980:	7081      	strb	r1, [r0, #2]
            G_io_seproxyhal_spi_buffer[1]  = (tx_len)>>8;
c0de7982:	0a09      	lsrs	r1, r1, #8
c0de7984:	7041      	strb	r1, [r0, #1]
c0de7986:	2103      	movs	r1, #3
            io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0de7988:	f001 fcb8 	bl	c0de92fc <io_seph_send>
            io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0de798c:	4870      	ldr	r0, [pc, #448]	; (c0de7b50 <io_exchange+0x2c4>)
c0de798e:	9902      	ldr	r1, [sp, #8]
c0de7990:	1808      	adds	r0, r1, r0
c0de7992:	4621      	mov	r1, r4
c0de7994:	f001 fcb2 	bl	c0de92fc <io_seph_send>
c0de7998:	2000      	movs	r0, #0
            G_io_app.apdu_state = APDU_IDLE;
c0de799a:	496b      	ldr	r1, [pc, #428]	; (c0de7b48 <io_exchange+0x2bc>)
c0de799c:	9a02      	ldr	r2, [sp, #8]
c0de799e:	5450      	strb	r0, [r2, r1]
c0de79a0:	e047      	b.n	c0de7a32 <io_exchange+0x1a6>
            LEDGER_BLE_send(G_io_apdu_buffer, tx_len);
c0de79a2:	4648      	mov	r0, r9
c0de79a4:	496a      	ldr	r1, [pc, #424]	; (c0de7b50 <io_exchange+0x2c4>)
c0de79a6:	1840      	adds	r0, r0, r1
c0de79a8:	9905      	ldr	r1, [sp, #20]
c0de79aa:	b289      	uxth	r1, r1
c0de79ac:	f7fd fcf0 	bl	c0de5390 <LEDGER_BLE_send>
c0de79b0:	e03f      	b.n	c0de7a32 <io_exchange+0x1a6>
            io_usb_hid_send(io_usb_send_apdu_data, tx_len);
c0de79b2:	9805      	ldr	r0, [sp, #20]
c0de79b4:	b281      	uxth	r1, r0
c0de79b6:	4867      	ldr	r0, [pc, #412]	; (c0de7b54 <io_exchange+0x2c8>)
c0de79b8:	4478      	add	r0, pc
c0de79ba:	f000 fa4b 	bl	c0de7e54 <io_usb_hid_send>
c0de79be:	e038      	b.n	c0de7a32 <io_exchange+0x1a6>
            }
#ifdef U2F_PROXY_MAGIC

            // user presence + counter + rapdu + sw must fit the apdu buffer
            if (1U+ 4U+ tx_len +2U > sizeof(G_io_apdu_buffer)) {
c0de79c0:	4629      	mov	r1, r5
c0de79c2:	311e      	adds	r1, #30
c0de79c4:	9c05      	ldr	r4, [sp, #20]
c0de79c6:	b2a0      	uxth	r0, r4
c0de79c8:	4288      	cmp	r0, r1
c0de79ca:	d900      	bls.n	c0de79ce <io_exchange+0x142>
c0de79cc:	e0b6      	b.n	c0de7b3c <io_exchange+0x2b0>
              THROW(INVALID_PARAMETER);
            }

            // u2F tunnel needs the status words to be included in the signature response BLOB, do it now.
            // always return 9000 in the signature to avoid error @ transport level in u2f layers.
            G_io_apdu_buffer[tx_len] = 0x90; //G_io_apdu_buffer[tx_len-2];
c0de79ce:	464a      	mov	r2, r9
c0de79d0:	9200      	str	r2, [sp, #0]
c0de79d2:	495f      	ldr	r1, [pc, #380]	; (c0de7b50 <io_exchange+0x2c4>)
c0de79d4:	1853      	adds	r3, r2, r1
c0de79d6:	9302      	str	r3, [sp, #8]
c0de79d8:	2190      	movs	r1, #144	; 0x90
c0de79da:	5419      	strb	r1, [r3, r0]
c0de79dc:	1818      	adds	r0, r3, r0
            G_io_apdu_buffer[tx_len+1] = 0x00; //G_io_apdu_buffer[tx_len-1];
c0de79de:	9901      	ldr	r1, [sp, #4]
c0de79e0:	7041      	strb	r1, [r0, #1]
            tx_len += 2;
            memmove(G_io_apdu_buffer + APDU_OFF_DATA, G_io_apdu_buffer, tx_len);
c0de79e2:	1d58      	adds	r0, r3, #5
            tx_len += 2;
c0de79e4:	1ca1      	adds	r1, r4, #2
            memmove(G_io_apdu_buffer + APDU_OFF_DATA, G_io_apdu_buffer, tx_len);
c0de79e6:	b28a      	uxth	r2, r1
c0de79e8:	4619      	mov	r1, r3
c0de79ea:	f005 ff1d 	bl	c0ded828 <__aeabi_memmove>
c0de79ee:	2105      	movs	r1, #5
            // zeroize user presence and counter
            memset(G_io_apdu_buffer, 0, APDU_OFF_DATA);
c0de79f0:	9802      	ldr	r0, [sp, #8]
c0de79f2:	f005 ff0f 	bl	c0ded814 <__aeabi_memclr>
            u2f_message_reply(&G_io_u2f, U2F_CMD_MSG, G_io_apdu_buffer, tx_len+5);
c0de79f6:	4855      	ldr	r0, [pc, #340]	; (c0de7b4c <io_exchange+0x2c0>)
c0de79f8:	9900      	ldr	r1, [sp, #0]
c0de79fa:	1808      	adds	r0, r1, r0
c0de79fc:	1de1      	adds	r1, r4, #7
c0de79fe:	b28b      	uxth	r3, r1
c0de7a00:	2183      	movs	r1, #131	; 0x83
c0de7a02:	9a02      	ldr	r2, [sp, #8]
c0de7a04:	f002 f994 	bl	c0de9d30 <u2f_message_reply>
c0de7a08:	e013      	b.n	c0de7a32 <io_exchange+0x1a6>
      break_send:

        // wait end of reply transmission
        // TODO: add timeout here to avoid spending too much time when host has disconnected
        while (G_io_app.apdu_state != APDU_IDLE) {
          io_seproxyhal_general_status();
c0de7a0a:	f7ff fd13 	bl	c0de7434 <io_seproxyhal_general_status>
          do {
            io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0de7a0e:	464c      	mov	r4, r9
c0de7a10:	19e0      	adds	r0, r4, r7
c0de7a12:	2200      	movs	r2, #0
c0de7a14:	4629      	mov	r1, r5
c0de7a16:	f001 fc85 	bl	c0de9324 <io_seph_recv>
            // check for reply timeout (when asynch reply (over hid or u2f for example))
            // this case shall be covered by usb_ep_timeout but is not, investigate that
            if (G_io_app.ms >= timeout_ms) {
c0de7a1a:	484b      	ldr	r0, [pc, #300]	; (c0de7b48 <io_exchange+0x2bc>)
c0de7a1c:	1820      	adds	r0, r4, r0
c0de7a1e:	6880      	ldr	r0, [r0, #8]
c0de7a20:	42b0      	cmp	r0, r6
c0de7a22:	d300      	bcc.n	c0de7a26 <io_exchange+0x19a>
c0de7a24:	e081      	b.n	c0de7b2a <io_exchange+0x29e>
              THROW(EXCEPTION_IO_RESET);
            }
            // avoid a general status to be replied
            io_seproxyhal_handle_event();
c0de7a26:	f7ff fdf7 	bl	c0de7618 <io_seproxyhal_handle_event>
          } while (io_seproxyhal_spi_is_status_sent());
c0de7a2a:	f001 fc71 	bl	c0de9310 <io_seph_is_status_sent>
c0de7a2e:	2800      	cmp	r0, #0
c0de7a30:	d1ed      	bne.n	c0de7a0e <io_exchange+0x182>
        while (G_io_app.apdu_state != APDU_IDLE) {
c0de7a32:	4648      	mov	r0, r9
c0de7a34:	4a44      	ldr	r2, [pc, #272]	; (c0de7b48 <io_exchange+0x2bc>)
c0de7a36:	5c80      	ldrb	r0, [r0, r2]
c0de7a38:	2800      	cmp	r0, #0
c0de7a3a:	d1e6      	bne.n	c0de7a0a <io_exchange+0x17e>
        }
        // reset apdu state
        G_io_app.apdu_state = APDU_IDLE;
c0de7a3c:	4649      	mov	r1, r9
c0de7a3e:	2000      	movs	r0, #0
c0de7a40:	5488      	strb	r0, [r1, r2]
c0de7a42:	1889      	adds	r1, r1, r2
        G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0de7a44:	7188      	strb	r0, [r1, #6]

        G_io_app.apdu_length = 0;
c0de7a46:	8048      	strh	r0, [r1, #2]
c0de7a48:	9c04      	ldr	r4, [sp, #16]

        // continue sending commands, don't issue status yet
        if (channel & IO_RETURN_AFTER_TX) {
c0de7a4a:	06a1      	lsls	r1, r4, #26
c0de7a4c:	d46a      	bmi.n	c0de7b24 <io_exchange+0x298>
          return 0;
        }
        // acknowledge the write request (general status OK) and no more command to follow (wait until another APDU container is received to continue unwrapping)
        io_seproxyhal_general_status();
c0de7a4e:	f7ff fcf1 	bl	c0de7434 <io_seproxyhal_general_status>
c0de7a52:	4b3d      	ldr	r3, [pc, #244]	; (c0de7b48 <io_exchange+0x2bc>)
        break;
      }

      // perform reset after io exchange
      if (channel & IO_RESET_AFTER_REPLIED) {
c0de7a54:	b260      	sxtb	r0, r4
c0de7a56:	2800      	cmp	r0, #0
c0de7a58:	9806      	ldr	r0, [sp, #24]
c0de7a5a:	9a03      	ldr	r2, [sp, #12]
c0de7a5c:	d468      	bmi.n	c0de7b30 <io_exchange+0x2a4>
        os_sched_exit((bolos_task_status_t)EXCEPTION_IO_RESET);
        //reset();
      }
    }

    if (!(channel&IO_ASYNCH_REPLY)) {
c0de7a5e:	2a00      	cmp	r2, #0
c0de7a60:	d106      	bne.n	c0de7a70 <io_exchange+0x1e4>

      // already received the data of the apdu when received the whole apdu
      if ((channel & (CHANNEL_APDU|IO_RECEIVE_DATA)) == (CHANNEL_APDU|IO_RECEIVE_DATA)) {
c0de7a62:	0640      	lsls	r0, r0, #25
c0de7a64:	d45a      	bmi.n	c0de7b1c <io_exchange+0x290>
        // return apdu data - header
        return G_io_app.apdu_length-5;
      }

      // reply has ended, proceed to next apdu reception (reset status only after asynch reply)
      G_io_app.apdu_state = APDU_IDLE;
c0de7a66:	4648      	mov	r0, r9
c0de7a68:	2100      	movs	r1, #0
c0de7a6a:	54c1      	strb	r1, [r0, r3]
c0de7a6c:	18c0      	adds	r0, r0, r3
      G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0de7a6e:	7181      	strb	r1, [r0, #6]
c0de7a70:	4648      	mov	r0, r9
c0de7a72:	18c0      	adds	r0, r0, r3
c0de7a74:	2100      	movs	r1, #0
c0de7a76:	8041      	strh	r1, [r0, #2]

    // ensure ready to receive an event (after an apdu processing with asynch flag, it may occur if the channel is not correctly managed)

    // until a new whole CAPDU is received
    for (;;) {
      io_seproxyhal_general_status();
c0de7a78:	f7ff fcdc 	bl	c0de7434 <io_seproxyhal_general_status>
      // wait until a SPI packet is available
      // NOTE: on ST31, dual wait ISO & RF (ISO instead of SPI)
      rx_len = io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0de7a7c:	4648      	mov	r0, r9
c0de7a7e:	19c0      	adds	r0, r0, r7
c0de7a80:	2600      	movs	r6, #0
c0de7a82:	4629      	mov	r1, r5
c0de7a84:	4632      	mov	r2, r6
c0de7a86:	f001 fc4d 	bl	c0de9324 <io_seph_recv>

      // can't process split TLV, continue
      if (rx_len < 3 || rx_len != U2(G_io_seproxyhal_spi_buffer[1],G_io_seproxyhal_spi_buffer[2])+3U) {
c0de7a8a:	2803      	cmp	r0, #3
c0de7a8c:	d314      	bcc.n	c0de7ab8 <io_exchange+0x22c>
c0de7a8e:	4649      	mov	r1, r9
c0de7a90:	19c9      	adds	r1, r1, r7
c0de7a92:	788a      	ldrb	r2, [r1, #2]
c0de7a94:	7849      	ldrb	r1, [r1, #1]
c0de7a96:	0209      	lsls	r1, r1, #8
c0de7a98:	1889      	adds	r1, r1, r2
c0de7a9a:	1cc9      	adds	r1, r1, #3
c0de7a9c:	4281      	cmp	r1, r0
c0de7a9e:	d10b      	bne.n	c0de7ab8 <io_exchange+0x22c>
        G_io_app.apdu_state = APDU_IDLE;
        G_io_app.apdu_length = 0;
        continue;
      }

      io_seproxyhal_handle_event();
c0de7aa0:	f7ff fdba 	bl	c0de7618 <io_seproxyhal_handle_event>

      // An apdu has been received asynchroneously.
      if (G_io_app.apdu_state != APDU_IDLE && G_io_app.apdu_length > 0) {
c0de7aa4:	4648      	mov	r0, r9
c0de7aa6:	4b28      	ldr	r3, [pc, #160]	; (c0de7b48 <io_exchange+0x2bc>)
c0de7aa8:	5cc1      	ldrb	r1, [r0, r3]
c0de7aaa:	18c0      	adds	r0, r0, r3
c0de7aac:	8840      	ldrh	r0, [r0, #2]
c0de7aae:	2900      	cmp	r1, #0
c0de7ab0:	d0e2      	beq.n	c0de7a78 <io_exchange+0x1ec>
c0de7ab2:	2800      	cmp	r0, #0
c0de7ab4:	d0e0      	beq.n	c0de7a78 <io_exchange+0x1ec>
c0de7ab6:	e003      	b.n	c0de7ac0 <io_exchange+0x234>
        G_io_app.apdu_state = APDU_IDLE;
c0de7ab8:	4648      	mov	r0, r9
c0de7aba:	4b23      	ldr	r3, [pc, #140]	; (c0de7b48 <io_exchange+0x2bc>)
c0de7abc:	54c6      	strb	r6, [r0, r3]
c0de7abe:	e7d7      	b.n	c0de7a70 <io_exchange+0x1e4>
  if (DEFAULT_APDU_CLA == G_io_apdu_buffer[APDU_OFF_CLA]) {
c0de7ac0:	4649      	mov	r1, r9
c0de7ac2:	4a23      	ldr	r2, [pc, #140]	; (c0de7b50 <io_exchange+0x2c4>)
c0de7ac4:	5c89      	ldrb	r1, [r1, r2]
c0de7ac6:	29b0      	cmp	r1, #176	; 0xb0
c0de7ac8:	d12c      	bne.n	c0de7b24 <io_exchange+0x298>
    switch (G_io_apdu_buffer[APDU_OFF_INS]) {
c0de7aca:	4649      	mov	r1, r9
c0de7acc:	1889      	adds	r1, r1, r2
c0de7ace:	7849      	ldrb	r1, [r1, #1]
c0de7ad0:	29a7      	cmp	r1, #167	; 0xa7
c0de7ad2:	d00e      	beq.n	c0de7af2 <io_exchange+0x266>
c0de7ad4:	2901      	cmp	r1, #1
c0de7ad6:	d125      	bne.n	c0de7b24 <io_exchange+0x298>
        if (!G_io_apdu_buffer[APDU_OFF_P1] && !G_io_apdu_buffer[APDU_OFF_P2]) {
c0de7ad8:	4649      	mov	r1, r9
c0de7ada:	1889      	adds	r1, r1, r2
c0de7adc:	788a      	ldrb	r2, [r1, #2]
c0de7ade:	78c9      	ldrb	r1, [r1, #3]
c0de7ae0:	4311      	orrs	r1, r2
c0de7ae2:	d11f      	bne.n	c0de7b24 <io_exchange+0x298>
c0de7ae4:	2007      	movs	r0, #7
          *channel &= ~IO_FLAGS;
c0de7ae6:	4004      	ands	r4, r0
          *tx_len = os_io_seproxyhal_get_app_name_and_version();
c0de7ae8:	f7ff feaa 	bl	c0de7840 <os_io_seproxyhal_get_app_name_and_version>
c0de7aec:	4b16      	ldr	r3, [pc, #88]	; (c0de7b48 <io_exchange+0x2bc>)
c0de7aee:	4606      	mov	r6, r0
c0de7af0:	e6d4      	b.n	c0de789c <io_exchange+0x10>
        if (!G_io_apdu_buffer[APDU_OFF_P1] && !G_io_apdu_buffer[APDU_OFF_P2]) {
c0de7af2:	4649      	mov	r1, r9
c0de7af4:	1889      	adds	r1, r1, r2
c0de7af6:	788a      	ldrb	r2, [r1, #2]
c0de7af8:	78c9      	ldrb	r1, [r1, #3]
c0de7afa:	4311      	orrs	r1, r2
c0de7afc:	d112      	bne.n	c0de7b24 <io_exchange+0x298>
          G_io_apdu_buffer[(*tx_len)++] = 0x90;
c0de7afe:	4648      	mov	r0, r9
c0de7b00:	2190      	movs	r1, #144	; 0x90
c0de7b02:	4a13      	ldr	r2, [pc, #76]	; (c0de7b50 <io_exchange+0x2c4>)
c0de7b04:	5481      	strb	r1, [r0, r2]
c0de7b06:	1880      	adds	r0, r0, r2
          G_io_apdu_buffer[(*tx_len)++] = 0x00;
c0de7b08:	7046      	strb	r6, [r0, #1]
c0de7b0a:	207f      	movs	r0, #127	; 0x7f
c0de7b0c:	43c0      	mvns	r0, r0
          *channel |= IO_RESET_AFTER_REPLIED;
c0de7b0e:	4304      	orrs	r4, r0
c0de7b10:	2602      	movs	r6, #2
c0de7b12:	e6c3      	b.n	c0de789c <io_exchange+0x10>
      }
    }
    break;

  default:
    return io_exchange_al(channel, tx_len);
c0de7b14:	b2b1      	uxth	r1, r6
c0de7b16:	f7fe fe3f 	bl	c0de6798 <io_exchange_al>
c0de7b1a:	e003      	b.n	c0de7b24 <io_exchange+0x298>
        return G_io_app.apdu_length-5;
c0de7b1c:	4648      	mov	r0, r9
c0de7b1e:	18c0      	adds	r0, r0, r3
c0de7b20:	8840      	ldrh	r0, [r0, #2]
c0de7b22:	1f40      	subs	r0, r0, #5
  }
}
c0de7b24:	b280      	uxth	r0, r0
c0de7b26:	b007      	add	sp, #28
c0de7b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de7b2a:	2005      	movs	r0, #5
c0de7b2c:	f7ff fc7b 	bl	c0de7426 <os_longjmp>
c0de7b30:	2005      	movs	r0, #5
        os_sched_exit((bolos_task_status_t)EXCEPTION_IO_RESET);
c0de7b32:	f001 fbd7 	bl	c0de92e4 <os_sched_exit>
c0de7b36:	2004      	movs	r0, #4
            THROW(INVALID_STATE);
c0de7b38:	f7ff fc75 	bl	c0de7426 <os_longjmp>
c0de7b3c:	2002      	movs	r0, #2
c0de7b3e:	f7ff fc72 	bl	c0de7426 <os_longjmp>
c0de7b42:	46c0      	nop			; (mov r8, r8)
c0de7b44:	00000444 	.word	0x00000444
c0de7b48:	00000ae4 	.word	0x00000ae4
c0de7b4c:	00000b10 	.word	0x00000b10
c0de7b50:	00000990 	.word	0x00000990
c0de7b54:	fffffbf1 	.word	0xfffffbf1
c0de7b58:	fffffc59 	.word	0xfffffc59

c0de7b5c <os_io_seph_recv_and_process>:

unsigned int os_io_seph_recv_and_process(unsigned int dont_process_ux_events) {
c0de7b5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de7b5e:	4605      	mov	r5, r0
  // send general status before receiving next event
  io_seproxyhal_general_status();
c0de7b60:	f7ff fc68 	bl	c0de7434 <io_seproxyhal_general_status>

  io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0de7b64:	4e0c      	ldr	r6, [pc, #48]	; (c0de7b98 <os_io_seph_recv_and_process+0x3c>)
c0de7b66:	464f      	mov	r7, r9
c0de7b68:	19b8      	adds	r0, r7, r6
c0de7b6a:	214b      	movs	r1, #75	; 0x4b
c0de7b6c:	0089      	lsls	r1, r1, #2
c0de7b6e:	2400      	movs	r4, #0
c0de7b70:	4622      	mov	r2, r4
c0de7b72:	f001 fbd7 	bl	c0de9324 <io_seph_recv>

  switch (G_io_seproxyhal_spi_buffer[0]) {
c0de7b76:	5db8      	ldrb	r0, [r7, r6]
c0de7b78:	2815      	cmp	r0, #21
c0de7b7a:	d806      	bhi.n	c0de7b8a <os_io_seph_recv_and_process+0x2e>
c0de7b7c:	2101      	movs	r1, #1
c0de7b7e:	4081      	lsls	r1, r0
c0de7b80:	4806      	ldr	r0, [pc, #24]	; (c0de7b9c <os_io_seph_recv_and_process+0x40>)
c0de7b82:	4201      	tst	r1, r0
c0de7b84:	d001      	beq.n	c0de7b8a <os_io_seph_recv_and_process+0x2e>
    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
    case SEPROXYHAL_TAG_TICKER_EVENT:
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
    case SEPROXYHAL_TAG_STATUS_EVENT:
      // perform UX event on these ones, don't process as an IO event
      if (dont_process_ux_events) {
c0de7b86:	2d00      	cmp	r5, #0
c0de7b88:	d104      	bne.n	c0de7b94 <os_io_seph_recv_and_process+0x38>
      }
      __attribute__((fallthrough));

    default:
      // if malformed, then a stall is likely to occur
      if (io_seproxyhal_handle_event()) {
c0de7b8a:	f7ff fd45 	bl	c0de7618 <io_seproxyhal_handle_event>
c0de7b8e:	4604      	mov	r4, r0
c0de7b90:	1e40      	subs	r0, r0, #1
c0de7b92:	4184      	sbcs	r4, r0
        return 1;
      }
  }
  return 0;
}
c0de7b94:	4620      	mov	r0, r4
c0de7b96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de7b98:	00000444 	.word	0x00000444
c0de7b9c:	00207020 	.word	0x00207020

c0de7ba0 <io_seproxyhal_io_heartbeat>:
  io_seproxyhal_spi_send(buf, 3);
  io_seproxyhal_spi_send((unsigned char*)str, charcount);
}
#endif // HAVE_PRINTF

void io_seproxyhal_io_heartbeat(void) {
c0de7ba0:	b5b0      	push	{r4, r5, r7, lr}
  io_seproxyhal_general_status();
c0de7ba2:	f7ff fc47 	bl	c0de7434 <io_seproxyhal_general_status>
c0de7ba6:	4c09      	ldr	r4, [pc, #36]	; (c0de7bcc <io_seproxyhal_io_heartbeat+0x2c>)
  do {
    io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0de7ba8:	464d      	mov	r5, r9
c0de7baa:	1928      	adds	r0, r5, r4
c0de7bac:	214b      	movs	r1, #75	; 0x4b
c0de7bae:	0089      	lsls	r1, r1, #2
c0de7bb0:	2200      	movs	r2, #0
c0de7bb2:	f001 fbb7 	bl	c0de9324 <io_seph_recv>
    // avoid a general status to be replied
    if(G_io_seproxyhal_spi_buffer[0] != SEPROXYHAL_TAG_TICKER_EVENT) {
c0de7bb6:	5d28      	ldrb	r0, [r5, r4]
c0de7bb8:	280e      	cmp	r0, #14
c0de7bba:	d001      	beq.n	c0de7bc0 <io_seproxyhal_io_heartbeat+0x20>
      io_seproxyhal_handle_event();
c0de7bbc:	f7ff fd2c 	bl	c0de7618 <io_seproxyhal_handle_event>
    }
  } while (io_seproxyhal_spi_is_status_sent());
c0de7bc0:	f001 fba6 	bl	c0de9310 <io_seph_is_status_sent>
c0de7bc4:	2800      	cmp	r0, #0
c0de7bc6:	d1f0      	bne.n	c0de7baa <io_seproxyhal_io_heartbeat+0xa>
}
c0de7bc8:	bdb0      	pop	{r4, r5, r7, pc}
c0de7bca:	46c0      	nop			; (mov r8, r8)
c0de7bcc:	00000444 	.word	0x00000444

c0de7bd0 <io_usb_hid_receive>:
volatile unsigned int   G_io_usb_hid_channel;
volatile unsigned int   G_io_usb_hid_remaining_length;
volatile unsigned int   G_io_usb_hid_sequence_number;
volatile unsigned char* G_io_usb_hid_current_buffer;

io_usb_hid_receive_status_t io_usb_hid_receive (io_send_t sndfct, unsigned char* buffer, unsigned short l) {
c0de7bd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de7bd2:	9200      	str	r2, [sp, #0]
c0de7bd4:	4605      	mov	r5, r0
  // avoid over/under flows
  if (buffer != G_io_usb_ep_buffer) {
c0de7bd6:	4b5a      	ldr	r3, [pc, #360]	; (c0de7d40 <io_usb_hid_receive+0x170>)
c0de7bd8:	4648      	mov	r0, r9
c0de7bda:	18c0      	adds	r0, r0, r3
c0de7bdc:	4281      	cmp	r1, r0
c0de7bde:	d012      	beq.n	c0de7c06 <io_usb_hid_receive+0x36>
c0de7be0:	460e      	mov	r6, r1
c0de7be2:	462c      	mov	r4, r5
    memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
c0de7be4:	4648      	mov	r0, r9
c0de7be6:	18c7      	adds	r7, r0, r3
c0de7be8:	2540      	movs	r5, #64	; 0x40
c0de7bea:	4638      	mov	r0, r7
c0de7bec:	4629      	mov	r1, r5
c0de7bee:	f005 fe11 	bl	c0ded814 <__aeabi_memclr>
c0de7bf2:	9a00      	ldr	r2, [sp, #0]
    memmove(G_io_usb_ep_buffer, buffer, MIN(l, sizeof(G_io_usb_ep_buffer)));
c0de7bf4:	2a40      	cmp	r2, #64	; 0x40
c0de7bf6:	d300      	bcc.n	c0de7bfa <io_usb_hid_receive+0x2a>
c0de7bf8:	462a      	mov	r2, r5
c0de7bfa:	4638      	mov	r0, r7
c0de7bfc:	4631      	mov	r1, r6
c0de7bfe:	f005 fe13 	bl	c0ded828 <__aeabi_memmove>
c0de7c02:	4b4f      	ldr	r3, [pc, #316]	; (c0de7d40 <io_usb_hid_receive+0x170>)
c0de7c04:	4625      	mov	r5, r4
  }

  // process the chunk content
  switch(G_io_usb_ep_buffer[2]) {
c0de7c06:	4648      	mov	r0, r9
c0de7c08:	18c0      	adds	r0, r0, r3
c0de7c0a:	7880      	ldrb	r0, [r0, #2]
c0de7c0c:	2800      	cmp	r0, #0
c0de7c0e:	d02f      	beq.n	c0de7c70 <io_usb_hid_receive+0xa0>
c0de7c10:	2801      	cmp	r0, #1
c0de7c12:	d037      	beq.n	c0de7c84 <io_usb_hid_receive+0xb4>
c0de7c14:	2802      	cmp	r0, #2
c0de7c16:	d03e      	beq.n	c0de7c96 <io_usb_hid_receive+0xc6>
c0de7c18:	2805      	cmp	r0, #5
c0de7c1a:	d17e      	bne.n	c0de7d1a <io_usb_hid_receive+0x14a>
c0de7c1c:	4648      	mov	r0, r9
c0de7c1e:	18c1      	adds	r1, r0, r3
c0de7c20:	790a      	ldrb	r2, [r1, #4]
c0de7c22:	78c9      	ldrb	r1, [r1, #3]
c0de7c24:	0209      	lsls	r1, r1, #8
c0de7c26:	1889      	adds	r1, r1, r2
  case 0x05:
    // ensure sequence idx is 0 for the first chunk ! 
    if ((unsigned int)U2BE(G_io_usb_ep_buffer, 3) != (unsigned int)G_io_usb_hid_sequence_number) {
c0de7c28:	4f46      	ldr	r7, [pc, #280]	; (c0de7d44 <io_usb_hid_receive+0x174>)
c0de7c2a:	59c0      	ldr	r0, [r0, r7]
c0de7c2c:	2600      	movs	r6, #0
c0de7c2e:	4288      	cmp	r0, r1
c0de7c30:	d17b      	bne.n	c0de7d2a <io_usb_hid_receive+0x15a>
    }
    // cid, tag, seq
    l -= 2+1+2;
    
    // append the received chunk to the current command apdu
    if (G_io_usb_hid_sequence_number == 0) {
c0de7c32:	4648      	mov	r0, r9
c0de7c34:	59c0      	ldr	r0, [r0, r7]
c0de7c36:	2800      	cmp	r0, #0
c0de7c38:	d033      	beq.n	c0de7ca2 <io_usb_hid_receive+0xd2>
c0de7c3a:	461d      	mov	r5, r3
c0de7c3c:	9800      	ldr	r0, [sp, #0]
c0de7c3e:	1f40      	subs	r0, r0, #5
      // copy data
      memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+7, l);
    }
    else {
      // check for invalid length encoding (more data in chunk that announced in the total apdu)
      if (l > G_io_usb_hid_remaining_length) {
c0de7c40:	4941      	ldr	r1, [pc, #260]	; (c0de7d48 <io_usb_hid_receive+0x178>)
c0de7c42:	464a      	mov	r2, r9
c0de7c44:	5852      	ldr	r2, [r2, r1]
c0de7c46:	b283      	uxth	r3, r0
c0de7c48:	429a      	cmp	r2, r3
c0de7c4a:	d201      	bcs.n	c0de7c50 <io_usb_hid_receive+0x80>
        l = G_io_usb_hid_remaining_length;
c0de7c4c:	4648      	mov	r0, r9
c0de7c4e:	5840      	ldr	r0, [r0, r1]
      }

      if (l > sizeof(G_io_usb_ep_buffer) - 5) {
c0de7c50:	b281      	uxth	r1, r0
c0de7c52:	293b      	cmp	r1, #59	; 0x3b
c0de7c54:	4629      	mov	r1, r5
c0de7c56:	d300      	bcc.n	c0de7c5a <io_usb_hid_receive+0x8a>
c0de7c58:	203b      	movs	r0, #59	; 0x3b
        l = sizeof(G_io_usb_ep_buffer) - 5;
      }

      /// This is a following chunk
      // append content
      memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+5, l);
c0de7c5a:	b284      	uxth	r4, r0
c0de7c5c:	4d3b      	ldr	r5, [pc, #236]	; (c0de7d4c <io_usb_hid_receive+0x17c>)
c0de7c5e:	464e      	mov	r6, r9
c0de7c60:	5970      	ldr	r0, [r6, r5]
c0de7c62:	1871      	adds	r1, r6, r1
c0de7c64:	1d49      	adds	r1, r1, #5
c0de7c66:	4622      	mov	r2, r4
c0de7c68:	f005 fdde 	bl	c0ded828 <__aeabi_memmove>
    }
    // factorize (f)
    G_io_usb_hid_current_buffer += l;
c0de7c6c:	5975      	ldr	r5, [r6, r5]
c0de7c6e:	e049      	b.n	c0de7d04 <io_usb_hid_receive+0x134>
    G_io_usb_hid_sequence_number++;
    break;

  case 0x00: // get version ID
    // do not reset the current apdu reception if any
    memset(G_io_usb_ep_buffer+3, 0, 4); // PROTOCOL VERSION is 0
c0de7c70:	4648      	mov	r0, r9
c0de7c72:	18c0      	adds	r0, r0, r3
c0de7c74:	2600      	movs	r6, #0
c0de7c76:	7186      	strb	r6, [r0, #6]
c0de7c78:	7146      	strb	r6, [r0, #5]
c0de7c7a:	7106      	strb	r6, [r0, #4]
c0de7c7c:	70c6      	strb	r6, [r0, #3]
c0de7c7e:	2140      	movs	r1, #64	; 0x40
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0de7c80:	47a8      	blx	r5
c0de7c82:	e052      	b.n	c0de7d2a <io_usb_hid_receive+0x15a>
    // await for the next chunk
    goto apdu_reset;

  case 0x01: // ALLOCATE CHANNEL
    // do not reset the current apdu reception if any
    cx_rng_no_throw(G_io_usb_ep_buffer+3, 4);
c0de7c84:	4648      	mov	r0, r9
c0de7c86:	18c4      	adds	r4, r0, r3
c0de7c88:	1ce0      	adds	r0, r4, #3
c0de7c8a:	2104      	movs	r1, #4
c0de7c8c:	f7fb fa20 	bl	c0de30d0 <cx_rng_no_throw>
c0de7c90:	2140      	movs	r1, #64	; 0x40
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0de7c92:	4620      	mov	r0, r4
c0de7c94:	e002      	b.n	c0de7c9c <io_usb_hid_receive+0xcc>
    goto apdu_reset;

  case 0x02: // ECHO|PING
    // do not reset the current apdu reception if any
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0de7c96:	4648      	mov	r0, r9
c0de7c98:	18c0      	adds	r0, r0, r3
c0de7c9a:	2140      	movs	r1, #64	; 0x40
c0de7c9c:	47a8      	blx	r5
c0de7c9e:	2600      	movs	r6, #0
c0de7ca0:	e043      	b.n	c0de7d2a <io_usb_hid_receive+0x15a>
c0de7ca2:	4649      	mov	r1, r9
c0de7ca4:	18c8      	adds	r0, r1, r3
c0de7ca6:	7982      	ldrb	r2, [r0, #6]
c0de7ca8:	7940      	ldrb	r0, [r0, #5]
c0de7caa:	0200      	lsls	r0, r0, #8
c0de7cac:	1882      	adds	r2, r0, r2
      G_io_usb_hid_total_length = U2BE(G_io_usb_ep_buffer, 5); //(G_io_usb_ep_buffer[5]<<8)+(G_io_usb_ep_buffer[6]&0xFF);
c0de7cae:	4828      	ldr	r0, [pc, #160]	; (c0de7d50 <io_usb_hid_receive+0x180>)
c0de7cb0:	500a      	str	r2, [r1, r0]
      if (G_io_usb_hid_total_length > sizeof(G_io_apdu_buffer)) {
c0de7cb2:	5809      	ldr	r1, [r1, r0]
c0de7cb4:	0849      	lsrs	r1, r1, #1
c0de7cb6:	29a8      	cmp	r1, #168	; 0xa8
c0de7cb8:	d837      	bhi.n	c0de7d2a <io_usb_hid_receive+0x15a>
      G_io_usb_hid_remaining_length = G_io_usb_hid_total_length;
c0de7cba:	464a      	mov	r2, r9
c0de7cbc:	5810      	ldr	r0, [r2, r0]
c0de7cbe:	4922      	ldr	r1, [pc, #136]	; (c0de7d48 <io_usb_hid_receive+0x178>)
c0de7cc0:	5050      	str	r0, [r2, r1]
c0de7cc2:	18d0      	adds	r0, r2, r3
c0de7cc4:	7840      	ldrb	r0, [r0, #1]
c0de7cc6:	461e      	mov	r6, r3
c0de7cc8:	5cd3      	ldrb	r3, [r2, r3]
c0de7cca:	021b      	lsls	r3, r3, #8
c0de7ccc:	1818      	adds	r0, r3, r0
      G_io_usb_hid_channel = U2BE(G_io_usb_ep_buffer, 0);
c0de7cce:	4b21      	ldr	r3, [pc, #132]	; (c0de7d54 <io_usb_hid_receive+0x184>)
c0de7cd0:	50d0      	str	r0, [r2, r3]
      G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0de7cd2:	4821      	ldr	r0, [pc, #132]	; (c0de7d58 <io_usb_hid_receive+0x188>)
c0de7cd4:	1813      	adds	r3, r2, r0
c0de7cd6:	4d1d      	ldr	r5, [pc, #116]	; (c0de7d4c <io_usb_hid_receive+0x17c>)
c0de7cd8:	5153      	str	r3, [r2, r5]
      if (l > G_io_usb_hid_remaining_length) {
c0de7cda:	5853      	ldr	r3, [r2, r1]
      l -= 2;
c0de7cdc:	9a00      	ldr	r2, [sp, #0]
c0de7cde:	1fd2      	subs	r2, r2, #7
      if (l > G_io_usb_hid_remaining_length) {
c0de7ce0:	b294      	uxth	r4, r2
c0de7ce2:	42a3      	cmp	r3, r4
c0de7ce4:	d201      	bcs.n	c0de7cea <io_usb_hid_receive+0x11a>
        l = G_io_usb_hid_remaining_length;
c0de7ce6:	464a      	mov	r2, r9
c0de7ce8:	5852      	ldr	r2, [r2, r1]
      if (l > sizeof(G_io_usb_ep_buffer) - 7) {
c0de7cea:	b291      	uxth	r1, r2
c0de7cec:	2939      	cmp	r1, #57	; 0x39
c0de7cee:	d300      	bcc.n	c0de7cf2 <io_usb_hid_receive+0x122>
c0de7cf0:	2239      	movs	r2, #57	; 0x39
      memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+7, l);
c0de7cf2:	b294      	uxth	r4, r2
c0de7cf4:	4649      	mov	r1, r9
c0de7cf6:	180d      	adds	r5, r1, r0
c0de7cf8:	1988      	adds	r0, r1, r6
c0de7cfa:	1dc1      	adds	r1, r0, #7
c0de7cfc:	4628      	mov	r0, r5
c0de7cfe:	4622      	mov	r2, r4
c0de7d00:	f005 fd8e 	bl	c0ded820 <__aeabi_memcpy>
    G_io_usb_hid_remaining_length -= l;
c0de7d04:	4810      	ldr	r0, [pc, #64]	; (c0de7d48 <io_usb_hid_receive+0x178>)
    G_io_usb_hid_current_buffer += l;
c0de7d06:	4649      	mov	r1, r9
    G_io_usb_hid_remaining_length -= l;
c0de7d08:	580a      	ldr	r2, [r1, r0]
c0de7d0a:	1b12      	subs	r2, r2, r4
c0de7d0c:	500a      	str	r2, [r1, r0]
    G_io_usb_hid_current_buffer += l;
c0de7d0e:	1928      	adds	r0, r5, r4
c0de7d10:	4a0e      	ldr	r2, [pc, #56]	; (c0de7d4c <io_usb_hid_receive+0x17c>)
c0de7d12:	5088      	str	r0, [r1, r2]
    G_io_usb_hid_sequence_number++;
c0de7d14:	59c8      	ldr	r0, [r1, r7]
c0de7d16:	1c40      	adds	r0, r0, #1
c0de7d18:	51c8      	str	r0, [r1, r7]
    // await for the next chunk
    goto apdu_reset;
  }

  // if more data to be received, notify it
  if (G_io_usb_hid_remaining_length) {
c0de7d1a:	480b      	ldr	r0, [pc, #44]	; (c0de7d48 <io_usb_hid_receive+0x178>)
c0de7d1c:	4649      	mov	r1, r9
c0de7d1e:	5808      	ldr	r0, [r1, r0]
c0de7d20:	2800      	cmp	r0, #0
c0de7d22:	d001      	beq.n	c0de7d28 <io_usb_hid_receive+0x158>
c0de7d24:	2601      	movs	r6, #1
c0de7d26:	e008      	b.n	c0de7d3a <io_usb_hid_receive+0x16a>
c0de7d28:	2602      	movs	r6, #2
c0de7d2a:	4806      	ldr	r0, [pc, #24]	; (c0de7d44 <io_usb_hid_receive+0x174>)
c0de7d2c:	4649      	mov	r1, r9
c0de7d2e:	2200      	movs	r2, #0
c0de7d30:	500a      	str	r2, [r1, r0]
c0de7d32:	4806      	ldr	r0, [pc, #24]	; (c0de7d4c <io_usb_hid_receive+0x17c>)
c0de7d34:	500a      	str	r2, [r1, r0]
c0de7d36:	4804      	ldr	r0, [pc, #16]	; (c0de7d48 <io_usb_hid_receive+0x178>)
c0de7d38:	500a      	str	r2, [r1, r0]
  return IO_USB_APDU_RECEIVED;

apdu_reset:
  io_usb_hid_init();
  return IO_USB_APDU_RESET;
}
c0de7d3a:	4630      	mov	r0, r6
c0de7d3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de7d3e:	46c0      	nop			; (mov r8, r8)
c0de7d40:	00000b54 	.word	0x00000b54
c0de7d44:	00000b98 	.word	0x00000b98
c0de7d48:	00000ba0 	.word	0x00000ba0
c0de7d4c:	00000ba4 	.word	0x00000ba4
c0de7d50:	00000b9c 	.word	0x00000b9c
c0de7d54:	00000ba8 	.word	0x00000ba8
c0de7d58:	00000990 	.word	0x00000990

c0de7d5c <io_usb_hid_init>:

void io_usb_hid_init(void) {
  G_io_usb_hid_sequence_number = 0; 
c0de7d5c:	4804      	ldr	r0, [pc, #16]	; (c0de7d70 <io_usb_hid_init+0x14>)
c0de7d5e:	4649      	mov	r1, r9
c0de7d60:	2200      	movs	r2, #0
c0de7d62:	500a      	str	r2, [r1, r0]
  G_io_usb_hid_remaining_length = 0;
  G_io_usb_hid_current_buffer = NULL;
c0de7d64:	4803      	ldr	r0, [pc, #12]	; (c0de7d74 <io_usb_hid_init+0x18>)
c0de7d66:	500a      	str	r2, [r1, r0]
  G_io_usb_hid_remaining_length = 0;
c0de7d68:	4803      	ldr	r0, [pc, #12]	; (c0de7d78 <io_usb_hid_init+0x1c>)
c0de7d6a:	500a      	str	r2, [r1, r0]
}
c0de7d6c:	4770      	bx	lr
c0de7d6e:	46c0      	nop			; (mov r8, r8)
c0de7d70:	00000b98 	.word	0x00000b98
c0de7d74:	00000ba4 	.word	0x00000ba4
c0de7d78:	00000ba0 	.word	0x00000ba0

c0de7d7c <io_usb_hid_sent>:

/**
 * sent the next io_usb_hid transport chunk (rx on the host, tx on the device)
 */
void io_usb_hid_sent(io_send_t sndfct) {
c0de7d7c:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
  unsigned int l;

  // only prepare next chunk if some data to be sent remain
  if (G_io_usb_hid_remaining_length && G_io_usb_hid_current_buffer) {
c0de7d7e:	4b2f      	ldr	r3, [pc, #188]	; (c0de7e3c <io_usb_hid_sent+0xc0>)
c0de7d80:	4649      	mov	r1, r9
c0de7d82:	58ca      	ldr	r2, [r1, r3]
c0de7d84:	4c2e      	ldr	r4, [pc, #184]	; (c0de7e40 <io_usb_hid_sent+0xc4>)
c0de7d86:	5909      	ldr	r1, [r1, r4]
c0de7d88:	2900      	cmp	r1, #0
c0de7d8a:	d029      	beq.n	c0de7de0 <io_usb_hid_sent+0x64>
c0de7d8c:	2a00      	cmp	r2, #0
c0de7d8e:	d027      	beq.n	c0de7de0 <io_usb_hid_sent+0x64>
c0de7d90:	9201      	str	r2, [sp, #4]
c0de7d92:	9002      	str	r0, [sp, #8]
    // fill the chunk
    memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
c0de7d94:	4d2d      	ldr	r5, [pc, #180]	; (c0de7e4c <io_usb_hid_sent+0xd0>)
c0de7d96:	464f      	mov	r7, r9
c0de7d98:	197c      	adds	r4, r7, r5
c0de7d9a:	1d60      	adds	r0, r4, #5
c0de7d9c:	263b      	movs	r6, #59	; 0x3b
c0de7d9e:	4631      	mov	r1, r6
c0de7da0:	f005 fd38 	bl	c0ded814 <__aeabi_memclr>

    // keep the channel identifier
    G_io_usb_ep_buffer[0] = (G_io_usb_hid_channel>>8)&0xFF;
c0de7da4:	482a      	ldr	r0, [pc, #168]	; (c0de7e50 <io_usb_hid_sent+0xd4>)
c0de7da6:	5839      	ldr	r1, [r7, r0]
c0de7da8:	0a09      	lsrs	r1, r1, #8
c0de7daa:	462a      	mov	r2, r5
c0de7dac:	5579      	strb	r1, [r7, r5]
c0de7dae:	2105      	movs	r1, #5
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
    G_io_usb_ep_buffer[2] = 0x05;
c0de7db0:	70a1      	strb	r1, [r4, #2]
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
c0de7db2:	5838      	ldr	r0, [r7, r0]
c0de7db4:	7060      	strb	r0, [r4, #1]
    G_io_usb_ep_buffer[3] = G_io_usb_hid_sequence_number>>8;
c0de7db6:	4923      	ldr	r1, [pc, #140]	; (c0de7e44 <io_usb_hid_sent+0xc8>)
c0de7db8:	5878      	ldr	r0, [r7, r1]
c0de7dba:	0a00      	lsrs	r0, r0, #8
c0de7dbc:	70e0      	strb	r0, [r4, #3]
    G_io_usb_ep_buffer[4] = G_io_usb_hid_sequence_number;
c0de7dbe:	5878      	ldr	r0, [r7, r1]
c0de7dc0:	7120      	strb	r0, [r4, #4]
c0de7dc2:	4c1f      	ldr	r4, [pc, #124]	; (c0de7e40 <io_usb_hid_sent+0xc4>)

    if (G_io_usb_hid_sequence_number == 0) {
c0de7dc4:	5879      	ldr	r1, [r7, r1]
c0de7dc6:	5938      	ldr	r0, [r7, r4]
c0de7dc8:	2900      	cmp	r1, #0
c0de7dca:	d012      	beq.n	c0de7df2 <io_usb_hid_sent+0x76>
      memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
      G_io_usb_hid_current_buffer += l;
      G_io_usb_hid_remaining_length -= l;
    }
    else {
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-5) ? IO_HID_EP_LENGTH-5 : G_io_usb_hid_remaining_length);
c0de7dcc:	283b      	cmp	r0, #59	; 0x3b
c0de7dce:	d801      	bhi.n	c0de7dd4 <io_usb_hid_sent+0x58>
c0de7dd0:	4648      	mov	r0, r9
c0de7dd2:	5906      	ldr	r6, [r0, r4]
      memmove(G_io_usb_ep_buffer+5, (const void*)G_io_usb_hid_current_buffer, l);
c0de7dd4:	4648      	mov	r0, r9
c0de7dd6:	4617      	mov	r7, r2
c0de7dd8:	1880      	adds	r0, r0, r2
c0de7dda:	1d40      	adds	r0, r0, #5
c0de7ddc:	9d01      	ldr	r5, [sp, #4]
c0de7dde:	e018      	b.n	c0de7e12 <io_usb_hid_sent+0x96>
  G_io_usb_hid_sequence_number = 0; 
c0de7de0:	4818      	ldr	r0, [pc, #96]	; (c0de7e44 <io_usb_hid_sent+0xc8>)
c0de7de2:	4649      	mov	r1, r9
c0de7de4:	2200      	movs	r2, #0
c0de7de6:	500a      	str	r2, [r1, r0]
  G_io_usb_hid_current_buffer = NULL;
c0de7de8:	50ca      	str	r2, [r1, r3]
  // cleanup when everything has been sent (ack for the last sent usb in packet)
  else {
    io_usb_hid_init();

    // we sent the whole response
    G_io_app.apdu_state = APDU_IDLE;
c0de7dea:	4817      	ldr	r0, [pc, #92]	; (c0de7e48 <io_usb_hid_sent+0xcc>)
c0de7dec:	540a      	strb	r2, [r1, r0]
  G_io_usb_hid_remaining_length = 0;
c0de7dee:	510a      	str	r2, [r1, r4]
  }
}
c0de7df0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-7) ? IO_HID_EP_LENGTH-7 : G_io_usb_hid_remaining_length);
c0de7df2:	2839      	cmp	r0, #57	; 0x39
c0de7df4:	4617      	mov	r7, r2
c0de7df6:	9d01      	ldr	r5, [sp, #4]
c0de7df8:	d901      	bls.n	c0de7dfe <io_usb_hid_sent+0x82>
c0de7dfa:	2639      	movs	r6, #57	; 0x39
c0de7dfc:	e001      	b.n	c0de7e02 <io_usb_hid_sent+0x86>
c0de7dfe:	4648      	mov	r0, r9
c0de7e00:	5906      	ldr	r6, [r0, r4]
      G_io_usb_ep_buffer[5] = G_io_usb_hid_remaining_length>>8;
c0de7e02:	4648      	mov	r0, r9
c0de7e04:	19c1      	adds	r1, r0, r7
c0de7e06:	5902      	ldr	r2, [r0, r4]
c0de7e08:	0a12      	lsrs	r2, r2, #8
c0de7e0a:	714a      	strb	r2, [r1, #5]
      G_io_usb_ep_buffer[6] = G_io_usb_hid_remaining_length;
c0de7e0c:	5900      	ldr	r0, [r0, r4]
c0de7e0e:	7188      	strb	r0, [r1, #6]
      memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
c0de7e10:	1dc8      	adds	r0, r1, #7
c0de7e12:	4629      	mov	r1, r5
c0de7e14:	4632      	mov	r2, r6
c0de7e16:	f005 fd07 	bl	c0ded828 <__aeabi_memmove>
c0de7e1a:	9a02      	ldr	r2, [sp, #8]
c0de7e1c:	4b07      	ldr	r3, [pc, #28]	; (c0de7e3c <io_usb_hid_sent+0xc0>)
c0de7e1e:	4648      	mov	r0, r9
c0de7e20:	5901      	ldr	r1, [r0, r4]
c0de7e22:	1b89      	subs	r1, r1, r6
c0de7e24:	5101      	str	r1, [r0, r4]
c0de7e26:	19a9      	adds	r1, r5, r6
c0de7e28:	50c1      	str	r1, [r0, r3]
c0de7e2a:	4b06      	ldr	r3, [pc, #24]	; (c0de7e44 <io_usb_hid_sent+0xc8>)
    G_io_usb_hid_sequence_number++;
c0de7e2c:	58c1      	ldr	r1, [r0, r3]
c0de7e2e:	1c49      	adds	r1, r1, #1
c0de7e30:	50c1      	str	r1, [r0, r3]
    sndfct(G_io_usb_ep_buffer, sizeof(G_io_usb_ep_buffer));
c0de7e32:	19c0      	adds	r0, r0, r7
c0de7e34:	2140      	movs	r1, #64	; 0x40
c0de7e36:	4790      	blx	r2
}
c0de7e38:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de7e3a:	46c0      	nop			; (mov r8, r8)
c0de7e3c:	00000ba4 	.word	0x00000ba4
c0de7e40:	00000ba0 	.word	0x00000ba0
c0de7e44:	00000b98 	.word	0x00000b98
c0de7e48:	00000ae4 	.word	0x00000ae4
c0de7e4c:	00000b54 	.word	0x00000b54
c0de7e50:	00000ba8 	.word	0x00000ba8

c0de7e54 <io_usb_hid_send>:

void io_usb_hid_send(io_send_t sndfct, unsigned short sndlength) {
c0de7e54:	b510      	push	{r4, lr}
  // perform send
  if (sndlength) {
c0de7e56:	2900      	cmp	r1, #0
c0de7e58:	d00d      	beq.n	c0de7e76 <io_usb_hid_send+0x22>
    G_io_usb_hid_sequence_number = 0; 
c0de7e5a:	4a07      	ldr	r2, [pc, #28]	; (c0de7e78 <io_usb_hid_send+0x24>)
c0de7e5c:	464b      	mov	r3, r9
c0de7e5e:	2400      	movs	r4, #0
c0de7e60:	509c      	str	r4, [r3, r2]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
    G_io_usb_hid_remaining_length = sndlength;
c0de7e62:	4a06      	ldr	r2, [pc, #24]	; (c0de7e7c <io_usb_hid_send+0x28>)
c0de7e64:	5099      	str	r1, [r3, r2]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0de7e66:	4a06      	ldr	r2, [pc, #24]	; (c0de7e80 <io_usb_hid_send+0x2c>)
c0de7e68:	189a      	adds	r2, r3, r2
c0de7e6a:	4c06      	ldr	r4, [pc, #24]	; (c0de7e84 <io_usb_hid_send+0x30>)
c0de7e6c:	511a      	str	r2, [r3, r4]
    G_io_usb_hid_total_length = sndlength;
c0de7e6e:	4a06      	ldr	r2, [pc, #24]	; (c0de7e88 <io_usb_hid_send+0x34>)
c0de7e70:	5099      	str	r1, [r3, r2]
    io_usb_hid_sent(sndfct);
c0de7e72:	f7ff ff83 	bl	c0de7d7c <io_usb_hid_sent>
  }
}
c0de7e76:	bd10      	pop	{r4, pc}
c0de7e78:	00000b98 	.word	0x00000b98
c0de7e7c:	00000ba0 	.word	0x00000ba0
c0de7e80:	00000990 	.word	0x00000990
c0de7e84:	00000ba4 	.word	0x00000ba4
c0de7e88:	00000b9c 	.word	0x00000b9c

c0de7e8c <snprintf>:
#endif // HAVE_PRINTF

#ifdef HAVE_SPRINTF
//unsigned int snprintf(unsigned char * str, unsigned int str_size, const char* format, ...)
int snprintf(char * str, size_t str_size, const char * format, ...)
 {
c0de7e8c:	b081      	sub	sp, #4
c0de7e8e:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de7e90:	b08e      	sub	sp, #56	; 0x38
c0de7e92:	9313      	str	r3, [sp, #76]	; 0x4c
    char cStrlenSet;

    //
    // Check the arguments.
    //
    if(str == NULL ||str_size < 2) {
c0de7e94:	2800      	cmp	r0, #0
c0de7e96:	d100      	bne.n	c0de7e9a <snprintf+0xe>
c0de7e98:	e1ad      	b.n	c0de81f6 <snprintf+0x36a>
c0de7e9a:	460d      	mov	r5, r1
c0de7e9c:	2902      	cmp	r1, #2
c0de7e9e:	d200      	bcs.n	c0de7ea2 <snprintf+0x16>
c0de7ea0:	e1a9      	b.n	c0de81f6 <snprintf+0x36a>
c0de7ea2:	4614      	mov	r4, r2
      return 0;
    }

    // ensure terminating string with a \0
    memset(str, 0, str_size);
c0de7ea4:	4629      	mov	r1, r5
c0de7ea6:	4606      	mov	r6, r0
c0de7ea8:	f005 fcb4 	bl	c0ded814 <__aeabi_memclr>
c0de7eac:	4633      	mov	r3, r6
c0de7eae:	a813      	add	r0, sp, #76	; 0x4c


    //
    // Start the varargs processing.
    //
    va_start(vaArgP, format);
c0de7eb0:	9009      	str	r0, [sp, #36]	; 0x24
    str_size--;
c0de7eb2:	1e6f      	subs	r7, r5, #1

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
c0de7eb4:	7820      	ldrb	r0, [r4, #0]
c0de7eb6:	2800      	cmp	r0, #0
c0de7eb8:	d100      	bne.n	c0de7ebc <snprintf+0x30>
c0de7eba:	e19c      	b.n	c0de81f6 <snprintf+0x36a>
c0de7ebc:	2600      	movs	r6, #0
    {
        //
        // Find the first non-% character, or the end of the string.
        //
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0de7ebe:	2800      	cmp	r0, #0
c0de7ec0:	d005      	beq.n	c0de7ece <snprintf+0x42>
c0de7ec2:	2825      	cmp	r0, #37	; 0x25
c0de7ec4:	d003      	beq.n	c0de7ece <snprintf+0x42>
c0de7ec6:	19a0      	adds	r0, r4, r6
c0de7ec8:	7840      	ldrb	r0, [r0, #1]
            ulIdx++)
c0de7eca:	1c76      	adds	r6, r6, #1
c0de7ecc:	e7f7      	b.n	c0de7ebe <snprintf+0x32>
        }

        //
        // Write this portion of the string.
        //
        ulIdx = MIN(ulIdx, str_size);
c0de7ece:	42be      	cmp	r6, r7
c0de7ed0:	4635      	mov	r5, r6
c0de7ed2:	d300      	bcc.n	c0de7ed6 <snprintf+0x4a>
c0de7ed4:	463d      	mov	r5, r7
        memmove(str, format, ulIdx);
c0de7ed6:	4618      	mov	r0, r3
c0de7ed8:	4621      	mov	r1, r4
c0de7eda:	9307      	str	r3, [sp, #28]
c0de7edc:	9708      	str	r7, [sp, #32]
c0de7ede:	462a      	mov	r2, r5
c0de7ee0:	f005 fca2 	bl	c0ded828 <__aeabi_memmove>
c0de7ee4:	9807      	ldr	r0, [sp, #28]
        str+= ulIdx;
        str_size -= ulIdx;
c0de7ee6:	9908      	ldr	r1, [sp, #32]
c0de7ee8:	1b4f      	subs	r7, r1, r5
c0de7eea:	d100      	bne.n	c0de7eee <snprintf+0x62>
c0de7eec:	e183      	b.n	c0de81f6 <snprintf+0x36a>
c0de7eee:	1943      	adds	r3, r0, r5
        }

        //
        // Skip the portion of the string that was written.
        //
        format += ulIdx;
c0de7ef0:	1960      	adds	r0, r4, r5

        //
        // See if the next character is a %.
        //
        if(*format == '%')
c0de7ef2:	5d61      	ldrb	r1, [r4, r5]
c0de7ef4:	2925      	cmp	r1, #37	; 0x25
c0de7ef6:	4604      	mov	r4, r0
c0de7ef8:	d1dc      	bne.n	c0de7eb4 <snprintf+0x28>
c0de7efa:	9303      	str	r3, [sp, #12]
        {
            //
            // Skip the %.
            //
            format++;
c0de7efc:	1c44      	adds	r4, r0, #1
c0de7efe:	2100      	movs	r1, #0
c0de7f00:	2020      	movs	r0, #32
c0de7f02:	9004      	str	r0, [sp, #16]
c0de7f04:	200a      	movs	r0, #10
c0de7f06:	9005      	str	r0, [sp, #20]
c0de7f08:	9100      	str	r1, [sp, #0]
c0de7f0a:	9101      	str	r1, [sp, #4]
c0de7f0c:	9106      	str	r1, [sp, #24]
c0de7f0e:	9702      	str	r7, [sp, #8]
c0de7f10:	460b      	mov	r3, r1
c0de7f12:	4619      	mov	r1, r3
again:

            //
            // Determine how to handle the next character.
            //
            switch(*format++)
c0de7f14:	7820      	ldrb	r0, [r4, #0]
c0de7f16:	1c64      	adds	r4, r4, #1
c0de7f18:	2300      	movs	r3, #0
c0de7f1a:	282d      	cmp	r0, #45	; 0x2d
c0de7f1c:	d0f9      	beq.n	c0de7f12 <snprintf+0x86>
c0de7f1e:	4603      	mov	r3, r0
c0de7f20:	3b30      	subs	r3, #48	; 0x30
c0de7f22:	2b0a      	cmp	r3, #10
c0de7f24:	d31d      	bcc.n	c0de7f62 <snprintf+0xd6>
c0de7f26:	2825      	cmp	r0, #37	; 0x25
c0de7f28:	d058      	beq.n	c0de7fdc <snprintf+0x150>
c0de7f2a:	282a      	cmp	r0, #42	; 0x2a
c0de7f2c:	9b03      	ldr	r3, [sp, #12]
c0de7f2e:	d00e      	beq.n	c0de7f4e <snprintf+0xc2>
c0de7f30:	282e      	cmp	r0, #46	; 0x2e
c0de7f32:	d126      	bne.n	c0de7f82 <snprintf+0xf6>
                // special %.*H or %.*h format to print a given length of hex digits (case: H UPPER, h lower)
                //
                case '.':
                {
                  // ensure next char is '*' and next one is 's'/'h'/'H'
                  if (format[0] == '*' && (format[1] == 's' || format[1] == 'H' || format[1] == 'h')) {
c0de7f34:	7820      	ldrb	r0, [r4, #0]
c0de7f36:	282a      	cmp	r0, #42	; 0x2a
c0de7f38:	d1bc      	bne.n	c0de7eb4 <snprintf+0x28>
c0de7f3a:	7861      	ldrb	r1, [r4, #1]
c0de7f3c:	2948      	cmp	r1, #72	; 0x48
c0de7f3e:	d003      	beq.n	c0de7f48 <snprintf+0xbc>
c0de7f40:	2973      	cmp	r1, #115	; 0x73
c0de7f42:	d001      	beq.n	c0de7f48 <snprintf+0xbc>
c0de7f44:	2968      	cmp	r1, #104	; 0x68
c0de7f46:	d1b5      	bne.n	c0de7eb4 <snprintf+0x28>
c0de7f48:	1c64      	adds	r4, r4, #1
c0de7f4a:	2301      	movs	r3, #1
c0de7f4c:	e003      	b.n	c0de7f56 <snprintf+0xca>
                  goto error;
                }

                case '*':
                {
                  if (*format == 's' ) {
c0de7f4e:	7820      	ldrb	r0, [r4, #0]
c0de7f50:	2873      	cmp	r0, #115	; 0x73
c0de7f52:	d1af      	bne.n	c0de7eb4 <snprintf+0x28>
c0de7f54:	2302      	movs	r3, #2
c0de7f56:	9909      	ldr	r1, [sp, #36]	; 0x24
c0de7f58:	1d08      	adds	r0, r1, #4
c0de7f5a:	9009      	str	r0, [sp, #36]	; 0x24
c0de7f5c:	6808      	ldr	r0, [r1, #0]
            switch(*format++)
c0de7f5e:	9000      	str	r0, [sp, #0]
c0de7f60:	e7d7      	b.n	c0de7f12 <snprintf+0x86>
c0de7f62:	2330      	movs	r3, #48	; 0x30
                    if((format[-1] == '0') && (ulCount == 0))
c0de7f64:	4602      	mov	r2, r0
c0de7f66:	405a      	eors	r2, r3
c0de7f68:	9f06      	ldr	r7, [sp, #24]
c0de7f6a:	433a      	orrs	r2, r7
c0de7f6c:	d000      	beq.n	c0de7f70 <snprintf+0xe4>
c0de7f6e:	9b04      	ldr	r3, [sp, #16]
c0de7f70:	220a      	movs	r2, #10
                    ulCount *= 10;
c0de7f72:	9f06      	ldr	r7, [sp, #24]
c0de7f74:	437a      	muls	r2, r7
                    ulCount += format[-1] - '0';
c0de7f76:	1810      	adds	r0, r2, r0
c0de7f78:	3830      	subs	r0, #48	; 0x30
c0de7f7a:	9006      	str	r0, [sp, #24]
c0de7f7c:	9304      	str	r3, [sp, #16]
c0de7f7e:	9f02      	ldr	r7, [sp, #8]
c0de7f80:	e7c6      	b.n	c0de7f10 <snprintf+0x84>
            switch(*format++)
c0de7f82:	2848      	cmp	r0, #72	; 0x48
c0de7f84:	d00c      	beq.n	c0de7fa0 <snprintf+0x114>
c0de7f86:	2858      	cmp	r0, #88	; 0x58
c0de7f88:	d02b      	beq.n	c0de7fe2 <snprintf+0x156>
c0de7f8a:	2863      	cmp	r0, #99	; 0x63
c0de7f8c:	d033      	beq.n	c0de7ff6 <snprintf+0x16a>
c0de7f8e:	2864      	cmp	r0, #100	; 0x64
c0de7f90:	d039      	beq.n	c0de8006 <snprintf+0x17a>
c0de7f92:	2868      	cmp	r0, #104	; 0x68
c0de7f94:	d006      	beq.n	c0de7fa4 <snprintf+0x118>
c0de7f96:	2870      	cmp	r0, #112	; 0x70
c0de7f98:	d025      	beq.n	c0de7fe6 <snprintf+0x15a>
c0de7f9a:	2873      	cmp	r0, #115	; 0x73
c0de7f9c:	d119      	bne.n	c0de7fd2 <snprintf+0x146>
c0de7f9e:	e003      	b.n	c0de7fa8 <snprintf+0x11c>
c0de7fa0:	2001      	movs	r0, #1
c0de7fa2:	9001      	str	r0, [sp, #4]
c0de7fa4:	2010      	movs	r0, #16
c0de7fa6:	9005      	str	r0, [sp, #20]
                case_s:
                {
                    //
                    // Get the string pointer from the varargs.
                    //
                    pcStr = va_arg(vaArgP, char *);
c0de7fa8:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0de7faa:	1d18      	adds	r0, r3, #4
c0de7fac:	9009      	str	r0, [sp, #36]	; 0x24

                    //
                    // Determine the length of the string. (if not specified using .*)
                    //
                    switch(cStrlenSet) {
c0de7fae:	b2ca      	uxtb	r2, r1
c0de7fb0:	2a03      	cmp	r2, #3
c0de7fb2:	d0ad      	beq.n	c0de7f10 <snprintf+0x84>
c0de7fb4:	6819      	ldr	r1, [r3, #0]
c0de7fb6:	2a01      	cmp	r2, #1
c0de7fb8:	d100      	bne.n	c0de7fbc <snprintf+0x130>
c0de7fba:	e0a7      	b.n	c0de810c <snprintf+0x280>
c0de7fbc:	2a02      	cmp	r2, #2
c0de7fbe:	9b03      	ldr	r3, [sp, #12]
c0de7fc0:	d100      	bne.n	c0de7fc4 <snprintf+0x138>
c0de7fc2:	e0ef      	b.n	c0de81a4 <snprintf+0x318>
c0de7fc4:	2200      	movs	r2, #0
                      // compute length with strlen
                      case 0:
                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
c0de7fc6:	5c88      	ldrb	r0, [r1, r2]
c0de7fc8:	1c52      	adds	r2, r2, #1
c0de7fca:	2800      	cmp	r0, #0
c0de7fcc:	d1fb      	bne.n	c0de7fc6 <snprintf+0x13a>
                    }

                    //
                    // Write the string.
                    //
                    switch(ulBase) {
c0de7fce:	1e55      	subs	r5, r2, #1
c0de7fd0:	e09e      	b.n	c0de8110 <snprintf+0x284>
            switch(*format++)
c0de7fd2:	2875      	cmp	r0, #117	; 0x75
c0de7fd4:	d021      	beq.n	c0de801a <snprintf+0x18e>
c0de7fd6:	2878      	cmp	r0, #120	; 0x78
c0de7fd8:	d005      	beq.n	c0de7fe6 <snprintf+0x15a>
c0de7fda:	e76b      	b.n	c0de7eb4 <snprintf+0x28>
c0de7fdc:	2025      	movs	r0, #37	; 0x25
c0de7fde:	9b03      	ldr	r3, [sp, #12]
c0de7fe0:	e00d      	b.n	c0de7ffe <snprintf+0x172>
c0de7fe2:	2001      	movs	r0, #1
c0de7fe4:	9001      	str	r0, [sp, #4]
                case 'p':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0de7fe6:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de7fe8:	1d01      	adds	r1, r0, #4
c0de7fea:	9109      	str	r1, [sp, #36]	; 0x24
c0de7fec:	6800      	ldr	r0, [r0, #0]
c0de7fee:	9008      	str	r0, [sp, #32]
c0de7ff0:	2700      	movs	r7, #0
c0de7ff2:	2010      	movs	r0, #16
c0de7ff4:	e018      	b.n	c0de8028 <snprintf+0x19c>
                    ulValue = va_arg(vaArgP, unsigned long);
c0de7ff6:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de7ff8:	1d01      	adds	r1, r0, #4
c0de7ffa:	9109      	str	r1, [sp, #36]	; 0x24
c0de7ffc:	6800      	ldr	r0, [r0, #0]
c0de7ffe:	7018      	strb	r0, [r3, #0]
c0de8000:	1e7f      	subs	r7, r7, #1
c0de8002:	1c5b      	adds	r3, r3, #1
c0de8004:	e0f1      	b.n	c0de81ea <snprintf+0x35e>
                    ulValue = va_arg(vaArgP, unsigned long);
c0de8006:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de8008:	1d01      	adds	r1, r0, #4
c0de800a:	9109      	str	r1, [sp, #36]	; 0x24
c0de800c:	6800      	ldr	r0, [r0, #0]
                    if((long)ulValue < 0)
c0de800e:	17c1      	asrs	r1, r0, #31
c0de8010:	1842      	adds	r2, r0, r1
c0de8012:	404a      	eors	r2, r1
c0de8014:	9208      	str	r2, [sp, #32]
c0de8016:	0fc7      	lsrs	r7, r0, #31
c0de8018:	e005      	b.n	c0de8026 <snprintf+0x19a>
                    ulValue = va_arg(vaArgP, unsigned long);
c0de801a:	9809      	ldr	r0, [sp, #36]	; 0x24
c0de801c:	1d01      	adds	r1, r0, #4
c0de801e:	9109      	str	r1, [sp, #36]	; 0x24
c0de8020:	6800      	ldr	r0, [r0, #0]
c0de8022:	9008      	str	r0, [sp, #32]
c0de8024:	2700      	movs	r7, #0
c0de8026:	200a      	movs	r0, #10
c0de8028:	9007      	str	r0, [sp, #28]
c0de802a:	4878      	ldr	r0, [pc, #480]	; (c0de820c <snprintf+0x380>)
c0de802c:	4478      	add	r0, pc
c0de802e:	9005      	str	r0, [sp, #20]
c0de8030:	4877      	ldr	r0, [pc, #476]	; (c0de8210 <snprintf+0x384>)
c0de8032:	4478      	add	r0, pc
c0de8034:	9000      	str	r0, [sp, #0]
c0de8036:	2501      	movs	r5, #1
c0de8038:	2600      	movs	r6, #0
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
                        (((ulIdx * ulBase) <= ulValue) &&
c0de803a:	9807      	ldr	r0, [sp, #28]
c0de803c:	4631      	mov	r1, r6
c0de803e:	462a      	mov	r2, r5
c0de8040:	4633      	mov	r3, r6
c0de8042:	f005 fac1 	bl	c0ded5c8 <__aeabi_lmul>
c0de8046:	1e4a      	subs	r2, r1, #1
c0de8048:	4191      	sbcs	r1, r2
c0de804a:	9a08      	ldr	r2, [sp, #32]
c0de804c:	4290      	cmp	r0, r2
c0de804e:	d806      	bhi.n	c0de805e <snprintf+0x1d2>
                    for(ulIdx = 1;
c0de8050:	2900      	cmp	r1, #0
c0de8052:	d104      	bne.n	c0de805e <snprintf+0x1d2>
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
                        ulIdx *= ulBase, ulCount--)
c0de8054:	9906      	ldr	r1, [sp, #24]
c0de8056:	1e49      	subs	r1, r1, #1
c0de8058:	9106      	str	r1, [sp, #24]
c0de805a:	4605      	mov	r5, r0
c0de805c:	e7ec      	b.n	c0de8038 <snprintf+0x1ac>

                    //
                    // If the value is negative, reduce the count of padding
                    // characters needed.
                    //
                    if(ulNeg)
c0de805e:	2f00      	cmp	r7, #0
c0de8060:	d101      	bne.n	c0de8066 <snprintf+0x1da>
c0de8062:	4639      	mov	r1, r7
c0de8064:	e000      	b.n	c0de8068 <snprintf+0x1dc>
c0de8066:	43f1      	mvns	r1, r6

                    //
                    // If the value is negative and the value is padded with
                    // zeros, then place the minus sign before the padding.
                    //
                    if(ulNeg && (cFill == '0'))
c0de8068:	2f00      	cmp	r7, #0
c0de806a:	d008      	beq.n	c0de807e <snprintf+0x1f2>
c0de806c:	9804      	ldr	r0, [sp, #16]
c0de806e:	b2c0      	uxtb	r0, r0
c0de8070:	2830      	cmp	r0, #48	; 0x30
c0de8072:	d107      	bne.n	c0de8084 <snprintf+0x1f8>
c0de8074:	a80a      	add	r0, sp, #40	; 0x28
c0de8076:	222d      	movs	r2, #45	; 0x2d
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0de8078:	7002      	strb	r2, [r0, #0]
c0de807a:	2701      	movs	r7, #1
c0de807c:	e000      	b.n	c0de8080 <snprintf+0x1f4>
c0de807e:	4637      	mov	r7, r6
c0de8080:	4630      	mov	r0, r6
c0de8082:	e001      	b.n	c0de8088 <snprintf+0x1fc>
c0de8084:	2001      	movs	r0, #1
c0de8086:	4637      	mov	r7, r6
c0de8088:	9b01      	ldr	r3, [sp, #4]
c0de808a:	9e06      	ldr	r6, [sp, #24]

                    //
                    // Provide additional padding at the beginning of the
                    // string conversion if needed.
                    //
                    if((ulCount > 1) && (ulCount < 16))
c0de808c:	198a      	adds	r2, r1, r6
c0de808e:	1e92      	subs	r2, r2, #2
c0de8090:	2a0d      	cmp	r2, #13
c0de8092:	d80b      	bhi.n	c0de80ac <snprintf+0x220>
c0de8094:	9301      	str	r3, [sp, #4]
c0de8096:	2201      	movs	r2, #1
                    {
                        for(ulCount--; ulCount; ulCount--)
c0de8098:	1a51      	subs	r1, r2, r1
c0de809a:	428e      	cmp	r6, r1
c0de809c:	d005      	beq.n	c0de80aa <snprintf+0x21e>
c0de809e:	aa0a      	add	r2, sp, #40	; 0x28
                        {
                            pcBuf[ulPos++] = cFill;
c0de80a0:	9b04      	ldr	r3, [sp, #16]
c0de80a2:	55d3      	strb	r3, [r2, r7]
                        for(ulCount--; ulCount; ulCount--)
c0de80a4:	1c49      	adds	r1, r1, #1
                            pcBuf[ulPos++] = cFill;
c0de80a6:	1c7f      	adds	r7, r7, #1
c0de80a8:	e7f7      	b.n	c0de809a <snprintf+0x20e>
c0de80aa:	9b01      	ldr	r3, [sp, #4]

                    //
                    // If the value is negative, then place the minus sign
                    // before the number.
                    //
                    if(ulNeg)
c0de80ac:	2800      	cmp	r0, #0
c0de80ae:	d003      	beq.n	c0de80b8 <snprintf+0x22c>
c0de80b0:	a80a      	add	r0, sp, #40	; 0x28
c0de80b2:	212d      	movs	r1, #45	; 0x2d
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0de80b4:	55c1      	strb	r1, [r0, r7]
c0de80b6:	1c7f      	adds	r7, r7, #1
c0de80b8:	2b00      	cmp	r3, #0
c0de80ba:	d014      	beq.n	c0de80e6 <snprintf+0x25a>
c0de80bc:	9800      	ldr	r0, [sp, #0]
c0de80be:	9005      	str	r0, [sp, #20]
c0de80c0:	e011      	b.n	c0de80e6 <snprintf+0x25a>
c0de80c2:	9808      	ldr	r0, [sp, #32]
c0de80c4:	4629      	mov	r1, r5
c0de80c6:	f005 f9bb 	bl	c0ded440 <__udivsi3>
c0de80ca:	9e07      	ldr	r6, [sp, #28]
c0de80cc:	4631      	mov	r1, r6
c0de80ce:	f005 fa3d 	bl	c0ded54c <__aeabi_uidivmod>
c0de80d2:	9805      	ldr	r0, [sp, #20]
c0de80d4:	5c40      	ldrb	r0, [r0, r1]
c0de80d6:	a90a      	add	r1, sp, #40	; 0x28
                    // Convert the value into a string.
                    //
                    for(; ulIdx; ulIdx /= ulBase)
                    {
                        if (!ulCap) {
                          pcBuf[ulPos++] = g_pcHex[(ulValue / ulIdx) % ulBase];
c0de80d8:	55c8      	strb	r0, [r1, r7]
                    for(; ulIdx; ulIdx /= ulBase)
c0de80da:	4628      	mov	r0, r5
c0de80dc:	4631      	mov	r1, r6
c0de80de:	f005 f9af 	bl	c0ded440 <__udivsi3>
c0de80e2:	4605      	mov	r5, r0
c0de80e4:	1c7f      	adds	r7, r7, #1
c0de80e6:	2d00      	cmp	r5, #0
c0de80e8:	d1eb      	bne.n	c0de80c2 <snprintf+0x236>
c0de80ea:	9d02      	ldr	r5, [sp, #8]
                    }

                    //
                    // Write the string.
                    //
                    ulPos = MIN(ulPos, str_size);
c0de80ec:	42af      	cmp	r7, r5
c0de80ee:	d300      	bcc.n	c0de80f2 <snprintf+0x266>
c0de80f0:	462f      	mov	r7, r5
c0de80f2:	a90a      	add	r1, sp, #40	; 0x28
c0de80f4:	9e03      	ldr	r6, [sp, #12]
                    memmove(str, pcBuf, ulPos);
c0de80f6:	4630      	mov	r0, r6
c0de80f8:	463a      	mov	r2, r7
c0de80fa:	f005 fb95 	bl	c0ded828 <__aeabi_memmove>
c0de80fe:	4633      	mov	r3, r6
                    str+= ulPos;
                    str_size -= ulPos;
c0de8100:	1bed      	subs	r5, r5, r7
                    str+= ulPos;
c0de8102:	19f3      	adds	r3, r6, r7
                    if (str_size == 0) {
c0de8104:	2d00      	cmp	r5, #0
c0de8106:	462f      	mov	r7, r5
c0de8108:	d075      	beq.n	c0de81f6 <snprintf+0x36a>
c0de810a:	e6d3      	b.n	c0de7eb4 <snprintf+0x28>
c0de810c:	9d00      	ldr	r5, [sp, #0]
c0de810e:	9b03      	ldr	r3, [sp, #12]
                    switch(ulBase) {
c0de8110:	9805      	ldr	r0, [sp, #20]
c0de8112:	2810      	cmp	r0, #16
c0de8114:	d13a      	bne.n	c0de818c <snprintf+0x300>
c0de8116:	9105      	str	r1, [sp, #20]
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0de8118:	006a      	lsls	r2, r5, #1
c0de811a:	9808      	ldr	r0, [sp, #32]
c0de811c:	42b0      	cmp	r0, r6
c0de811e:	d300      	bcc.n	c0de8122 <snprintf+0x296>
c0de8120:	4630      	mov	r0, r6
c0de8122:	1abf      	subs	r7, r7, r2
c0de8124:	2201      	movs	r2, #1
c0de8126:	43d2      	mvns	r2, r2
c0de8128:	9204      	str	r2, [sp, #16]
c0de812a:	1c51      	adds	r1, r2, #1
c0de812c:	4341      	muls	r1, r0
c0de812e:	9106      	str	r1, [sp, #24]
c0de8130:	1c81      	adds	r1, r0, #2
c0de8132:	9702      	str	r7, [sp, #8]
c0de8134:	9807      	ldr	r0, [sp, #28]
c0de8136:	9a08      	ldr	r2, [sp, #32]
c0de8138:	1846      	adds	r6, r0, r1
c0de813a:	2d00      	cmp	r5, #0
c0de813c:	d058      	beq.n	c0de81f0 <snprintf+0x364>
c0de813e:	9806      	ldr	r0, [sp, #24]
c0de8140:	1810      	adds	r0, r2, r0
                          if (str_size < 2) {
c0de8142:	2802      	cmp	r0, #2
c0de8144:	d357      	bcc.n	c0de81f6 <snprintf+0x36a>
c0de8146:	9805      	ldr	r0, [sp, #20]
c0de8148:	7800      	ldrb	r0, [r0, #0]
c0de814a:	9a01      	ldr	r2, [sp, #4]
                          switch(ulCap) {
c0de814c:	2a00      	cmp	r2, #0
c0de814e:	d004      	beq.n	c0de815a <snprintf+0x2ce>
c0de8150:	2a01      	cmp	r2, #1
c0de8152:	d10e      	bne.n	c0de8172 <snprintf+0x2e6>
c0de8154:	4a2c      	ldr	r2, [pc, #176]	; (c0de8208 <snprintf+0x37c>)
c0de8156:	447a      	add	r2, pc
c0de8158:	e001      	b.n	c0de815e <snprintf+0x2d2>
c0de815a:	4a2a      	ldr	r2, [pc, #168]	; (c0de8204 <snprintf+0x378>)
c0de815c:	447a      	add	r2, pc
c0de815e:	270f      	movs	r7, #15
c0de8160:	4007      	ands	r7, r0
c0de8162:	0900      	lsrs	r0, r0, #4
c0de8164:	5c10      	ldrb	r0, [r2, r0]
c0de8166:	9b04      	ldr	r3, [sp, #16]
c0de8168:	54f0      	strb	r0, [r6, r3]
c0de816a:	5dd0      	ldrb	r0, [r2, r7]
c0de816c:	199a      	adds	r2, r3, r6
c0de816e:	7050      	strb	r0, [r2, #1]
c0de8170:	9f02      	ldr	r7, [sp, #8]
c0de8172:	9a08      	ldr	r2, [sp, #32]
                          if (str_size == 0) {
c0de8174:	428a      	cmp	r2, r1
c0de8176:	9807      	ldr	r0, [sp, #28]
c0de8178:	d03d      	beq.n	c0de81f6 <snprintf+0x36a>
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0de817a:	9b06      	ldr	r3, [sp, #24]
c0de817c:	1e9b      	subs	r3, r3, #2
c0de817e:	9306      	str	r3, [sp, #24]
c0de8180:	1c89      	adds	r1, r1, #2
c0de8182:	9b05      	ldr	r3, [sp, #20]
c0de8184:	1c5b      	adds	r3, r3, #1
c0de8186:	9305      	str	r3, [sp, #20]
c0de8188:	1e6d      	subs	r5, r5, #1
c0de818a:	e7d5      	b.n	c0de8138 <snprintf+0x2ac>
                        ulIdx = MIN(ulIdx, str_size);
c0de818c:	42bd      	cmp	r5, r7
c0de818e:	d300      	bcc.n	c0de8192 <snprintf+0x306>
c0de8190:	463d      	mov	r5, r7
                        memmove(str, pcStr, ulIdx);
c0de8192:	4618      	mov	r0, r3
c0de8194:	462a      	mov	r2, r5
c0de8196:	f005 fb47 	bl	c0ded828 <__aeabi_memmove>
c0de819a:	9b03      	ldr	r3, [sp, #12]
                        str_size -= ulIdx;
c0de819c:	1b7f      	subs	r7, r7, r5
c0de819e:	462e      	mov	r6, r5
c0de81a0:	d110      	bne.n	c0de81c4 <snprintf+0x338>
c0de81a2:	e028      	b.n	c0de81f6 <snprintf+0x36a>
                        if (pcStr[0] == '\0') {
c0de81a4:	7808      	ldrb	r0, [r1, #0]
c0de81a6:	2800      	cmp	r0, #0
c0de81a8:	9e00      	ldr	r6, [sp, #0]
c0de81aa:	d000      	beq.n	c0de81ae <snprintf+0x322>
c0de81ac:	e682      	b.n	c0de7eb4 <snprintf+0x28>
                          ulStrlen = MIN(ulStrlen, str_size);
c0de81ae:	42be      	cmp	r6, r7
c0de81b0:	d300      	bcc.n	c0de81b4 <snprintf+0x328>
c0de81b2:	463e      	mov	r6, r7
c0de81b4:	2220      	movs	r2, #32
                          memset(str, ' ', ulStrlen);
c0de81b6:	4618      	mov	r0, r3
c0de81b8:	4631      	mov	r1, r6
c0de81ba:	f005 fb39 	bl	c0ded830 <__aeabi_memset>
c0de81be:	9b03      	ldr	r3, [sp, #12]
                          str_size -= ulStrlen;
c0de81c0:	1bbf      	subs	r7, r7, r6
                          if (str_size == 0) {
c0de81c2:	d018      	beq.n	c0de81f6 <snprintf+0x36a>
c0de81c4:	199b      	adds	r3, r3, r6
                    if(ulCount > ulIdx)
c0de81c6:	9806      	ldr	r0, [sp, #24]
c0de81c8:	42a8      	cmp	r0, r5
c0de81ca:	d800      	bhi.n	c0de81ce <snprintf+0x342>
c0de81cc:	e672      	b.n	c0de7eb4 <snprintf+0x28>
                        ulCount -= ulIdx;
c0de81ce:	9806      	ldr	r0, [sp, #24]
c0de81d0:	1b45      	subs	r5, r0, r5
                        ulCount = MIN(ulCount, str_size);
c0de81d2:	42bd      	cmp	r5, r7
c0de81d4:	d300      	bcc.n	c0de81d8 <snprintf+0x34c>
c0de81d6:	463d      	mov	r5, r7
c0de81d8:	2220      	movs	r2, #32
                        memset(str, ' ', ulCount);
c0de81da:	4618      	mov	r0, r3
c0de81dc:	4629      	mov	r1, r5
c0de81de:	461e      	mov	r6, r3
c0de81e0:	f005 fb26 	bl	c0ded830 <__aeabi_memset>
c0de81e4:	4633      	mov	r3, r6
                        str_size -= ulCount;
c0de81e6:	1b7f      	subs	r7, r7, r5
                        str+= ulCount;
c0de81e8:	1973      	adds	r3, r6, r5
c0de81ea:	2f00      	cmp	r7, #0
c0de81ec:	d003      	beq.n	c0de81f6 <snprintf+0x36a>
c0de81ee:	e661      	b.n	c0de7eb4 <snprintf+0x28>
c0de81f0:	9804      	ldr	r0, [sp, #16]
c0de81f2:	1833      	adds	r3, r6, r0
c0de81f4:	e65e      	b.n	c0de7eb4 <snprintf+0x28>
c0de81f6:	2000      	movs	r0, #0
    // End the varargs processing.
    //
    va_end(vaArgP);

    return 0;
}
c0de81f8:	b00e      	add	sp, #56	; 0x38
c0de81fa:	bcf0      	pop	{r4, r5, r6, r7}
c0de81fc:	bc02      	pop	{r1}
c0de81fe:	b001      	add	sp, #4
c0de8200:	4708      	bx	r1
c0de8202:	46c0      	nop			; (mov r8, r8)
c0de8204:	00007c05 	.word	0x00007c05
c0de8208:	00007c1b 	.word	0x00007c1b
c0de820c:	00007d35 	.word	0x00007d35
c0de8210:	00007d3f 	.word	0x00007d3f

c0de8214 <Osal_MemCpy>:
 * Osal_MemCpy
 * 
 */
 
void* Osal_MemCpy( void *dest, const void *src, unsigned int size )
{
c0de8214:	b510      	push	{r4, lr}
c0de8216:	4604      	mov	r4, r0
  return memcpy( dest, src, size ); 
c0de8218:	f005 fb02 	bl	c0ded820 <__aeabi_memcpy>
c0de821c:	4620      	mov	r0, r4
c0de821e:	bd10      	pop	{r4, pc}

c0de8220 <Osal_MemSet>:
 * Osal_MemSet
 * 
 */
 
void* Osal_MemSet( void *ptr, int value, unsigned int size )
{
c0de8220:	b510      	push	{r4, lr}
c0de8222:	4613      	mov	r3, r2
c0de8224:	4604      	mov	r4, r0
  return memset( ptr, value, size );
c0de8226:	b2ca      	uxtb	r2, r1
c0de8228:	4619      	mov	r1, r3
c0de822a:	f005 fb01 	bl	c0ded830 <__aeabi_memset>
c0de822e:	4620      	mov	r0, r4
c0de8230:	bd10      	pop	{r4, pc}
c0de8232:	d4d4      	bmi.n	c0de81de <snprintf+0x352>

c0de8234 <pic_internal>:
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
__attribute__((naked)) void *pic_internal(void *link_address)
{
  // compute the delta offset between LinkMemAddr & ExecMemAddr
  __asm volatile ("mov r2, pc\n");
c0de8234:	467a      	mov	r2, pc
  __asm volatile ("ldr r1, =pic_internal\n");
c0de8236:	4902      	ldr	r1, [pc, #8]	; (c0de8240 <pic_internal+0xc>)
  __asm volatile ("adds r1, r1, #3\n");
c0de8238:	1cc9      	adds	r1, r1, #3
  __asm volatile ("subs r1, r1, r2\n");
c0de823a:	1a89      	subs	r1, r1, r2

  // adjust value of the given parameter
  __asm volatile ("subs r0, r0, r1\n");
c0de823c:	1a40      	subs	r0, r0, r1
  __asm volatile ("bx lr\n");
c0de823e:	4770      	bx	lr
c0de8240:	c0de8235 	.word	0xc0de8235

c0de8244 <pic>:
#elif defined(ST33)

extern void _bss;
extern void _estack;

void *pic(void *link_address) {
c0de8244:	b580      	push	{r7, lr}
  void *n, *en;

  // check if in the LINKED TEXT zone
  __asm volatile("ldr %0, =_nvram":"=r"(n));
c0de8246:	4a09      	ldr	r2, [pc, #36]	; (c0de826c <pic+0x28>)
  __asm volatile("ldr %0, =_envram":"=r"(en));
c0de8248:	4909      	ldr	r1, [pc, #36]	; (c0de8270 <pic+0x2c>)
  if (link_address >= n && link_address <= en) {
c0de824a:	4282      	cmp	r2, r0
c0de824c:	d803      	bhi.n	c0de8256 <pic+0x12>
c0de824e:	4281      	cmp	r1, r0
c0de8250:	d301      	bcc.n	c0de8256 <pic+0x12>
    link_address = pic_internal(link_address);
c0de8252:	f7ff ffef 	bl	c0de8234 <pic_internal>
  }

  // check if in the LINKED RAM zone
  __asm volatile("ldr %0, =_bss":"=r"(n));
c0de8256:	4907      	ldr	r1, [pc, #28]	; (c0de8274 <pic+0x30>)
  __asm volatile("ldr %0, =_estack":"=r"(en));
c0de8258:	4a07      	ldr	r2, [pc, #28]	; (c0de8278 <pic+0x34>)
  if (link_address >= n && link_address <= en) {
c0de825a:	4288      	cmp	r0, r1
c0de825c:	d304      	bcc.n	c0de8268 <pic+0x24>
c0de825e:	4290      	cmp	r0, r2
c0de8260:	d802      	bhi.n	c0de8268 <pic+0x24>
    __asm volatile("mov %0, r9":"=r"(en));
    // deref into the RAM therefore add the RAM offset from R9
    link_address = (char *)link_address - (char *)n + (char *)en;
c0de8262:	1a40      	subs	r0, r0, r1
    __asm volatile("mov %0, r9":"=r"(en));
c0de8264:	4649      	mov	r1, r9
    link_address = (char *)link_address - (char *)n + (char *)en;
c0de8266:	1808      	adds	r0, r1, r0
  }

  return link_address;
c0de8268:	bd80      	pop	{r7, pc}
c0de826a:	46c0      	nop			; (mov r8, r8)
c0de826c:	c0de0000 	.word	0xc0de0000
c0de8270:	c0df1800 	.word	0xc0df1800
c0de8274:	da7a0000 	.word	0xda7a0000
c0de8278:	da7a7800 	.word	0xda7a7800

c0de827c <poorstream_init>:
#ifdef HAVE_STARKWARE

#include "poorstream.h"

void poorstream_init(poorstream_t *stream, uint8_t *buffer) {
c0de827c:	b5b0      	push	{r4, r5, r7, lr}
c0de827e:	460c      	mov	r4, r1
c0de8280:	4605      	mov	r5, r0
    memset((void *) stream, 0, sizeof(poorstream_t));
c0de8282:	1d00      	adds	r0, r0, #4
c0de8284:	2114      	movs	r1, #20
c0de8286:	f005 fac5 	bl	c0ded814 <__aeabi_memclr>
    stream->pointer = buffer;
c0de828a:	602c      	str	r4, [r5, #0]
}
c0de828c:	bdb0      	pop	{r4, r5, r7, pc}

c0de828e <poorstream_flush>:

void poorstream_flush(poorstream_t *stream) {
    // PRINTF("Flush\n");
    *(stream->pointer + 0) = (stream->accumulator >> 56);
c0de828e:	6801      	ldr	r1, [r0, #0]
c0de8290:	7dc2      	ldrb	r2, [r0, #23]
c0de8292:	700a      	strb	r2, [r1, #0]
    *(stream->pointer + 1) = (stream->accumulator >> 48);
c0de8294:	6801      	ldr	r1, [r0, #0]
c0de8296:	7d82      	ldrb	r2, [r0, #22]
c0de8298:	704a      	strb	r2, [r1, #1]
    *(stream->pointer + 2) = (stream->accumulator >> 40);
c0de829a:	6801      	ldr	r1, [r0, #0]
c0de829c:	7d42      	ldrb	r2, [r0, #21]
c0de829e:	708a      	strb	r2, [r1, #2]
    *(stream->pointer + 3) = (stream->accumulator >> 32);
c0de82a0:	6801      	ldr	r1, [r0, #0]
c0de82a2:	7d02      	ldrb	r2, [r0, #20]
c0de82a4:	70ca      	strb	r2, [r1, #3]
    *(stream->pointer + 4) = (stream->accumulator >> 24);
c0de82a6:	6801      	ldr	r1, [r0, #0]
c0de82a8:	7cc2      	ldrb	r2, [r0, #19]
c0de82aa:	710a      	strb	r2, [r1, #4]
    *(stream->pointer + 5) = (stream->accumulator >> 16);
c0de82ac:	6801      	ldr	r1, [r0, #0]
c0de82ae:	7c82      	ldrb	r2, [r0, #18]
c0de82b0:	714a      	strb	r2, [r1, #5]
    *(stream->pointer + 6) = (stream->accumulator >> 8);
c0de82b2:	6801      	ldr	r1, [r0, #0]
c0de82b4:	7c42      	ldrb	r2, [r0, #17]
c0de82b6:	718a      	strb	r2, [r1, #6]
    *(stream->pointer + 7) = (stream->accumulator >> 0);
c0de82b8:	6801      	ldr	r1, [r0, #0]
c0de82ba:	7c00      	ldrb	r0, [r0, #16]
c0de82bc:	71c8      	strb	r0, [r1, #7]
}
c0de82be:	4770      	bx	lr

c0de82c0 <poorstream_write_bits>:

void poorstream_write_bits(poorstream_t *stream, uint64_t bits, uint32_t num_bits) {
c0de82c0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de82c2:	4615      	mov	r5, r2
c0de82c4:	4604      	mov	r4, r0
    stream->offset += num_bits;
c0de82c6:	6841      	ldr	r1, [r0, #4]
c0de82c8:	9808      	ldr	r0, [sp, #32]
c0de82ca:	180a      	adds	r2, r1, r0
c0de82cc:	6062      	str	r2, [r4, #4]
    if (stream->offset < 64) {
c0de82ce:	2a3f      	cmp	r2, #63	; 0x3f
c0de82d0:	d80c      	bhi.n	c0de82ec <poorstream_write_bits+0x2c>
c0de82d2:	2040      	movs	r0, #64	; 0x40
        stream->accumulator |= (bits << (64 - stream->offset));
c0de82d4:	1a82      	subs	r2, r0, r2
c0de82d6:	4628      	mov	r0, r5
c0de82d8:	4619      	mov	r1, r3
c0de82da:	f005 f949 	bl	c0ded570 <__aeabi_llsl>
c0de82de:	6922      	ldr	r2, [r4, #16]
c0de82e0:	4302      	orrs	r2, r0
c0de82e2:	6122      	str	r2, [r4, #16]
c0de82e4:	6960      	ldr	r0, [r4, #20]
c0de82e6:	4308      	orrs	r0, r1
c0de82e8:	6160      	str	r0, [r4, #20]
        if (stream->offset) {
            stream->mask = ((1 << stream->offset) - 1);
            stream->accumulator |= ((bits & stream->mask) << (64 - stream->offset));
        }
    }
}
c0de82ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        stream->offset -= 64;
c0de82ec:	3a40      	subs	r2, #64	; 0x40
        stream->mask = ((1 << (num_bits - stream->offset)) - 1);
c0de82ee:	1a81      	subs	r1, r0, r2
c0de82f0:	4628      	mov	r0, r5
c0de82f2:	2500      	movs	r5, #0
c0de82f4:	43ef      	mvns	r7, r5
c0de82f6:	9700      	str	r7, [sp, #0]
c0de82f8:	408f      	lsls	r7, r1
c0de82fa:	43f9      	mvns	r1, r7
c0de82fc:	17ce      	asrs	r6, r1, #31
        stream->offset -= 64;
c0de82fe:	6062      	str	r2, [r4, #4]
        stream->mask = ((1 << (num_bits - stream->offset)) - 1);
c0de8300:	60a1      	str	r1, [r4, #8]
c0de8302:	60e6      	str	r6, [r4, #12]
c0de8304:	9001      	str	r0, [sp, #4]
c0de8306:	9302      	str	r3, [sp, #8]
        stream->accumulator |= ((bits >> stream->offset) & stream->mask);
c0de8308:	4619      	mov	r1, r3
c0de830a:	f005 f925 	bl	c0ded558 <__aeabi_llsr>
c0de830e:	43b8      	bics	r0, r7
c0de8310:	6922      	ldr	r2, [r4, #16]
c0de8312:	4302      	orrs	r2, r0
c0de8314:	6122      	str	r2, [r4, #16]
c0de8316:	4031      	ands	r1, r6
c0de8318:	6960      	ldr	r0, [r4, #20]
c0de831a:	4308      	orrs	r0, r1
c0de831c:	6160      	str	r0, [r4, #20]
        poorstream_flush(stream);
c0de831e:	4620      	mov	r0, r4
c0de8320:	f7ff ffb5 	bl	c0de828e <poorstream_flush>
        stream->accumulator = 0;
c0de8324:	6125      	str	r5, [r4, #16]
c0de8326:	6165      	str	r5, [r4, #20]
        stream->pointer += 8;
c0de8328:	6820      	ldr	r0, [r4, #0]
c0de832a:	3008      	adds	r0, #8
c0de832c:	6020      	str	r0, [r4, #0]
        if (stream->offset) {
c0de832e:	6860      	ldr	r0, [r4, #4]
c0de8330:	2800      	cmp	r0, #0
c0de8332:	d00f      	beq.n	c0de8354 <poorstream_write_bits+0x94>
c0de8334:	9d00      	ldr	r5, [sp, #0]
            stream->mask = ((1 << stream->offset) - 1);
c0de8336:	4085      	lsls	r5, r0
c0de8338:	43e9      	mvns	r1, r5
c0de833a:	17cb      	asrs	r3, r1, #31
c0de833c:	60a1      	str	r1, [r4, #8]
c0de833e:	60e3      	str	r3, [r4, #12]
c0de8340:	2140      	movs	r1, #64	; 0x40
            stream->accumulator |= ((bits & stream->mask) << (64 - stream->offset));
c0de8342:	1a0a      	subs	r2, r1, r0
c0de8344:	9801      	ldr	r0, [sp, #4]
c0de8346:	43a8      	bics	r0, r5
c0de8348:	9902      	ldr	r1, [sp, #8]
c0de834a:	4019      	ands	r1, r3
c0de834c:	f005 f910 	bl	c0ded570 <__aeabi_llsl>
c0de8350:	6120      	str	r0, [r4, #16]
c0de8352:	6161      	str	r1, [r4, #20]
}
c0de8354:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de8356:	d4d4      	bmi.n	c0de8302 <poorstream_write_bits+0x42>

c0de8358 <starkDerivePrivateKey>:
// C_cx_secp256k1_n - (C_cx_secp256k1_n % C_cx_Stark256_n)
static unsigned char const STARK_DERIVE_BIAS[] = {
    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,
    0x38, 0xa1, 0x3b, 0x4b, 0x92, 0x0e, 0x94, 0x11, 0xae, 0x6d, 0xa5, 0xf4, 0x0b, 0x03, 0x58, 0xb1};

void starkDerivePrivateKey(uint32_t *bip32Path, uint32_t bip32PathLength, uint8_t *privateKeyData) {
c0de8358:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de835a:	b08d      	sub	sp, #52	; 0x34
c0de835c:	4614      	mov	r4, r2
c0de835e:	460a      	mov	r2, r1
  PRINTF("Private key after processing %.*H\n", 32, privateKeyData);
#else
    uint8_t tmp[33];
    uint8_t index = 0;
    // Sanity check
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0de8360:	2902      	cmp	r1, #2
c0de8362:	d333      	bcc.n	c0de83cc <starkDerivePrivateKey+0x74>
c0de8364:	4601      	mov	r1, r0
c0de8366:	6800      	ldr	r0, [r0, #0]
c0de8368:	4b1a      	ldr	r3, [pc, #104]	; (c0de83d4 <starkDerivePrivateKey+0x7c>)
c0de836a:	4298      	cmp	r0, r3
c0de836c:	d12e      	bne.n	c0de83cc <starkDerivePrivateKey+0x74>
        (bip32Path[1] != STARK_BIP32_PATH_1)) {
c0de836e:	6848      	ldr	r0, [r1, #4]
c0de8370:	4b19      	ldr	r3, [pc, #100]	; (c0de83d8 <starkDerivePrivateKey+0x80>)
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0de8372:	4298      	cmp	r0, r3
c0de8374:	d12a      	bne.n	c0de83cc <starkDerivePrivateKey+0x74>
c0de8376:	2500      	movs	r5, #0
        PRINTF("Invalid Stark derivation path %d %d\n", bip32Path[0], bip32Path[1]);
        THROW(0x6a80);
    }
    os_perso_derive_node_bip32(CX_CURVE_256K1, bip32Path, bip32PathLength, tmp, NULL);
c0de8378:	9500      	str	r5, [sp, #0]
c0de837a:	2021      	movs	r0, #33	; 0x21
c0de837c:	ae03      	add	r6, sp, #12
c0de837e:	4633      	mov	r3, r6
c0de8380:	f000 ff38 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0de8384:	3620      	adds	r6, #32
c0de8386:	9602      	str	r6, [sp, #8]
c0de8388:	4e14      	ldr	r6, [pc, #80]	; (c0de83dc <starkDerivePrivateKey+0x84>)
c0de838a:	447e      	add	r6, pc
    PRINTF("Private key before processing %.*H\n", 32, tmp);
    for (;;) {
        tmp[32] = index;
c0de838c:	9802      	ldr	r0, [sp, #8]
c0de838e:	7005      	strb	r5, [r0, #0]
c0de8390:	a803      	add	r0, sp, #12
c0de8392:	2121      	movs	r1, #33	; 0x21
c0de8394:	2720      	movs	r7, #32
        cx_hash_sha256(tmp, 33, privateKeyData, 32);
c0de8396:	4622      	mov	r2, r4
c0de8398:	463b      	mov	r3, r7
c0de839a:	f7fa fe75 	bl	c0de3088 <cx_hash_sha256>
c0de839e:	ab0c      	add	r3, sp, #48	; 0x30
  CX_THROW(cx_math_cmp_no_throw(a, b, length, &diff));
c0de83a0:	4620      	mov	r0, r4
c0de83a2:	4631      	mov	r1, r6
c0de83a4:	463a      	mov	r2, r7
c0de83a6:	f7fa fe81 	bl	c0de30ac <cx_math_cmp_no_throw>
c0de83aa:	2800      	cmp	r0, #0
c0de83ac:	d110      	bne.n	c0de83d0 <starkDerivePrivateKey+0x78>
  return diff;
c0de83ae:	980c      	ldr	r0, [sp, #48]	; 0x30
        PRINTF("Key hash %.*H\n", 32, privateKeyData);
        if (cx_math_cmp(privateKeyData, STARK_DERIVE_BIAS, 32) < 0) {
            cx_math_modm(privateKeyData, 32, C_cx_Stark256_n, 32);
            break;
        }
        index++;
c0de83b0:	1c6d      	adds	r5, r5, #1
        if (cx_math_cmp(privateKeyData, STARK_DERIVE_BIAS, 32) < 0) {
c0de83b2:	2800      	cmp	r0, #0
c0de83b4:	d5ea      	bpl.n	c0de838c <starkDerivePrivateKey+0x34>
 * @throws              CX_NOT_LOCKED
 * @throws              CX_MEMORY_FULL
 * @throws              CX_INVALID_PARAMETER
 */
static inline void cx_math_modm(uint8_t *v, size_t len_v, const uint8_t *m, size_t len_m) {
  CX_THROW(cx_math_modm_no_throw(v, len_v, m, len_m));
c0de83b6:	4a0a      	ldr	r2, [pc, #40]	; (c0de83e0 <starkDerivePrivateKey+0x88>)
c0de83b8:	447a      	add	r2, pc
c0de83ba:	2120      	movs	r1, #32
c0de83bc:	4620      	mov	r0, r4
c0de83be:	460b      	mov	r3, r1
c0de83c0:	f7fa fe7a 	bl	c0de30b8 <cx_math_modm_no_throw>
c0de83c4:	2800      	cmp	r0, #0
c0de83c6:	d103      	bne.n	c0de83d0 <starkDerivePrivateKey+0x78>
    }
    PRINTF("Key result %.*H\n", 32, privateKeyData);

#endif
}
c0de83c8:	b00d      	add	sp, #52	; 0x34
c0de83ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de83cc:	20d5      	movs	r0, #213	; 0xd5
c0de83ce:	01c0      	lsls	r0, r0, #7
c0de83d0:	f7ff f829 	bl	c0de7426 <os_longjmp>
c0de83d4:	80000a55 	.word	0x80000a55
c0de83d8:	a2862ad3 	.word	0xa2862ad3
c0de83dc:	000079f7 	.word	0x000079f7
c0de83e0:	000079e9 	.word	0x000079e9

c0de83e4 <stark_get_amount_string>:

void stark_get_amount_string(uint8_t *contractAddress,
                             uint8_t *quantum256,
                             uint8_t *amount64,
                             char *tmp100,
                             char *target100) {
c0de83e4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de83e6:	b09f      	sub	sp, #124	; 0x7c
c0de83e8:	461f      	mov	r7, r3
c0de83ea:	9203      	str	r2, [sp, #12]
c0de83ec:	460c      	mov	r4, r1
    uint256_t amountPre, quantum, amount;
    uint8_t decimals;
    char *ticker = chainConfig->coinName;
c0de83ee:	4926      	ldr	r1, [pc, #152]	; (c0de8488 <stark_get_amount_string+0xa4>)
c0de83f0:	464a      	mov	r2, r9
c0de83f2:	5853      	ldr	r3, [r2, r1]
c0de83f4:	2100      	movs	r1, #0
c0de83f6:	9e24      	ldr	r6, [sp, #144]	; 0x90
c0de83f8:	9705      	str	r7, [sp, #20]
    for (size_t i = 0; i < n; ++i) {
c0de83fa:	2914      	cmp	r1, #20
c0de83fc:	d00d      	beq.n	c0de841a <stark_get_amount_string+0x36>
        if (p[i]) {
c0de83fe:	5c42      	ldrb	r2, [r0, r1]
    for (size_t i = 0; i < n; ++i) {
c0de8400:	1c49      	adds	r1, r1, #1
        if (p[i]) {
c0de8402:	2a00      	cmp	r2, #0
c0de8404:	d0f9      	beq.n	c0de83fa <stark_get_amount_string+0x16>

    if (allzeroes(contractAddress, 20)) {
        decimals = WEI_TO_ETHER;
        PRINTF("stark_get_amount_string - ETH\n");
    } else {
        tokenDefinition_t *token = &getKnownToken(contractAddress)->token;
c0de8406:	f7fe f9eb 	bl	c0de67e0 <getKnownToken>
        if (token == NULL) {  // caught earlier
c0de840a:	2800      	cmp	r0, #0
c0de840c:	d038      	beq.n	c0de8480 <stark_get_amount_string+0x9c>
c0de840e:	2120      	movs	r1, #32
            THROW(0x6A80);
        }
        decimals = token->decimals;
c0de8410:	5c41      	ldrb	r1, [r0, r1]
c0de8412:	9104      	str	r1, [sp, #16]
c0de8414:	3014      	adds	r0, #20
c0de8416:	9002      	str	r0, [sp, #8]
c0de8418:	e002      	b.n	c0de8420 <stark_get_amount_string+0x3c>
c0de841a:	2012      	movs	r0, #18
c0de841c:	9004      	str	r0, [sp, #16]
c0de841e:	9302      	str	r3, [sp, #8]
c0de8420:	9803      	ldr	r0, [sp, #12]
c0de8422:	2108      	movs	r1, #8
c0de8424:	ad16      	add	r5, sp, #88	; 0x58
        ticker = (char *) token->ticker;
        PRINTF("stark_get_amount_string - decimals %d ticker %s\n", decimals, ticker);
    }
    convertUint256BE(amount64, 8, &amountPre);
c0de8426:	462a      	mov	r2, r5
c0de8428:	f004 f80e 	bl	c0dec448 <convertUint256BE>
c0de842c:	af0e      	add	r7, sp, #56	; 0x38
    readu256BE(quantum256, &quantum);
c0de842e:	4620      	mov	r0, r4
c0de8430:	4639      	mov	r1, r7
c0de8432:	f002 fb9d 	bl	c0deab70 <readu256BE>
c0de8436:	ac06      	add	r4, sp, #24
    mul256(&amountPre, &quantum, &amount);
c0de8438:	4628      	mov	r0, r5
c0de843a:	4639      	mov	r1, r7
c0de843c:	4622      	mov	r2, r4
c0de843e:	f002 fee1 	bl	c0deb204 <mul256>
c0de8442:	210a      	movs	r1, #10
c0de8444:	2764      	movs	r7, #100	; 0x64
    tostring256(&amount, 10, tmp100, 100);
c0de8446:	4620      	mov	r0, r4
c0de8448:	9d05      	ldr	r5, [sp, #20]
c0de844a:	462a      	mov	r2, r5
c0de844c:	463b      	mov	r3, r7
c0de844e:	f002 fff1 	bl	c0deb434 <tostring256>
    PRINTF("stark_get_amount_string - mul256 %s\n", tmp100);
    strlcpy(target100, ticker, 100);
c0de8452:	4630      	mov	r0, r6
c0de8454:	9c02      	ldr	r4, [sp, #8]
c0de8456:	4621      	mov	r1, r4
c0de8458:	463a      	mov	r2, r7
c0de845a:	f005 fbbb 	bl	c0dedbd4 <strlcpy>
    adjustDecimals(tmp100, strlen(tmp100), target100 + strlen(ticker), 100, decimals);
c0de845e:	4628      	mov	r0, r5
c0de8460:	f005 fbde 	bl	c0dedc20 <strlen>
c0de8464:	9003      	str	r0, [sp, #12]
c0de8466:	4620      	mov	r0, r4
c0de8468:	f005 fbda 	bl	c0dedc20 <strlen>
c0de846c:	9904      	ldr	r1, [sp, #16]
c0de846e:	9100      	str	r1, [sp, #0]
c0de8470:	1832      	adds	r2, r6, r0
c0de8472:	4628      	mov	r0, r5
c0de8474:	9903      	ldr	r1, [sp, #12]
c0de8476:	463b      	mov	r3, r7
c0de8478:	f7fc f9fa 	bl	c0de4870 <adjustDecimals>
    PRINTF("get_amount_string %s\n", target100);
}
c0de847c:	b01f      	add	sp, #124	; 0x7c
c0de847e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de8480:	20d5      	movs	r0, #213	; 0xd5
c0de8482:	01c0      	lsls	r0, r0, #7
            THROW(0x6A80);
c0de8484:	f7fe ffcf 	bl	c0de7426 <os_longjmp>
c0de8488:	00000590 	.word	0x00000590

c0de848c <accum_ec_mul>:
        0x01, 0xb7, 0x7b, 0x3e, 0x37, 0xd1, 0x35, 0x04, 0xb3, 0x48, 0x04,
        0x62, 0x68, 0xd8, 0xae, 0x25, 0xce, 0x98, 0xad, 0x78, 0x3c, 0x25,
        0x56, 0x1a, 0x87, 0x9d, 0xcc, 0x77, 0xe9, 0x9c, 0x24, 0x26,
    }};

void accum_ec_mul(ECPoint *hash, uint8_t *buf, int len, int pedersen_idx) {
c0de848c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de848e:	b09d      	sub	sp, #116	; 0x74
c0de8490:	461c      	mov	r4, r3
c0de8492:	4615      	mov	r5, r2
c0de8494:	460e      	mov	r6, r1
c0de8496:	4607      	mov	r7, r0
    ECPoint tmp;
    if (!allzeroes(buf, len)) {
c0de8498:	4608      	mov	r0, r1
c0de849a:	4611      	mov	r1, r2
c0de849c:	f000 f840 	bl	c0de8520 <allzeroes>
c0de84a0:	2800      	cmp	r0, #0
c0de84a2:	d136      	bne.n	c0de8512 <accum_ec_mul+0x86>
c0de84a4:	9702      	str	r7, [sp, #8]
c0de84a6:	2241      	movs	r2, #65	; 0x41
        uint8_t pad[32];
        memcpy(tmp, PEDERSEN_POINTS[pedersen_idx], sizeof(ECPoint));
c0de84a8:	4354      	muls	r4, r2
c0de84aa:	481c      	ldr	r0, [pc, #112]	; (c0de851c <accum_ec_mul+0x90>)
c0de84ac:	4478      	add	r0, pc
c0de84ae:	1901      	adds	r1, r0, r4
c0de84b0:	a80b      	add	r0, sp, #44	; 0x2c
c0de84b2:	9001      	str	r0, [sp, #4]
c0de84b4:	f005 f9b4 	bl	c0ded820 <__aeabi_memcpy>
        io_seproxyhal_io_heartbeat();
c0de84b8:	f7ff fb72 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de84bc:	ac03      	add	r4, sp, #12
c0de84be:	2720      	movs	r7, #32
        memset(pad, 0, sizeof(pad));
c0de84c0:	4620      	mov	r0, r4
c0de84c2:	4639      	mov	r1, r7
c0de84c4:	f005 f9a6 	bl	c0ded814 <__aeabi_memclr>
        memmove(pad + 32 - len, buf, len);
c0de84c8:	1b60      	subs	r0, r4, r5
c0de84ca:	3020      	adds	r0, #32
c0de84cc:	4631      	mov	r1, r6
c0de84ce:	462a      	mov	r2, r5
c0de84d0:	f005 f9a6 	bl	c0ded820 <__aeabi_memcpy>
c0de84d4:	2051      	movs	r0, #81	; 0x51
  CX_THROW(cx_ecfp_scalar_mult_no_throw(curve, P, k, k_len));
c0de84d6:	9901      	ldr	r1, [sp, #4]
c0de84d8:	4622      	mov	r2, r4
c0de84da:	463b      	mov	r3, r7
c0de84dc:	f7fa fdc2 	bl	c0de3064 <cx_ecfp_scalar_mult_no_throw>
c0de84e0:	2800      	cmp	r0, #0
c0de84e2:	d118      	bne.n	c0de8516 <accum_ec_mul+0x8a>
c0de84e4:	2051      	movs	r0, #81	; 0x51
c0de84e6:	a91c      	add	r1, sp, #112	; 0x70
  CX_THROW(cx_ecdomain_parameters_length(curve, &size));
c0de84e8:	f000 fe6c 	bl	c0de91c4 <cx_ecdomain_parameters_length>
c0de84ec:	2800      	cmp	r0, #0
c0de84ee:	9c02      	ldr	r4, [sp, #8]
c0de84f0:	d111      	bne.n	c0de8516 <accum_ec_mul+0x8a>
        cx_ecfp_scalar_mult(CX_CURVE_Stark256, tmp, sizeof(ECPoint), pad, sizeof(pad));
        io_seproxyhal_io_heartbeat();
c0de84f2:	f7ff fb55 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de84f6:	2051      	movs	r0, #81	; 0x51
c0de84f8:	ab0b      	add	r3, sp, #44	; 0x2c
  CX_THROW(cx_ecfp_add_point_no_throw(curve, R, P, Q));
c0de84fa:	4621      	mov	r1, r4
c0de84fc:	4622      	mov	r2, r4
c0de84fe:	f7fa fd99 	bl	c0de3034 <cx_ecfp_add_point_no_throw>
c0de8502:	2800      	cmp	r0, #0
c0de8504:	d107      	bne.n	c0de8516 <accum_ec_mul+0x8a>
c0de8506:	2051      	movs	r0, #81	; 0x51
c0de8508:	a91c      	add	r1, sp, #112	; 0x70
  CX_THROW(cx_ecdomain_parameters_length(curve, &size));
c0de850a:	f000 fe5b 	bl	c0de91c4 <cx_ecdomain_parameters_length>
c0de850e:	2800      	cmp	r0, #0
c0de8510:	d101      	bne.n	c0de8516 <accum_ec_mul+0x8a>
        cx_ecfp_add_point(CX_CURVE_Stark256, *hash, *hash, tmp, sizeof(ECPoint));
    }
}
c0de8512:	b01d      	add	sp, #116	; 0x74
c0de8514:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de8516:	f7fe ff86 	bl	c0de7426 <os_longjmp>
c0de851a:	46c0      	nop			; (mov r8, r8)
c0de851c:	00007915 	.word	0x00007915

c0de8520 <allzeroes>:
    for (size_t i = 0; i < n; ++i) {
c0de8520:	2900      	cmp	r1, #0
c0de8522:	d007      	beq.n	c0de8534 <allzeroes+0x14>
        if (p[i]) {
c0de8524:	1c42      	adds	r2, r0, #1
c0de8526:	1e49      	subs	r1, r1, #1
c0de8528:	7800      	ldrb	r0, [r0, #0]
c0de852a:	2800      	cmp	r0, #0
c0de852c:	4610      	mov	r0, r2
c0de852e:	d0f7      	beq.n	c0de8520 <allzeroes>
c0de8530:	2000      	movs	r0, #0
}
c0de8532:	4770      	bx	lr
c0de8534:	2001      	movs	r0, #1
c0de8536:	4770      	bx	lr

c0de8538 <pedersen>:

void pedersen(FieldElement res, /* out */
              FieldElement a,
              FieldElement b) {
c0de8538:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de853a:	b095      	sub	sp, #84	; 0x54
c0de853c:	9202      	str	r2, [sp, #8]
c0de853e:	460c      	mov	r4, r1
c0de8540:	9003      	str	r0, [sp, #12]
c0de8542:	ad04      	add	r5, sp, #16
    ECPoint hash;

    memcpy(hash, PEDERSEN_SHIFT, sizeof(hash));
c0de8544:	4912      	ldr	r1, [pc, #72]	; (c0de8590 <pedersen+0x58>)
c0de8546:	4479      	add	r1, pc
c0de8548:	2241      	movs	r2, #65	; 0x41
c0de854a:	4628      	mov	r0, r5
c0de854c:	f005 f968 	bl	c0ded820 <__aeabi_memcpy>
c0de8550:	2701      	movs	r7, #1

    accum_ec_mul(&hash, a, 1, 1);
c0de8552:	4e10      	ldr	r6, [pc, #64]	; (c0de8594 <pedersen+0x5c>)
c0de8554:	447e      	add	r6, pc
c0de8556:	4628      	mov	r0, r5
c0de8558:	4621      	mov	r1, r4
c0de855a:	463a      	mov	r2, r7
c0de855c:	463b      	mov	r3, r7
c0de855e:	47b0      	blx	r6
    accum_ec_mul(&hash, a + 1, FIELD_ELEMENT_SIZE - 1, 0);
c0de8560:	1c61      	adds	r1, r4, #1
c0de8562:	221f      	movs	r2, #31
c0de8564:	9201      	str	r2, [sp, #4]
c0de8566:	2300      	movs	r3, #0
c0de8568:	4628      	mov	r0, r5
c0de856a:	47b0      	blx	r6
c0de856c:	2303      	movs	r3, #3
    accum_ec_mul(&hash, b, 1, 3);
c0de856e:	4628      	mov	r0, r5
c0de8570:	9c02      	ldr	r4, [sp, #8]
c0de8572:	4621      	mov	r1, r4
c0de8574:	463a      	mov	r2, r7
c0de8576:	47b0      	blx	r6
    accum_ec_mul(&hash, b + 1, FIELD_ELEMENT_SIZE - 1, 2);
c0de8578:	1c61      	adds	r1, r4, #1
c0de857a:	2302      	movs	r3, #2
c0de857c:	4628      	mov	r0, r5
c0de857e:	9a01      	ldr	r2, [sp, #4]
c0de8580:	47b0      	blx	r6

    memcpy(res, hash + 1, FIELD_ELEMENT_SIZE);
c0de8582:	1c69      	adds	r1, r5, #1
c0de8584:	2220      	movs	r2, #32
c0de8586:	9803      	ldr	r0, [sp, #12]
c0de8588:	f005 f94a 	bl	c0ded820 <__aeabi_memcpy>
}
c0de858c:	b015      	add	sp, #84	; 0x54
c0de858e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de8590:	00007982 	.word	0x00007982
c0de8594:	ffffff35 	.word	0xffffff35

c0de8598 <shift_stark_hash>:

void shift_stark_hash(FieldElement hash) {
c0de8598:	b5b0      	push	{r4, r5, r7, lr}
c0de859a:	b090      	sub	sp, #64	; 0x40
c0de859c:	4604      	mov	r4, r0
c0de859e:	ad08      	add	r5, sp, #32
    uint256_t hash256, final_hash256;
    readu256BE(hash, &hash256);
c0de85a0:	4629      	mov	r1, r5
c0de85a2:	f002 fae5 	bl	c0deab70 <readu256BE>
    uint32_t bits_count = bits256(&hash256);
c0de85a6:	4628      	mov	r0, r5
c0de85a8:	f002 fcbc 	bl	c0deaf24 <bits256>
    if (bits_count < 248) {
c0de85ac:	28f8      	cmp	r0, #248	; 0xf8
c0de85ae:	d31e      	bcc.n	c0de85ee <shift_stark_hash+0x56>
c0de85b0:	2107      	movs	r1, #7
        return;
    } else if (bits_count >= 248 && bits_count % 8 >= 1 && bits_count % 8 <= 4) {
c0de85b2:	4008      	ands	r0, r1
c0de85b4:	1e40      	subs	r0, r0, #1
c0de85b6:	2803      	cmp	r0, #3
c0de85b8:	d81b      	bhi.n	c0de85f2 <shift_stark_hash+0x5a>
c0de85ba:	a808      	add	r0, sp, #32
c0de85bc:	2104      	movs	r1, #4
c0de85be:	466a      	mov	r2, sp
        shiftl256(&hash256, 4, &final_hash256);
c0de85c0:	f002 fb28 	bl	c0deac14 <shiftl256>
        write_u64_be(hash, UPPER(UPPER_P((&final_hash256))));
c0de85c4:	9b01      	ldr	r3, [sp, #4]
c0de85c6:	9a00      	ldr	r2, [sp, #0]
c0de85c8:	4d0c      	ldr	r5, [pc, #48]	; (c0de85fc <shift_stark_hash+0x64>)
c0de85ca:	447d      	add	r5, pc
c0de85cc:	4620      	mov	r0, r4
c0de85ce:	47a8      	blx	r5
        write_u64_be(hash + 8, LOWER(UPPER_P((&final_hash256))));
c0de85d0:	9b03      	ldr	r3, [sp, #12]
c0de85d2:	9a02      	ldr	r2, [sp, #8]
c0de85d4:	4620      	mov	r0, r4
c0de85d6:	3008      	adds	r0, #8
c0de85d8:	47a8      	blx	r5
        write_u64_be(hash + 16, UPPER(LOWER_P((&final_hash256))));
c0de85da:	9b05      	ldr	r3, [sp, #20]
c0de85dc:	9a04      	ldr	r2, [sp, #16]
c0de85de:	4620      	mov	r0, r4
c0de85e0:	3010      	adds	r0, #16
c0de85e2:	47a8      	blx	r5
        write_u64_be(hash + 24, LOWER(LOWER_P((&final_hash256))));
c0de85e4:	9b07      	ldr	r3, [sp, #28]
c0de85e6:	9a06      	ldr	r2, [sp, #24]
c0de85e8:	3418      	adds	r4, #24
c0de85ea:	4620      	mov	r0, r4
c0de85ec:	47a8      	blx	r5
        return;
    } else {
        THROW(0x6A80);
    }
}
c0de85ee:	b010      	add	sp, #64	; 0x40
c0de85f0:	bdb0      	pop	{r4, r5, r7, pc}
c0de85f2:	20d5      	movs	r0, #213	; 0xd5
c0de85f4:	01c0      	lsls	r0, r0, #7
        THROW(0x6A80);
c0de85f6:	f7fe ff16 	bl	c0de7426 <os_longjmp>
c0de85fa:	46c0      	nop			; (mov r8, r8)
c0de85fc:	00002bf7 	.word	0x00002bf7

c0de8600 <stark_sign>:
int stark_sign(uint8_t *signature, /* out */
               uint8_t *privateKeyData,
               FieldElement token1,
               FieldElement token2,
               FieldElement msg,
               FieldElement condition) {
c0de8600:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de8602:	b099      	sub	sp, #100	; 0x64
c0de8604:	460d      	mov	r5, r1
c0de8606:	4604      	mov	r4, r0
c0de8608:	a80f      	add	r0, sp, #60	; 0x3c
    PRINTF("Stark sign msg w2 %.*H\n", 32, token2);
    PRINTF("Stark sign w3 %.*H\n", 32, msg);
    if (condition != NULL) {
        PRINTF("Stark sign w4 %.*H\n", 32, condition);
    }
    pedersen(hash, token1, token2);
c0de860a:	4611      	mov	r1, r2
c0de860c:	461a      	mov	r2, r3
c0de860e:	f7ff ff93 	bl	c0de8538 <pedersen>
c0de8612:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
c0de8614:	9e1e      	ldr	r6, [sp, #120]	; 0x78
    PRINTF("Pedersen hash 1 %.*H\n", 32, hash);
    if (condition != NULL) {
c0de8616:	2a00      	cmp	r2, #0
c0de8618:	d003      	beq.n	c0de8622 <stark_sign+0x22>
c0de861a:	a80f      	add	r0, sp, #60	; 0x3c
        pedersen(hash, hash, condition);
c0de861c:	4601      	mov	r1, r0
c0de861e:	f7ff ff8b 	bl	c0de8538 <pedersen>
c0de8622:	af0f      	add	r7, sp, #60	; 0x3c
        PRINTF("Pedersen hash condition %.*H\n", 32, hash);
    }
    pedersen(hash, hash, msg);
c0de8624:	4638      	mov	r0, r7
c0de8626:	4639      	mov	r1, r7
c0de8628:	4632      	mov	r2, r6
c0de862a:	f7ff ff85 	bl	c0de8538 <pedersen>
    PRINTF("Pedersen hash 2 %.*H\n", 32, hash);
    shift_stark_hash(hash);
c0de862e:	4638      	mov	r0, r7
c0de8630:	f7ff ffb2 	bl	c0de8598 <shift_stark_hash>
c0de8634:	2051      	movs	r0, #81	; 0x51
c0de8636:	2620      	movs	r6, #32
c0de8638:	ab05      	add	r3, sp, #20
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de863a:	4629      	mov	r1, r5
c0de863c:	4632      	mov	r2, r6
c0de863e:	f7fa fd05 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de8642:	2800      	cmp	r0, #0
c0de8644:	d114      	bne.n	c0de8670 <stark_sign+0x70>
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
    io_seproxyhal_io_heartbeat();
c0de8646:	f7ff faab 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de864a:	2048      	movs	r0, #72	; 0x48
  size_t sig_len_ = sig_len;
c0de864c:	9018      	str	r0, [sp, #96]	; 0x60
c0de864e:	a817      	add	r0, sp, #92	; 0x5c
  CX_THROW(cx_ecdsa_sign_no_throw(pvkey, mode, hashID, hash, hash_len, sig, &sig_len_, &info_));
c0de8650:	9003      	str	r0, [sp, #12]
c0de8652:	a818      	add	r0, sp, #96	; 0x60
c0de8654:	9002      	str	r0, [sp, #8]
c0de8656:	9401      	str	r4, [sp, #4]
c0de8658:	9600      	str	r6, [sp, #0]
c0de865a:	a805      	add	r0, sp, #20
c0de865c:	4905      	ldr	r1, [pc, #20]	; (c0de8674 <stark_sign+0x74>)
c0de865e:	2203      	movs	r2, #3
c0de8660:	ab0f      	add	r3, sp, #60	; 0x3c
c0de8662:	f7fa fcdb 	bl	c0de301c <cx_ecdsa_sign_no_throw>
c0de8666:	2800      	cmp	r0, #0
c0de8668:	d102      	bne.n	c0de8670 <stark_sign+0x70>
  return sig_len_;
c0de866a:	9818      	ldr	r0, [sp, #96]	; 0x60
                                        sizeof(hash),
                                        signature,
                                        SIGNATURE_MAX_LEN,
                                        &info);
    PRINTF("Stark signature %.*H\n", signatureLength, signature);
    return signatureLength;
c0de866c:	b019      	add	sp, #100	; 0x64
c0de866e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de8670:	f7fe fed9 	bl	c0de7426 <os_longjmp>
c0de8674:	00000601 	.word	0x00000601

c0de8678 <compute_token_id>:
                      uint8_t *contractAddress,
                      uint8_t quantumType,
                      uint8_t *quantum,
                      uint8_t *mintingBlob,
                      bool assetTypeOnly,
                      uint8_t *output) {
c0de8678:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de867a:	b08f      	sub	sp, #60	; 0x3c
c0de867c:	461d      	mov	r5, r3
c0de867e:	4614      	mov	r4, r2
c0de8680:	460e      	mov	r6, r1
c0de8682:	9005      	str	r0, [sp, #20]
    uint8_t tmp[36];
    cx_keccak_init(sha3, 256);
c0de8684:	f000 f8b8 	bl	c0de87f8 <cx_keccak_init>
    if ((contractAddress != NULL) && (!allzeroes(contractAddress, 20))) {
c0de8688:	2e00      	cmp	r6, #0
c0de868a:	d005      	beq.n	c0de8698 <compute_token_id+0x20>
c0de868c:	2114      	movs	r1, #20
c0de868e:	4630      	mov	r0, r6
c0de8690:	f7ff ff46 	bl	c0de8520 <allzeroes>
c0de8694:	2800      	cmp	r0, #0
c0de8696:	d007      	beq.n	c0de86a8 <compute_token_id+0x30>
c0de8698:	2100      	movs	r1, #0
        memmove(tmp, selector, 4);
        memmove(tmp + 16, contractAddress, 20);
        cx_hash((cx_hash_t *) sha3, 0, tmp, sizeof(tmp), NULL, 0);
    } else {
        PRINTF("compute_token_id for ETH\n");
        cx_hash((cx_hash_t *) sha3, 0, ETH_SELECTOR, sizeof(ETH_SELECTOR), NULL, 0);
c0de869a:	9100      	str	r1, [sp, #0]
c0de869c:	9101      	str	r1, [sp, #4]
c0de869e:	4a52      	ldr	r2, [pc, #328]	; (c0de87e8 <compute_token_id+0x170>)
c0de86a0:	447a      	add	r2, pc
c0de86a2:	2304      	movs	r3, #4
c0de86a4:	9805      	ldr	r0, [sp, #20]
c0de86a6:	e032      	b.n	c0de870e <compute_token_id+0x96>
c0de86a8:	484b      	ldr	r0, [pc, #300]	; (c0de87d8 <compute_token_id+0x160>)
c0de86aa:	4478      	add	r0, pc
        switch (quantumType) {
c0de86ac:	2c00      	cmp	r4, #0
c0de86ae:	d010      	beq.n	c0de86d2 <compute_token_id+0x5a>
c0de86b0:	2c02      	cmp	r4, #2
c0de86b2:	d00e      	beq.n	c0de86d2 <compute_token_id+0x5a>
c0de86b4:	2c05      	cmp	r4, #5
c0de86b6:	d007      	beq.n	c0de86c8 <compute_token_id+0x50>
c0de86b8:	2c04      	cmp	r4, #4
c0de86ba:	d008      	beq.n	c0de86ce <compute_token_id+0x56>
c0de86bc:	2c03      	cmp	r4, #3
c0de86be:	d000      	beq.n	c0de86c2 <compute_token_id+0x4a>
c0de86c0:	e088      	b.n	c0de87d4 <compute_token_id+0x15c>
c0de86c2:	4846      	ldr	r0, [pc, #280]	; (c0de87dc <compute_token_id+0x164>)
c0de86c4:	4478      	add	r0, pc
c0de86c6:	e004      	b.n	c0de86d2 <compute_token_id+0x5a>
c0de86c8:	4846      	ldr	r0, [pc, #280]	; (c0de87e4 <compute_token_id+0x16c>)
c0de86ca:	4478      	add	r0, pc
c0de86cc:	e001      	b.n	c0de86d2 <compute_token_id+0x5a>
c0de86ce:	4844      	ldr	r0, [pc, #272]	; (c0de87e0 <compute_token_id+0x168>)
c0de86d0:	4478      	add	r0, pc
c0de86d2:	2700      	movs	r7, #0
        memset(tmp, 0, sizeof(tmp));
c0de86d4:	9709      	str	r7, [sp, #36]	; 0x24
c0de86d6:	9708      	str	r7, [sp, #32]
c0de86d8:	9707      	str	r7, [sp, #28]
        memmove(tmp, selector, 4);
c0de86da:	7801      	ldrb	r1, [r0, #0]
c0de86dc:	7842      	ldrb	r2, [r0, #1]
c0de86de:	0212      	lsls	r2, r2, #8
c0de86e0:	1851      	adds	r1, r2, r1
c0de86e2:	7882      	ldrb	r2, [r0, #2]
c0de86e4:	78c0      	ldrb	r0, [r0, #3]
c0de86e6:	0200      	lsls	r0, r0, #8
c0de86e8:	1880      	adds	r0, r0, r2
c0de86ea:	0400      	lsls	r0, r0, #16
c0de86ec:	1840      	adds	r0, r0, r1
c0de86ee:	9006      	str	r0, [sp, #24]
c0de86f0:	9504      	str	r5, [sp, #16]
c0de86f2:	ad06      	add	r5, sp, #24
        memmove(tmp + 16, contractAddress, 20);
c0de86f4:	4628      	mov	r0, r5
c0de86f6:	3010      	adds	r0, #16
c0de86f8:	2214      	movs	r2, #20
c0de86fa:	4631      	mov	r1, r6
c0de86fc:	f005 f890 	bl	c0ded820 <__aeabi_memcpy>
        cx_hash((cx_hash_t *) sha3, 0, tmp, sizeof(tmp), NULL, 0);
c0de8700:	9700      	str	r7, [sp, #0]
c0de8702:	9701      	str	r7, [sp, #4]
c0de8704:	2324      	movs	r3, #36	; 0x24
c0de8706:	9805      	ldr	r0, [sp, #20]
c0de8708:	4639      	mov	r1, r7
c0de870a:	462a      	mov	r2, r5
c0de870c:	9d04      	ldr	r5, [sp, #16]
c0de870e:	f000 f87d 	bl	c0de880c <cx_hash>
c0de8712:	9e16      	ldr	r6, [sp, #88]	; 0x58
    }
    if ((quantumType == STARK_QUANTUM_ERC721) || (quantumType == STARK_QUANTUM_MINTABLE_ERC721)) {
c0de8714:	2c05      	cmp	r4, #5
c0de8716:	d001      	beq.n	c0de871c <compute_token_id+0xa4>
c0de8718:	2c03      	cmp	r4, #3
c0de871a:	d10d      	bne.n	c0de8738 <compute_token_id+0xc0>
c0de871c:	ad06      	add	r5, sp, #24
c0de871e:	2720      	movs	r7, #32
        memset(tmp, 0, 32);
c0de8720:	4628      	mov	r0, r5
c0de8722:	4639      	mov	r1, r7
c0de8724:	f005 f876 	bl	c0ded814 <__aeabi_memclr>
c0de8728:	2101      	movs	r1, #1
        tmp[31] = 1;
c0de872a:	77e9      	strb	r1, [r5, #31]
        PRINTF("compute_token_id quantum %.*H\n", 32, tmp);
        cx_hash((cx_hash_t *) sha3, CX_LAST, tmp, 32, output, 32);
c0de872c:	9600      	str	r6, [sp, #0]
c0de872e:	9701      	str	r7, [sp, #4]
c0de8730:	9805      	ldr	r0, [sp, #20]
c0de8732:	462a      	mov	r2, r5
c0de8734:	463b      	mov	r3, r7
c0de8736:	e005      	b.n	c0de8744 <compute_token_id+0xcc>
c0de8738:	2320      	movs	r3, #32
    } else {
        PRINTF("compute_token_id quantum %.*H\n", 32, quantum);
        cx_hash((cx_hash_t *) sha3, CX_LAST, quantum, 32, output, 32);
c0de873a:	9600      	str	r6, [sp, #0]
c0de873c:	9301      	str	r3, [sp, #4]
c0de873e:	2101      	movs	r1, #1
c0de8740:	9805      	ldr	r0, [sp, #20]
c0de8742:	462a      	mov	r2, r5
c0de8744:	f000 f862 	bl	c0de880c <cx_hash>
    }
    if (!assetTypeOnly &&
c0de8748:	2c03      	cmp	r4, #3
c0de874a:	d33f      	bcc.n	c0de87cc <compute_token_id+0x154>
c0de874c:	9815      	ldr	r0, [sp, #84]	; 0x54
c0de874e:	2800      	cmp	r0, #0
c0de8750:	d13c      	bne.n	c0de87cc <compute_token_id+0x154>
        ((quantumType != STARK_QUANTUM_LEGACY) && (quantumType != STARK_QUANTUM_ETH) &&
         (quantumType != STARK_QUANTUM_ERC20))) {
        const char *prefix = NULL;
        output[0] &= 0x03;
c0de8752:	7830      	ldrb	r0, [r6, #0]
c0de8754:	2103      	movs	r1, #3
c0de8756:	4001      	ands	r1, r0
c0de8758:	7031      	strb	r1, [r6, #0]
        cx_keccak_init(sha3, 256);
c0de875a:	9805      	ldr	r0, [sp, #20]
c0de875c:	f000 f84c 	bl	c0de87f8 <cx_keccak_init>
        switch (quantumType) {
c0de8760:	1f20      	subs	r0, r4, #4
c0de8762:	2802      	cmp	r0, #2
c0de8764:	d203      	bcs.n	c0de876e <compute_token_id+0xf6>
c0de8766:	9403      	str	r4, [sp, #12]
c0de8768:	4d21      	ldr	r5, [pc, #132]	; (c0de87f0 <compute_token_id+0x178>)
c0de876a:	447d      	add	r5, pc
c0de876c:	e004      	b.n	c0de8778 <compute_token_id+0x100>
c0de876e:	2c03      	cmp	r4, #3
c0de8770:	d130      	bne.n	c0de87d4 <compute_token_id+0x15c>
c0de8772:	9403      	str	r4, [sp, #12]
c0de8774:	4d1d      	ldr	r5, [pc, #116]	; (c0de87ec <compute_token_id+0x174>)
c0de8776:	447d      	add	r5, pc
c0de8778:	9814      	ldr	r0, [sp, #80]	; 0x50
                break;
            default:
                PRINTF("Unsupported non default quantum type %d\n", quantumType);
                return;
        }
        cx_hash((cx_hash_t *) sha3, 0, (const uint8_t *) prefix, strlen(prefix), NULL, 0);
c0de877a:	9002      	str	r0, [sp, #8]
c0de877c:	4628      	mov	r0, r5
c0de877e:	f005 fa4f 	bl	c0dedc20 <strlen>
c0de8782:	4603      	mov	r3, r0
c0de8784:	2700      	movs	r7, #0
c0de8786:	9700      	str	r7, [sp, #0]
c0de8788:	9701      	str	r7, [sp, #4]
c0de878a:	4c1a      	ldr	r4, [pc, #104]	; (c0de87f4 <compute_token_id+0x17c>)
c0de878c:	447c      	add	r4, pc
c0de878e:	9404      	str	r4, [sp, #16]
c0de8790:	9805      	ldr	r0, [sp, #20]
c0de8792:	4639      	mov	r1, r7
c0de8794:	462a      	mov	r2, r5
c0de8796:	47a0      	blx	r4
        cx_hash((cx_hash_t *) sha3, 0, output, 32, NULL, 0);
c0de8798:	9700      	str	r7, [sp, #0]
c0de879a:	9701      	str	r7, [sp, #4]
c0de879c:	2520      	movs	r5, #32
c0de879e:	9805      	ldr	r0, [sp, #20]
c0de87a0:	4639      	mov	r1, r7
c0de87a2:	4632      	mov	r2, r6
c0de87a4:	462b      	mov	r3, r5
c0de87a6:	9c04      	ldr	r4, [sp, #16]
c0de87a8:	47a0      	blx	r4
        cx_hash((cx_hash_t *) sha3, CX_LAST, mintingBlob, 32, output, 32);
c0de87aa:	9600      	str	r6, [sp, #0]
c0de87ac:	9501      	str	r5, [sp, #4]
c0de87ae:	2101      	movs	r1, #1
c0de87b0:	9805      	ldr	r0, [sp, #20]
c0de87b2:	9a02      	ldr	r2, [sp, #8]
c0de87b4:	462b      	mov	r3, r5
c0de87b6:	9c04      	ldr	r4, [sp, #16]
c0de87b8:	47a0      	blx	r4
c0de87ba:	20fe      	movs	r0, #254	; 0xfe
c0de87bc:	9903      	ldr	r1, [sp, #12]
    }
    if (!assetTypeOnly && ((quantumType == STARK_QUANTUM_MINTABLE_ERC20) ||
c0de87be:	4001      	ands	r1, r0
c0de87c0:	2904      	cmp	r1, #4
c0de87c2:	d103      	bne.n	c0de87cc <compute_token_id+0x154>
                           (quantumType == STARK_QUANTUM_MINTABLE_ERC721))) {
        output[0] = 0x04;
        output[1] = 0x00;
c0de87c4:	7077      	strb	r7, [r6, #1]
c0de87c6:	2004      	movs	r0, #4
        output[0] = 0x04;
c0de87c8:	7030      	strb	r0, [r6, #0]
c0de87ca:	e003      	b.n	c0de87d4 <compute_token_id+0x15c>
    } else {
        output[0] &= 0x03;
c0de87cc:	7830      	ldrb	r0, [r6, #0]
c0de87ce:	2103      	movs	r1, #3
c0de87d0:	4001      	ands	r1, r0
c0de87d2:	7031      	strb	r1, [r6, #0]
    }
    PRINTF("compute_token_id computed token %.*H\n", 32, output);
}
c0de87d4:	b00f      	add	sp, #60	; 0x3c
c0de87d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de87d8:	0000712e 	.word	0x0000712e
c0de87dc:	00007118 	.word	0x00007118
c0de87e0:	00007100 	.word	0x00007100
c0de87e4:	00007102 	.word	0x00007102
c0de87e8:	00007869 	.word	0x00007869
c0de87ec:	00008f16 	.word	0x00008f16
c0de87f0:	000077a3 	.word	0x000077a3
c0de87f4:	0000007d 	.word	0x0000007d

c0de87f8 <cx_keccak_init>:
{
c0de87f8:	b580      	push	{r7, lr}
c0de87fa:	2101      	movs	r1, #1
c0de87fc:	0209      	lsls	r1, r1, #8
  CX_THROW(cx_keccak_init_no_throw(hash, size));
c0de87fe:	f7fa fc4f 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de8802:	2800      	cmp	r0, #0
c0de8804:	d100      	bne.n	c0de8808 <cx_keccak_init+0x10>
c0de8806:	bd80      	pop	{r7, pc}
c0de8808:	f7fe fe0d 	bl	c0de7426 <os_longjmp>

c0de880c <cx_hash>:
{
c0de880c:	b51c      	push	{r2, r3, r4, lr}
c0de880e:	4604      	mov	r4, r0
c0de8810:	9805      	ldr	r0, [sp, #20]
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de8812:	9001      	str	r0, [sp, #4]
c0de8814:	9804      	ldr	r0, [sp, #16]
c0de8816:	9000      	str	r0, [sp, #0]
c0de8818:	4620      	mov	r0, r4
c0de881a:	f7fa fc2f 	bl	c0de307c <cx_hash_no_throw>
c0de881e:	2800      	cmp	r0, #0
c0de8820:	d103      	bne.n	c0de882a <cx_hash+0x1e>
  return cx_hash_get_size(hash);
c0de8822:	4620      	mov	r0, r4
c0de8824:	f7fa fc24 	bl	c0de3070 <cx_hash_get_size>
c0de8828:	bd1c      	pop	{r2, r3, r4, pc}
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0de882a:	f7fe fdfc 	bl	c0de7426 <os_longjmp>
c0de882e:	d4d4      	bmi.n	c0de87da <compute_token_id+0x162>

c0de8830 <is_deversify_contract>:
} starkware_parameters_t;

#define STARK_KEY_LENGTH (2 + length * 2 + 1)
#define VAULT_ID_LENGTH  10

bool is_deversify_contract(const uint8_t *address) {
c0de8830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de8832:	4605      	mov	r5, r0
c0de8834:	4809      	ldr	r0, [pc, #36]	; (c0de885c <is_deversify_contract+0x2c>)
c0de8836:	4478      	add	r0, pc
c0de8838:	1c46      	adds	r6, r0, #1
c0de883a:	2400      	movs	r4, #0
c0de883c:	4627      	mov	r7, r4
    uint32_t offset = 0;
    uint8_t i;

    for (i = 0; i < DEVERSIFI_CONTRACT[0]; i++) {
c0de883e:	2f01      	cmp	r7, #1
c0de8840:	d80a      	bhi.n	c0de8858 <is_deversify_contract+0x28>
c0de8842:	2214      	movs	r2, #20
        if (memcmp(address, DEVERSIFI_CONTRACT + offset + 1, 20) == 0) {
c0de8844:	4628      	mov	r0, r5
c0de8846:	4631      	mov	r1, r6
c0de8848:	f005 f804 	bl	c0ded854 <memcmp>
c0de884c:	2800      	cmp	r0, #0
c0de884e:	d002      	beq.n	c0de8856 <is_deversify_contract+0x26>
    for (i = 0; i < DEVERSIFI_CONTRACT[0]; i++) {
c0de8850:	3614      	adds	r6, #20
c0de8852:	1c7f      	adds	r7, r7, #1
c0de8854:	e7f3      	b.n	c0de883e <is_deversify_contract+0xe>
c0de8856:	2401      	movs	r4, #1
            return true;
        }
        offset += 20;
    }
    return false;
}
c0de8858:	4620      	mov	r0, r4
c0de885a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de885c:	000076e1 	.word	0x000076e1

c0de8860 <starkware_verify_asset_id>:

// TODO : rewrite as independant code
bool starkware_verify_asset_id(uint8_t *tmp32, const uint8_t *tokenId, bool assetTypeOnly) {
c0de8860:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de8862:	b0ef      	sub	sp, #444	; 0x1bc
c0de8864:	4616      	mov	r6, r2
c0de8866:	4604      	mov	r4, r0
    if (quantumSet) {
c0de8868:	481c      	ldr	r0, [pc, #112]	; (c0de88dc <starkware_verify_asset_id+0x7c>)
c0de886a:	464a      	mov	r2, r9
c0de886c:	5c10      	ldrb	r0, [r2, r0]
c0de886e:	2800      	cmp	r0, #0
c0de8870:	d021      	beq.n	c0de88b6 <starkware_verify_asset_id+0x56>
c0de8872:	9103      	str	r1, [sp, #12]
        cx_sha3_t sha3;
        tokenDefinition_t *currentToken = NULL;
        if (dataContext.tokenContext.quantumIndex != MAX_ITEMS) {
c0de8874:	4d1a      	ldr	r5, [pc, #104]	; (c0de88e0 <starkware_verify_asset_id+0x80>)
c0de8876:	4648      	mov	r0, r9
c0de8878:	1940      	adds	r0, r0, r5
c0de887a:	2149      	movs	r1, #73	; 0x49
c0de887c:	0089      	lsls	r1, r1, #2
c0de887e:	5c47      	ldrb	r7, [r0, r1]
c0de8880:	2001      	movs	r0, #1
c0de8882:	0201      	lsls	r1, r0, #8
c0de8884:	a804      	add	r0, sp, #16
c0de8886:	f7fa fc0b 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de888a:	2800      	cmp	r0, #0
c0de888c:	d123      	bne.n	c0de88d6 <starkware_verify_asset_id+0x76>
c0de888e:	4648      	mov	r0, r9
                &tmpCtx.transactionContext.extraInfo[dataContext.tokenContext.quantumIndex].token;
        }
        cx_keccak_init(&sha3, 256);
        compute_token_id(&sha3,
                         (currentToken != NULL ? currentToken->address : NULL),
                         dataContext.tokenContext.quantumType,
c0de8890:	1943      	adds	r3, r0, r5
c0de8892:	21ff      	movs	r1, #255	; 0xff
c0de8894:	3126      	adds	r1, #38	; 0x26
c0de8896:	5c5a      	ldrb	r2, [r3, r1]
c0de8898:	2141      	movs	r1, #65	; 0x41
c0de889a:	0089      	lsls	r1, r1, #2
        compute_token_id(&sha3,
c0de889c:	1859      	adds	r1, r3, r1
c0de889e:	9100      	str	r1, [sp, #0]
c0de88a0:	9601      	str	r6, [sp, #4]
c0de88a2:	9402      	str	r4, [sp, #8]
        if (dataContext.tokenContext.quantumIndex != MAX_ITEMS) {
c0de88a4:	2f02      	cmp	r7, #2
c0de88a6:	d008      	beq.n	c0de88ba <starkware_verify_asset_id+0x5a>
c0de88a8:	215b      	movs	r1, #91	; 0x5b
c0de88aa:	4379      	muls	r1, r7
c0de88ac:	4d0d      	ldr	r5, [pc, #52]	; (c0de88e4 <starkware_verify_asset_id+0x84>)
c0de88ae:	1940      	adds	r0, r0, r5
c0de88b0:	1841      	adds	r1, r0, r1
c0de88b2:	314c      	adds	r1, #76	; 0x4c
c0de88b4:	e002      	b.n	c0de88bc <starkware_verify_asset_id+0x5c>
c0de88b6:	2000      	movs	r0, #0
c0de88b8:	e00b      	b.n	c0de88d2 <starkware_verify_asset_id+0x72>
c0de88ba:	2100      	movs	r1, #0
        compute_token_id(&sha3,
c0de88bc:	33e4      	adds	r3, #228	; 0xe4
c0de88be:	a804      	add	r0, sp, #16
c0de88c0:	f7ff feda 	bl	c0de8678 <compute_token_id>
c0de88c4:	2220      	movs	r2, #32
                         dataContext.tokenContext.quantum,
                         dataContext.tokenContext.mintingBlob,
                         assetTypeOnly,
                         tmp32);
        if (memcmp(tokenId, tmp32, 32) != 0) {
c0de88c6:	9803      	ldr	r0, [sp, #12]
c0de88c8:	4621      	mov	r1, r4
c0de88ca:	f004 ffc3 	bl	c0ded854 <memcmp>
c0de88ce:	4241      	negs	r1, r0
c0de88d0:	4148      	adcs	r0, r1
c0de88d2:	b06f      	add	sp, #444	; 0x1bc
c0de88d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de88d6:	f7fe fda6 	bl	c0de7426 <os_longjmp>
c0de88da:	46c0      	nop			; (mov r8, r8)
c0de88dc:	0000011f 	.word	0x0000011f
c0de88e0:	00000594 	.word	0x00000594
c0de88e4:	00000124 	.word	0x00000124

c0de88e8 <starkware_verify_nft_token_id>:
        return false;
    }
    return true;
}

bool starkware_verify_nft_token_id(const uint8_t *tokenId) {
c0de88e8:	b510      	push	{r4, lr}
c0de88ea:	4601      	mov	r1, r0
    if (!quantumSet) {
c0de88ec:	480c      	ldr	r0, [pc, #48]	; (c0de8920 <starkware_verify_nft_token_id+0x38>)
c0de88ee:	464a      	mov	r2, r9
c0de88f0:	5c12      	ldrb	r2, [r2, r0]
c0de88f2:	2000      	movs	r0, #0
c0de88f4:	2a00      	cmp	r2, #0
c0de88f6:	d012      	beq.n	c0de891e <starkware_verify_nft_token_id+0x36>
        PRINTF("Quantum not set\n");
        return false;
    }
    switch (dataContext.tokenContext.quantumType) {
c0de88f8:	4a0a      	ldr	r2, [pc, #40]	; (c0de8924 <starkware_verify_nft_token_id+0x3c>)
c0de88fa:	464b      	mov	r3, r9
c0de88fc:	189b      	adds	r3, r3, r2
c0de88fe:	24ff      	movs	r4, #255	; 0xff
c0de8900:	3426      	adds	r4, #38	; 0x26
c0de8902:	5d1b      	ldrb	r3, [r3, r4]
c0de8904:	2b05      	cmp	r3, #5
c0de8906:	d001      	beq.n	c0de890c <starkware_verify_nft_token_id+0x24>
c0de8908:	2b03      	cmp	r3, #3
c0de890a:	d108      	bne.n	c0de891e <starkware_verify_nft_token_id+0x36>
        default:
            PRINTF("Unexpected quantum type for NFT token id check %d\n",
                   dataContext.tokenContext.quantumType);
            return false;
    }
    if (memcmp(dataContext.tokenContext.quantum, tokenId, 32) != 0) {
c0de890c:	4648      	mov	r0, r9
c0de890e:	1880      	adds	r0, r0, r2
c0de8910:	30e4      	adds	r0, #228	; 0xe4
c0de8912:	2220      	movs	r2, #32
c0de8914:	f004 ff9e 	bl	c0ded854 <memcmp>
c0de8918:	4601      	mov	r1, r0
c0de891a:	4240      	negs	r0, r0
c0de891c:	4148      	adcs	r0, r1
        PRINTF("Token ID not matching - expected %.*H\n", 32, dataContext.tokenContext.quantum);
        PRINTF("Current token ID %.*H\n", 32, tokenId);
        return false;
    }
    return true;
}
c0de891e:	bd10      	pop	{r4, pc}
c0de8920:	0000011f 	.word	0x0000011f
c0de8924:	00000594 	.word	0x00000594

c0de8928 <starkware_print_vault_id>:

void starkware_print_vault_id(uint32_t vaultId, char *destination, size_t max_length) {
c0de8928:	b510      	push	{r4, lr}
    if (VAULT_ID_LENGTH > max_length) {
c0de892a:	2a09      	cmp	r2, #9
c0de892c:	d908      	bls.n	c0de8940 <starkware_print_vault_id+0x18>
c0de892e:	4614      	mov	r4, r2
c0de8930:	4603      	mov	r3, r0
        os_sched_exit(EXCEPTION_OVERFLOW);
    }
    snprintf(destination, max_length, "%d", vaultId);
c0de8932:	4a05      	ldr	r2, [pc, #20]	; (c0de8948 <starkware_print_vault_id+0x20>)
c0de8934:	447a      	add	r2, pc
c0de8936:	4608      	mov	r0, r1
c0de8938:	4621      	mov	r1, r4
c0de893a:	f7ff faa7 	bl	c0de7e8c <snprintf>
}
c0de893e:	bd10      	pop	{r4, pc}
c0de8940:	2007      	movs	r0, #7
        os_sched_exit(EXCEPTION_OVERFLOW);
c0de8942:	f000 fccf 	bl	c0de92e4 <os_sched_exit>
c0de8946:	46c0      	nop			; (mov r8, r8)
c0de8948:	00005410 	.word	0x00005410

c0de894c <starkware_print_stark_key>:

void starkware_print_stark_key(uint8_t *starkKey,
                               size_t length,
                               char *destination,
                               size_t max_length) {
c0de894c:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0de894e:	461c      	mov	r4, r3
c0de8950:	460b      	mov	r3, r1
    if (STARK_KEY_LENGTH > max_length) {
c0de8952:	0049      	lsls	r1, r1, #1
c0de8954:	1cc9      	adds	r1, r1, #3
c0de8956:	42a1      	cmp	r1, r4
c0de8958:	d808      	bhi.n	c0de896c <starkware_print_stark_key+0x20>
c0de895a:	4615      	mov	r5, r2
        os_sched_exit(EXCEPTION_OVERFLOW);
    }
    snprintf(destination, max_length, "0x%.*H", length, starkKey);
c0de895c:	9000      	str	r0, [sp, #0]
c0de895e:	4a05      	ldr	r2, [pc, #20]	; (c0de8974 <starkware_print_stark_key+0x28>)
c0de8960:	447a      	add	r2, pc
c0de8962:	4628      	mov	r0, r5
c0de8964:	4621      	mov	r1, r4
c0de8966:	f7ff fa91 	bl	c0de7e8c <snprintf>
}
c0de896a:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0de896c:	2007      	movs	r0, #7
        os_sched_exit(EXCEPTION_OVERFLOW);
c0de896e:	f000 fcb9 	bl	c0de92e4 <os_sched_exit>
c0de8972:	46c0      	nop			; (mov r8, r8)
c0de8974:	00005777 	.word	0x00005777

c0de8978 <starkware_print_amount>:

// TODO : rewrite as independant code
void starkware_print_amount(uint8_t *amountData,
                            char *destination,
                            size_t destinationLength,
                            bool forEscape) {
c0de8978:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de897a:	b09b      	sub	sp, #108	; 0x6c
c0de897c:	4614      	mov	r4, r2
c0de897e:	460d      	mov	r5, r1
c0de8980:	4607      	mov	r7, r0
    uint256_t amount, amountPre, quantum;
    uint8_t decimals;
    char *ticker = chainConfig->coinName;
c0de8982:	4830      	ldr	r0, [pc, #192]	; (c0de8a44 <starkware_print_amount+0xcc>)
c0de8984:	4649      	mov	r1, r9
c0de8986:	580e      	ldr	r6, [r1, r0]

    if ((amountData == NULL) ||
c0de8988:	2f00      	cmp	r7, #0
c0de898a:	d009      	beq.n	c0de89a0 <starkware_print_amount+0x28>
        (forEscape && (dataContext.tokenContext.quantumIndex == MAX_ITEMS))) {
c0de898c:	482e      	ldr	r0, [pc, #184]	; (c0de8a48 <starkware_print_amount+0xd0>)
c0de898e:	4649      	mov	r1, r9
c0de8990:	1808      	adds	r0, r1, r0
c0de8992:	2149      	movs	r1, #73	; 0x49
c0de8994:	0089      	lsls	r1, r1, #2
c0de8996:	5c40      	ldrb	r0, [r0, r1]
c0de8998:	2802      	cmp	r0, #2
c0de899a:	d108      	bne.n	c0de89ae <starkware_print_amount+0x36>
c0de899c:	2b00      	cmp	r3, #0
c0de899e:	d006      	beq.n	c0de89ae <starkware_print_amount+0x36>
        decimals = WEI_TO_ETHER;
        if (!forEscape) {
c0de89a0:	2b00      	cmp	r3, #0
c0de89a2:	d013      	beq.n	c0de89cc <starkware_print_amount+0x54>
c0de89a4:	a90a      	add	r1, sp, #40	; 0x28
            convertUint256BE(tmpContent.txContent.value.value,
                             tmpContent.txContent.value.length,
                             &amount);
        } else {
            readu256BE(amountData, &amountPre);
c0de89a6:	4638      	mov	r0, r7
c0de89a8:	f002 f8e2 	bl	c0deab70 <readu256BE>
c0de89ac:	e017      	b.n	c0de89de <starkware_print_amount+0x66>
c0de89ae:	215b      	movs	r1, #91	; 0x5b
        }
    } else {
        tokenDefinition_t *token =
            &tmpCtx.transactionContext.extraInfo[dataContext.tokenContext.quantumIndex].token;
        decimals = token->decimals;
c0de89b0:	4341      	muls	r1, r0
c0de89b2:	4826      	ldr	r0, [pc, #152]	; (c0de8a4c <starkware_print_amount+0xd4>)
c0de89b4:	464a      	mov	r2, r9
c0de89b6:	1810      	adds	r0, r2, r0
c0de89b8:	1846      	adds	r6, r0, r1
c0de89ba:	206c      	movs	r0, #108	; 0x6c
c0de89bc:	5c30      	ldrb	r0, [r6, r0]
        ticker = token->ticker;
        readu256BE(amountData, &amountPre);
c0de89be:	9001      	str	r0, [sp, #4]
c0de89c0:	a90a      	add	r1, sp, #40	; 0x28
c0de89c2:	4638      	mov	r0, r7
c0de89c4:	f002 f8d4 	bl	c0deab70 <readu256BE>
        decimals = token->decimals;
c0de89c8:	3660      	adds	r6, #96	; 0x60
c0de89ca:	e00c      	b.n	c0de89e6 <starkware_print_amount+0x6e>
                             tmpContent.txContent.value.length,
c0de89cc:	4820      	ldr	r0, [pc, #128]	; (c0de8a50 <starkware_print_amount+0xd8>)
c0de89ce:	4649      	mov	r1, r9
c0de89d0:	1808      	adds	r0, r1, r0
c0de89d2:	2162      	movs	r1, #98	; 0x62
c0de89d4:	5c41      	ldrb	r1, [r0, r1]
            convertUint256BE(tmpContent.txContent.value.value,
c0de89d6:	3042      	adds	r0, #66	; 0x42
c0de89d8:	aa12      	add	r2, sp, #72	; 0x48
c0de89da:	f003 fd35 	bl	c0dec448 <convertUint256BE>
c0de89de:	2012      	movs	r0, #18
    }
    if (amountData != NULL) {
c0de89e0:	9001      	str	r0, [sp, #4]
c0de89e2:	2f00      	cmp	r7, #0
c0de89e4:	d00c      	beq.n	c0de8a00 <starkware_print_amount+0x88>
        readu256BE(dataContext.tokenContext.quantum, &quantum);
c0de89e6:	4818      	ldr	r0, [pc, #96]	; (c0de8a48 <starkware_print_amount+0xd0>)
c0de89e8:	4649      	mov	r1, r9
c0de89ea:	1808      	adds	r0, r1, r0
c0de89ec:	30e4      	adds	r0, #228	; 0xe4
c0de89ee:	af02      	add	r7, sp, #8
c0de89f0:	4639      	mov	r1, r7
c0de89f2:	f002 f8bd 	bl	c0deab70 <readu256BE>
c0de89f6:	a80a      	add	r0, sp, #40	; 0x28
c0de89f8:	aa12      	add	r2, sp, #72	; 0x48
        mul256(&amountPre, &quantum, &amount);
c0de89fa:	4639      	mov	r1, r7
c0de89fc:	f002 fc02 	bl	c0deb204 <mul256>
    }
    tostring256(&amount, 10, (char *) (G_io_apdu_buffer + 100), 100);
c0de8a00:	4814      	ldr	r0, [pc, #80]	; (c0de8a54 <starkware_print_amount+0xdc>)
c0de8a02:	4649      	mov	r1, r9
c0de8a04:	180f      	adds	r7, r1, r0
c0de8a06:	3764      	adds	r7, #100	; 0x64
c0de8a08:	a812      	add	r0, sp, #72	; 0x48
c0de8a0a:	210a      	movs	r1, #10
c0de8a0c:	2364      	movs	r3, #100	; 0x64
c0de8a0e:	463a      	mov	r2, r7
c0de8a10:	f002 fd10 	bl	c0deb434 <tostring256>
    strlcpy(destination, ticker, destinationLength);
c0de8a14:	4628      	mov	r0, r5
c0de8a16:	4631      	mov	r1, r6
c0de8a18:	4622      	mov	r2, r4
c0de8a1a:	f005 f8db 	bl	c0dedbd4 <strlcpy>
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
                   strlen((char *) (G_io_apdu_buffer + 100)),
c0de8a1e:	4638      	mov	r0, r7
c0de8a20:	f005 f8fe 	bl	c0dedc20 <strlen>
c0de8a24:	4631      	mov	r1, r6
c0de8a26:	4606      	mov	r6, r0
                   destination + strlen(ticker),
c0de8a28:	4608      	mov	r0, r1
c0de8a2a:	f005 f8f9 	bl	c0dedc20 <strlen>
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0de8a2e:	9901      	ldr	r1, [sp, #4]
c0de8a30:	9100      	str	r1, [sp, #0]
                   destination + strlen(ticker),
c0de8a32:	182a      	adds	r2, r5, r0
                   destinationLength - strlen(ticker),
c0de8a34:	1a23      	subs	r3, r4, r0
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0de8a36:	4638      	mov	r0, r7
c0de8a38:	4631      	mov	r1, r6
c0de8a3a:	f7fb ff19 	bl	c0de4870 <adjustDecimals>
                   decimals);
}
c0de8a3e:	b01b      	add	sp, #108	; 0x6c
c0de8a40:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de8a42:	46c0      	nop			; (mov r8, r8)
c0de8a44:	00000590 	.word	0x00000590
c0de8a48:	00000594 	.word	0x00000594
c0de8a4c:	00000124 	.word	0x00000124
c0de8a50:	0000026c 	.word	0x0000026c
c0de8a54:	00000990 	.word	0x00000990

c0de8a58 <starkware_print_ticker>:

// TODO : rewrite as independant code
void starkware_print_ticker(char *destination, size_t destinationLength) {
c0de8a58:	b510      	push	{r4, lr}
c0de8a5a:	460a      	mov	r2, r1
    char *ticker = chainConfig->coinName;
c0de8a5c:	4649      	mov	r1, r9

    if (dataContext.tokenContext.quantumIndex != MAX_ITEMS) {
c0de8a5e:	4b0a      	ldr	r3, [pc, #40]	; (c0de8a88 <starkware_print_ticker+0x30>)
c0de8a60:	18cb      	adds	r3, r1, r3
c0de8a62:	2449      	movs	r4, #73	; 0x49
c0de8a64:	00a4      	lsls	r4, r4, #2
c0de8a66:	5d1b      	ldrb	r3, [r3, r4]
c0de8a68:	2b02      	cmp	r3, #2
c0de8a6a:	d006      	beq.n	c0de8a7a <starkware_print_ticker+0x22>
c0de8a6c:	4c05      	ldr	r4, [pc, #20]	; (c0de8a84 <starkware_print_ticker+0x2c>)
c0de8a6e:	1909      	adds	r1, r1, r4
c0de8a70:	245b      	movs	r4, #91	; 0x5b
c0de8a72:	435c      	muls	r4, r3
c0de8a74:	1909      	adds	r1, r1, r4
c0de8a76:	3160      	adds	r1, #96	; 0x60
c0de8a78:	e001      	b.n	c0de8a7e <starkware_print_ticker+0x26>
c0de8a7a:	4b04      	ldr	r3, [pc, #16]	; (c0de8a8c <starkware_print_ticker+0x34>)
c0de8a7c:	58c9      	ldr	r1, [r1, r3]
        tokenDefinition_t *token =
            &tmpCtx.transactionContext.extraInfo[dataContext.tokenContext.quantumIndex].token;
        ticker = token->ticker;
    }
    strlcpy(destination, ticker, destinationLength);
c0de8a7e:	f005 f8a9 	bl	c0dedbd4 <strlcpy>
}
c0de8a82:	bd10      	pop	{r4, pc}
c0de8a84:	00000124 	.word	0x00000124
c0de8a88:	00000594 	.word	0x00000594
c0de8a8c:	00000590 	.word	0x00000590

c0de8a90 <starkware_print_asset_contract>:

// TODO : rewrite as independant code
void starkware_print_asset_contract(char *destination, size_t destinationLength) {
c0de8a90:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0de8a92:	460a      	mov	r2, r1
c0de8a94:	4604      	mov	r4, r0
    // token has been validated to be present previously
    if (dataContext.tokenContext.quantumIndex != MAX_ITEMS) {
c0de8a96:	4810      	ldr	r0, [pc, #64]	; (c0de8ad8 <starkware_print_asset_contract+0x48>)
c0de8a98:	4649      	mov	r1, r9
c0de8a9a:	1808      	adds	r0, r1, r0
c0de8a9c:	2149      	movs	r1, #73	; 0x49
c0de8a9e:	0089      	lsls	r1, r1, #2
c0de8aa0:	5c40      	ldrb	r0, [r0, r1]
c0de8aa2:	2802      	cmp	r0, #2
c0de8aa4:	d105      	bne.n	c0de8ab2 <starkware_print_asset_contract+0x22>
                                 destination,
                                 destinationLength,
                                 &global_sha3,
                                 chainConfig->chainId);
    } else {
        strlcpy(destination, "UNKNOWN", destinationLength);
c0de8aa6:	4910      	ldr	r1, [pc, #64]	; (c0de8ae8 <starkware_print_asset_contract+0x58>)
c0de8aa8:	4479      	add	r1, pc
c0de8aaa:	4620      	mov	r0, r4
c0de8aac:	f005 f892 	bl	c0dedbd4 <strlcpy>
    }
}
c0de8ab0:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
                                 chainConfig->chainId);
c0de8ab2:	490a      	ldr	r1, [pc, #40]	; (c0de8adc <starkware_print_asset_contract+0x4c>)
        getEthDisplayableAddress(token->address,
c0de8ab4:	464b      	mov	r3, r9
                                 chainConfig->chainId);
c0de8ab6:	5859      	ldr	r1, [r3, r1]
c0de8ab8:	690d      	ldr	r5, [r1, #16]
c0de8aba:	6949      	ldr	r1, [r1, #20]
        getEthDisplayableAddress(token->address,
c0de8abc:	9500      	str	r5, [sp, #0]
c0de8abe:	9101      	str	r1, [sp, #4]
c0de8ac0:	215b      	movs	r1, #91	; 0x5b
c0de8ac2:	4341      	muls	r1, r0
c0de8ac4:	4806      	ldr	r0, [pc, #24]	; (c0de8ae0 <starkware_print_asset_contract+0x50>)
c0de8ac6:	1818      	adds	r0, r3, r0
c0de8ac8:	1840      	adds	r0, r0, r1
c0de8aca:	304c      	adds	r0, #76	; 0x4c
c0de8acc:	4905      	ldr	r1, [pc, #20]	; (c0de8ae4 <starkware_print_asset_contract+0x54>)
c0de8ace:	185b      	adds	r3, r3, r1
c0de8ad0:	4621      	mov	r1, r4
c0de8ad2:	f7fb feb3 	bl	c0de483c <getEthDisplayableAddress>
}
c0de8ad6:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0de8ad8:	00000594 	.word	0x00000594
c0de8adc:	00000590 	.word	0x00000590
c0de8ae0:	00000124 	.word	0x00000124
c0de8ae4:	000007e8 	.word	0x000007e8
c0de8ae8:	000054ce 	.word	0x000054ce

c0de8aec <starkware_get_source_address>:

// TODO : rewrite as independant code
void starkware_get_source_address(char *destination) {
c0de8aec:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de8aee:	b0a7      	sub	sp, #156	; 0x9c
c0de8af0:	4604      	mov	r4, r0
    uint8_t privateKeyData[INT256_LENGTH];
    cx_ecfp_private_key_t privateKey;
    cx_ecfp_public_key_t publicKey;
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0de8af2:	4820      	ldr	r0, [pc, #128]	; (c0de8b74 <starkware_get_source_address+0x88>)
c0de8af4:	4649      	mov	r1, r9
c0de8af6:	5c0a      	ldrb	r2, [r1, r0]
c0de8af8:	2700      	movs	r7, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de8afa:	9700      	str	r7, [sp, #0]
                               tmpCtx.transactionContext.pathLength,
c0de8afc:	1808      	adds	r0, r1, r0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de8afe:	1d01      	adds	r1, r0, #4
c0de8b00:	2521      	movs	r5, #33	; 0x21
c0de8b02:	ae1f      	add	r6, sp, #124	; 0x7c
c0de8b04:	4628      	mov	r0, r5
c0de8b06:	4633      	mov	r3, r6
c0de8b08:	f000 fb74 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0de8b0c:	2220      	movs	r2, #32
c0de8b0e:	ab15      	add	r3, sp, #84	; 0x54
c0de8b10:	4628      	mov	r0, r5
c0de8b12:	4631      	mov	r1, r6
c0de8b14:	f7fa fa9a 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de8b18:	2800      	cmp	r0, #0
c0de8b1a:	d128      	bne.n	c0de8b6e <starkware_get_source_address+0x82>
                               privateKeyData,
                               NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
    io_seproxyhal_io_heartbeat();
c0de8b1c:	f7ff f840 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de8b20:	2021      	movs	r0, #33	; 0x21
c0de8b22:	a902      	add	r1, sp, #8
c0de8b24:	aa15      	add	r2, sp, #84	; 0x54
c0de8b26:	2301      	movs	r3, #1
  CX_THROW(cx_ecfp_generate_pair_no_throw(curve, pubkey, privkey, keepprivate));
c0de8b28:	f7fa fa8a 	bl	c0de3040 <cx_ecfp_generate_pair_no_throw>
c0de8b2c:	2800      	cmp	r0, #0
c0de8b2e:	d11e      	bne.n	c0de8b6e <starkware_get_source_address+0x82>
c0de8b30:	a815      	add	r0, sp, #84	; 0x54
c0de8b32:	2128      	movs	r1, #40	; 0x28
    cx_ecfp_generate_pair(CX_CURVE_256K1, &publicKey, &privateKey, 1);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de8b34:	f004 fe84 	bl	c0ded840 <explicit_bzero>
c0de8b38:	a81f      	add	r0, sp, #124	; 0x7c
c0de8b3a:	2120      	movs	r1, #32
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de8b3c:	f004 fe80 	bl	c0ded840 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0de8b40:	f7ff f82e 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de8b44:	2078      	movs	r0, #120	; 0x78
    destination[0] = '0';
    destination[1] = 'x';
c0de8b46:	7060      	strb	r0, [r4, #1]
c0de8b48:	2030      	movs	r0, #48	; 0x30
    destination[0] = '0';
c0de8b4a:	7020      	strb	r0, [r4, #0]
    getEthAddressStringFromKey(&publicKey, destination + 2, &global_sha3, chainConfig->chainId);
c0de8b4c:	480a      	ldr	r0, [pc, #40]	; (c0de8b78 <starkware_get_source_address+0x8c>)
c0de8b4e:	4649      	mov	r1, r9
c0de8b50:	5808      	ldr	r0, [r1, r0]
c0de8b52:	6902      	ldr	r2, [r0, #16]
c0de8b54:	6940      	ldr	r0, [r0, #20]
c0de8b56:	9200      	str	r2, [sp, #0]
c0de8b58:	9001      	str	r0, [sp, #4]
c0de8b5a:	4808      	ldr	r0, [pc, #32]	; (c0de8b7c <starkware_get_source_address+0x90>)
c0de8b5c:	180a      	adds	r2, r1, r0
c0de8b5e:	1ca1      	adds	r1, r4, #2
c0de8b60:	a802      	add	r0, sp, #8
c0de8b62:	f7fb fda5 	bl	c0de46b0 <getEthAddressStringFromKey>
c0de8b66:	202a      	movs	r0, #42	; 0x2a
    destination[42] = '\0';
c0de8b68:	5427      	strb	r7, [r4, r0]
}
c0de8b6a:	b027      	add	sp, #156	; 0x9c
c0de8b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de8b6e:	f7fe fc5a 	bl	c0de7426 <os_longjmp>
c0de8b72:	46c0      	nop			; (mov r8, r8)
c0de8b74:	00000124 	.word	0x00000124
c0de8b78:	00000590 	.word	0x00000590
c0de8b7c:	000007e8 	.word	0x000007e8

c0de8b80 <starkware_plugin_call>:

void starkware_plugin_call(int message, void *parameters) {
c0de8b80:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de8b82:	460c      	mov	r4, r1
c0de8b84:	2183      	movs	r1, #131	; 0x83
c0de8b86:	0049      	lsls	r1, r1, #1
    switch (message) {
c0de8b88:	4288      	cmp	r0, r1
c0de8b8a:	d035      	beq.n	c0de8bf8 <starkware_plugin_call+0x78>
c0de8b8c:	2181      	movs	r1, #129	; 0x81
c0de8b8e:	0049      	lsls	r1, r1, #1
c0de8b90:	4288      	cmp	r0, r1
c0de8b92:	d05b      	beq.n	c0de8c4c <starkware_plugin_call+0xcc>
c0de8b94:	21ff      	movs	r1, #255	; 0xff
c0de8b96:	460a      	mov	r2, r1
c0de8b98:	3204      	adds	r2, #4
c0de8b9a:	4290      	cmp	r0, r2
c0de8b9c:	d05d      	beq.n	c0de8c5a <starkware_plugin_call+0xda>
c0de8b9e:	460a      	mov	r2, r1
c0de8ba0:	3206      	adds	r2, #6
c0de8ba2:	4290      	cmp	r0, r2
c0de8ba4:	d068      	beq.n	c0de8c78 <starkware_plugin_call+0xf8>
c0de8ba6:	3102      	adds	r1, #2
c0de8ba8:	4288      	cmp	r0, r1
c0de8baa:	d000      	beq.n	c0de8bae <starkware_plugin_call+0x2e>
c0de8bac:	e0d0      	b.n	c0de8d50 <starkware_plugin_call+0x1d0>
        case ETH_PLUGIN_INIT_CONTRACT: {
            uint8_t i;
            ethPluginInitContract_t *msg = (ethPluginInitContract_t *) parameters;
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0de8bae:	68e5      	ldr	r5, [r4, #12]
c0de8bb0:	2600      	movs	r6, #0
c0de8bb2:	4ffb      	ldr	r7, [pc, #1004]	; (c0de8fa0 <starkware_plugin_call+0x420>)
c0de8bb4:	447f      	add	r7, pc
            PRINTF("starkware plugin init\n");
            for (i = 0; i < NUM_STARKWARE_SELECTORS; i++) {
c0de8bb6:	2e14      	cmp	r6, #20
c0de8bb8:	d100      	bne.n	c0de8bbc <starkware_plugin_call+0x3c>
c0de8bba:	e0c9      	b.n	c0de8d50 <starkware_plugin_call+0x1d0>
                if (memcmp((const void *) PIC(STARKWARE_SELECTORS[i]),
c0de8bbc:	6838      	ldr	r0, [r7, #0]
c0de8bbe:	f7ff fb41 	bl	c0de8244 <pic>
c0de8bc2:	7801      	ldrb	r1, [r0, #0]
c0de8bc4:	7842      	ldrb	r2, [r0, #1]
c0de8bc6:	0212      	lsls	r2, r2, #8
c0de8bc8:	1851      	adds	r1, r2, r1
c0de8bca:	7882      	ldrb	r2, [r0, #2]
c0de8bcc:	78c0      	ldrb	r0, [r0, #3]
c0de8bce:	0200      	lsls	r0, r0, #8
c0de8bd0:	1880      	adds	r0, r0, r2
c0de8bd2:	0400      	lsls	r0, r0, #16
c0de8bd4:	1840      	adds	r0, r0, r1
                           msg->selector,
c0de8bd6:	6961      	ldr	r1, [r4, #20]
                if (memcmp((const void *) PIC(STARKWARE_SELECTORS[i]),
c0de8bd8:	780a      	ldrb	r2, [r1, #0]
c0de8bda:	784b      	ldrb	r3, [r1, #1]
c0de8bdc:	021b      	lsls	r3, r3, #8
c0de8bde:	189a      	adds	r2, r3, r2
c0de8be0:	788b      	ldrb	r3, [r1, #2]
c0de8be2:	78c9      	ldrb	r1, [r1, #3]
c0de8be4:	0209      	lsls	r1, r1, #8
c0de8be6:	18c9      	adds	r1, r1, r3
c0de8be8:	0409      	lsls	r1, r1, #16
c0de8bea:	1889      	adds	r1, r1, r2
c0de8bec:	4288      	cmp	r0, r1
c0de8bee:	d100      	bne.n	c0de8bf2 <starkware_plugin_call+0x72>
c0de8bf0:	e09e      	b.n	c0de8d30 <starkware_plugin_call+0x1b0>
            for (i = 0; i < NUM_STARKWARE_SELECTORS; i++) {
c0de8bf2:	1d3f      	adds	r7, r7, #4
c0de8bf4:	1c76      	adds	r6, r6, #1
c0de8bf6:	e7de      	b.n	c0de8bb6 <starkware_plugin_call+0x36>
c0de8bf8:	4626      	mov	r6, r4
c0de8bfa:	3620      	adds	r6, #32
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0de8bfc:	7830      	ldrb	r0, [r6, #0]
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0de8bfe:	69e5      	ldr	r5, [r4, #28]
            switch (msg->screenIndex) {
c0de8c00:	2804      	cmp	r0, #4
c0de8c02:	d100      	bne.n	c0de8c06 <starkware_plugin_call+0x86>
c0de8c04:	e0a8      	b.n	c0de8d58 <starkware_plugin_call+0x1d8>
c0de8c06:	2801      	cmp	r0, #1
c0de8c08:	d100      	bne.n	c0de8c0c <starkware_plugin_call+0x8c>
c0de8c0a:	e0bd      	b.n	c0de8d88 <starkware_plugin_call+0x208>
c0de8c0c:	2802      	cmp	r0, #2
c0de8c0e:	d100      	bne.n	c0de8c12 <starkware_plugin_call+0x92>
c0de8c10:	e0d1      	b.n	c0de8db6 <starkware_plugin_call+0x236>
c0de8c12:	2803      	cmp	r0, #3
c0de8c14:	d100      	bne.n	c0de8c18 <starkware_plugin_call+0x98>
c0de8c16:	e0f5      	b.n	c0de8e04 <starkware_plugin_call+0x284>
c0de8c18:	2800      	cmp	r0, #0
c0de8c1a:	d000      	beq.n	c0de8c1e <starkware_plugin_call+0x9e>
c0de8c1c:	e098      	b.n	c0de8d50 <starkware_plugin_call+0x1d0>
                case 0:
                    strlcpy(msg->title, "Contract Name", msg->titleLength);
c0de8c1e:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8c20:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8c22:	49fc      	ldr	r1, [pc, #1008]	; (c0de9014 <starkware_plugin_call+0x494>)
c0de8c24:	4479      	add	r1, pc
c0de8c26:	f004 ffd5 	bl	c0dedbd4 <strlcpy>
                    if (is_deversify_contract(tmpContent.txContent.destination)) {
c0de8c2a:	4ffb      	ldr	r7, [pc, #1004]	; (c0de9018 <starkware_plugin_call+0x498>)
c0de8c2c:	4648      	mov	r0, r9
c0de8c2e:	19c0      	adds	r0, r0, r7
c0de8c30:	30a5      	adds	r0, #165	; 0xa5
c0de8c32:	f7ff fdfd 	bl	c0de8830 <is_deversify_contract>
c0de8c36:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
c0de8c38:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de8c3a:	2800      	cmp	r0, #0
c0de8c3c:	d100      	bne.n	c0de8c40 <starkware_plugin_call+0xc0>
c0de8c3e:	e119      	b.n	c0de8e74 <starkware_plugin_call+0x2f4>
                        strlcpy(msg->msg, "DeversiFi", msg->msgLength);
c0de8c40:	49f6      	ldr	r1, [pc, #984]	; (c0de901c <starkware_plugin_call+0x49c>)
c0de8c42:	4479      	add	r1, pc
c0de8c44:	4628      	mov	r0, r5
c0de8c46:	f004 ffc5 	bl	c0dedbd4 <strlcpy>
c0de8c4a:	e200      	b.n	c0de904e <starkware_plugin_call+0x4ce>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0de8c4c:	68a5      	ldr	r5, [r4, #8]
            if (context->selectorIndex == STARKWARE_VERIFY_ESCAPE) {
c0de8c4e:	7928      	ldrb	r0, [r5, #4]
c0de8c50:	2809      	cmp	r0, #9
c0de8c52:	d14b      	bne.n	c0de8cec <starkware_plugin_call+0x16c>
c0de8c54:	2004      	movs	r0, #4
c0de8c56:	7520      	strb	r0, [r4, #20]
c0de8c58:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0de8c5a:	68a0      	ldr	r0, [r4, #8]
c0de8c5c:	2145      	movs	r1, #69	; 0x45
            if (!context->validToken) {
c0de8c5e:	5c41      	ldrb	r1, [r0, r1]
c0de8c60:	2900      	cmp	r1, #0
c0de8c62:	d076      	beq.n	c0de8d52 <starkware_plugin_call+0x1d2>
c0de8c64:	2102      	movs	r1, #2
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0de8c66:	7721      	strb	r1, [r4, #28]
c0de8c68:	2104      	movs	r1, #4
                msg->result = ETH_PLUGIN_RESULT_OK;
c0de8c6a:	77a1      	strb	r1, [r4, #30]
                msg->numScreens = STARKWARE_NUM_SCREENS[context->selectorIndex];
c0de8c6c:	7900      	ldrb	r0, [r0, #4]
c0de8c6e:	49ec      	ldr	r1, [pc, #944]	; (c0de9020 <starkware_plugin_call+0x4a0>)
c0de8c70:	4479      	add	r1, pc
c0de8c72:	5c08      	ldrb	r0, [r1, r0]
c0de8c74:	7760      	strb	r0, [r4, #29]
c0de8c76:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0de8c78:	68a0      	ldr	r0, [r4, #8]
            switch (context->selectorIndex) {
c0de8c7a:	7900      	ldrb	r0, [r0, #4]
c0de8c7c:	1e41      	subs	r1, r0, #1
c0de8c7e:	2902      	cmp	r1, #2
c0de8c80:	d331      	bcc.n	c0de8ce6 <starkware_plugin_call+0x166>
c0de8c82:	4601      	mov	r1, r0
c0de8c84:	390d      	subs	r1, #13
c0de8c86:	2902      	cmp	r1, #2
c0de8c88:	d200      	bcs.n	c0de8c8c <starkware_plugin_call+0x10c>
c0de8c8a:	e0e7      	b.n	c0de8e5c <starkware_plugin_call+0x2dc>
c0de8c8c:	4601      	mov	r1, r0
c0de8c8e:	3910      	subs	r1, #16
c0de8c90:	2902      	cmp	r1, #2
c0de8c92:	d200      	bcs.n	c0de8c96 <starkware_plugin_call+0x116>
c0de8c94:	e0e5      	b.n	c0de8e62 <starkware_plugin_call+0x2e2>
c0de8c96:	4601      	mov	r1, r0
c0de8c98:	3912      	subs	r1, #18
c0de8c9a:	2902      	cmp	r1, #2
c0de8c9c:	d323      	bcc.n	c0de8ce6 <starkware_plugin_call+0x166>
c0de8c9e:	2800      	cmp	r0, #0
c0de8ca0:	d100      	bne.n	c0de8ca4 <starkware_plugin_call+0x124>
c0de8ca2:	e153      	b.n	c0de8f4c <starkware_plugin_call+0x3cc>
c0de8ca4:	2803      	cmp	r0, #3
c0de8ca6:	d100      	bne.n	c0de8caa <starkware_plugin_call+0x12a>
c0de8ca8:	e153      	b.n	c0de8f52 <starkware_plugin_call+0x3d2>
c0de8caa:	2804      	cmp	r0, #4
c0de8cac:	d100      	bne.n	c0de8cb0 <starkware_plugin_call+0x130>
c0de8cae:	e0de      	b.n	c0de8e6e <starkware_plugin_call+0x2ee>
c0de8cb0:	2805      	cmp	r0, #5
c0de8cb2:	d100      	bne.n	c0de8cb6 <starkware_plugin_call+0x136>
c0de8cb4:	e0d2      	b.n	c0de8e5c <starkware_plugin_call+0x2dc>
c0de8cb6:	2806      	cmp	r0, #6
c0de8cb8:	d100      	bne.n	c0de8cbc <starkware_plugin_call+0x13c>
c0de8cba:	e14d      	b.n	c0de8f58 <starkware_plugin_call+0x3d8>
c0de8cbc:	2807      	cmp	r0, #7
c0de8cbe:	d100      	bne.n	c0de8cc2 <starkware_plugin_call+0x142>
c0de8cc0:	e14d      	b.n	c0de8f5e <starkware_plugin_call+0x3de>
c0de8cc2:	2808      	cmp	r0, #8
c0de8cc4:	d100      	bne.n	c0de8cc8 <starkware_plugin_call+0x148>
c0de8cc6:	e14d      	b.n	c0de8f64 <starkware_plugin_call+0x3e4>
c0de8cc8:	2809      	cmp	r0, #9
c0de8cca:	d100      	bne.n	c0de8cce <starkware_plugin_call+0x14e>
c0de8ccc:	e14d      	b.n	c0de8f6a <starkware_plugin_call+0x3ea>
c0de8cce:	280a      	cmp	r0, #10
c0de8cd0:	d100      	bne.n	c0de8cd4 <starkware_plugin_call+0x154>
c0de8cd2:	e0c9      	b.n	c0de8e68 <starkware_plugin_call+0x2e8>
c0de8cd4:	280f      	cmp	r0, #15
c0de8cd6:	d100      	bne.n	c0de8cda <starkware_plugin_call+0x15a>
c0de8cd8:	e0c6      	b.n	c0de8e68 <starkware_plugin_call+0x2e8>
c0de8cda:	280c      	cmp	r0, #12
c0de8cdc:	d100      	bne.n	c0de8ce0 <starkware_plugin_call+0x160>
c0de8cde:	e0c6      	b.n	c0de8e6e <starkware_plugin_call+0x2ee>
c0de8ce0:	280b      	cmp	r0, #11
c0de8ce2:	d000      	beq.n	c0de8ce6 <starkware_plugin_call+0x166>
c0de8ce4:	e147      	b.n	c0de8f76 <starkware_plugin_call+0x3f6>
c0de8ce6:	49f8      	ldr	r1, [pc, #992]	; (c0de90c8 <starkware_plugin_call+0x548>)
c0de8ce8:	4479      	add	r1, pc
c0de8cea:	e140      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
            switch (msg->parameterOffset) {
c0de8cec:	6921      	ldr	r1, [r4, #16]
c0de8cee:	1f09      	subs	r1, r1, #4
c0de8cf0:	2205      	movs	r2, #5
c0de8cf2:	41d1      	rors	r1, r2
c0de8cf4:	2906      	cmp	r1, #6
c0de8cf6:	d0ad      	beq.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de8cf8:	2901      	cmp	r1, #1
c0de8cfa:	d100      	bne.n	c0de8cfe <starkware_plugin_call+0x17e>
c0de8cfc:	e0c7      	b.n	c0de8e8e <starkware_plugin_call+0x30e>
c0de8cfe:	2902      	cmp	r1, #2
c0de8d00:	d100      	bne.n	c0de8d04 <starkware_plugin_call+0x184>
c0de8d02:	e0d4      	b.n	c0de8eae <starkware_plugin_call+0x32e>
c0de8d04:	2903      	cmp	r1, #3
c0de8d06:	d100      	bne.n	c0de8d0a <starkware_plugin_call+0x18a>
c0de8d08:	e0ea      	b.n	c0de8ee0 <starkware_plugin_call+0x360>
c0de8d0a:	2904      	cmp	r1, #4
c0de8d0c:	d0a2      	beq.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de8d0e:	2905      	cmp	r1, #5
c0de8d10:	d0a0      	beq.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de8d12:	2900      	cmp	r1, #0
c0de8d14:	d000      	beq.n	c0de8d18 <starkware_plugin_call+0x198>
c0de8d16:	e0fb      	b.n	c0de8f10 <starkware_plugin_call+0x390>
                    switch (context->selectorIndex) {
c0de8d18:	2813      	cmp	r0, #19
c0de8d1a:	d89b      	bhi.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de8d1c:	2101      	movs	r1, #1
c0de8d1e:	4081      	lsls	r1, r0
c0de8d20:	4af2      	ldr	r2, [pc, #968]	; (c0de90ec <starkware_plugin_call+0x56c>)
c0de8d22:	4211      	tst	r1, r2
c0de8d24:	d100      	bne.n	c0de8d28 <starkware_plugin_call+0x1a8>
c0de8d26:	e1c3      	b.n	c0de90b0 <starkware_plugin_call+0x530>
c0de8d28:	68e1      	ldr	r1, [r4, #12]
c0de8d2a:	1d68      	adds	r0, r5, #5
c0de8d2c:	2220      	movs	r2, #32
c0de8d2e:	e1c7      	b.n	c0de90c0 <starkware_plugin_call+0x540>
                    context->selectorIndex = i;
c0de8d30:	712e      	strb	r6, [r5, #4]
c0de8d32:	48ef      	ldr	r0, [pc, #956]	; (c0de90f0 <starkware_plugin_call+0x570>)
            if (STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex] != 0) {
c0de8d34:	40f0      	lsrs	r0, r6
c0de8d36:	07c0      	lsls	r0, r0, #31
c0de8d38:	d005      	beq.n	c0de8d46 <starkware_plugin_call+0x1c6>
c0de8d3a:	48ee      	ldr	r0, [pc, #952]	; (c0de90f4 <starkware_plugin_call+0x574>)
c0de8d3c:	4478      	add	r0, pc
c0de8d3e:	5d80      	ldrb	r0, [r0, r6]
                if (msg->dataSize != STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex]) {
c0de8d40:	69a1      	ldr	r1, [r4, #24]
c0de8d42:	4281      	cmp	r1, r0
c0de8d44:	d104      	bne.n	c0de8d50 <starkware_plugin_call+0x1d0>
c0de8d46:	2045      	movs	r0, #69	; 0x45
c0de8d48:	2101      	movs	r1, #1
            context->validToken = true;
c0de8d4a:	5429      	strb	r1, [r5, r0]
c0de8d4c:	2004      	movs	r0, #4
            msg->result = ETH_PLUGIN_RESULT_OK;
c0de8d4e:	7060      	strb	r0, [r4, #1]
c0de8d50:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de8d52:	2006      	movs	r0, #6
                msg->result = ETH_PLUGIN_RESULT_FALLBACK;
c0de8d54:	77a0      	strb	r0, [r4, #30]
c0de8d56:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                    }
                    msg->result = ETH_PLUGIN_RESULT_OK;
                    break;

                case 4:
                    switch (context->selectorIndex) {
c0de8d58:	7929      	ldrb	r1, [r5, #4]
c0de8d5a:	2911      	cmp	r1, #17
c0de8d5c:	d900      	bls.n	c0de8d60 <starkware_plugin_call+0x1e0>
c0de8d5e:	e176      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de8d60:	2001      	movs	r0, #1
c0de8d62:	4088      	lsls	r0, r1
c0de8d64:	211b      	movs	r1, #27
c0de8d66:	02c9      	lsls	r1, r1, #11
c0de8d68:	4208      	tst	r0, r1
c0de8d6a:	d100      	bne.n	c0de8d6e <starkware_plugin_call+0x1ee>
c0de8d6c:	e0da      	b.n	c0de8f24 <starkware_plugin_call+0x3a4>
                        case STARKWARE_WITHDRAW_NFT:
                        case STARKWARE_WITHDRAW_NFT_TO:
                        case STARKWARE_DEPOSIT_NFT:
                        case STARKWARE_DEPOSIT_NFT_RECLAIM:
                            strlcpy(msg->title, "TokenID", msg->titleLength);
c0de8d6e:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8d70:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8d72:	49f8      	ldr	r1, [pc, #992]	; (c0de9154 <starkware_plugin_call+0x5d4>)
c0de8d74:	4479      	add	r1, pc
c0de8d76:	f004 ff2d 	bl	c0dedbd4 <strlcpy>
                            starkware_print_stark_key(dataContext.tokenContext.quantum,
c0de8d7a:	48d4      	ldr	r0, [pc, #848]	; (c0de90cc <starkware_plugin_call+0x54c>)
c0de8d7c:	4649      	mov	r1, r9
c0de8d7e:	1808      	adds	r0, r1, r0
c0de8d80:	30e4      	adds	r0, #228	; 0xe4
                                                      sizeof(dataContext.tokenContext.quantum),
                                                      msg->msg,
c0de8d82:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
                                                      msg->msgLength);
c0de8d84:	6b23      	ldr	r3, [r4, #48]	; 0x30
c0de8d86:	e012      	b.n	c0de8dae <starkware_plugin_call+0x22e>
                    switch (context->selectorIndex) {
c0de8d88:	7929      	ldrb	r1, [r5, #4]
c0de8d8a:	2913      	cmp	r1, #19
c0de8d8c:	d900      	bls.n	c0de8d90 <starkware_plugin_call+0x210>
c0de8d8e:	e15e      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de8d90:	2001      	movs	r0, #1
c0de8d92:	4088      	lsls	r0, r1
c0de8d94:	49d0      	ldr	r1, [pc, #832]	; (c0de90d8 <starkware_plugin_call+0x558>)
c0de8d96:	4208      	tst	r0, r1
c0de8d98:	d100      	bne.n	c0de8d9c <starkware_plugin_call+0x21c>
c0de8d9a:	e122      	b.n	c0de8fe2 <starkware_plugin_call+0x462>
c0de8d9c:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8d9e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8da0:	49e3      	ldr	r1, [pc, #908]	; (c0de9130 <starkware_plugin_call+0x5b0>)
c0de8da2:	4479      	add	r1, pc
c0de8da4:	f004 ff16 	bl	c0dedbd4 <strlcpy>
c0de8da8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
c0de8daa:	6b23      	ldr	r3, [r4, #48]	; 0x30
c0de8dac:	1d68      	adds	r0, r5, #5
c0de8dae:	2120      	movs	r1, #32
c0de8db0:	f7ff fdcc 	bl	c0de894c <starkware_print_stark_key>
c0de8db4:	e14b      	b.n	c0de904e <starkware_plugin_call+0x4ce>
                    switch (context->selectorIndex) {
c0de8db6:	7928      	ldrb	r0, [r5, #4]
c0de8db8:	1e41      	subs	r1, r0, #1
c0de8dba:	2904      	cmp	r1, #4
c0de8dbc:	d340      	bcc.n	c0de8e40 <starkware_plugin_call+0x2c0>
c0de8dbe:	1f81      	subs	r1, r0, #6
c0de8dc0:	2902      	cmp	r1, #2
c0de8dc2:	d33d      	bcc.n	c0de8e40 <starkware_plugin_call+0x2c0>
c0de8dc4:	4601      	mov	r1, r0
c0de8dc6:	390b      	subs	r1, #11
c0de8dc8:	2902      	cmp	r1, #2
c0de8dca:	d339      	bcc.n	c0de8e40 <starkware_plugin_call+0x2c0>
c0de8dcc:	4601      	mov	r1, r0
c0de8dce:	3910      	subs	r1, #16
c0de8dd0:	2902      	cmp	r1, #2
c0de8dd2:	d3e3      	bcc.n	c0de8d9c <starkware_plugin_call+0x21c>
c0de8dd4:	4601      	mov	r1, r0
c0de8dd6:	3912      	subs	r1, #18
c0de8dd8:	2902      	cmp	r1, #2
c0de8dda:	d331      	bcc.n	c0de8e40 <starkware_plugin_call+0x2c0>
c0de8ddc:	2800      	cmp	r0, #0
c0de8dde:	d0dd      	beq.n	c0de8d9c <starkware_plugin_call+0x21c>
c0de8de0:	2805      	cmp	r0, #5
c0de8de2:	d100      	bne.n	c0de8de6 <starkware_plugin_call+0x266>
c0de8de4:	e136      	b.n	c0de9054 <starkware_plugin_call+0x4d4>
c0de8de6:	280f      	cmp	r0, #15
c0de8de8:	d100      	bne.n	c0de8dec <starkware_plugin_call+0x26c>
c0de8dea:	e11b      	b.n	c0de9024 <starkware_plugin_call+0x4a4>
c0de8dec:	280a      	cmp	r0, #10
c0de8dee:	d100      	bne.n	c0de8df2 <starkware_plugin_call+0x272>
c0de8df0:	e118      	b.n	c0de9024 <starkware_plugin_call+0x4a4>
c0de8df2:	280d      	cmp	r0, #13
c0de8df4:	d100      	bne.n	c0de8df8 <starkware_plugin_call+0x278>
c0de8df6:	e146      	b.n	c0de9086 <starkware_plugin_call+0x506>
c0de8df8:	280e      	cmp	r0, #14
c0de8dfa:	d100      	bne.n	c0de8dfe <starkware_plugin_call+0x27e>
c0de8dfc:	e12a      	b.n	c0de9054 <starkware_plugin_call+0x4d4>
c0de8dfe:	2808      	cmp	r0, #8
c0de8e00:	d0cc      	beq.n	c0de8d9c <starkware_plugin_call+0x21c>
c0de8e02:	e124      	b.n	c0de904e <starkware_plugin_call+0x4ce>
                    switch (context->selectorIndex) {
c0de8e04:	7928      	ldrb	r0, [r5, #4]
c0de8e06:	2813      	cmp	r0, #19
c0de8e08:	d80d      	bhi.n	c0de8e26 <starkware_plugin_call+0x2a6>
c0de8e0a:	2101      	movs	r1, #1
c0de8e0c:	4081      	lsls	r1, r0
c0de8e0e:	221b      	movs	r2, #27
c0de8e10:	02d2      	lsls	r2, r2, #11
c0de8e12:	4211      	tst	r1, r2
c0de8e14:	d000      	beq.n	c0de8e18 <starkware_plugin_call+0x298>
c0de8e16:	e0c5      	b.n	c0de8fa4 <starkware_plugin_call+0x424>
c0de8e18:	038a      	lsls	r2, r1, #14
c0de8e1a:	0f92      	lsrs	r2, r2, #30
c0de8e1c:	d110      	bne.n	c0de8e40 <starkware_plugin_call+0x2c0>
c0de8e1e:	0309      	lsls	r1, r1, #12
c0de8e20:	0f89      	lsrs	r1, r1, #30
c0de8e22:	d000      	beq.n	c0de8e26 <starkware_plugin_call+0x2a6>
c0de8e24:	e0c9      	b.n	c0de8fba <starkware_plugin_call+0x43a>
c0de8e26:	1e41      	subs	r1, r0, #1
c0de8e28:	2902      	cmp	r1, #2
c0de8e2a:	d200      	bcs.n	c0de8e2e <starkware_plugin_call+0x2ae>
c0de8e2c:	e0c5      	b.n	c0de8fba <starkware_plugin_call+0x43a>
c0de8e2e:	2805      	cmp	r0, #5
c0de8e30:	d100      	bne.n	c0de8e34 <starkware_plugin_call+0x2b4>
c0de8e32:	e0de      	b.n	c0de8ff2 <starkware_plugin_call+0x472>
c0de8e34:	280a      	cmp	r0, #10
c0de8e36:	d100      	bne.n	c0de8e3a <starkware_plugin_call+0x2ba>
c0de8e38:	e0db      	b.n	c0de8ff2 <starkware_plugin_call+0x472>
c0de8e3a:	2808      	cmp	r0, #8
c0de8e3c:	d000      	beq.n	c0de8e40 <starkware_plugin_call+0x2c0>
c0de8e3e:	e106      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de8e40:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8e42:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8e44:	49be      	ldr	r1, [pc, #760]	; (c0de9140 <starkware_plugin_call+0x5c0>)
c0de8e46:	4479      	add	r1, pc
c0de8e48:	f004 fec4 	bl	c0dedbd4 <strlcpy>
c0de8e4c:	4628      	mov	r0, r5
c0de8e4e:	f000 f983 	bl	c0de9158 <U4BE>
c0de8e52:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de8e54:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de8e56:	f7ff fd67 	bl	c0de8928 <starkware_print_vault_id>
c0de8e5a:	e0f8      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de8e5c:	49a9      	ldr	r1, [pc, #676]	; (c0de9104 <starkware_plugin_call+0x584>)
c0de8e5e:	4479      	add	r1, pc
c0de8e60:	e085      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8e62:	49ae      	ldr	r1, [pc, #696]	; (c0de911c <starkware_plugin_call+0x59c>)
c0de8e64:	4479      	add	r1, pc
c0de8e66:	e082      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8e68:	49ab      	ldr	r1, [pc, #684]	; (c0de9118 <starkware_plugin_call+0x598>)
c0de8e6a:	4479      	add	r1, pc
c0de8e6c:	e07f      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8e6e:	49a4      	ldr	r1, [pc, #656]	; (c0de9100 <starkware_plugin_call+0x580>)
c0de8e70:	4479      	add	r1, pc
c0de8e72:	e07c      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
                                                 chainConfig->chainId);
c0de8e74:	4896      	ldr	r0, [pc, #600]	; (c0de90d0 <starkware_plugin_call+0x550>)
c0de8e76:	4649      	mov	r1, r9
c0de8e78:	5808      	ldr	r0, [r1, r0]
c0de8e7a:	6903      	ldr	r3, [r0, #16]
c0de8e7c:	6940      	ldr	r0, [r0, #20]
                        getEthDisplayableAddress(tmpContent.txContent.destination,
c0de8e7e:	9300      	str	r3, [sp, #0]
c0de8e80:	9001      	str	r0, [sp, #4]
c0de8e82:	4894      	ldr	r0, [pc, #592]	; (c0de90d4 <starkware_plugin_call+0x554>)
c0de8e84:	180b      	adds	r3, r1, r0
c0de8e86:	19c8      	adds	r0, r1, r7
c0de8e88:	30a5      	adds	r0, #165	; 0xa5
c0de8e8a:	4629      	mov	r1, r5
c0de8e8c:	e0dd      	b.n	c0de904a <starkware_plugin_call+0x4ca>
                    switch (context->selectorIndex) {
c0de8e8e:	2813      	cmp	r0, #19
c0de8e90:	d900      	bls.n	c0de8e94 <starkware_plugin_call+0x314>
c0de8e92:	e109      	b.n	c0de90a8 <starkware_plugin_call+0x528>
c0de8e94:	2101      	movs	r1, #1
c0de8e96:	4081      	lsls	r1, r0
c0de8e98:	4a93      	ldr	r2, [pc, #588]	; (c0de90e8 <starkware_plugin_call+0x568>)
c0de8e9a:	4211      	tst	r1, r2
c0de8e9c:	d100      	bne.n	c0de8ea0 <starkware_plugin_call+0x320>
c0de8e9e:	e0e3      	b.n	c0de9068 <starkware_plugin_call+0x4e8>
c0de8ea0:	68e1      	ldr	r1, [r4, #12]
c0de8ea2:	4628      	mov	r0, r5
c0de8ea4:	3025      	adds	r0, #37	; 0x25
c0de8ea6:	2201      	movs	r2, #1
c0de8ea8:	f7ff fcda 	bl	c0de8860 <starkware_verify_asset_id>
c0de8eac:	e0af      	b.n	c0de900e <starkware_plugin_call+0x48e>
                    switch (context->selectorIndex) {
c0de8eae:	2813      	cmp	r0, #19
c0de8eb0:	d80c      	bhi.n	c0de8ecc <starkware_plugin_call+0x34c>
c0de8eb2:	2101      	movs	r1, #1
c0de8eb4:	4081      	lsls	r1, r0
c0de8eb6:	4a8b      	ldr	r2, [pc, #556]	; (c0de90e4 <starkware_plugin_call+0x564>)
c0de8eb8:	4211      	tst	r1, r2
c0de8eba:	d000      	beq.n	c0de8ebe <starkware_plugin_call+0x33e>
c0de8ebc:	e0d9      	b.n	c0de9072 <starkware_plugin_call+0x4f2>
c0de8ebe:	040a      	lsls	r2, r1, #16
c0de8ec0:	0f92      	lsrs	r2, r2, #30
c0de8ec2:	d000      	beq.n	c0de8ec6 <starkware_plugin_call+0x346>
c0de8ec4:	e0a0      	b.n	c0de9008 <starkware_plugin_call+0x488>
c0de8ec6:	0389      	lsls	r1, r1, #14
c0de8ec8:	0f89      	lsrs	r1, r1, #30
c0de8eca:	d1e9      	bne.n	c0de8ea0 <starkware_plugin_call+0x320>
c0de8ecc:	1e41      	subs	r1, r0, #1
c0de8ece:	2904      	cmp	r1, #4
c0de8ed0:	d200      	bcs.n	c0de8ed4 <starkware_plugin_call+0x354>
c0de8ed2:	e0ce      	b.n	c0de9072 <starkware_plugin_call+0x4f2>
c0de8ed4:	280a      	cmp	r0, #10
c0de8ed6:	d100      	bne.n	c0de8eda <starkware_plugin_call+0x35a>
c0de8ed8:	e0ed      	b.n	c0de90b6 <starkware_plugin_call+0x536>
c0de8eda:	2808      	cmp	r0, #8
c0de8edc:	d0e0      	beq.n	c0de8ea0 <starkware_plugin_call+0x320>
c0de8ede:	e6b9      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
                    switch (context->selectorIndex) {
c0de8ee0:	4601      	mov	r1, r0
c0de8ee2:	390b      	subs	r1, #11
c0de8ee4:	2902      	cmp	r1, #2
c0de8ee6:	d200      	bcs.n	c0de8eea <starkware_plugin_call+0x36a>
c0de8ee8:	e08e      	b.n	c0de9008 <starkware_plugin_call+0x488>
c0de8eea:	4601      	mov	r1, r0
c0de8eec:	3910      	subs	r1, #16
c0de8eee:	2902      	cmp	r1, #2
c0de8ef0:	d200      	bcs.n	c0de8ef4 <starkware_plugin_call+0x374>
c0de8ef2:	e0be      	b.n	c0de9072 <starkware_plugin_call+0x4f2>
c0de8ef4:	2801      	cmp	r0, #1
c0de8ef6:	d007      	beq.n	c0de8f08 <starkware_plugin_call+0x388>
c0de8ef8:	2812      	cmp	r0, #18
c0de8efa:	d005      	beq.n	c0de8f08 <starkware_plugin_call+0x388>
c0de8efc:	280f      	cmp	r0, #15
c0de8efe:	d100      	bne.n	c0de8f02 <starkware_plugin_call+0x382>
c0de8f00:	e0d9      	b.n	c0de90b6 <starkware_plugin_call+0x536>
c0de8f02:	2808      	cmp	r0, #8
c0de8f04:	d000      	beq.n	c0de8f08 <starkware_plugin_call+0x388>
c0de8f06:	e6a5      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
                            memmove(context->amount, msg->parameter, 32);
c0de8f08:	68e1      	ldr	r1, [r4, #12]
c0de8f0a:	3525      	adds	r5, #37	; 0x25
c0de8f0c:	2220      	movs	r2, #32
c0de8f0e:	e0d6      	b.n	c0de90be <starkware_plugin_call+0x53e>
                    switch (context->selectorIndex) {
c0de8f10:	2811      	cmp	r0, #17
c0de8f12:	d900      	bls.n	c0de8f16 <starkware_plugin_call+0x396>
c0de8f14:	e71c      	b.n	c0de8d50 <starkware_plugin_call+0x1d0>
c0de8f16:	2101      	movs	r1, #1
c0de8f18:	4081      	lsls	r1, r0
c0de8f1a:	4870      	ldr	r0, [pc, #448]	; (c0de90dc <starkware_plugin_call+0x55c>)
c0de8f1c:	4201      	tst	r1, r0
c0de8f1e:	d000      	beq.n	c0de8f22 <starkware_plugin_call+0x3a2>
c0de8f20:	e698      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de8f22:	e715      	b.n	c0de8d50 <starkware_plugin_call+0x1d0>
c0de8f24:	0380      	lsls	r0, r0, #14
c0de8f26:	0f80      	lsrs	r0, r0, #30
c0de8f28:	d100      	bne.n	c0de8f2c <starkware_plugin_call+0x3ac>
c0de8f2a:	e090      	b.n	c0de904e <starkware_plugin_call+0x4ce>
                            break;

                        case STARKWARE_REGISTER_AND_DEPOSIT_TOKEN:
                        case STARKWARE_REGISTER_AND_DEPOSIT_ETH:
                            strlcpy(msg->title, "Amount", msg->titleLength);
c0de8f2c:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8f2e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8f30:	4987      	ldr	r1, [pc, #540]	; (c0de9150 <starkware_plugin_call+0x5d0>)
c0de8f32:	4479      	add	r1, pc
c0de8f34:	f004 fe4e 	bl	c0dedbd4 <strlcpy>
                            starkware_print_amount(
                                ((context->selectorIndex == STARKWARE_REGISTER_AND_DEPOSIT_ETH)
c0de8f38:	7928      	ldrb	r0, [r5, #4]
c0de8f3a:	2300      	movs	r3, #0
c0de8f3c:	2811      	cmp	r0, #17
c0de8f3e:	4618      	mov	r0, r3
c0de8f40:	d001      	beq.n	c0de8f46 <starkware_plugin_call+0x3c6>
c0de8f42:	3525      	adds	r5, #37	; 0x25
c0de8f44:	4628      	mov	r0, r5
                                     ? NULL
                                     : context->amount),
                                msg->msg,
c0de8f46:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
                                msg->msgLength,
c0de8f48:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de8f4a:	e047      	b.n	c0de8fdc <starkware_plugin_call+0x45c>
c0de8f4c:	496a      	ldr	r1, [pc, #424]	; (c0de90f8 <starkware_plugin_call+0x578>)
c0de8f4e:	4479      	add	r1, pc
c0de8f50:	e00d      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8f52:	496a      	ldr	r1, [pc, #424]	; (c0de90fc <starkware_plugin_call+0x57c>)
c0de8f54:	4479      	add	r1, pc
c0de8f56:	e00a      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8f58:	496b      	ldr	r1, [pc, #428]	; (c0de9108 <starkware_plugin_call+0x588>)
c0de8f5a:	4479      	add	r1, pc
c0de8f5c:	e007      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8f5e:	496b      	ldr	r1, [pc, #428]	; (c0de910c <starkware_plugin_call+0x58c>)
c0de8f60:	4479      	add	r1, pc
c0de8f62:	e004      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8f64:	496a      	ldr	r1, [pc, #424]	; (c0de9110 <starkware_plugin_call+0x590>)
c0de8f66:	4479      	add	r1, pc
c0de8f68:	e001      	b.n	c0de8f6e <starkware_plugin_call+0x3ee>
c0de8f6a:	496a      	ldr	r1, [pc, #424]	; (c0de9114 <starkware_plugin_call+0x594>)
c0de8f6c:	4479      	add	r1, pc
c0de8f6e:	68e0      	ldr	r0, [r4, #12]
c0de8f70:	6922      	ldr	r2, [r4, #16]
c0de8f72:	f004 fe2f 	bl	c0dedbd4 <strlcpy>
                is_deversify_contract(tmpContent.txContent.destination) ? "DeversiFi" : "Starkware",
c0de8f76:	485a      	ldr	r0, [pc, #360]	; (c0de90e0 <starkware_plugin_call+0x560>)
c0de8f78:	4649      	mov	r1, r9
c0de8f7a:	1808      	adds	r0, r1, r0
c0de8f7c:	30a5      	adds	r0, #165	; 0xa5
                msg->version,
c0de8f7e:	6965      	ldr	r5, [r4, #20]
                is_deversify_contract(tmpContent.txContent.destination) ? "DeversiFi" : "Starkware",
c0de8f80:	f7ff fc56 	bl	c0de8830 <is_deversify_contract>
c0de8f84:	2800      	cmp	r0, #0
c0de8f86:	d102      	bne.n	c0de8f8e <starkware_plugin_call+0x40e>
c0de8f88:	4966      	ldr	r1, [pc, #408]	; (c0de9124 <starkware_plugin_call+0x5a4>)
c0de8f8a:	4479      	add	r1, pc
c0de8f8c:	e001      	b.n	c0de8f92 <starkware_plugin_call+0x412>
c0de8f8e:	4964      	ldr	r1, [pc, #400]	; (c0de9120 <starkware_plugin_call+0x5a0>)
c0de8f90:	4479      	add	r1, pc
                msg->versionLength);
c0de8f92:	69a2      	ldr	r2, [r4, #24]
            strlcpy(
c0de8f94:	4628      	mov	r0, r5
c0de8f96:	f004 fe1d 	bl	c0dedbd4 <strlcpy>
c0de8f9a:	2004      	movs	r0, #4
            msg->result = ETH_PLUGIN_RESULT_OK;
c0de8f9c:	7720      	strb	r0, [r4, #28]
c0de8f9e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de8fa0:	00006ed0 	.word	0x00006ed0
                            strlcpy(msg->title, "NFT Contract", msg->titleLength);
c0de8fa4:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8fa6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8fa8:	4968      	ldr	r1, [pc, #416]	; (c0de914c <starkware_plugin_call+0x5cc>)
c0de8faa:	4479      	add	r1, pc
c0de8fac:	f004 fe12 	bl	c0dedbd4 <strlcpy>
c0de8fb0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de8fb2:	6b21      	ldr	r1, [r4, #48]	; 0x30
c0de8fb4:	f7ff fd6c 	bl	c0de8a90 <starkware_print_asset_contract>
c0de8fb8:	e049      	b.n	c0de904e <starkware_plugin_call+0x4ce>
                            strlcpy(msg->title, "Amount", msg->titleLength);
c0de8fba:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8fbc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8fbe:	4961      	ldr	r1, [pc, #388]	; (c0de9144 <starkware_plugin_call+0x5c4>)
c0de8fc0:	4479      	add	r1, pc
c0de8fc2:	f004 fe07 	bl	c0dedbd4 <strlcpy>
                                (((context->selectorIndex == STARKWARE_DEPOSIT_ETH) ||
c0de8fc6:	7929      	ldrb	r1, [r5, #4]
c0de8fc8:	2000      	movs	r0, #0
c0de8fca:	2902      	cmp	r1, #2
c0de8fcc:	d003      	beq.n	c0de8fd6 <starkware_plugin_call+0x456>
c0de8fce:	2913      	cmp	r1, #19
c0de8fd0:	d001      	beq.n	c0de8fd6 <starkware_plugin_call+0x456>
                                     : context->amount),
c0de8fd2:	3525      	adds	r5, #37	; 0x25
                                (((context->selectorIndex == STARKWARE_DEPOSIT_ETH) ||
c0de8fd4:	4628      	mov	r0, r5
                                msg->msg,
c0de8fd6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
                                msg->msgLength,
c0de8fd8:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de8fda:	2300      	movs	r3, #0
c0de8fdc:	f7ff fccc 	bl	c0de8978 <starkware_print_amount>
c0de8fe0:	e035      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de8fe2:	493e      	ldr	r1, [pc, #248]	; (c0de90dc <starkware_plugin_call+0x55c>)
c0de8fe4:	4208      	tst	r0, r1
c0de8fe6:	d053      	beq.n	c0de9090 <starkware_plugin_call+0x510>
                            strlcpy(msg->title, "From ETH Address", msg->titleLength);
c0de8fe8:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8fea:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8fec:	494e      	ldr	r1, [pc, #312]	; (c0de9128 <starkware_plugin_call+0x5a8>)
c0de8fee:	4479      	add	r1, pc
c0de8ff0:	e01c      	b.n	c0de902c <starkware_plugin_call+0x4ac>
                            strlcpy(msg->title, "Token Symbol", msg->titleLength);
c0de8ff2:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de8ff4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de8ff6:	4954      	ldr	r1, [pc, #336]	; (c0de9148 <starkware_plugin_call+0x5c8>)
c0de8ff8:	4479      	add	r1, pc
c0de8ffa:	f004 fdeb 	bl	c0dedbd4 <strlcpy>
                            starkware_print_ticker(msg->msg, msg->msgLength);
c0de8ffe:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de9000:	6b21      	ldr	r1, [r4, #48]	; 0x30
c0de9002:	f7ff fd29 	bl	c0de8a58 <starkware_print_ticker>
c0de9006:	e022      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de9008:	68e0      	ldr	r0, [r4, #12]
c0de900a:	f7ff fc6d 	bl	c0de88e8 <starkware_verify_nft_token_id>
c0de900e:	2145      	movs	r1, #69	; 0x45
c0de9010:	5468      	strb	r0, [r5, r1]
c0de9012:	e61f      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de9014:	000053a0 	.word	0x000053a0
c0de9018:	0000026c 	.word	0x0000026c
c0de901c:	000055c0 	.word	0x000055c0
c0de9020:	000072e4 	.word	0x000072e4
                            strlcpy(msg->title, "To ETH Address", msg->titleLength);
c0de9024:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de9026:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de9028:	4943      	ldr	r1, [pc, #268]	; (c0de9138 <starkware_plugin_call+0x5b8>)
c0de902a:	4479      	add	r1, pc
c0de902c:	f004 fdd2 	bl	c0dedbd4 <strlcpy>
c0de9030:	4827      	ldr	r0, [pc, #156]	; (c0de90d0 <starkware_plugin_call+0x550>)
c0de9032:	464b      	mov	r3, r9
c0de9034:	5818      	ldr	r0, [r3, r0]
c0de9036:	6907      	ldr	r7, [r0, #16]
c0de9038:	6940      	ldr	r0, [r0, #20]
c0de903a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de903c:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de903e:	9700      	str	r7, [sp, #0]
c0de9040:	9001      	str	r0, [sp, #4]
c0de9042:	4824      	ldr	r0, [pc, #144]	; (c0de90d4 <starkware_plugin_call+0x554>)
c0de9044:	181b      	adds	r3, r3, r0
c0de9046:	3525      	adds	r5, #37	; 0x25
c0de9048:	4628      	mov	r0, r5
c0de904a:	f7fb fbf7 	bl	c0de483c <getEthDisplayableAddress>
c0de904e:	2004      	movs	r0, #4
c0de9050:	7530      	strb	r0, [r6, #20]
c0de9052:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                            strlcpy(msg->title, "To ETH Address", msg->titleLength);
c0de9054:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de9056:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de9058:	4936      	ldr	r1, [pc, #216]	; (c0de9134 <starkware_plugin_call+0x5b4>)
c0de905a:	4479      	add	r1, pc
c0de905c:	f004 fdba 	bl	c0dedbd4 <strlcpy>
                            starkware_get_source_address(msg->msg);
c0de9060:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0de9062:	f7ff fd43 	bl	c0de8aec <starkware_get_source_address>
c0de9066:	e7f2      	b.n	c0de904e <starkware_plugin_call+0x4ce>
c0de9068:	0609      	lsls	r1, r1, #24
c0de906a:	0f89      	lsrs	r1, r1, #30
c0de906c:	d101      	bne.n	c0de9072 <starkware_plugin_call+0x4f2>
c0de906e:	2808      	cmp	r0, #8
c0de9070:	d11a      	bne.n	c0de90a8 <starkware_plugin_call+0x528>
c0de9072:	68e0      	ldr	r0, [r4, #12]
c0de9074:	7f41      	ldrb	r1, [r0, #29]
c0de9076:	7f02      	ldrb	r2, [r0, #28]
c0de9078:	7fc3      	ldrb	r3, [r0, #31]
c0de907a:	7f80      	ldrb	r0, [r0, #30]
c0de907c:	70a8      	strb	r0, [r5, #2]
c0de907e:	70eb      	strb	r3, [r5, #3]
c0de9080:	702a      	strb	r2, [r5, #0]
c0de9082:	7069      	strb	r1, [r5, #1]
c0de9084:	e5e6      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
                            strlcpy(msg->title, "Asset Contract", msg->titleLength);
c0de9086:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de9088:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de908a:	492c      	ldr	r1, [pc, #176]	; (c0de913c <starkware_plugin_call+0x5bc>)
c0de908c:	4479      	add	r1, pc
c0de908e:	e78d      	b.n	c0de8fac <starkware_plugin_call+0x42c>
                            strlcpy(msg->title, "Amount", msg->titleLength);
c0de9090:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0de9092:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0de9094:	4925      	ldr	r1, [pc, #148]	; (c0de912c <starkware_plugin_call+0x5ac>)
c0de9096:	4479      	add	r1, pc
c0de9098:	f004 fd9c 	bl	c0dedbd4 <strlcpy>
                            starkware_print_amount(context->amount, msg->msg, msg->msgLength, true);
c0de909c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
c0de909e:	6b22      	ldr	r2, [r4, #48]	; 0x30
c0de90a0:	3525      	adds	r5, #37	; 0x25
c0de90a2:	2301      	movs	r3, #1
c0de90a4:	4628      	mov	r0, r5
c0de90a6:	e799      	b.n	c0de8fdc <starkware_plugin_call+0x45c>
                    switch (context->selectorIndex) {
c0de90a8:	2800      	cmp	r0, #0
c0de90aa:	d000      	beq.n	c0de90ae <starkware_plugin_call+0x52e>
c0de90ac:	e5d2      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de90ae:	e63b      	b.n	c0de8d28 <starkware_plugin_call+0x1a8>
c0de90b0:	2800      	cmp	r0, #0
c0de90b2:	d000      	beq.n	c0de90b6 <starkware_plugin_call+0x536>
c0de90b4:	e5ce      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de90b6:	68e1      	ldr	r1, [r4, #12]
c0de90b8:	3525      	adds	r5, #37	; 0x25
c0de90ba:	310c      	adds	r1, #12
c0de90bc:	2214      	movs	r2, #20
c0de90be:	4628      	mov	r0, r5
c0de90c0:	f004 fbb2 	bl	c0ded828 <__aeabi_memmove>
c0de90c4:	e5c6      	b.n	c0de8c54 <starkware_plugin_call+0xd4>
c0de90c6:	46c0      	nop			; (mov r8, r8)
c0de90c8:	00005579 	.word	0x00005579
c0de90cc:	00000594 	.word	0x00000594
c0de90d0:	00000590 	.word	0x00000590
c0de90d4:	000007e8 	.word	0x000007e8
c0de90d8:	000cfefe 	.word	0x000cfefe
c0de90dc:	00030001 	.word	0x00030001
c0de90e0:	0000026c 	.word	0x0000026c
c0de90e4:	000c1800 	.word	0x000c1800
c0de90e8:	000cfc26 	.word	0x000cfc26
c0de90ec:	000ffdfe 	.word	0x000ffdfe
c0de90f0:	000cddfe 	.word	0x000cddfe
c0de90f4:	00007204 	.word	0x00007204
c0de90f8:	00005176 	.word	0x00005176
c0de90fc:	0000532d 	.word	0x0000532d
c0de9100:	00004fde 	.word	0x00004fde
c0de9104:	00005313 	.word	0x00005313
c0de9108:	000050a0 	.word	0x000050a0
c0de910c:	000050eb 	.word	0x000050eb
c0de9110:	00005018 	.word	0x00005018
c0de9114:	00005113 	.word	0x00005113
c0de9118:	000052b3 	.word	0x000052b3
c0de911c:	0000542c 	.word	0x0000542c
c0de9120:	00005272 	.word	0x00005272
c0de9124:	00005143 	.word	0x00005143
c0de9128:	0000509f 	.word	0x0000509f
c0de912c:	00004de3 	.word	0x00004de3
c0de9130:	00004fe2 	.word	0x00004fe2
c0de9134:	00004e04 	.word	0x00004e04
c0de9138:	00004e34 	.word	0x00004e34
c0de913c:	00004f46 	.word	0x00004f46
c0de9140:	000050c0 	.word	0x000050c0
c0de9144:	00004eb9 	.word	0x00004eb9
c0de9148:	000051d8 	.word	0x000051d8
c0de914c:	00004e2b 	.word	0x00004e2b
c0de9150:	00004f47 	.word	0x00004f47
c0de9154:	00005211 	.word	0x00005211

c0de9158 <U4BE>:
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de9158:	7801      	ldrb	r1, [r0, #0]
c0de915a:	0609      	lsls	r1, r1, #24
c0de915c:	7842      	ldrb	r2, [r0, #1]
c0de915e:	0412      	lsls	r2, r2, #16
c0de9160:	1851      	adds	r1, r2, r1
         (buf[off + 2] << 8) | buf[off + 3];
c0de9162:	7882      	ldrb	r2, [r0, #2]
c0de9164:	0212      	lsls	r2, r2, #8
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de9166:	1889      	adds	r1, r1, r2
         (buf[off + 2] << 8) | buf[off + 3];
c0de9168:	78c0      	ldrb	r0, [r0, #3]
c0de916a:	1808      	adds	r0, r1, r0
  return (((uint32_t)buf[off]) << 24) | (buf[off + 1] << 16) |
c0de916c:	4770      	bx	lr

c0de916e <SVC_Call>:
.thumb
.thumb_func
.global SVC_Call

SVC_Call:
    svc 1
c0de916e:	df01      	svc	1
    cmp r1, #0
c0de9170:	2900      	cmp	r1, #0
    bne exception
c0de9172:	d100      	bne.n	c0de9176 <exception>
    bx lr
c0de9174:	4770      	bx	lr

c0de9176 <exception>:
exception:
    // THROW(ex);
    mov r0, r1
c0de9176:	4608      	mov	r0, r1
    bl os_longjmp
c0de9178:	f7fe f955 	bl	c0de7426 <os_longjmp>

c0de917c <SVC_cx_call>:
.thumb
.thumb_func
.global SVC_cx_call

SVC_cx_call:
    svc 1
c0de917c:	df01      	svc	1
    bx lr
c0de917e:	4770      	bx	lr

c0de9180 <get_api_level>:
#include <string.h>

unsigned int SVC_Call(unsigned int syscall_id, void *parameters);
unsigned int SVC_cx_call(unsigned int syscall_id, unsigned int * parameters);

unsigned int get_api_level(void) {
c0de9180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de9182:	2000      	movs	r0, #0
  unsigned int parameters [2+1];
  parameters[0] = 0;
  parameters[1] = 0;
c0de9184:	9002      	str	r0, [sp, #8]
  parameters[0] = 0;
c0de9186:	9001      	str	r0, [sp, #4]
c0de9188:	4802      	ldr	r0, [pc, #8]	; (c0de9194 <get_api_level+0x14>)
c0de918a:	a901      	add	r1, sp, #4
  return SVC_Call(SYSCALL_get_api_level_ID_IN, parameters);
c0de918c:	f7ff ffef 	bl	c0de916e <SVC_Call>
c0de9190:	b004      	add	sp, #16
c0de9192:	bd80      	pop	{r7, pc}
c0de9194:	60000138 	.word	0x60000138

c0de9198 <halt>:
}

void halt ( void ) {
c0de9198:	b5e0      	push	{r5, r6, r7, lr}
c0de919a:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de919c:	9001      	str	r0, [sp, #4]
c0de919e:	4802      	ldr	r0, [pc, #8]	; (c0de91a8 <halt+0x10>)
c0de91a0:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_halt_ID_IN, parameters);
c0de91a2:	f7ff ffe4 	bl	c0de916e <SVC_Call>
  return;
}
c0de91a6:	bd8c      	pop	{r2, r3, r7, pc}
c0de91a8:	6000023c 	.word	0x6000023c

c0de91ac <nvm_write>:

void nvm_write ( void * dst_adr, void * src_adr, unsigned int src_len ) {
c0de91ac:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+3];
  parameters[0] = (unsigned int)dst_adr;
c0de91ae:	ab01      	add	r3, sp, #4
c0de91b0:	c307      	stmia	r3!, {r0, r1, r2}
c0de91b2:	4803      	ldr	r0, [pc, #12]	; (c0de91c0 <nvm_write+0x14>)
c0de91b4:	a901      	add	r1, sp, #4
  parameters[1] = (unsigned int)src_adr;
  parameters[2] = (unsigned int)src_len;
  SVC_Call(SYSCALL_nvm_write_ID_IN, parameters);
c0de91b6:	f7ff ffda 	bl	c0de916e <SVC_Call>
  return;
}
c0de91ba:	b006      	add	sp, #24
c0de91bc:	bd80      	pop	{r7, pc}
c0de91be:	46c0      	nop			; (mov r8, r8)
c0de91c0:	6000037f 	.word	0x6000037f

c0de91c4 <cx_ecdomain_parameters_length>:
  parameters[0] = (unsigned int)cv;
  parameters[1] = (unsigned int)length;
  return SVC_cx_call(SYSCALL_cx_ecdomain_size_ID_IN, parameters);
}

cx_err_t cx_ecdomain_parameters_length ( cx_curve_t cv, size_t *length ) {
c0de91c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+2];
  parameters[0] = (unsigned int)cv;
  parameters[1] = (unsigned int)length;
c0de91c6:	9101      	str	r1, [sp, #4]
  parameters[0] = (unsigned int)cv;
c0de91c8:	9000      	str	r0, [sp, #0]
c0de91ca:	4803      	ldr	r0, [pc, #12]	; (c0de91d8 <cx_ecdomain_parameters_length+0x14>)
c0de91cc:	4669      	mov	r1, sp
  return SVC_cx_call(SYSCALL_cx_ecdomain_parameters_length_ID_IN, parameters);
c0de91ce:	f7ff ffd5 	bl	c0de917c <SVC_cx_call>
c0de91d2:	b004      	add	sp, #16
c0de91d4:	bd80      	pop	{r7, pc}
c0de91d6:	46c0      	nop			; (mov r8, r8)
c0de91d8:	60012fb4 	.word	0x60012fb4

c0de91dc <os_perso_isonboarded>:
  parameters[1] = 0;
  SVC_Call(SYSCALL_os_perso_finalize_ID_IN, parameters);
  return;
}

bolos_bool_t os_perso_isonboarded ( void ) {
c0de91dc:	b5e0      	push	{r5, r6, r7, lr}
c0de91de:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de91e0:	9001      	str	r0, [sp, #4]
c0de91e2:	4803      	ldr	r0, [pc, #12]	; (c0de91f0 <os_perso_isonboarded+0x14>)
c0de91e4:	4669      	mov	r1, sp
  return (bolos_bool_t) SVC_Call(SYSCALL_os_perso_isonboarded_ID_IN, parameters);
c0de91e6:	f7ff ffc2 	bl	c0de916e <SVC_Call>
c0de91ea:	b2c0      	uxtb	r0, r0
c0de91ec:	bd8c      	pop	{r2, r3, r7, pc}
c0de91ee:	46c0      	nop			; (mov r8, r8)
c0de91f0:	60009f4f 	.word	0x60009f4f

c0de91f4 <os_perso_derive_node_bip32>:
  parameters[3] = (unsigned int)isConfirming;
  SVC_Call(SYSCALL_os_perso_setonboardingstatus_ID_IN, parameters);
  return;
}

void os_perso_derive_node_bip32 ( cx_curve_t curve, const unsigned int * path, unsigned int pathLength, unsigned char * privateKey, unsigned char * chain ) {
c0de91f4:	b510      	push	{r4, lr}
c0de91f6:	b088      	sub	sp, #32
c0de91f8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
  parameters[1] = (unsigned int)path;
  parameters[2] = (unsigned int)pathLength;
  parameters[3] = (unsigned int)privateKey;
  parameters[4] = (unsigned int)chain;
c0de91fa:	9405      	str	r4, [sp, #20]
  parameters[3] = (unsigned int)privateKey;
c0de91fc:	9304      	str	r3, [sp, #16]
  parameters[2] = (unsigned int)pathLength;
c0de91fe:	9203      	str	r2, [sp, #12]
  parameters[1] = (unsigned int)path;
c0de9200:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)curve;
c0de9202:	9001      	str	r0, [sp, #4]
c0de9204:	4802      	ldr	r0, [pc, #8]	; (c0de9210 <os_perso_derive_node_bip32+0x1c>)
c0de9206:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_perso_derive_node_bip32_ID_IN, parameters);
c0de9208:	f7ff ffb1 	bl	c0de916e <SVC_Call>
  return;
}
c0de920c:	b008      	add	sp, #32
c0de920e:	bd10      	pop	{r4, pc}
c0de9210:	600053ba 	.word	0x600053ba

c0de9214 <os_perso_derive_eip2333>:
  parameters[7] = (unsigned int)seed_key_length;
  SVC_Call(SYSCALL_os_perso_derive_node_with_seed_key_ID_IN, parameters);
  return;
}

void os_perso_derive_eip2333 ( cx_curve_t curve, const unsigned int * path, unsigned int pathLength, unsigned char * privateKey ) {
c0de9214:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0de9216:	af00      	add	r7, sp, #0
c0de9218:	c70f      	stmia	r7!, {r0, r1, r2, r3}
c0de921a:	4803      	ldr	r0, [pc, #12]	; (c0de9228 <os_perso_derive_eip2333+0x14>)
c0de921c:	4669      	mov	r1, sp
  parameters[1] = (unsigned int)path;
  parameters[2] = (unsigned int)pathLength;
  parameters[3] = (unsigned int)privateKey;
  SVC_Call(SYSCALL_os_perso_derive_eip2333_ID_IN, parameters);
c0de921e:	f7ff ffa6 	bl	c0de916e <SVC_Call>
  return;
}
c0de9222:	b006      	add	sp, #24
c0de9224:	bd80      	pop	{r7, pc}
c0de9226:	46c0      	nop			; (mov r8, r8)
c0de9228:	6000a750 	.word	0x6000a750

c0de922c <os_global_pin_is_validated>:
  parameters[1] = (unsigned int)length;
  SVC_Call(SYSCALL_os_perso_set_current_identity_pin_ID_IN, parameters);
  return;
}

bolos_bool_t os_global_pin_is_validated ( void ) {
c0de922c:	b5e0      	push	{r5, r6, r7, lr}
c0de922e:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de9230:	9001      	str	r0, [sp, #4]
c0de9232:	4803      	ldr	r0, [pc, #12]	; (c0de9240 <os_global_pin_is_validated+0x14>)
c0de9234:	4669      	mov	r1, sp
  return (bolos_bool_t) SVC_Call(SYSCALL_os_global_pin_is_validated_ID_IN, parameters);
c0de9236:	f7ff ff9a 	bl	c0de916e <SVC_Call>
c0de923a:	b2c0      	uxtb	r0, r0
c0de923c:	bd8c      	pop	{r2, r3, r7, pc}
c0de923e:	46c0      	nop			; (mov r8, r8)
c0de9240:	6000a03c 	.word	0x6000a03c

c0de9244 <os_ux>:
  SVC_Call(SYSCALL_os_registry_get_ID_IN, parameters);
  return;
}

#if !defined(APP_UX)
unsigned int os_ux ( bolos_ux_params_t * params ) {
c0de9244:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de9246:	2100      	movs	r1, #0
  unsigned int parameters [2+1];
  parameters[0] = (unsigned int)params;
  parameters[1] = 0;
c0de9248:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)params;
c0de924a:	9001      	str	r0, [sp, #4]
c0de924c:	4802      	ldr	r0, [pc, #8]	; (c0de9258 <os_ux+0x14>)
c0de924e:	a901      	add	r1, sp, #4
  return (unsigned int) SVC_Call(SYSCALL_os_ux_ID_IN, parameters);
c0de9250:	f7ff ff8d 	bl	c0de916e <SVC_Call>
c0de9254:	b004      	add	sp, #16
c0de9256:	bd80      	pop	{r7, pc}
c0de9258:	60006458 	.word	0x60006458

c0de925c <os_lib_call>:
  SVC_Call(SYSCALL_os_ux_result_ID_IN, parameters);
  return;
}
#endif // !defined(APP_UX)

void os_lib_call ( unsigned int * call_parameters ) {
c0de925c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de925e:	2100      	movs	r1, #0
  unsigned int parameters [2+1];
  parameters[0] = (unsigned int)call_parameters;
  parameters[1] = 0;
c0de9260:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)call_parameters;
c0de9262:	9001      	str	r0, [sp, #4]
c0de9264:	4802      	ldr	r0, [pc, #8]	; (c0de9270 <os_lib_call+0x14>)
c0de9266:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_lib_call_ID_IN, parameters);
c0de9268:	f7ff ff81 	bl	c0de916e <SVC_Call>
  return;
}
c0de926c:	bd8f      	pop	{r0, r1, r2, r3, r7, pc}
c0de926e:	46c0      	nop			; (mov r8, r8)
c0de9270:	6000670d 	.word	0x6000670d

c0de9274 <os_lib_end>:

void os_lib_end ( void ) {
c0de9274:	b5e0      	push	{r5, r6, r7, lr}
c0de9276:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de9278:	9001      	str	r0, [sp, #4]
c0de927a:	4802      	ldr	r0, [pc, #8]	; (c0de9284 <os_lib_end+0x10>)
c0de927c:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_os_lib_end_ID_IN, parameters);
c0de927e:	f7ff ff76 	bl	c0de916e <SVC_Call>
  return;
}
c0de9282:	bd8c      	pop	{r2, r3, r7, pc}
c0de9284:	6000688d 	.word	0x6000688d

c0de9288 <os_flags>:

unsigned int os_flags ( void ) {
c0de9288:	b5e0      	push	{r5, r6, r7, lr}
c0de928a:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de928c:	9001      	str	r0, [sp, #4]
c0de928e:	4802      	ldr	r0, [pc, #8]	; (c0de9298 <os_flags+0x10>)
c0de9290:	4669      	mov	r1, sp
  return (unsigned int) SVC_Call(SYSCALL_os_flags_ID_IN, parameters);
c0de9292:	f7ff ff6c 	bl	c0de916e <SVC_Call>
c0de9296:	bd8c      	pop	{r2, r3, r7, pc}
c0de9298:	60006a6e 	.word	0x60006a6e

c0de929c <os_serial>:
  parameters[0] = (unsigned int)version;
  parameters[1] = (unsigned int)maxlength;
  return (unsigned int) SVC_Call(SYSCALL_os_version_ID_IN, parameters);
}

unsigned int os_serial ( unsigned char * serial, unsigned int maxlength ) {
c0de929c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+2];
  parameters[0] = (unsigned int)serial;
  parameters[1] = (unsigned int)maxlength;
c0de929e:	9101      	str	r1, [sp, #4]
  parameters[0] = (unsigned int)serial;
c0de92a0:	9000      	str	r0, [sp, #0]
c0de92a2:	4803      	ldr	r0, [pc, #12]	; (c0de92b0 <os_serial+0x14>)
c0de92a4:	4669      	mov	r1, sp
  return (unsigned int) SVC_Call(SYSCALL_os_serial_ID_IN, parameters);
c0de92a6:	f7ff ff62 	bl	c0de916e <SVC_Call>
c0de92aa:	b004      	add	sp, #16
c0de92ac:	bd80      	pop	{r7, pc}
c0de92ae:	46c0      	nop			; (mov r8, r8)
c0de92b0:	60006cb3 	.word	0x60006cb3

c0de92b4 <os_setting_get>:
  parameters[0] = (unsigned int)version;
  parameters[1] = (unsigned int)maxlength;
  return (unsigned int) SVC_Call(SYSCALL_os_bootloader_version_ID_IN, parameters);
}

unsigned int os_setting_get ( unsigned int setting_id, unsigned char * value, unsigned int maxlen ) {
c0de92b4:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+3];
  parameters[0] = (unsigned int)setting_id;
c0de92b6:	ab01      	add	r3, sp, #4
c0de92b8:	c307      	stmia	r3!, {r0, r1, r2}
c0de92ba:	4803      	ldr	r0, [pc, #12]	; (c0de92c8 <os_setting_get+0x14>)
c0de92bc:	a901      	add	r1, sp, #4
  parameters[1] = (unsigned int)value;
  parameters[2] = (unsigned int)maxlen;
  return (unsigned int) SVC_Call(SYSCALL_os_setting_get_ID_IN, parameters);
c0de92be:	f7ff ff56 	bl	c0de916e <SVC_Call>
c0de92c2:	b006      	add	sp, #24
c0de92c4:	bd80      	pop	{r7, pc}
c0de92c6:	46c0      	nop			; (mov r8, r8)
c0de92c8:	600070c5 	.word	0x600070c5

c0de92cc <os_registry_get_current_app_tag>:
  parameters[4] = (unsigned int)buffer;
  parameters[5] = (unsigned int)maxlength;
  return (unsigned int) SVC_Call(SYSCALL_os_registry_get_tag_ID_IN, parameters);
}

unsigned int os_registry_get_current_app_tag ( unsigned int tag, unsigned char * buffer, unsigned int maxlen ) {
c0de92cc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+3];
  parameters[0] = (unsigned int)tag;
c0de92ce:	ab01      	add	r3, sp, #4
c0de92d0:	c307      	stmia	r3!, {r0, r1, r2}
c0de92d2:	4803      	ldr	r0, [pc, #12]	; (c0de92e0 <os_registry_get_current_app_tag+0x14>)
c0de92d4:	a901      	add	r1, sp, #4
  parameters[1] = (unsigned int)buffer;
  parameters[2] = (unsigned int)maxlen;
  return (unsigned int) SVC_Call(SYSCALL_os_registry_get_current_app_tag_ID_IN, parameters);
c0de92d6:	f7ff ff4a 	bl	c0de916e <SVC_Call>
c0de92da:	b006      	add	sp, #24
c0de92dc:	bd80      	pop	{r7, pc}
c0de92de:	46c0      	nop			; (mov r8, r8)
c0de92e0:	600074d4 	.word	0x600074d4

c0de92e4 <os_sched_exit>:
  parameters[1] = 0;
  SVC_Call(SYSCALL_os_sched_exec_ID_IN, parameters);
  return;
}

void __attribute__((noreturn)) os_sched_exit ( bolos_task_status_t exit_code ) {
c0de92e4:	b084      	sub	sp, #16
c0de92e6:	2100      	movs	r1, #0
  unsigned int parameters [2+1];
  parameters[0] = (unsigned int)exit_code;
  parameters[1] = 0;
c0de92e8:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)exit_code;
c0de92ea:	9001      	str	r0, [sp, #4]
c0de92ec:	4802      	ldr	r0, [pc, #8]	; (c0de92f8 <os_sched_exit+0x14>)
c0de92ee:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_sched_exit_ID_IN, parameters);
c0de92f0:	f7ff ff3d 	bl	c0de916e <SVC_Call>

  // The os_sched_exit syscall should never return. Just in case, prevent the
  // device from freezing (because of the following infinite loop) thanks to an
  // undefined instruction.
  asm volatile ("udf #255");
c0de92f4:	deff      	udf	#255	; 0xff

  // remove the warning caused by -Winvalid-noreturn
  while (1) {
c0de92f6:	e7fe      	b.n	c0de92f6 <os_sched_exit+0x12>
c0de92f8:	60009abe 	.word	0x60009abe

c0de92fc <io_seph_send>:
  parameters[1] = 0;
  SVC_Call(SYSCALL_os_sched_kill_ID_IN, parameters);
  return;
}

void io_seph_send ( const unsigned char * buffer, unsigned short length ) {
c0de92fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+2];
  parameters[0] = (unsigned int)buffer;
  parameters[1] = (unsigned int)length;
c0de92fe:	9101      	str	r1, [sp, #4]
  parameters[0] = (unsigned int)buffer;
c0de9300:	9000      	str	r0, [sp, #0]
c0de9302:	4802      	ldr	r0, [pc, #8]	; (c0de930c <io_seph_send+0x10>)
c0de9304:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_io_seph_send_ID_IN, parameters);
c0de9306:	f7ff ff32 	bl	c0de916e <SVC_Call>
  return;
}
c0de930a:	bd8f      	pop	{r0, r1, r2, r3, r7, pc}
c0de930c:	60008381 	.word	0x60008381

c0de9310 <io_seph_is_status_sent>:

unsigned int io_seph_is_status_sent ( void ) {
c0de9310:	b5e0      	push	{r5, r6, r7, lr}
c0de9312:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de9314:	9001      	str	r0, [sp, #4]
c0de9316:	4802      	ldr	r0, [pc, #8]	; (c0de9320 <io_seph_is_status_sent+0x10>)
c0de9318:	4669      	mov	r1, sp
  return (unsigned int) SVC_Call(SYSCALL_io_seph_is_status_sent_ID_IN, parameters);
c0de931a:	f7ff ff28 	bl	c0de916e <SVC_Call>
c0de931e:	bd8c      	pop	{r2, r3, r7, pc}
c0de9320:	600084bb 	.word	0x600084bb

c0de9324 <io_seph_recv>:
}

unsigned short io_seph_recv ( unsigned char * buffer, unsigned short maxlength, unsigned int flags ) {
c0de9324:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
  unsigned int parameters [2+3];
  parameters[0] = (unsigned int)buffer;
c0de9326:	ab01      	add	r3, sp, #4
c0de9328:	c307      	stmia	r3!, {r0, r1, r2}
c0de932a:	4803      	ldr	r0, [pc, #12]	; (c0de9338 <io_seph_recv+0x14>)
c0de932c:	a901      	add	r1, sp, #4
  parameters[1] = (unsigned int)maxlength;
  parameters[2] = (unsigned int)flags;
  return (unsigned short) SVC_Call(SYSCALL_io_seph_recv_ID_IN, parameters);
c0de932e:	f7ff ff1e 	bl	c0de916e <SVC_Call>
c0de9332:	b280      	uxth	r0, r0
c0de9334:	b006      	add	sp, #24
c0de9336:	bd80      	pop	{r7, pc}
c0de9338:	600085e4 	.word	0x600085e4

c0de933c <try_context_get>:
  parameters[1] = 0;
  SVC_Call(SYSCALL_nvm_erase_page_ID_IN, parameters);
  return;
}

try_context_t * try_context_get ( void ) {
c0de933c:	b5e0      	push	{r5, r6, r7, lr}
c0de933e:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de9340:	9001      	str	r0, [sp, #4]
c0de9342:	4802      	ldr	r0, [pc, #8]	; (c0de934c <try_context_get+0x10>)
c0de9344:	4669      	mov	r1, sp
  return (try_context_t *) SVC_Call(SYSCALL_try_context_get_ID_IN, parameters);
c0de9346:	f7ff ff12 	bl	c0de916e <SVC_Call>
c0de934a:	bd8c      	pop	{r2, r3, r7, pc}
c0de934c:	600087b1 	.word	0x600087b1

c0de9350 <try_context_set>:
}

try_context_t * try_context_set ( try_context_t *context ) {
c0de9350:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de9352:	2100      	movs	r1, #0
  unsigned int parameters [2+1];
  parameters[0] = (unsigned int)context;
  parameters[1] = 0;
c0de9354:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)context;
c0de9356:	9001      	str	r0, [sp, #4]
c0de9358:	4802      	ldr	r0, [pc, #8]	; (c0de9364 <try_context_set+0x14>)
c0de935a:	a901      	add	r1, sp, #4
  return (try_context_t *) SVC_Call(SYSCALL_try_context_set_ID_IN, parameters);
c0de935c:	f7ff ff07 	bl	c0de916e <SVC_Call>
c0de9360:	b004      	add	sp, #16
c0de9362:	bd80      	pop	{r7, pc}
c0de9364:	60010b06 	.word	0x60010b06

c0de9368 <os_sched_last_status>:
}

bolos_task_status_t os_sched_last_status ( unsigned int task_idx ) {
c0de9368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de936a:	2100      	movs	r1, #0
  unsigned int parameters [2+1];
  parameters[0] = (unsigned int)task_idx;
  parameters[1] = 0;
c0de936c:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)task_idx;
c0de936e:	9001      	str	r0, [sp, #4]
c0de9370:	4803      	ldr	r0, [pc, #12]	; (c0de9380 <os_sched_last_status+0x18>)
c0de9372:	a901      	add	r1, sp, #4
  return (bolos_task_status_t) SVC_Call(SYSCALL_os_sched_last_status_ID_IN, parameters);
c0de9374:	f7ff fefb 	bl	c0de916e <SVC_Call>
c0de9378:	b2c0      	uxtb	r0, r0
c0de937a:	b004      	add	sp, #16
c0de937c:	bd80      	pop	{r7, pc}
c0de937e:	46c0      	nop			; (mov r8, r8)
c0de9380:	60009c8b 	.word	0x60009c8b

c0de9384 <screen_update>:
  parameters[1] = 0;
  SVC_Call(SYSCALL_screen_clear_ID_IN, parameters);
  return;
}

void screen_update ( void ) {
c0de9384:	b5e0      	push	{r5, r6, r7, lr}
c0de9386:	2000      	movs	r0, #0
  unsigned int parameters [2];
  parameters[1] = 0;
c0de9388:	9001      	str	r0, [sp, #4]
c0de938a:	4802      	ldr	r0, [pc, #8]	; (c0de9394 <screen_update+0x10>)
c0de938c:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_screen_update_ID_IN, parameters);
c0de938e:	f7ff feee 	bl	c0de916e <SVC_Call>
  return;
}
c0de9392:	bd8c      	pop	{r2, r3, r7, pc}
c0de9394:	60007af3 	.word	0x60007af3

c0de9398 <bagl_hal_draw_bitmap_within_rect>:
  parameters[3] = (unsigned int)height;
  SVC_Call(SYSCALL_screen_set_keepout_ID_IN, parameters);
  return;
}

void bagl_hal_draw_bitmap_within_rect ( int x, int y, unsigned int width, unsigned int height, unsigned int color_count, const unsigned int * colors, unsigned int bit_per_pixel, const unsigned char * bitmap, unsigned int bitmap_length_bits ) {
c0de9398:	b510      	push	{r4, lr}
c0de939a:	b08c      	sub	sp, #48	; 0x30
c0de939c:	9c12      	ldr	r4, [sp, #72]	; 0x48
  parameters[3] = (unsigned int)height;
  parameters[4] = (unsigned int)color_count;
  parameters[5] = (unsigned int)colors;
  parameters[6] = (unsigned int)bit_per_pixel;
  parameters[7] = (unsigned int)bitmap;
  parameters[8] = (unsigned int)bitmap_length_bits;
c0de939e:	9409      	str	r4, [sp, #36]	; 0x24
c0de93a0:	9c11      	ldr	r4, [sp, #68]	; 0x44
  parameters[7] = (unsigned int)bitmap;
c0de93a2:	9408      	str	r4, [sp, #32]
c0de93a4:	9c10      	ldr	r4, [sp, #64]	; 0x40
  parameters[6] = (unsigned int)bit_per_pixel;
c0de93a6:	9407      	str	r4, [sp, #28]
c0de93a8:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
  parameters[5] = (unsigned int)colors;
c0de93aa:	9406      	str	r4, [sp, #24]
c0de93ac:	9c0e      	ldr	r4, [sp, #56]	; 0x38
  parameters[4] = (unsigned int)color_count;
c0de93ae:	9405      	str	r4, [sp, #20]
  parameters[3] = (unsigned int)height;
c0de93b0:	9304      	str	r3, [sp, #16]
  parameters[2] = (unsigned int)width;
c0de93b2:	9203      	str	r2, [sp, #12]
  parameters[1] = (unsigned int)y;
c0de93b4:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)x;
c0de93b6:	9001      	str	r0, [sp, #4]
c0de93b8:	4802      	ldr	r0, [pc, #8]	; (c0de93c4 <bagl_hal_draw_bitmap_within_rect+0x2c>)
c0de93ba:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_bagl_hal_draw_bitmap_within_rect_ID_IN, parameters);
c0de93bc:	f7ff fed7 	bl	c0de916e <SVC_Call>
  return;
}
c0de93c0:	b00c      	add	sp, #48	; 0x30
c0de93c2:	bd10      	pop	{r4, pc}
c0de93c4:	60007ca0 	.word	0x60007ca0

c0de93c8 <bagl_hal_draw_rect>:

void bagl_hal_draw_rect ( unsigned int color, int x, int y, unsigned int width, unsigned int height ) {
c0de93c8:	b510      	push	{r4, lr}
c0de93ca:	b088      	sub	sp, #32
c0de93cc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  unsigned int parameters [2+5];
  parameters[0] = (unsigned int)color;
  parameters[1] = (unsigned int)x;
  parameters[2] = (unsigned int)y;
  parameters[3] = (unsigned int)width;
  parameters[4] = (unsigned int)height;
c0de93ce:	9405      	str	r4, [sp, #20]
  parameters[3] = (unsigned int)width;
c0de93d0:	9304      	str	r3, [sp, #16]
  parameters[2] = (unsigned int)y;
c0de93d2:	9203      	str	r2, [sp, #12]
  parameters[1] = (unsigned int)x;
c0de93d4:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)color;
c0de93d6:	9001      	str	r0, [sp, #4]
c0de93d8:	4802      	ldr	r0, [pc, #8]	; (c0de93e4 <bagl_hal_draw_rect+0x1c>)
c0de93da:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_bagl_hal_draw_rect_ID_IN, parameters);
c0de93dc:	f7ff fec7 	bl	c0de916e <SVC_Call>
  return;
}
c0de93e0:	b008      	add	sp, #32
c0de93e2:	bd10      	pop	{r4, pc}
c0de93e4:	60007da4 	.word	0x60007da4

c0de93e8 <os_ux_get_status>:
  parameters[1] = (unsigned int)status;
  SVC_Call(SYSCALL_os_ux_set_status_ID_IN, parameters);
  return;
}

unsigned int os_ux_get_status ( unsigned int ux_id ) {
c0de93e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de93ea:	2100      	movs	r1, #0
  unsigned int parameters [2+1];
  parameters[0] = (unsigned int)ux_id;
  parameters[1] = 0;
c0de93ec:	9102      	str	r1, [sp, #8]
  parameters[0] = (unsigned int)ux_id;
c0de93ee:	9001      	str	r0, [sp, #4]
c0de93f0:	4802      	ldr	r0, [pc, #8]	; (c0de93fc <os_ux_get_status+0x14>)
c0de93f2:	a901      	add	r1, sp, #4
  return (unsigned int) SVC_Call(SYSCALL_os_ux_get_status_ID_IN, parameters);
c0de93f4:	f7ff febb 	bl	c0de916e <SVC_Call>
c0de93f8:	b004      	add	sp, #16
c0de93fa:	bd80      	pop	{r7, pc}
c0de93fc:	60013593 	.word	0x60013593

c0de9400 <u2f_apdu_sign>:

    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
}

void u2f_apdu_sign(u2f_service_t *service, uint8_t p1, uint8_t p2,
                     uint8_t *buffer, uint16_t length) {
c0de9400:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0de9402:	4604      	mov	r4, r0
    UNUSED(p2);
    uint8_t keyHandleLength;
    uint8_t i;

    // can't process the apdu if another one is already scheduled in
    if (G_io_app.apdu_state != APDU_IDLE) {
c0de9404:	4a3c      	ldr	r2, [pc, #240]	; (c0de94f8 <u2f_apdu_sign+0xf8>)
c0de9406:	4648      	mov	r0, r9
c0de9408:	5c80      	ldrb	r0, [r0, r2]
c0de940a:	2800      	cmp	r0, #0
c0de940c:	d003      	beq.n	c0de9416 <u2f_apdu_sign+0x16>
c0de940e:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0de9410:	4a3b      	ldr	r2, [pc, #236]	; (c0de9500 <u2f_apdu_sign+0x100>)
c0de9412:	447a      	add	r2, pc
c0de9414:	e00b      	b.n	c0de942e <u2f_apdu_sign+0x2e>
c0de9416:	9f08      	ldr	r7, [sp, #32]
                  (uint8_t *)SW_BUSY,
                  sizeof(SW_BUSY));
        return;        
    }

    if (length < U2F_HANDLE_SIGN_HEADER_SIZE + 5 /*at least an apdu header*/) {
c0de9418:	2f45      	cmp	r7, #69	; 0x45
c0de941a:	d803      	bhi.n	c0de9424 <u2f_apdu_sign+0x24>
c0de941c:	2183      	movs	r1, #131	; 0x83
c0de941e:	4a39      	ldr	r2, [pc, #228]	; (c0de9504 <u2f_apdu_sign+0x104>)
c0de9420:	447a      	add	r2, pc
c0de9422:	e004      	b.n	c0de942e <u2f_apdu_sign+0x2e>
                  sizeof(SW_WRONG_LENGTH));
        return;
    }

    // Confirm immediately if it's just a validation call
    if (p1 == P1_SIGN_CHECK_ONLY) {
c0de9424:	2907      	cmp	r1, #7
c0de9426:	d107      	bne.n	c0de9438 <u2f_apdu_sign+0x38>
c0de9428:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0de942a:	4a37      	ldr	r2, [pc, #220]	; (c0de9508 <u2f_apdu_sign+0x108>)
c0de942c:	447a      	add	r2, pc
c0de942e:	2302      	movs	r3, #2
c0de9430:	4620      	mov	r0, r4
c0de9432:	f000 fc7d 	bl	c0de9d30 <u2f_message_reply>
    app_dispatch();
    if ((btchip_context_D.io_flags & IO_ASYNCH_REPLY) == 0) {
        u2f_proxy_response(service, btchip_context_D.outLength);
    }
    */
}
c0de9436:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de9438:	461d      	mov	r5, r3
c0de943a:	4619      	mov	r1, r3
c0de943c:	3140      	adds	r1, #64	; 0x40
    keyHandleLength = buffer[U2F_HANDLE_SIGN_HEADER_SIZE - 1];
c0de943e:	780e      	ldrb	r6, [r1, #0]
    if (U2F_HANDLE_SIGN_HEADER_SIZE + keyHandleLength != length) {
c0de9440:	4630      	mov	r0, r6
c0de9442:	3041      	adds	r0, #65	; 0x41
c0de9444:	42b8      	cmp	r0, r7
c0de9446:	d1e9      	bne.n	c0de941c <u2f_apdu_sign+0x1c>
    if (keyHandleLength == 5) {
c0de9448:	2e05      	cmp	r6, #5
c0de944a:	9602      	str	r6, [sp, #8]
c0de944c:	d10b      	bne.n	c0de9466 <u2f_apdu_sign+0x66>
        if (memcmp(buffer+U2F_HANDLE_SIGN_HEADER_SIZE, "\xF1\xD0\x00\x00\x00", 5) == 0 ) {
c0de944e:	4628      	mov	r0, r5
c0de9450:	3041      	adds	r0, #65	; 0x41
c0de9452:	460e      	mov	r6, r1
c0de9454:	492e      	ldr	r1, [pc, #184]	; (c0de9510 <u2f_apdu_sign+0x110>)
c0de9456:	4479      	add	r1, pc
c0de9458:	2205      	movs	r2, #5
c0de945a:	f004 f9fb 	bl	c0ded854 <memcmp>
c0de945e:	4631      	mov	r1, r6
c0de9460:	9e02      	ldr	r6, [sp, #8]
c0de9462:	2800      	cmp	r0, #0
c0de9464:	d032      	beq.n	c0de94cc <u2f_apdu_sign+0xcc>
c0de9466:	9700      	str	r7, [sp, #0]
c0de9468:	9401      	str	r4, [sp, #4]
    for (i = 0; i < keyHandleLength; i++) {
c0de946a:	3541      	adds	r5, #65	; 0x41
c0de946c:	2700      	movs	r7, #0
c0de946e:	4c27      	ldr	r4, [pc, #156]	; (c0de950c <u2f_apdu_sign+0x10c>)
c0de9470:	447c      	add	r4, pc
c0de9472:	42be      	cmp	r6, r7
c0de9474:	d00c      	beq.n	c0de9490 <u2f_apdu_sign+0x90>
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
c0de9476:	b2f8      	uxtb	r0, r7
c0de9478:	460e      	mov	r6, r1
c0de947a:	2103      	movs	r1, #3
c0de947c:	f004 f866 	bl	c0ded54c <__aeabi_uidivmod>
c0de9480:	5de8      	ldrb	r0, [r5, r7]
c0de9482:	5c61      	ldrb	r1, [r4, r1]
c0de9484:	4041      	eors	r1, r0
c0de9486:	55e9      	strb	r1, [r5, r7]
c0de9488:	4631      	mov	r1, r6
c0de948a:	9e02      	ldr	r6, [sp, #8]
    for (i = 0; i < keyHandleLength; i++) {
c0de948c:	1c7f      	adds	r7, r7, #1
c0de948e:	e7f0      	b.n	c0de9472 <u2f_apdu_sign+0x72>
    if (length != U2F_HANDLE_SIGN_HEADER_SIZE + 5 + buffer[U2F_HANDLE_SIGN_HEADER_SIZE + 4]) {
c0de9490:	7948      	ldrb	r0, [r1, #5]
c0de9492:	3046      	adds	r0, #70	; 0x46
c0de9494:	9900      	ldr	r1, [sp, #0]
c0de9496:	4288      	cmp	r0, r1
c0de9498:	d112      	bne.n	c0de94c0 <u2f_apdu_sign+0xc0>
    memmove(G_io_apdu_buffer, buffer + U2F_HANDLE_SIGN_HEADER_SIZE, keyHandleLength);
c0de949a:	4818      	ldr	r0, [pc, #96]	; (c0de94fc <u2f_apdu_sign+0xfc>)
c0de949c:	464c      	mov	r4, r9
c0de949e:	1820      	adds	r0, r4, r0
c0de94a0:	4629      	mov	r1, r5
c0de94a2:	4632      	mov	r2, r6
c0de94a4:	f004 f9c0 	bl	c0ded828 <__aeabi_memmove>
c0de94a8:	2009      	movs	r0, #9
c0de94aa:	4913      	ldr	r1, [pc, #76]	; (c0de94f8 <u2f_apdu_sign+0xf8>)
    G_io_app.apdu_state = APDU_U2F;
c0de94ac:	5460      	strb	r0, [r4, r1]
    G_io_app.apdu_length = keyHandleLength;
c0de94ae:	1860      	adds	r0, r4, r1
c0de94b0:	2107      	movs	r1, #7
    G_io_app.apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
c0de94b2:	7181      	strb	r1, [r0, #6]
    G_io_app.apdu_length = keyHandleLength;
c0de94b4:	8046      	strh	r6, [r0, #2]
c0de94b6:	2101      	movs	r1, #1
    u2f_message_set_autoreply_wait_user_presence(service, true);
c0de94b8:	9801      	ldr	r0, [sp, #4]
c0de94ba:	f000 fc24 	bl	c0de9d06 <u2f_message_set_autoreply_wait_user_presence>
}
c0de94be:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0de94c0:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0de94c2:	4a15      	ldr	r2, [pc, #84]	; (c0de9518 <u2f_apdu_sign+0x118>)
c0de94c4:	447a      	add	r2, pc
c0de94c6:	2302      	movs	r3, #2
c0de94c8:	9801      	ldr	r0, [sp, #4]
c0de94ca:	e7b2      	b.n	c0de9432 <u2f_apdu_sign+0x32>
            G_io_apdu_buffer[0] = sizeof(U2F_PROXY_MAGIC)-1;
c0de94cc:	480b      	ldr	r0, [pc, #44]	; (c0de94fc <u2f_apdu_sign+0xfc>)
c0de94ce:	4649      	mov	r1, r9
c0de94d0:	2203      	movs	r2, #3
c0de94d2:	540a      	strb	r2, [r1, r0]
c0de94d4:	180d      	adds	r5, r1, r0
            memcpy(G_io_apdu_buffer+1, U2F_PROXY_MAGIC, sizeof(U2F_PROXY_MAGIC)-1);
c0de94d6:	1c68      	adds	r0, r5, #1
c0de94d8:	490e      	ldr	r1, [pc, #56]	; (c0de9514 <u2f_apdu_sign+0x114>)
c0de94da:	4479      	add	r1, pc
c0de94dc:	f004 f9a0 	bl	c0ded820 <__aeabi_memcpy>
c0de94e0:	2000      	movs	r0, #0
            memcpy(G_io_apdu_buffer+1+sizeof(U2F_PROXY_MAGIC)-1, "\x90\x00\x90\x00", 4);
c0de94e2:	71e8      	strb	r0, [r5, #7]
c0de94e4:	2190      	movs	r1, #144	; 0x90
c0de94e6:	71a9      	strb	r1, [r5, #6]
c0de94e8:	7168      	strb	r0, [r5, #5]
c0de94ea:	7129      	strb	r1, [r5, #4]
c0de94ec:	2183      	movs	r1, #131	; 0x83
c0de94ee:	2308      	movs	r3, #8
            u2f_message_reply(service, U2F_CMD_MSG,
c0de94f0:	4620      	mov	r0, r4
c0de94f2:	462a      	mov	r2, r5
c0de94f4:	e79d      	b.n	c0de9432 <u2f_apdu_sign+0x32>
c0de94f6:	46c0      	nop			; (mov r8, r8)
c0de94f8:	00000ae4 	.word	0x00000ae4
c0de94fc:	00000990 	.word	0x00000990
c0de9500:	00006b58 	.word	0x00006b58
c0de9504:	00006b4c 	.word	0x00006b4c
c0de9508:	00006b42 	.word	0x00006b42
c0de950c:	00004ad6 	.word	0x00004ad6
c0de9510:	00006b1a 	.word	0x00006b1a
c0de9514:	00004a6c 	.word	0x00004a6c
c0de9518:	00006ab2 	.word	0x00006ab2

c0de951c <u2f_handle_cmd_init>:
}

#endif // U2F_PROXY_MAGIC

void u2f_handle_cmd_init(u2f_service_t *service, uint8_t *buffer,
                         uint16_t length, uint8_t *channelInit) {
c0de951c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de951e:	b089      	sub	sp, #36	; 0x24
c0de9520:	461c      	mov	r4, r3
c0de9522:	460e      	mov	r6, r1
c0de9524:	4605      	mov	r5, r0
    // screen_printf("U2F init\n");
    uint8_t channel[4];
    (void)length;
    if (u2f_is_channel_broadcast(channelInit)) {
c0de9526:	4618      	mov	r0, r3
c0de9528:	f000 fbd2 	bl	c0de9cd0 <u2f_is_channel_broadcast>
c0de952c:	2800      	cmp	r0, #0
c0de952e:	9506      	str	r5, [sp, #24]
c0de9530:	9404      	str	r4, [sp, #16]
c0de9532:	d009      	beq.n	c0de9548 <u2f_handle_cmd_init+0x2c>
        // cx_rng_no_throw(channel, 4); // not available within the IO task, just do without
	service->next_channel += 1;
c0de9534:	6828      	ldr	r0, [r5, #0]
c0de9536:	1c44      	adds	r4, r0, #1
c0de9538:	602c      	str	r4, [r5, #0]
}
static inline void U4BE_ENCODE(uint8_t *buf, size_t off, uint32_t value) {
  buf[off + 0] = (value >> 24) & 0xFF;
  buf[off + 1] = (value >> 16) & 0xFF;
  buf[off + 2] = (value >> 8) & 0xFF;
c0de953a:	0a20      	lsrs	r0, r4, #8
  buf[off + 1] = (value >> 16) & 0xFF;
c0de953c:	9007      	str	r0, [sp, #28]
c0de953e:	0c20      	lsrs	r0, r4, #16
  buf[off + 0] = (value >> 24) & 0xFF;
c0de9540:	9008      	str	r0, [sp, #32]
c0de9542:	0e20      	lsrs	r0, r4, #24
        U4BE_ENCODE(channel, 0, service->next_channel);
    } else {
c0de9544:	9005      	str	r0, [sp, #20]
c0de9546:	e00f      	b.n	c0de9568 <u2f_handle_cmd_init+0x4c>
        memcpy(channel, channelInit, 4);
c0de9548:	7820      	ldrb	r0, [r4, #0]
c0de954a:	7861      	ldrb	r1, [r4, #1]
c0de954c:	0209      	lsls	r1, r1, #8
c0de954e:	1808      	adds	r0, r1, r0
c0de9550:	78a1      	ldrb	r1, [r4, #2]
c0de9552:	78e2      	ldrb	r2, [r4, #3]
c0de9554:	0212      	lsls	r2, r2, #8
c0de9556:	1851      	adds	r1, r2, r1
c0de9558:	0409      	lsls	r1, r1, #16
c0de955a:	1808      	adds	r0, r1, r0
c0de955c:	0e04      	lsrs	r4, r0, #24
c0de955e:	0c01      	lsrs	r1, r0, #16
c0de9560:	9107      	str	r1, [sp, #28]
c0de9562:	9005      	str	r0, [sp, #20]
c0de9564:	0a00      	lsrs	r0, r0, #8
c0de9566:	9008      	str	r0, [sp, #32]
    }
    memmove(G_io_apdu_buffer, buffer, 8);
c0de9568:	7870      	ldrb	r0, [r6, #1]
c0de956a:	9003      	str	r0, [sp, #12]
c0de956c:	78f0      	ldrb	r0, [r6, #3]
c0de956e:	9002      	str	r0, [sp, #8]
c0de9570:	78b0      	ldrb	r0, [r6, #2]
c0de9572:	9001      	str	r0, [sp, #4]
c0de9574:	7973      	ldrb	r3, [r6, #5]
c0de9576:	7932      	ldrb	r2, [r6, #4]
c0de9578:	79f1      	ldrb	r1, [r6, #7]
c0de957a:	79b5      	ldrb	r5, [r6, #6]
c0de957c:	7836      	ldrb	r6, [r6, #0]
c0de957e:	4f1c      	ldr	r7, [pc, #112]	; (c0de95f0 <u2f_handle_cmd_init+0xd4>)
c0de9580:	4648      	mov	r0, r9
c0de9582:	55c6      	strb	r6, [r0, r7]
c0de9584:	19c6      	adds	r6, r0, r7
c0de9586:	2700      	movs	r7, #0
    memcpy(G_io_apdu_buffer + 8, channel, 4);
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
c0de9588:	7377      	strb	r7, [r6, #13]
c0de958a:	2001      	movs	r0, #1
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
c0de958c:	73b0      	strb	r0, [r6, #14]
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
c0de958e:	73f7      	strb	r7, [r6, #15]
    G_io_apdu_buffer[16] = INIT_CAPABILITIES;
c0de9590:	7437      	strb	r7, [r6, #16]
    memmove(G_io_apdu_buffer, buffer, 8);
c0de9592:	71b5      	strb	r5, [r6, #6]
c0de9594:	71f1      	strb	r1, [r6, #7]
c0de9596:	7132      	strb	r2, [r6, #4]
c0de9598:	7173      	strb	r3, [r6, #5]
c0de959a:	9801      	ldr	r0, [sp, #4]
c0de959c:	70b0      	strb	r0, [r6, #2]
c0de959e:	9802      	ldr	r0, [sp, #8]
c0de95a0:	70f0      	strb	r0, [r6, #3]
c0de95a2:	9803      	ldr	r0, [sp, #12]
c0de95a4:	7070      	strb	r0, [r6, #1]
    memcpy(G_io_apdu_buffer + 8, channel, 4);
c0de95a6:	9807      	ldr	r0, [sp, #28]
c0de95a8:	72b0      	strb	r0, [r6, #10]
c0de95aa:	72f4      	strb	r4, [r6, #11]
c0de95ac:	9d05      	ldr	r5, [sp, #20]
c0de95ae:	7235      	strb	r5, [r6, #8]
c0de95b0:	9808      	ldr	r0, [sp, #32]
c0de95b2:	7270      	strb	r0, [r6, #9]
c0de95b4:	2002      	movs	r0, #2
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
c0de95b6:	7330      	strb	r0, [r6, #12]

    if (u2f_is_channel_broadcast(channelInit)) {
c0de95b8:	9804      	ldr	r0, [sp, #16]
c0de95ba:	f000 fb89 	bl	c0de9cd0 <u2f_is_channel_broadcast>
c0de95be:	2800      	cmp	r0, #0
c0de95c0:	d10b      	bne.n	c0de95da <u2f_handle_cmd_init+0xbe>
c0de95c2:	0620      	lsls	r0, r4, #24
c0de95c4:	9907      	ldr	r1, [sp, #28]
c0de95c6:	0609      	lsls	r1, r1, #24
c0de95c8:	0a09      	lsrs	r1, r1, #8
c0de95ca:	1808      	adds	r0, r1, r0
c0de95cc:	9908      	ldr	r1, [sp, #32]
c0de95ce:	0609      	lsls	r1, r1, #24
c0de95d0:	0c09      	lsrs	r1, r1, #16
c0de95d2:	1840      	adds	r0, r0, r1
c0de95d4:	b2e9      	uxtb	r1, r5
c0de95d6:	1841      	adds	r1, r0, r1
c0de95d8:	e000      	b.n	c0de95dc <u2f_handle_cmd_init+0xc0>
c0de95da:	43f9      	mvns	r1, r7
c0de95dc:	9806      	ldr	r0, [sp, #24]
c0de95de:	6041      	str	r1, [r0, #4]
c0de95e0:	2186      	movs	r1, #134	; 0x86
c0de95e2:	2311      	movs	r3, #17
        memset(service->channel, 0xff, 4);
    } else {
        memcpy(service->channel, channel, 4);
    }
    u2f_message_reply(service, U2F_CMD_INIT, G_io_apdu_buffer, 17);
c0de95e4:	4632      	mov	r2, r6
c0de95e6:	f000 fba3 	bl	c0de9d30 <u2f_message_reply>
}
c0de95ea:	b009      	add	sp, #36	; 0x24
c0de95ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de95ee:	46c0      	nop			; (mov r8, r8)
c0de95f0:	00000990 	.word	0x00000990

c0de95f4 <u2f_handle_cmd_ping>:

void u2f_handle_cmd_ping(u2f_service_t *service, uint8_t *buffer,
                         uint16_t length) {
c0de95f4:	b580      	push	{r7, lr}
c0de95f6:	4613      	mov	r3, r2
c0de95f8:	460a      	mov	r2, r1
c0de95fa:	2181      	movs	r1, #129	; 0x81
    // screen_printf("U2F ping\n");
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
c0de95fc:	f000 fb98 	bl	c0de9d30 <u2f_message_reply>
}
c0de9600:	bd80      	pop	{r7, pc}
c0de9602:	d4d4      	bmi.n	c0de95ae <u2f_handle_cmd_init+0x92>

c0de9604 <u2f_handle_cmd_msg>:

void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
c0de9604:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
    uint8_t cla = buffer[0];
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
    uint8_t p2 = buffer[3];
    // in extended length buffer[4] must be 0
    uint32_t dataLength = /*(buffer[4] << 16) |*/ (buffer[5] << 8) | (buffer[6]);
c0de9606:	798b      	ldrb	r3, [r1, #6]
c0de9608:	794c      	ldrb	r4, [r1, #5]
c0de960a:	0224      	lsls	r4, r4, #8
c0de960c:	18e7      	adds	r7, r4, r3
    uint8_t p1 = buffer[2];
c0de960e:	788b      	ldrb	r3, [r1, #2]
    uint8_t ins = buffer[1];
c0de9610:	9302      	str	r3, [sp, #8]
c0de9612:	784b      	ldrb	r3, [r1, #1]
    uint8_t cla = buffer[0];
c0de9614:	780e      	ldrb	r6, [r1, #0]
    if (dataLength == (uint16_t)(length - 9) || dataLength == (uint16_t)(length - 7)) {
c0de9616:	4615      	mov	r5, r2
c0de9618:	3d09      	subs	r5, #9
c0de961a:	b2ac      	uxth	r4, r5
c0de961c:	42a7      	cmp	r7, r4
c0de961e:	d003      	beq.n	c0de9628 <u2f_handle_cmd_msg+0x24>
c0de9620:	1fd2      	subs	r2, r2, #7
c0de9622:	b294      	uxth	r4, r2
c0de9624:	42a7      	cmp	r7, r4
c0de9626:	d115      	bne.n	c0de9654 <u2f_handle_cmd_msg+0x50>
c0de9628:	463d      	mov	r5, r7
    G_io_app.apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
    G_io_app.apdu_state = APDU_U2F;

#else // U2F_PROXY_MAGIC

    if (cla != FIDO_CLA) {
c0de962a:	2e00      	cmp	r6, #0
c0de962c:	d006      	beq.n	c0de963c <u2f_handle_cmd_msg+0x38>
c0de962e:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0de9630:	4a18      	ldr	r2, [pc, #96]	; (c0de9694 <u2f_handle_cmd_msg+0x90>)
c0de9632:	447a      	add	r2, pc
c0de9634:	2302      	movs	r3, #2
c0de9636:	f000 fb7b 	bl	c0de9d30 <u2f_message_reply>
                 sizeof(SW_UNKNOWN_INSTRUCTION));
        return;
    }

#endif // U2F_PROXY_MAGIC
}
c0de963a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    switch (ins) {
c0de963c:	2bc1      	cmp	r3, #193	; 0xc1
c0de963e:	d014      	beq.n	c0de966a <u2f_handle_cmd_msg+0x66>
c0de9640:	2b02      	cmp	r3, #2
c0de9642:	d017      	beq.n	c0de9674 <u2f_handle_cmd_msg+0x70>
c0de9644:	2183      	movs	r1, #131	; 0x83
c0de9646:	2b03      	cmp	r3, #3
c0de9648:	d01c      	beq.n	c0de9684 <u2f_handle_cmd_msg+0x80>
c0de964a:	2b01      	cmp	r3, #1
c0de964c:	d11e      	bne.n	c0de968c <u2f_handle_cmd_msg+0x88>
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
c0de964e:	4a13      	ldr	r2, [pc, #76]	; (c0de969c <u2f_handle_cmd_msg+0x98>)
c0de9650:	447a      	add	r2, pc
c0de9652:	e7ef      	b.n	c0de9634 <u2f_handle_cmd_msg+0x30>
    else if (dataLength == (uint16_t)(length - 9)%256) {
c0de9654:	b2ec      	uxtb	r4, r5
c0de9656:	42a7      	cmp	r7, r4
c0de9658:	d0e7      	beq.n	c0de962a <u2f_handle_cmd_msg+0x26>
    else if (dataLength == (uint16_t)(length - 7)%256) {
c0de965a:	b2d4      	uxtb	r4, r2
c0de965c:	42a7      	cmp	r7, r4
c0de965e:	4615      	mov	r5, r2
c0de9660:	d0e3      	beq.n	c0de962a <u2f_handle_cmd_msg+0x26>
c0de9662:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0de9664:	4a0c      	ldr	r2, [pc, #48]	; (c0de9698 <u2f_handle_cmd_msg+0x94>)
c0de9666:	447a      	add	r2, pc
c0de9668:	e7e4      	b.n	c0de9634 <u2f_handle_cmd_msg+0x30>
c0de966a:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)INFO, sizeof(INFO));
c0de966c:	4a0d      	ldr	r2, [pc, #52]	; (c0de96a4 <u2f_handle_cmd_msg+0xa0>)
c0de966e:	447a      	add	r2, pc
c0de9670:	2304      	movs	r3, #4
c0de9672:	e7e0      	b.n	c0de9636 <u2f_handle_cmd_msg+0x32>
        u2f_apdu_sign(service, p1, p2, buffer + 7, dataLength);
c0de9674:	b2aa      	uxth	r2, r5
c0de9676:	9200      	str	r2, [sp, #0]
c0de9678:	1dcb      	adds	r3, r1, #7
c0de967a:	2200      	movs	r2, #0
c0de967c:	9902      	ldr	r1, [sp, #8]
c0de967e:	f7ff febf 	bl	c0de9400 <u2f_apdu_sign>
}
c0de9682:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)U2F_VERSION, sizeof(U2F_VERSION));
c0de9684:	4a06      	ldr	r2, [pc, #24]	; (c0de96a0 <u2f_handle_cmd_msg+0x9c>)
c0de9686:	447a      	add	r2, pc
c0de9688:	2308      	movs	r3, #8
c0de968a:	e7d4      	b.n	c0de9636 <u2f_handle_cmd_msg+0x32>
        u2f_message_reply(service, U2F_CMD_MSG,
c0de968c:	4a06      	ldr	r2, [pc, #24]	; (c0de96a8 <u2f_handle_cmd_msg+0xa4>)
c0de968e:	447a      	add	r2, pc
c0de9690:	e7d0      	b.n	c0de9634 <u2f_handle_cmd_msg+0x30>
c0de9692:	46c0      	nop			; (mov r8, r8)
c0de9694:	00006952 	.word	0x00006952
c0de9698:	00006906 	.word	0x00006906
c0de969c:	00006918 	.word	0x00006918
c0de96a0:	000068f2 	.word	0x000068f2
c0de96a4:	00006912 	.word	0x00006912
c0de96a8:	000068f8 	.word	0x000068f8

c0de96ac <u2f_message_complete>:

void u2f_message_complete(u2f_service_t *service) {
c0de96ac:	b580      	push	{r7, lr}
    uint8_t cmd = service->transportBuffer[0];
c0de96ae:	69c1      	ldr	r1, [r0, #28]
    uint16_t length = (service->transportBuffer[1] << 8) | (service->transportBuffer[2]);
c0de96b0:	788a      	ldrb	r2, [r1, #2]
c0de96b2:	784b      	ldrb	r3, [r1, #1]
c0de96b4:	021b      	lsls	r3, r3, #8
c0de96b6:	189a      	adds	r2, r3, r2
    uint8_t cmd = service->transportBuffer[0];
c0de96b8:	780b      	ldrb	r3, [r1, #0]
    switch (cmd) {
c0de96ba:	2b81      	cmp	r3, #129	; 0x81
c0de96bc:	d009      	beq.n	c0de96d2 <u2f_message_complete+0x26>
c0de96be:	2b83      	cmp	r3, #131	; 0x83
c0de96c0:	d00c      	beq.n	c0de96dc <u2f_message_complete+0x30>
c0de96c2:	2b86      	cmp	r3, #134	; 0x86
c0de96c4:	d10e      	bne.n	c0de96e4 <u2f_message_complete+0x38>
    case U2F_CMD_INIT:
        u2f_handle_cmd_init(service, service->transportBuffer + 3, length, service->channel);
c0de96c6:	1cc9      	adds	r1, r1, #3
c0de96c8:	1d03      	adds	r3, r0, #4
c0de96ca:	2200      	movs	r2, #0
c0de96cc:	f7ff ff26 	bl	c0de951c <u2f_handle_cmd_init>
    case CTAP2_CMD_CANCEL:
        ctap2_handle_cmd_cancel(service, service->transportBuffer + 3, length);
        break;
#endif        	
    }
}
c0de96d0:	bd80      	pop	{r7, pc}
        u2f_handle_cmd_ping(service, service->transportBuffer + 3, length);
c0de96d2:	1cc9      	adds	r1, r1, #3
c0de96d4:	b292      	uxth	r2, r2
c0de96d6:	f7ff ff8d 	bl	c0de95f4 <u2f_handle_cmd_ping>
}
c0de96da:	bd80      	pop	{r7, pc}
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
c0de96dc:	1cc9      	adds	r1, r1, #3
c0de96de:	b292      	uxth	r2, r2
c0de96e0:	f7ff ff90 	bl	c0de9604 <u2f_handle_cmd_msg>
}
c0de96e4:	bd80      	pop	{r7, pc}
c0de96e6:	d4d4      	bmi.n	c0de9692 <u2f_handle_cmd_msg+0x8e>

c0de96e8 <u2f_io_send>:
#include "u2f_processing.h"
#include "u2f_impl.h"

#include "os_io_seproxyhal.h"

void u2f_io_send(uint8_t *buffer, uint16_t length, u2f_transport_media_t media) {
c0de96e8:	b570      	push	{r4, r5, r6, lr}
c0de96ea:	460c      	mov	r4, r1
c0de96ec:	4601      	mov	r1, r0
    if (media == U2F_MEDIA_USB) {
c0de96ee:	2a03      	cmp	r2, #3
c0de96f0:	d014      	beq.n	c0de971c <u2f_io_send+0x34>
c0de96f2:	2a01      	cmp	r2, #1
c0de96f4:	d116      	bne.n	c0de9724 <u2f_io_send+0x3c>
        memmove(G_io_usb_ep_buffer, buffer, length);
c0de96f6:	480c      	ldr	r0, [pc, #48]	; (c0de9728 <u2f_io_send+0x40>)
c0de96f8:	464a      	mov	r2, r9
c0de96fa:	1815      	adds	r5, r2, r0
c0de96fc:	4628      	mov	r0, r5
c0de96fe:	4622      	mov	r2, r4
c0de9700:	f004 f892 	bl	c0ded828 <__aeabi_memmove>
c0de9704:	2640      	movs	r6, #64	; 0x40
        // wipe the remaining to avoid :
        // 1/ data leaks
        // 2/ invalid junk
        memset(G_io_usb_ep_buffer+length, 0, sizeof(G_io_usb_ep_buffer)-length);
c0de9706:	1b31      	subs	r1, r6, r4
c0de9708:	1928      	adds	r0, r5, r4
c0de970a:	f004 f883 	bl	c0ded814 <__aeabi_memclr>
c0de970e:	2081      	movs	r0, #129	; 0x81
c0de9710:	2300      	movs	r3, #0
    }
    switch (media) {
    case U2F_MEDIA_USB:
        io_usb_send_ep(U2F_EPIN_ADDR, G_io_usb_ep_buffer, USB_SEGMENT_SIZE, 0);
c0de9712:	4629      	mov	r1, r5
c0de9714:	4632      	mov	r2, r6
c0de9716:	f7fd ff1f 	bl	c0de7558 <io_usb_send_ep>
#endif
    default:
        PRINTF("Request to send on unsupported media %d\n", media);
        break;
    }
}
c0de971a:	bd70      	pop	{r4, r5, r6, pc}
        LEDGER_BLE_send(buffer, length);
c0de971c:	4608      	mov	r0, r1
c0de971e:	4621      	mov	r1, r4
c0de9720:	f7fb fe36 	bl	c0de5390 <LEDGER_BLE_send>
}
c0de9724:	bd70      	pop	{r4, r5, r6, pc}
c0de9726:	46c0      	nop			; (mov r8, r8)
c0de9728:	00000b54 	.word	0x00000b54

c0de972c <u2f_transport_init>:
}

/**
 * Initialize the u2f transport and provide the buffer into which to store incoming message
 */
void u2f_transport_init(u2f_service_t *service, uint8_t* message_buffer, uint16_t message_buffer_length) {
c0de972c:	2300      	movs	r3, #0
    service->transportPacketIndex = 0;
c0de972e:	7683      	strb	r3, [r0, #26]
    service->transportOffset = 0;
c0de9730:	82c3      	strh	r3, [r0, #22]
    service->next_channel = 1;
    service->transportReceiveBuffer = message_buffer;
    service->transportReceiveBufferLength = message_buffer_length;
c0de9732:	8202      	strh	r2, [r0, #16]
    service->transportReceiveBuffer = message_buffer;
c0de9734:	60c1      	str	r1, [r0, #12]
c0de9736:	2201      	movs	r2, #1
    service->next_channel = 1;
c0de9738:	6002      	str	r2, [r0, #0]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0de973a:	8543      	strh	r3, [r0, #42]	; 0x2a
    service->transportMedia = 0;
c0de973c:	8483      	strh	r3, [r0, #36]	; 0x24
    service->transportBuffer = service->transportReceiveBuffer;
c0de973e:	61c1      	str	r1, [r0, #28]
    service->transportMedia = 0;
c0de9740:	6203      	str	r3, [r0, #32]
    u2f_transport_reset(service);
}
c0de9742:	4770      	bx	lr

c0de9744 <u2f_transport_sent>:

/**
 * Function called when the previously scheduled message to be sent on the media is effectively sent.
 * And a new message can be scheduled.
 */
void u2f_transport_sent(u2f_service_t* service, u2f_transport_media_t media) {
c0de9744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de9746:	460d      	mov	r5, r1
c0de9748:	4604      	mov	r4, r0

    // don't process when replying to anti timeout requests
    if (!u2f_message_repliable(service)) {
c0de974a:	f000 f877 	bl	c0de983c <u2f_message_repliable>
c0de974e:	222b      	movs	r2, #43	; 0x2b
c0de9750:	2100      	movs	r1, #0
c0de9752:	54a1      	strb	r1, [r4, r2]
c0de9754:	2800      	cmp	r0, #0
c0de9756:	d01a      	beq.n	c0de978e <u2f_transport_sent+0x4a>
c0de9758:	4620      	mov	r0, r4
c0de975a:	3020      	adds	r0, #32

    // previous mark packet as sent
    service->sending = false;

    // if idle (possibly after an error), then only await for a transmission 
    if (service->transportState != U2F_SENDING_RESPONSE 
c0de975c:	7802      	ldrb	r2, [r0, #0]
        && service->transportState != U2F_SENDING_ERROR) {
c0de975e:	1ed2      	subs	r2, r2, #3
c0de9760:	2a01      	cmp	r2, #1
c0de9762:	d814      	bhi.n	c0de978e <u2f_transport_sent+0x4a>
        // absorb the error, transport is erroneous but that won't hurt in the end.
        // also absorb the fake channel user presence check reply ack
        //THROW(INVALID_STATE);
        return;
    }
    if (service->transportOffset < service->transportLength) {
c0de9764:	8b23      	ldrh	r3, [r4, #24]
c0de9766:	8ae7      	ldrh	r7, [r4, #22]
c0de9768:	42bb      	cmp	r3, r7
c0de976a:	d905      	bls.n	c0de9778 <u2f_transport_sent+0x34>
        uint16_t mtu = (media == U2F_MEDIA_USB) ? USB_SEGMENT_SIZE : BLE_SEGMENT_SIZE;
        uint16_t channelHeader =
            (media == U2F_MEDIA_USB ? 4 : 0);
        uint8_t headerSize =
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0de976c:	7ea0      	ldrb	r0, [r4, #26]
c0de976e:	9000      	str	r0, [sp, #0]
c0de9770:	2800      	cmp	r0, #0
c0de9772:	d00d      	beq.n	c0de9790 <u2f_transport_sent+0x4c>
c0de9774:	2001      	movs	r0, #1
c0de9776:	e00c      	b.n	c0de9792 <u2f_transport_sent+0x4e>
        service->transportOffset += blockSize;
        service->transportPacketIndex++;
        u2f_io_send(G_io_usb_ep_buffer, dataSize, media);
    }
    // last part sent
    else if (service->transportOffset == service->transportLength) {
c0de9778:	d109      	bne.n	c0de978e <u2f_transport_sent+0x4a>
    service->transportMedia = 0;
c0de977a:	6001      	str	r1, [r0, #0]
c0de977c:	8081      	strh	r1, [r0, #4]
        u2f_transport_reset(service);
        // we sent the whole response (even if we haven't yet received the ack for the last sent usb in packet)
        G_io_app.apdu_state = APDU_IDLE;
c0de977e:	4a2d      	ldr	r2, [pc, #180]	; (c0de9834 <u2f_transport_sent+0xf0>)
c0de9780:	464b      	mov	r3, r9
c0de9782:	5499      	strb	r1, [r3, r2]
    service->transportPacketIndex = 0;
c0de9784:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0de9786:	82e1      	strh	r1, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0de9788:	8141      	strh	r1, [r0, #10]
    service->transportBuffer = service->transportReceiveBuffer;
c0de978a:	68e0      	ldr	r0, [r4, #12]
c0de978c:	61e0      	str	r0, [r4, #28]
    }
}
c0de978e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de9790:	2003      	movs	r0, #3
        uint16_t mtu = (media == U2F_MEDIA_USB) ? USB_SEGMENT_SIZE : BLE_SEGMENT_SIZE;
c0de9792:	1e6e      	subs	r6, r5, #1
c0de9794:	4272      	negs	r2, r6
c0de9796:	4172      	adcs	r2, r6
c0de9798:	0092      	lsls	r2, r2, #2
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0de979a:	1880      	adds	r0, r0, r2
                                      (mtu - headerSize)
c0de979c:	2d01      	cmp	r5, #1
c0de979e:	d001      	beq.n	c0de97a4 <u2f_transport_sent+0x60>
c0de97a0:	2620      	movs	r6, #32
c0de97a2:	e000      	b.n	c0de97a6 <u2f_transport_sent+0x62>
c0de97a4:	2640      	movs	r6, #64	; 0x40
c0de97a6:	1a36      	subs	r6, r6, r0
        uint16_t blockSize = ((service->transportLength - service->transportOffset) >
c0de97a8:	1bdb      	subs	r3, r3, r7
c0de97aa:	42b3      	cmp	r3, r6
c0de97ac:	dc00      	bgt.n	c0de97b0 <u2f_transport_sent+0x6c>
c0de97ae:	461e      	mov	r6, r3
        if (media == U2F_MEDIA_USB) {
c0de97b0:	2d01      	cmp	r5, #1
c0de97b2:	d10b      	bne.n	c0de97cc <u2f_transport_sent+0x88>
            memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de97b4:	6861      	ldr	r1, [r4, #4]
c0de97b6:	4a20      	ldr	r2, [pc, #128]	; (c0de9838 <u2f_transport_sent+0xf4>)
c0de97b8:	464b      	mov	r3, r9
c0de97ba:	5499      	strb	r1, [r3, r2]
c0de97bc:	189a      	adds	r2, r3, r2
c0de97be:	0e0b      	lsrs	r3, r1, #24
c0de97c0:	70d3      	strb	r3, [r2, #3]
c0de97c2:	0c0b      	lsrs	r3, r1, #16
c0de97c4:	7093      	strb	r3, [r2, #2]
c0de97c6:	0a09      	lsrs	r1, r1, #8
c0de97c8:	7051      	strb	r1, [r2, #1]
c0de97ca:	2104      	movs	r1, #4
c0de97cc:	9a00      	ldr	r2, [sp, #0]
        if (service->transportPacketIndex == 0) {
c0de97ce:	2a00      	cmp	r2, #0
c0de97d0:	d001      	beq.n	c0de97d6 <u2f_transport_sent+0x92>
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
c0de97d2:	1e52      	subs	r2, r2, #1
c0de97d4:	e00c      	b.n	c0de97f0 <u2f_transport_sent+0xac>
c0de97d6:	4622      	mov	r2, r4
c0de97d8:	3240      	adds	r2, #64	; 0x40
            G_io_usb_ep_buffer[offset++] = service->sendCmd;
c0de97da:	4b17      	ldr	r3, [pc, #92]	; (c0de9838 <u2f_transport_sent+0xf4>)
c0de97dc:	464f      	mov	r7, r9
c0de97de:	18fb      	adds	r3, r7, r3
c0de97e0:	7812      	ldrb	r2, [r2, #0]
c0de97e2:	545a      	strb	r2, [r3, r1]
c0de97e4:	2201      	movs	r2, #1
c0de97e6:	430a      	orrs	r2, r1
            G_io_usb_ep_buffer[offset++] = (service->transportLength >> 8);
c0de97e8:	7e61      	ldrb	r1, [r4, #25]
c0de97ea:	5499      	strb	r1, [r3, r2]
c0de97ec:	1c51      	adds	r1, r2, #1
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
c0de97ee:	7e22      	ldrb	r2, [r4, #24]
c0de97f0:	1833      	adds	r3, r6, r0
c0de97f2:	9300      	str	r3, [sp, #0]
c0de97f4:	4607      	mov	r7, r0
c0de97f6:	4810      	ldr	r0, [pc, #64]	; (c0de9838 <u2f_transport_sent+0xf4>)
c0de97f8:	464b      	mov	r3, r9
c0de97fa:	181b      	adds	r3, r3, r0
c0de97fc:	545a      	strb	r2, [r3, r1]
        if (service->transportBuffer != NULL) {
c0de97fe:	69e1      	ldr	r1, [r4, #28]
c0de9800:	2900      	cmp	r1, #0
c0de9802:	d008      	beq.n	c0de9816 <u2f_transport_sent+0xd2>
c0de9804:	b2b2      	uxth	r2, r6
            memmove(G_io_usb_ep_buffer + headerSize,
c0de9806:	464b      	mov	r3, r9
c0de9808:	480b      	ldr	r0, [pc, #44]	; (c0de9838 <u2f_transport_sent+0xf4>)
c0de980a:	181b      	adds	r3, r3, r0
c0de980c:	19d8      	adds	r0, r3, r7
                       service->transportBuffer + service->transportOffset, blockSize);
c0de980e:	8ae3      	ldrh	r3, [r4, #22]
c0de9810:	18c9      	adds	r1, r1, r3
            memmove(G_io_usb_ep_buffer + headerSize,
c0de9812:	f004 f809 	bl	c0ded828 <__aeabi_memmove>
        service->transportOffset += blockSize;
c0de9816:	8ae0      	ldrh	r0, [r4, #22]
c0de9818:	1980      	adds	r0, r0, r6
c0de981a:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0de981c:	7ea0      	ldrb	r0, [r4, #26]
c0de981e:	1c40      	adds	r0, r0, #1
c0de9820:	76a0      	strb	r0, [r4, #26]
        u2f_io_send(G_io_usb_ep_buffer, dataSize, media);
c0de9822:	4648      	mov	r0, r9
c0de9824:	4904      	ldr	r1, [pc, #16]	; (c0de9838 <u2f_transport_sent+0xf4>)
c0de9826:	1840      	adds	r0, r0, r1
c0de9828:	9900      	ldr	r1, [sp, #0]
c0de982a:	b289      	uxth	r1, r1
c0de982c:	462a      	mov	r2, r5
c0de982e:	f7ff ff5b 	bl	c0de96e8 <u2f_io_send>
}
c0de9832:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de9834:	00000ae4 	.word	0x00000ae4
c0de9838:	00000b54 	.word	0x00000b54

c0de983c <u2f_message_repliable>:
    else if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
        service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_REPLY_READY;
    }
}

bool u2f_message_repliable(u2f_service_t* service) {
c0de983c:	212a      	movs	r1, #42	; 0x2a
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0de983e:	5c41      	ldrb	r1, [r0, r1]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0de9840:	2900      	cmp	r1, #0
c0de9842:	d00b      	beq.n	c0de985c <u2f_message_repliable+0x20>
c0de9844:	2901      	cmp	r1, #1
c0de9846:	d007      	beq.n	c0de9858 <u2f_message_repliable+0x1c>
c0de9848:	3025      	adds	r0, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0de984a:	7801      	ldrb	r1, [r0, #0]
            && service->sending == false)
c0de984c:	2906      	cmp	r1, #6
c0de984e:	d103      	bne.n	c0de9858 <u2f_message_repliable+0x1c>
c0de9850:	7981      	ldrb	r1, [r0, #6]
c0de9852:	4248      	negs	r0, r1
c0de9854:	4148      	adcs	r0, r1
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0de9856:	4770      	bx	lr
c0de9858:	2000      	movs	r0, #0
c0de985a:	4770      	bx	lr
c0de985c:	2001      	movs	r0, #1
c0de985e:	4770      	bx	lr

c0de9860 <u2f_transport_send_usb_user_presence_required>:
void u2f_transport_send_usb_user_presence_required(u2f_service_t *service) {
c0de9860:	b580      	push	{r7, lr}
c0de9862:	212b      	movs	r1, #43	; 0x2b
c0de9864:	2201      	movs	r2, #1
    service->sending = true;
c0de9866:	5442      	strb	r2, [r0, r1]
    memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de9868:	6841      	ldr	r1, [r0, #4]
c0de986a:	480c      	ldr	r0, [pc, #48]	; (c0de989c <u2f_transport_send_usb_user_presence_required+0x3c>)
c0de986c:	464b      	mov	r3, r9
c0de986e:	5419      	strb	r1, [r3, r0]
c0de9870:	1818      	adds	r0, r3, r0
c0de9872:	2383      	movs	r3, #131	; 0x83
    G_io_usb_ep_buffer[offset++] = U2F_CMD_MSG;
c0de9874:	7103      	strb	r3, [r0, #4]
c0de9876:	2300      	movs	r3, #0
    G_io_usb_ep_buffer[offset++] = 0;
c0de9878:	7143      	strb	r3, [r0, #5]
c0de987a:	2302      	movs	r3, #2
    G_io_usb_ep_buffer[offset++] = 2;
c0de987c:	7183      	strb	r3, [r0, #6]
c0de987e:	2369      	movs	r3, #105	; 0x69
    G_io_usb_ep_buffer[offset++] = 0x69;
c0de9880:	71c3      	strb	r3, [r0, #7]
c0de9882:	2385      	movs	r3, #133	; 0x85
    G_io_usb_ep_buffer[offset++] = 0x85;
c0de9884:	7203      	strb	r3, [r0, #8]
    memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de9886:	0e0b      	lsrs	r3, r1, #24
c0de9888:	70c3      	strb	r3, [r0, #3]
c0de988a:	0c0b      	lsrs	r3, r1, #16
c0de988c:	7083      	strb	r3, [r0, #2]
c0de988e:	0a09      	lsrs	r1, r1, #8
c0de9890:	7041      	strb	r1, [r0, #1]
c0de9892:	2109      	movs	r1, #9
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0de9894:	f7ff ff28 	bl	c0de96e8 <u2f_io_send>
}
c0de9898:	bd80      	pop	{r7, pc}
c0de989a:	46c0      	nop			; (mov r8, r8)
c0de989c:	00000b54 	.word	0x00000b54

c0de98a0 <u2f_transport_send_wink>:
void u2f_transport_send_wink(u2f_service_t *service) {
c0de98a0:	b580      	push	{r7, lr}
c0de98a2:	212b      	movs	r1, #43	; 0x2b
c0de98a4:	2201      	movs	r2, #1
    service->sending = true;
c0de98a6:	5442      	strb	r2, [r0, r1]
    memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de98a8:	6841      	ldr	r1, [r0, #4]
c0de98aa:	4809      	ldr	r0, [pc, #36]	; (c0de98d0 <u2f_transport_send_wink+0x30>)
c0de98ac:	464b      	mov	r3, r9
c0de98ae:	5419      	strb	r1, [r3, r0]
c0de98b0:	1818      	adds	r0, r3, r0
c0de98b2:	2388      	movs	r3, #136	; 0x88
    G_io_usb_ep_buffer[offset++] = U2F_CMD_WINK;
c0de98b4:	7103      	strb	r3, [r0, #4]
c0de98b6:	2300      	movs	r3, #0
    G_io_usb_ep_buffer[offset++] = 0;
c0de98b8:	7143      	strb	r3, [r0, #5]
    G_io_usb_ep_buffer[offset++] = 0;
c0de98ba:	7183      	strb	r3, [r0, #6]
    memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de98bc:	0e0b      	lsrs	r3, r1, #24
c0de98be:	70c3      	strb	r3, [r0, #3]
c0de98c0:	0c0b      	lsrs	r3, r1, #16
c0de98c2:	7083      	strb	r3, [r0, #2]
c0de98c4:	0a09      	lsrs	r1, r1, #8
c0de98c6:	7041      	strb	r1, [r0, #1]
c0de98c8:	2107      	movs	r1, #7
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0de98ca:	f7ff ff0d 	bl	c0de96e8 <u2f_io_send>
}
c0de98ce:	bd80      	pop	{r7, pc}
c0de98d0:	00000b54 	.word	0x00000b54

c0de98d4 <u2f_transport_receive_fakeChannel>:
bool u2f_transport_receive_fakeChannel(u2f_service_t *service, uint8_t *buffer, uint16_t size) {
c0de98d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de98d6:	4604      	mov	r4, r0
c0de98d8:	2025      	movs	r0, #37	; 0x25
    if (service->fakeChannelTransportState == U2F_INTERNAL_ERROR) {
c0de98da:	5c20      	ldrb	r0, [r4, r0]
c0de98dc:	2805      	cmp	r0, #5
c0de98de:	d101      	bne.n	c0de98e4 <u2f_transport_receive_fakeChannel+0x10>
c0de98e0:	2500      	movs	r5, #0
c0de98e2:	e05d      	b.n	c0de99a0 <u2f_transport_receive_fakeChannel+0xcc>
c0de98e4:	4626      	mov	r6, r4
c0de98e6:	3624      	adds	r6, #36	; 0x24
    if (memcmp(service->channel, buffer, 4) != 0) {
c0de98e8:	7808      	ldrb	r0, [r1, #0]
c0de98ea:	784b      	ldrb	r3, [r1, #1]
c0de98ec:	021b      	lsls	r3, r3, #8
c0de98ee:	1818      	adds	r0, r3, r0
c0de98f0:	788b      	ldrb	r3, [r1, #2]
c0de98f2:	78cd      	ldrb	r5, [r1, #3]
c0de98f4:	022d      	lsls	r5, r5, #8
c0de98f6:	18eb      	adds	r3, r5, r3
c0de98f8:	041b      	lsls	r3, r3, #16
c0de98fa:	1818      	adds	r0, r3, r0
c0de98fc:	7923      	ldrb	r3, [r4, #4]
c0de98fe:	7965      	ldrb	r5, [r4, #5]
c0de9900:	022d      	lsls	r5, r5, #8
c0de9902:	18eb      	adds	r3, r5, r3
c0de9904:	79a5      	ldrb	r5, [r4, #6]
c0de9906:	79e7      	ldrb	r7, [r4, #7]
c0de9908:	023f      	lsls	r7, r7, #8
c0de990a:	197d      	adds	r5, r7, r5
c0de990c:	042d      	lsls	r5, r5, #16
c0de990e:	18eb      	adds	r3, r5, r3
c0de9910:	4283      	cmp	r3, r0
c0de9912:	d147      	bne.n	c0de99a4 <u2f_transport_receive_fakeChannel+0xd0>
c0de9914:	790b      	ldrb	r3, [r1, #4]
    if (service->fakeChannelTransportOffset == 0) {        
c0de9916:	8c60      	ldrh	r0, [r4, #34]	; 0x22
c0de9918:	2800      	cmp	r0, #0
c0de991a:	d010      	beq.n	c0de993e <u2f_transport_receive_fakeChannel+0x6a>
        if (buffer[4] != service->fakeChannelTransportPacketIndex) {
c0de991c:	7835      	ldrb	r5, [r6, #0]
c0de991e:	42ab      	cmp	r3, r5
c0de9920:	d140      	bne.n	c0de99a4 <u2f_transport_receive_fakeChannel+0xd0>
        service->fakeChannelTransportPacketIndex++;
c0de9922:	1c5b      	adds	r3, r3, #1
c0de9924:	7033      	strb	r3, [r6, #0]
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0de9926:	8b23      	ldrh	r3, [r4, #24]
c0de9928:	1a1b      	subs	r3, r3, r0
c0de992a:	1f52      	subs	r2, r2, #5
c0de992c:	429a      	cmp	r2, r3
c0de992e:	db00      	blt.n	c0de9932 <u2f_transport_receive_fakeChannel+0x5e>
c0de9930:	461a      	mov	r2, r3
        service->fakeChannelTransportOffset += xfer_len;
c0de9932:	1880      	adds	r0, r0, r2
c0de9934:	8460      	strh	r0, [r4, #34]	; 0x22
c0de9936:	b292      	uxth	r2, r2
        service->fakeChannelCrc = cx_crc16_update(service->fakeChannelCrc, buffer + 5, xfer_len);   
c0de9938:	8d20      	ldrh	r0, [r4, #40]	; 0x28
c0de993a:	1d49      	adds	r1, r1, #5
c0de993c:	e01a      	b.n	c0de9974 <u2f_transport_receive_fakeChannel+0xa0>
        if (buffer[4] == U2F_CMD_WINK) {
c0de993e:	2b88      	cmp	r3, #136	; 0x88
c0de9940:	d104      	bne.n	c0de994c <u2f_transport_receive_fakeChannel+0x78>
            u2f_transport_send_wink(service);
c0de9942:	4620      	mov	r0, r4
c0de9944:	f7ff ffac 	bl	c0de98a0 <u2f_transport_send_wink>
c0de9948:	2501      	movs	r5, #1
c0de994a:	e029      	b.n	c0de99a0 <u2f_transport_receive_fakeChannel+0xcc>
        if (commandLength != service->transportLength) {
c0de994c:	2b83      	cmp	r3, #131	; 0x83
c0de994e:	d129      	bne.n	c0de99a4 <u2f_transport_receive_fakeChannel+0xd0>
c0de9950:	7988      	ldrb	r0, [r1, #6]
c0de9952:	794b      	ldrb	r3, [r1, #5]
c0de9954:	021b      	lsls	r3, r3, #8
c0de9956:	1818      	adds	r0, r3, r0
c0de9958:	1cc0      	adds	r0, r0, #3
c0de995a:	8b23      	ldrh	r3, [r4, #24]
c0de995c:	b280      	uxth	r0, r0
c0de995e:	4298      	cmp	r0, r3
c0de9960:	d120      	bne.n	c0de99a4 <u2f_transport_receive_fakeChannel+0xd0>
c0de9962:	1d09      	adds	r1, r1, #4
c0de9964:	2000      	movs	r0, #0
        service->fakeChannelTransportPacketIndex = 0;
c0de9966:	7030      	strb	r0, [r6, #0]
        service->fakeChannelTransportOffset = MIN(size - 4, service->transportLength);
c0de9968:	1f12      	subs	r2, r2, #4
c0de996a:	429a      	cmp	r2, r3
c0de996c:	db00      	blt.n	c0de9970 <u2f_transport_receive_fakeChannel+0x9c>
c0de996e:	461a      	mov	r2, r3
c0de9970:	8462      	strh	r2, [r4, #34]	; 0x22
        service->fakeChannelCrc = cx_crc16_update(0, buffer + 4, service->fakeChannelTransportOffset);
c0de9972:	b292      	uxth	r2, r2
c0de9974:	f7f9 fb4c 	bl	c0de3010 <cx_crc16_update>
c0de9978:	8520      	strh	r0, [r4, #40]	; 0x28
    if (service->fakeChannelTransportOffset >= service->transportLength) {
c0de997a:	8b21      	ldrh	r1, [r4, #24]
c0de997c:	8c62      	ldrh	r2, [r4, #34]	; 0x22
c0de997e:	2501      	movs	r5, #1
c0de9980:	428a      	cmp	r2, r1
c0de9982:	d30d      	bcc.n	c0de99a0 <u2f_transport_receive_fakeChannel+0xcc>
        if (service->fakeChannelCrc != service->commandCrc) {
c0de9984:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
c0de9986:	4288      	cmp	r0, r1
c0de9988:	d10c      	bne.n	c0de99a4 <u2f_transport_receive_fakeChannel+0xd0>
c0de998a:	2700      	movs	r7, #0
        service->fakeChannelTransportOffset = 0;
c0de998c:	8467      	strh	r7, [r4, #34]	; 0x22
c0de998e:	2006      	movs	r0, #6
        service->fakeChannelTransportState = U2F_FAKE_RECEIVED;
c0de9990:	7070      	strb	r0, [r6, #1]
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0de9992:	79b0      	ldrb	r0, [r6, #6]
c0de9994:	2801      	cmp	r0, #1
c0de9996:	d103      	bne.n	c0de99a0 <u2f_transport_receive_fakeChannel+0xcc>
            u2f_transport_send_usb_user_presence_required(service);
c0de9998:	4620      	mov	r0, r4
c0de999a:	f7ff ff61 	bl	c0de9860 <u2f_transport_send_usb_user_presence_required>
            service->fakeChannelTransportState = U2F_IDLE;
c0de999e:	7077      	strb	r7, [r6, #1]
}
c0de99a0:	4628      	mov	r0, r5
c0de99a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de99a4:	2005      	movs	r0, #5
    service->fakeChannelTransportState = U2F_INTERNAL_ERROR;
c0de99a6:	7070      	strb	r0, [r6, #1]
    THROW(EXCEPTION_IO_RESET);
c0de99a8:	f7fd fd3d 	bl	c0de7426 <os_longjmp>

c0de99ac <u2f_transport_received>:
                          uint16_t size, u2f_transport_media_t media) {
c0de99ac:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de99ae:	b087      	sub	sp, #28
c0de99b0:	460f      	mov	r7, r1
c0de99b2:	4604      	mov	r4, r0
    service->media = media;
c0de99b4:	7203      	strb	r3, [r0, #8]
c0de99b6:	2020      	movs	r0, #32
    if (service->transportState == U2F_SENDING_RESPONSE) {
c0de99b8:	5c21      	ldrb	r1, [r4, r0]
c0de99ba:	2903      	cmp	r1, #3
c0de99bc:	d00a      	beq.n	c0de99d4 <u2f_transport_received+0x28>
c0de99be:	4626      	mov	r6, r4
c0de99c0:	3612      	adds	r6, #18
    if (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_IDLE) {
c0de99c2:	7e30      	ldrb	r0, [r6, #24]
c0de99c4:	2800      	cmp	r0, #0
c0de99c6:	d00b      	beq.n	c0de99e0 <u2f_transport_received+0x34>
        if (!u2f_transport_receive_fakeChannel(service, buffer, size)) {
c0de99c8:	4620      	mov	r0, r4
c0de99ca:	4639      	mov	r1, r7
c0de99cc:	f7ff ff82 	bl	c0de98d4 <u2f_transport_receive_fakeChannel>
c0de99d0:	2800      	cmp	r0, #0
c0de99d2:	d103      	bne.n	c0de99dc <u2f_transport_received+0x30>
c0de99d4:	2106      	movs	r1, #6
c0de99d6:	4620      	mov	r0, r4
c0de99d8:	f000 f962 	bl	c0de9ca0 <u2f_transport_error>
}
c0de99dc:	b007      	add	sp, #28
c0de99de:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de99e0:	461d      	mov	r5, r3
c0de99e2:	9206      	str	r2, [sp, #24]
c0de99e4:	4623      	mov	r3, r4
c0de99e6:	3320      	adds	r3, #32
    if (service->transportState == U2F_SENDING_ERROR) {
c0de99e8:	2904      	cmp	r1, #4
c0de99ea:	d107      	bne.n	c0de99fc <u2f_transport_received+0x50>
c0de99ec:	2100      	movs	r1, #0
    service->transportPacketIndex = 0;
c0de99ee:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0de99f0:	82e1      	strh	r1, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0de99f2:	8331      	strh	r1, [r6, #24]
    service->transportMedia = 0;
c0de99f4:	6019      	str	r1, [r3, #0]
c0de99f6:	8099      	strh	r1, [r3, #4]
    service->transportBuffer = service->transportReceiveBuffer;
c0de99f8:	68e0      	ldr	r0, [r4, #12]
c0de99fa:	61e0      	str	r0, [r4, #28]
    uint16_t channelHeader = (media == U2F_MEDIA_USB ? 4 : 0);
c0de99fc:	1e68      	subs	r0, r5, #1
c0de99fe:	4242      	negs	r2, r0
c0de9a00:	4142      	adcs	r2, r0
    if (size < (1 + channelHeader)) {
c0de9a02:	0090      	lsls	r0, r2, #2
c0de9a04:	9005      	str	r0, [sp, #20]
c0de9a06:	1c40      	adds	r0, r0, #1
c0de9a08:	9a06      	ldr	r2, [sp, #24]
c0de9a0a:	4290      	cmp	r0, r2
c0de9a0c:	d900      	bls.n	c0de9a10 <u2f_transport_received+0x64>
c0de9a0e:	e084      	b.n	c0de9b1a <u2f_transport_received+0x16e>
c0de9a10:	9004      	str	r0, [sp, #16]
c0de9a12:	9303      	str	r3, [sp, #12]
    if (media == U2F_MEDIA_USB) {
c0de9a14:	2d01      	cmp	r5, #1
c0de9a16:	d10b      	bne.n	c0de9a30 <u2f_transport_received+0x84>
        memcpy(service->channel, buffer, 4);
c0de9a18:	783a      	ldrb	r2, [r7, #0]
c0de9a1a:	787b      	ldrb	r3, [r7, #1]
c0de9a1c:	021b      	lsls	r3, r3, #8
c0de9a1e:	189a      	adds	r2, r3, r2
c0de9a20:	78bb      	ldrb	r3, [r7, #2]
c0de9a22:	78f8      	ldrb	r0, [r7, #3]
c0de9a24:	0200      	lsls	r0, r0, #8
c0de9a26:	18c0      	adds	r0, r0, r3
c0de9a28:	0400      	lsls	r0, r0, #16
c0de9a2a:	1880      	adds	r0, r0, r2
c0de9a2c:	9a06      	ldr	r2, [sp, #24]
c0de9a2e:	6060      	str	r0, [r4, #4]
    if (service->transportOffset == 0
c0de9a30:	8ae3      	ldrh	r3, [r4, #22]
        || (media == U2F_MEDIA_USB && memcmp(service->transportChannel, service->channel, 4) != 0)
c0de9a32:	2b00      	cmp	r3, #0
c0de9a34:	d022      	beq.n	c0de9a7c <u2f_transport_received+0xd0>
c0de9a36:	2d01      	cmp	r5, #1
c0de9a38:	d11c      	bne.n	c0de9a74 <u2f_transport_received+0xc8>
c0de9a3a:	7920      	ldrb	r0, [r4, #4]
c0de9a3c:	9302      	str	r3, [sp, #8]
c0de9a3e:	7963      	ldrb	r3, [r4, #5]
c0de9a40:	021b      	lsls	r3, r3, #8
c0de9a42:	1818      	adds	r0, r3, r0
c0de9a44:	79a3      	ldrb	r3, [r4, #6]
c0de9a46:	79e2      	ldrb	r2, [r4, #7]
c0de9a48:	0212      	lsls	r2, r2, #8
c0de9a4a:	18d2      	adds	r2, r2, r3
c0de9a4c:	0412      	lsls	r2, r2, #16
c0de9a4e:	1810      	adds	r0, r2, r0
c0de9a50:	9001      	str	r0, [sp, #4]
c0de9a52:	7ca2      	ldrb	r2, [r4, #18]
c0de9a54:	7ce3      	ldrb	r3, [r4, #19]
c0de9a56:	021b      	lsls	r3, r3, #8
c0de9a58:	189a      	adds	r2, r3, r2
c0de9a5a:	7d23      	ldrb	r3, [r4, #20]
c0de9a5c:	7d60      	ldrb	r0, [r4, #21]
c0de9a5e:	0200      	lsls	r0, r0, #8
c0de9a60:	18c0      	adds	r0, r0, r3
c0de9a62:	9b02      	ldr	r3, [sp, #8]
c0de9a64:	0400      	lsls	r0, r0, #16
c0de9a66:	1880      	adds	r0, r0, r2
c0de9a68:	9a06      	ldr	r2, [sp, #24]
c0de9a6a:	9700      	str	r7, [sp, #0]
        || (buffer[channelHeader] == U2F_CMD_INIT)) {
c0de9a6c:	9f01      	ldr	r7, [sp, #4]
c0de9a6e:	42b8      	cmp	r0, r7
c0de9a70:	9f00      	ldr	r7, [sp, #0]
c0de9a72:	d103      	bne.n	c0de9a7c <u2f_transport_received+0xd0>
c0de9a74:	9805      	ldr	r0, [sp, #20]
c0de9a76:	5c38      	ldrb	r0, [r7, r0]
    if (service->transportOffset == 0
c0de9a78:	2886      	cmp	r0, #134	; 0x86
c0de9a7a:	d147      	bne.n	c0de9b0c <u2f_transport_received+0x160>
c0de9a7c:	2003      	movs	r0, #3
c0de9a7e:	9b05      	ldr	r3, [sp, #20]
        if (size < (channelHeader + 3)) {
c0de9a80:	4318      	orrs	r0, r3
c0de9a82:	4290      	cmp	r0, r2
c0de9a84:	d849      	bhi.n	c0de9b1a <u2f_transport_received+0x16e>
        if ((buffer[channelHeader+0]&U2F_MASK_COMMAND) == 0) {
c0de9a86:	56fa      	ldrsb	r2, [r7, r3]
c0de9a88:	2a00      	cmp	r2, #0
c0de9a8a:	d5a7      	bpl.n	c0de99dc <u2f_transport_received+0x30>
c0de9a8c:	b2d2      	uxtb	r2, r2
        if (media == U2F_MEDIA_USB) {
c0de9a8e:	2d01      	cmp	r5, #1
c0de9a90:	d000      	beq.n	c0de9a94 <u2f_transport_received+0xe8>
c0de9a92:	e089      	b.n	c0de9ba8 <u2f_transport_received+0x1fc>
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0de9a94:	2901      	cmp	r1, #1
c0de9a96:	d000      	beq.n	c0de9a9a <u2f_transport_received+0xee>
c0de9a98:	e08e      	b.n	c0de9bb8 <u2f_transport_received+0x20c>
                (memcmp(service->channel, service->transportChannel, 4) !=
c0de9a9a:	7ca0      	ldrb	r0, [r4, #18]
c0de9a9c:	7ce3      	ldrb	r3, [r4, #19]
c0de9a9e:	021b      	lsls	r3, r3, #8
c0de9aa0:	1818      	adds	r0, r3, r0
c0de9aa2:	9002      	str	r0, [sp, #8]
c0de9aa4:	7d23      	ldrb	r3, [r4, #20]
c0de9aa6:	7d60      	ldrb	r0, [r4, #21]
c0de9aa8:	0200      	lsls	r0, r0, #8
c0de9aaa:	18c0      	adds	r0, r0, r3
c0de9aac:	0400      	lsls	r0, r0, #16
c0de9aae:	9b02      	ldr	r3, [sp, #8]
c0de9ab0:	18c0      	adds	r0, r0, r3
c0de9ab2:	9002      	str	r0, [sp, #8]
c0de9ab4:	7923      	ldrb	r3, [r4, #4]
c0de9ab6:	7960      	ldrb	r0, [r4, #5]
c0de9ab8:	0200      	lsls	r0, r0, #8
c0de9aba:	18c0      	adds	r0, r0, r3
c0de9abc:	9001      	str	r0, [sp, #4]
c0de9abe:	79a3      	ldrb	r3, [r4, #6]
c0de9ac0:	79e0      	ldrb	r0, [r4, #7]
c0de9ac2:	0200      	lsls	r0, r0, #8
c0de9ac4:	18c0      	adds	r0, r0, r3
c0de9ac6:	0400      	lsls	r0, r0, #16
c0de9ac8:	9b01      	ldr	r3, [sp, #4]
c0de9aca:	18c0      	adds	r0, r0, r3
c0de9acc:	9b02      	ldr	r3, [sp, #8]
c0de9ace:	1ac3      	subs	r3, r0, r3
c0de9ad0:	1e58      	subs	r0, r3, #1
c0de9ad2:	4183      	sbcs	r3, r0
                 0) &&
c0de9ad4:	2a86      	cmp	r2, #134	; 0x86
c0de9ad6:	d067      	beq.n	c0de9ba8 <u2f_transport_received+0x1fc>
c0de9ad8:	2b00      	cmp	r3, #0
c0de9ada:	d065      	beq.n	c0de9ba8 <u2f_transport_received+0x1fc>
c0de9adc:	1d20      	adds	r0, r4, #4
                    memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de9ade:	6801      	ldr	r1, [r0, #0]
c0de9ae0:	486e      	ldr	r0, [pc, #440]	; (c0de9c9c <u2f_transport_received+0x2f0>)
c0de9ae2:	464a      	mov	r2, r9
c0de9ae4:	5411      	strb	r1, [r2, r0]
c0de9ae6:	1810      	adds	r0, r2, r0
c0de9ae8:	2206      	movs	r2, #6
                G_io_usb_ep_buffer[offset++] = ERROR_CHANNEL_BUSY;
c0de9aea:	71c2      	strb	r2, [r0, #7]
c0de9aec:	2201      	movs	r2, #1
                G_io_usb_ep_buffer[offset++] = 1;
c0de9aee:	7182      	strb	r2, [r0, #6]
c0de9af0:	2300      	movs	r3, #0
                G_io_usb_ep_buffer[offset++] = 0;
c0de9af2:	7143      	strb	r3, [r0, #5]
c0de9af4:	23bf      	movs	r3, #191	; 0xbf
                G_io_usb_ep_buffer[offset++] = U2F_STATUS_ERROR;
c0de9af6:	7103      	strb	r3, [r0, #4]
                    memcpy(G_io_usb_ep_buffer, service->channel, 4);
c0de9af8:	0e0b      	lsrs	r3, r1, #24
c0de9afa:	70c3      	strb	r3, [r0, #3]
c0de9afc:	0c0b      	lsrs	r3, r1, #16
c0de9afe:	7083      	strb	r3, [r0, #2]
c0de9b00:	0a09      	lsrs	r1, r1, #8
c0de9b02:	7041      	strb	r1, [r0, #1]
c0de9b04:	2108      	movs	r1, #8
                u2f_io_send(G_io_usb_ep_buffer, offset, media);
c0de9b06:	f7ff fdef 	bl	c0de96e8 <u2f_io_send>
c0de9b0a:	e767      	b.n	c0de99dc <u2f_transport_received+0x30>
c0de9b0c:	9001      	str	r0, [sp, #4]
c0de9b0e:	9302      	str	r3, [sp, #8]
c0de9b10:	2002      	movs	r0, #2
        if (size < (channelHeader + 2)) {
c0de9b12:	9b05      	ldr	r3, [sp, #20]
c0de9b14:	4318      	orrs	r0, r3
c0de9b16:	4290      	cmp	r0, r2
c0de9b18:	d901      	bls.n	c0de9b1e <u2f_transport_received+0x172>
c0de9b1a:	2185      	movs	r1, #133	; 0x85
c0de9b1c:	e75b      	b.n	c0de99d6 <u2f_transport_received+0x2a>
        if (media != service->transportMedia) {
c0de9b1e:	7bf0      	ldrb	r0, [r6, #15]
c0de9b20:	42a8      	cmp	r0, r5
c0de9b22:	d155      	bne.n	c0de9bd0 <u2f_transport_received+0x224>
        if (service->transportState != U2F_HANDLE_SEGMENTED) {
c0de9b24:	2901      	cmp	r1, #1
c0de9b26:	d166      	bne.n	c0de9bf6 <u2f_transport_received+0x24a>
        if (media == U2F_MEDIA_USB) {
c0de9b28:	2d01      	cmp	r5, #1
c0de9b2a:	d117      	bne.n	c0de9b5c <u2f_transport_received+0x1b0>
            if (memcmp(buffer, service->channel, 4) != 0) {
c0de9b2c:	7920      	ldrb	r0, [r4, #4]
c0de9b2e:	7961      	ldrb	r1, [r4, #5]
c0de9b30:	0209      	lsls	r1, r1, #8
c0de9b32:	1808      	adds	r0, r1, r0
c0de9b34:	79a1      	ldrb	r1, [r4, #6]
c0de9b36:	79e2      	ldrb	r2, [r4, #7]
c0de9b38:	0212      	lsls	r2, r2, #8
c0de9b3a:	1851      	adds	r1, r2, r1
c0de9b3c:	0409      	lsls	r1, r1, #16
c0de9b3e:	1808      	adds	r0, r1, r0
c0de9b40:	7839      	ldrb	r1, [r7, #0]
c0de9b42:	787a      	ldrb	r2, [r7, #1]
c0de9b44:	0212      	lsls	r2, r2, #8
c0de9b46:	1851      	adds	r1, r2, r1
c0de9b48:	78ba      	ldrb	r2, [r7, #2]
c0de9b4a:	78fe      	ldrb	r6, [r7, #3]
c0de9b4c:	0236      	lsls	r6, r6, #8
c0de9b4e:	18b2      	adds	r2, r6, r2
c0de9b50:	0412      	lsls	r2, r2, #16
c0de9b52:	1851      	adds	r1, r2, r1
c0de9b54:	9a06      	ldr	r2, [sp, #24]
c0de9b56:	4281      	cmp	r1, r0
c0de9b58:	d000      	beq.n	c0de9b5c <u2f_transport_received+0x1b0>
c0de9b5a:	e73b      	b.n	c0de99d4 <u2f_transport_received+0x28>
        if (buffer[channelHeader] != service->transportPacketIndex) {
c0de9b5c:	7ea0      	ldrb	r0, [r4, #26]
c0de9b5e:	9901      	ldr	r1, [sp, #4]
c0de9b60:	4281      	cmp	r1, r0
c0de9b62:	d154      	bne.n	c0de9c0e <u2f_transport_received+0x262>
c0de9b64:	9805      	ldr	r0, [sp, #20]
c0de9b66:	1839      	adds	r1, r7, r0
        xfer_len = MIN(size - (channelHeader + 1), service->transportLength - service->transportOffset);
c0de9b68:	9804      	ldr	r0, [sp, #16]
c0de9b6a:	1a17      	subs	r7, r2, r0
c0de9b6c:	8b20      	ldrh	r0, [r4, #24]
c0de9b6e:	9a02      	ldr	r2, [sp, #8]
c0de9b70:	1a80      	subs	r0, r0, r2
c0de9b72:	4287      	cmp	r7, r0
c0de9b74:	db00      	blt.n	c0de9b78 <u2f_transport_received+0x1cc>
c0de9b76:	4607      	mov	r7, r0
        memmove(service->transportBuffer + service->transportOffset, buffer + channelHeader + 1, xfer_len);
c0de9b78:	b2be      	uxth	r6, r7
c0de9b7a:	69e0      	ldr	r0, [r4, #28]
c0de9b7c:	1880      	adds	r0, r0, r2
c0de9b7e:	1c49      	adds	r1, r1, #1
c0de9b80:	4632      	mov	r2, r6
c0de9b82:	f003 fe51 	bl	c0ded828 <__aeabi_memmove>
        if (media == U2F_MEDIA_USB) {
c0de9b86:	2d01      	cmp	r5, #1
c0de9b88:	d107      	bne.n	c0de9b9a <u2f_transport_received+0x1ee>
            service->commandCrc = cx_crc16_update(service->commandCrc, service->transportBuffer + service->transportOffset, xfer_len);
c0de9b8a:	8ae0      	ldrh	r0, [r4, #22]
c0de9b8c:	69e1      	ldr	r1, [r4, #28]
c0de9b8e:	1809      	adds	r1, r1, r0
c0de9b90:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
c0de9b92:	4632      	mov	r2, r6
c0de9b94:	f7f9 fa3c 	bl	c0de3010 <cx_crc16_update>
c0de9b98:	84e0      	strh	r0, [r4, #38]	; 0x26
        service->transportOffset += xfer_len;
c0de9b9a:	8ae0      	ldrh	r0, [r4, #22]
c0de9b9c:	19c7      	adds	r7, r0, r7
c0de9b9e:	82e7      	strh	r7, [r4, #22]
        service->transportPacketIndex++;
c0de9ba0:	7ea0      	ldrb	r0, [r4, #26]
c0de9ba2:	1c40      	adds	r0, r0, #1
c0de9ba4:	76a0      	strb	r0, [r4, #26]
c0de9ba6:	e061      	b.n	c0de9c6c <u2f_transport_received+0x2c0>
c0de9ba8:	2086      	movs	r0, #134	; 0x86
              (buffer[channelHeader] == U2F_CMD_INIT))) {
c0de9baa:	4050      	eors	r0, r2
c0de9bac:	2301      	movs	r3, #1
    uint16_t channelHeader = (media == U2F_MEDIA_USB ? 4 : 0);
c0de9bae:	406b      	eors	r3, r5
            !((media == U2F_MEDIA_USB) &&
c0de9bb0:	4303      	orrs	r3, r0
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0de9bb2:	d001      	beq.n	c0de9bb8 <u2f_transport_received+0x20c>
c0de9bb4:	2901      	cmp	r1, #1
c0de9bb6:	d02a      	beq.n	c0de9c0e <u2f_transport_received+0x262>
c0de9bb8:	9904      	ldr	r1, [sp, #16]
  return (buf[off] << 8) | buf[off + 1];
c0de9bba:	1878      	adds	r0, r7, r1
c0de9bbc:	7840      	ldrb	r0, [r0, #1]
c0de9bbe:	5c79      	ldrb	r1, [r7, r1]
c0de9bc0:	0209      	lsls	r1, r1, #8
c0de9bc2:	1809      	adds	r1, r1, r0
        if (commandLength > (service->transportReceiveBufferLength - 3)) {
c0de9bc4:	8a20      	ldrh	r0, [r4, #16]
c0de9bc6:	1ec0      	subs	r0, r0, #3
c0de9bc8:	4288      	cmp	r0, r1
c0de9bca:	da03      	bge.n	c0de9bd4 <u2f_transport_received+0x228>
c0de9bcc:	2103      	movs	r1, #3
c0de9bce:	e702      	b.n	c0de99d6 <u2f_transport_received+0x2a>
c0de9bd0:	218d      	movs	r1, #141	; 0x8d
c0de9bd2:	e700      	b.n	c0de99d6 <u2f_transport_received+0x2a>
        switch (buffer[channelHeader]) {
c0de9bd4:	2a81      	cmp	r2, #129	; 0x81
c0de9bd6:	d003      	beq.n	c0de9be0 <u2f_transport_received+0x234>
c0de9bd8:	2a86      	cmp	r2, #134	; 0x86
c0de9bda:	d01a      	beq.n	c0de9c12 <u2f_transport_received+0x266>
c0de9bdc:	2a83      	cmp	r2, #131	; 0x83
c0de9bde:	d122      	bne.n	c0de9c26 <u2f_transport_received+0x27a>
c0de9be0:	9104      	str	r1, [sp, #16]
            if (media == U2F_MEDIA_USB) {
c0de9be2:	2d01      	cmp	r5, #1
c0de9be4:	d121      	bne.n	c0de9c2a <u2f_transport_received+0x27e>
                if (u2f_is_channel_broadcast(service->channel) ||
c0de9be6:	1d20      	adds	r0, r4, #4
c0de9be8:	9002      	str	r0, [sp, #8]
c0de9bea:	f000 f871 	bl	c0de9cd0 <u2f_is_channel_broadcast>
c0de9bee:	2800      	cmp	r0, #0
c0de9bf0:	d117      	bne.n	c0de9c22 <u2f_transport_received+0x276>
                    u2f_is_channel_forbidden(service->channel)) {
c0de9bf2:	9802      	ldr	r0, [sp, #8]
c0de9bf4:	e011      	b.n	c0de9c1a <u2f_transport_received+0x26e>
            if (media == U2F_MEDIA_USB) {
c0de9bf6:	2d01      	cmp	r5, #1
c0de9bf8:	d109      	bne.n	c0de9c0e <u2f_transport_received+0x262>
c0de9bfa:	2000      	movs	r0, #0
    service->transportPacketIndex = 0;
c0de9bfc:	76a0      	strb	r0, [r4, #26]
    service->transportOffset = 0;
c0de9bfe:	82e0      	strh	r0, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0de9c00:	8330      	strh	r0, [r6, #24]
c0de9c02:	9903      	ldr	r1, [sp, #12]
    service->transportMedia = 0;
c0de9c04:	6008      	str	r0, [r1, #0]
c0de9c06:	8088      	strh	r0, [r1, #4]
    service->transportBuffer = service->transportReceiveBuffer;
c0de9c08:	68e0      	ldr	r0, [r4, #12]
c0de9c0a:	61e0      	str	r0, [r4, #28]
c0de9c0c:	e6e6      	b.n	c0de99dc <u2f_transport_received+0x30>
c0de9c0e:	2104      	movs	r1, #4
c0de9c10:	e6e1      	b.n	c0de99d6 <u2f_transport_received+0x2a>
            if (media != U2F_MEDIA_USB) {
c0de9c12:	2d01      	cmp	r5, #1
c0de9c14:	d107      	bne.n	c0de9c26 <u2f_transport_received+0x27a>
c0de9c16:	9104      	str	r1, [sp, #16]
            if (u2f_is_channel_forbidden(service->channel)) {
c0de9c18:	1d20      	adds	r0, r4, #4
c0de9c1a:	f000 f867 	bl	c0de9cec <u2f_is_channel_forbidden>
c0de9c1e:	2800      	cmp	r0, #0
c0de9c20:	d003      	beq.n	c0de9c2a <u2f_transport_received+0x27e>
c0de9c22:	210b      	movs	r1, #11
c0de9c24:	e6d7      	b.n	c0de99d6 <u2f_transport_received+0x2a>
c0de9c26:	2101      	movs	r1, #1
c0de9c28:	e6d5      	b.n	c0de99d6 <u2f_transport_received+0x2a>
c0de9c2a:	9a05      	ldr	r2, [sp, #20]
c0de9c2c:	18b9      	adds	r1, r7, r2
            xfer_len = MIN(size - (channelHeader), U2F_COMMAND_HEADER_SIZE+commandLength);
c0de9c2e:	9806      	ldr	r0, [sp, #24]
c0de9c30:	1a87      	subs	r7, r0, r2
c0de9c32:	9804      	ldr	r0, [sp, #16]
c0de9c34:	1cc0      	adds	r0, r0, #3
c0de9c36:	4287      	cmp	r7, r0
c0de9c38:	db00      	blt.n	c0de9c3c <u2f_transport_received+0x290>
c0de9c3a:	4607      	mov	r7, r0
c0de9c3c:	9006      	str	r0, [sp, #24]
            memmove(service->transportBuffer, buffer + channelHeader, xfer_len);
c0de9c3e:	b2ba      	uxth	r2, r7
c0de9c40:	69e0      	ldr	r0, [r4, #28]
c0de9c42:	9205      	str	r2, [sp, #20]
c0de9c44:	f003 fdf0 	bl	c0ded828 <__aeabi_memmove>
            if (media == U2F_MEDIA_USB) {
c0de9c48:	2d01      	cmp	r5, #1
c0de9c4a:	d105      	bne.n	c0de9c58 <u2f_transport_received+0x2ac>
                service->commandCrc = cx_crc16_update(0, service->transportBuffer, xfer_len);
c0de9c4c:	69e1      	ldr	r1, [r4, #28]
c0de9c4e:	2000      	movs	r0, #0
c0de9c50:	9a05      	ldr	r2, [sp, #20]
c0de9c52:	f7f9 f9dd 	bl	c0de3010 <cx_crc16_update>
c0de9c56:	84e0      	strh	r0, [r4, #38]	; 0x26
            service->transportLength = U2F_COMMAND_HEADER_SIZE+commandLength;
c0de9c58:	9806      	ldr	r0, [sp, #24]
c0de9c5a:	8320      	strh	r0, [r4, #24]
            service->transportOffset = xfer_len;
c0de9c5c:	82e7      	strh	r7, [r4, #22]
            service->transportMedia = media;
c0de9c5e:	73f5      	strb	r5, [r6, #15]
c0de9c60:	2000      	movs	r0, #0
            service->transportPacketIndex = 0;
c0de9c62:	76a0      	strb	r0, [r4, #26]
            memcpy(service->transportChannel, service->channel, 4);
c0de9c64:	6860      	ldr	r0, [r4, #4]
c0de9c66:	8030      	strh	r0, [r6, #0]
c0de9c68:	0c00      	lsrs	r0, r0, #16
c0de9c6a:	8070      	strh	r0, [r6, #2]
    if ((media != U2F_MEDIA_USB) &&
c0de9c6c:	2d01      	cmp	r5, #1
c0de9c6e:	9b03      	ldr	r3, [sp, #12]
c0de9c70:	d101      	bne.n	c0de9c76 <u2f_transport_received+0x2ca>
    } else if (service->transportOffset >= service->transportLength) {
c0de9c72:	8b20      	ldrh	r0, [r4, #24]
c0de9c74:	e004      	b.n	c0de9c80 <u2f_transport_received+0x2d4>
        (service->transportOffset >
c0de9c76:	b2b9      	uxth	r1, r7
         (service->transportLength + U2F_COMMAND_HEADER_SIZE))) {
c0de9c78:	8b20      	ldrh	r0, [r4, #24]
c0de9c7a:	1cc2      	adds	r2, r0, #3
    if ((media != U2F_MEDIA_USB) &&
c0de9c7c:	428a      	cmp	r2, r1
c0de9c7e:	d3a5      	bcc.n	c0de9bcc <u2f_transport_received+0x220>
    } else if (service->transportOffset >= service->transportLength) {
c0de9c80:	b2b9      	uxth	r1, r7
c0de9c82:	4281      	cmp	r1, r0
c0de9c84:	d204      	bcs.n	c0de9c90 <u2f_transport_received+0x2e4>
c0de9c86:	2001      	movs	r0, #1
        service->transportState = U2F_HANDLE_SEGMENTED;
c0de9c88:	7018      	strb	r0, [r3, #0]
c0de9c8a:	2000      	movs	r0, #0
        service->seqTimeout = 0;
c0de9c8c:	6360      	str	r0, [r4, #52]	; 0x34
c0de9c8e:	e6a5      	b.n	c0de99dc <u2f_transport_received+0x30>
c0de9c90:	2002      	movs	r0, #2
        service->transportState = U2F_PROCESSING_COMMAND;
c0de9c92:	7018      	strb	r0, [r3, #0]
        u2f_message_complete(service);
c0de9c94:	4620      	mov	r0, r4
c0de9c96:	f7ff fd09 	bl	c0de96ac <u2f_message_complete>
c0de9c9a:	e69f      	b.n	c0de99dc <u2f_transport_received+0x30>
c0de9c9c:	00000b54 	.word	0x00000b54

c0de9ca0 <u2f_transport_error>:
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
c0de9ca0:	b580      	push	{r7, lr}
    G_io_usb_ep_buffer[8] = errorCode;
c0de9ca2:	4a0a      	ldr	r2, [pc, #40]	; (c0de9ccc <u2f_transport_error+0x2c>)
c0de9ca4:	464b      	mov	r3, r9
c0de9ca6:	189a      	adds	r2, r3, r2
c0de9ca8:	7211      	strb	r1, [r2, #8]
c0de9caa:	2120      	movs	r1, #32
c0de9cac:	2304      	movs	r3, #4
    service->transportState = U2F_SENDING_ERROR;
c0de9cae:	5443      	strb	r3, [r0, r1]
c0de9cb0:	2140      	movs	r1, #64	; 0x40
c0de9cb2:	23bf      	movs	r3, #191	; 0xbf
    service->sendCmd = U2F_STATUS_ERROR;
c0de9cb4:	5443      	strb	r3, [r0, r1]
c0de9cb6:	2100      	movs	r1, #0
    service->transportPacketIndex = 0;
c0de9cb8:	7681      	strb	r1, [r0, #26]
c0de9cba:	2301      	movs	r3, #1
    service->transportLength = 1;
c0de9cbc:	8303      	strh	r3, [r0, #24]
    service->transportOffset = 0;
c0de9cbe:	82c1      	strh	r1, [r0, #22]
    G_io_usb_ep_buffer[8] = errorCode;
c0de9cc0:	3208      	adds	r2, #8
    service->transportBuffer = G_io_usb_ep_buffer + 8;
c0de9cc2:	61c2      	str	r2, [r0, #28]
    u2f_transport_sent(service, service->media);
c0de9cc4:	7a01      	ldrb	r1, [r0, #8]
c0de9cc6:	f7ff fd3d 	bl	c0de9744 <u2f_transport_sent>
}
c0de9cca:	bd80      	pop	{r7, pc}
c0de9ccc:	00000b54 	.word	0x00000b54

c0de9cd0 <u2f_is_channel_broadcast>:
    return (memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0de9cd0:	7801      	ldrb	r1, [r0, #0]
c0de9cd2:	7842      	ldrb	r2, [r0, #1]
c0de9cd4:	0212      	lsls	r2, r2, #8
c0de9cd6:	1851      	adds	r1, r2, r1
c0de9cd8:	7882      	ldrb	r2, [r0, #2]
c0de9cda:	78c0      	ldrb	r0, [r0, #3]
c0de9cdc:	0200      	lsls	r0, r0, #8
c0de9cde:	1880      	adds	r0, r0, r2
c0de9ce0:	0400      	lsls	r0, r0, #16
c0de9ce2:	1840      	adds	r0, r0, r1
c0de9ce4:	1c41      	adds	r1, r0, #1
c0de9ce6:	4248      	negs	r0, r1
c0de9ce8:	4148      	adcs	r0, r1
c0de9cea:	4770      	bx	lr

c0de9cec <u2f_is_channel_forbidden>:
    return (memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0de9cec:	7801      	ldrb	r1, [r0, #0]
c0de9cee:	7842      	ldrb	r2, [r0, #1]
c0de9cf0:	0212      	lsls	r2, r2, #8
c0de9cf2:	1851      	adds	r1, r2, r1
c0de9cf4:	7882      	ldrb	r2, [r0, #2]
c0de9cf6:	78c0      	ldrb	r0, [r0, #3]
c0de9cf8:	0200      	lsls	r0, r0, #8
c0de9cfa:	1880      	adds	r0, r0, r2
c0de9cfc:	0400      	lsls	r0, r0, #16
c0de9cfe:	1841      	adds	r1, r0, r1
c0de9d00:	4248      	negs	r0, r1
c0de9d02:	4148      	adcs	r0, r1
c0de9d04:	4770      	bx	lr

c0de9d06 <u2f_message_set_autoreply_wait_user_presence>:
void u2f_message_set_autoreply_wait_user_presence(u2f_service_t* service, bool enabled) {
c0de9d06:	b580      	push	{r7, lr}
c0de9d08:	222a      	movs	r2, #42	; 0x2a
c0de9d0a:	5c83      	ldrb	r3, [r0, r2]
c0de9d0c:	4602      	mov	r2, r0
c0de9d0e:	322a      	adds	r2, #42	; 0x2a
    if (enabled) {
c0de9d10:	2900      	cmp	r1, #0
c0de9d12:	d002      	beq.n	c0de9d1a <u2f_message_set_autoreply_wait_user_presence+0x14>
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE) {
c0de9d14:	2b00      	cmp	r3, #0
c0de9d16:	d005      	beq.n	c0de9d24 <u2f_message_set_autoreply_wait_user_presence+0x1e>
}
c0de9d18:	bd80      	pop	{r7, pc}
    else if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0de9d1a:	2b01      	cmp	r3, #1
c0de9d1c:	d1fc      	bne.n	c0de9d18 <u2f_message_set_autoreply_wait_user_presence+0x12>
c0de9d1e:	2002      	movs	r0, #2
        service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_REPLY_READY;
c0de9d20:	7010      	strb	r0, [r2, #0]
}
c0de9d22:	bd80      	pop	{r7, pc}
c0de9d24:	2101      	movs	r1, #1
            service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_ON;
c0de9d26:	7011      	strb	r1, [r2, #0]
            u2f_transport_send_usb_user_presence_required(service);
c0de9d28:	f7ff fd9a 	bl	c0de9860 <u2f_transport_send_usb_user_presence_required>
}
c0de9d2c:	bd80      	pop	{r7, pc}
c0de9d2e:	d4d4      	bmi.n	c0de9cda <u2f_is_channel_broadcast+0xa>

c0de9d30 <u2f_message_reply>:
        ;
}

void u2f_message_reply(u2f_service_t *service, uint8_t cmd, uint8_t *buffer, uint16_t len) {
c0de9d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0de9d32:	461e      	mov	r6, r3
c0de9d34:	4617      	mov	r7, r2
c0de9d36:	460d      	mov	r5, r1
c0de9d38:	4604      	mov	r4, r0

    // if U2F is not ready to reply, then gently avoid replying
    if (u2f_message_repliable(service)) 
c0de9d3a:	f7ff fd7f 	bl	c0de983c <u2f_message_repliable>
c0de9d3e:	2800      	cmp	r0, #0
c0de9d40:	d01c      	beq.n	c0de9d7c <u2f_message_reply+0x4c>
c0de9d42:	462b      	mov	r3, r5
c0de9d44:	4625      	mov	r5, r4
c0de9d46:	3520      	adds	r5, #32
c0de9d48:	4620      	mov	r0, r4
c0de9d4a:	3040      	adds	r0, #64	; 0x40
    {
        service->transportState = U2F_SENDING_RESPONSE;
        service->transportPacketIndex = 0;
        service->transportBuffer = buffer;
c0de9d4c:	61e7      	str	r7, [r4, #28]
c0de9d4e:	2100      	movs	r1, #0
        service->transportPacketIndex = 0;
c0de9d50:	76a1      	strb	r1, [r4, #26]
c0de9d52:	2203      	movs	r2, #3
        service->transportState = U2F_SENDING_RESPONSE;
c0de9d54:	702a      	strb	r2, [r5, #0]
        service->transportOffset = 0;
        service->transportLength = len;
c0de9d56:	8326      	strh	r6, [r4, #24]
        service->transportOffset = 0;
c0de9d58:	82e1      	strh	r1, [r4, #22]
        service->sendCmd = cmd;
c0de9d5a:	7003      	strb	r3, [r0, #0]
        if (service->transportMedia != U2F_MEDIA_BLE) {
c0de9d5c:	7869      	ldrb	r1, [r5, #1]
c0de9d5e:	2903      	cmp	r1, #3
c0de9d60:	d109      	bne.n	c0de9d76 <u2f_message_reply+0x46>
c0de9d62:	4e07      	ldr	r6, [pc, #28]	; (c0de9d80 <u2f_message_reply+0x50>)
            // pump the first message
            u2f_transport_sent(service, service->transportMedia);
        }
        else {
            while (G_io_app.apdu_state != APDU_IDLE) {
c0de9d64:	4648      	mov	r0, r9
c0de9d66:	5d80      	ldrb	r0, [r0, r6]
c0de9d68:	2800      	cmp	r0, #0
c0de9d6a:	d007      	beq.n	c0de9d7c <u2f_message_reply+0x4c>
                u2f_transport_sent(service, service->transportMedia);       
c0de9d6c:	7869      	ldrb	r1, [r5, #1]
c0de9d6e:	4620      	mov	r0, r4
c0de9d70:	f7ff fce8 	bl	c0de9744 <u2f_transport_sent>
c0de9d74:	e7f6      	b.n	c0de9d64 <u2f_message_reply+0x34>
            u2f_transport_sent(service, service->transportMedia);
c0de9d76:	4620      	mov	r0, r4
c0de9d78:	f7ff fce4 	bl	c0de9744 <u2f_transport_sent>
            }
        }
    }
}
c0de9d7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0de9d7e:	46c0      	nop			; (mov r8, r8)
c0de9d80:	00000ae4 	.word	0x00000ae4

c0de9d84 <io_seproxyhal_touch_eth2_address_ok>:

#include "shared_context.h"
#include "feature_getEth2PublicKey.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_eth2_address_ok(__attribute__((unused)) const bagl_element_t *e) {
c0de9d84:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_eth2_publicKey();
    G_io_apdu_buffer[tx++] = 0x90;
c0de9d86:	480b      	ldr	r0, [pc, #44]	; (c0de9db4 <io_seproxyhal_touch_eth2_address_ok+0x30>)
c0de9d88:	4649      	mov	r1, r9
c0de9d8a:	180d      	adds	r5, r1, r0
    uint32_t tx = set_result_get_eth2_publicKey();
c0de9d8c:	f7fc f828 	bl	c0de5de0 <set_result_get_eth2_publicKey>
c0de9d90:	4604      	mov	r4, r0
c0de9d92:	2090      	movs	r0, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0de9d94:	5528      	strb	r0, [r5, r4]
c0de9d96:	1928      	adds	r0, r5, r4
c0de9d98:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0de9d9a:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0de9d9c:	f7fc fc62 	bl	c0de6664 <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0de9da0:	1ca0      	adds	r0, r4, #2
c0de9da2:	b281      	uxth	r1, r0
c0de9da4:	2020      	movs	r0, #32
c0de9da6:	f7fd fd71 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9daa:	f7fc fc8b 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0de9dae:	4628      	mov	r0, r5
c0de9db0:	bdb0      	pop	{r4, r5, r7, pc}
c0de9db2:	46c0      	nop			; (mov r8, r8)
c0de9db4:	00000990 	.word	0x00000990

c0de9db8 <io_seproxyhal_touch_address_ok>:
#include "shared_context.h"
#include "feature_getPublicKey.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_address_ok(__attribute__((unused)) const bagl_element_t *e) {
c0de9db8:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_publicKey();
    G_io_apdu_buffer[tx++] = 0x90;
c0de9dba:	480b      	ldr	r0, [pc, #44]	; (c0de9de8 <io_seproxyhal_touch_address_ok+0x30>)
c0de9dbc:	4649      	mov	r1, r9
c0de9dbe:	180d      	adds	r5, r1, r0
    uint32_t tx = set_result_get_publicKey();
c0de9dc0:	f7fc f820 	bl	c0de5e04 <set_result_get_publicKey>
c0de9dc4:	4604      	mov	r4, r0
c0de9dc6:	2090      	movs	r0, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0de9dc8:	5528      	strb	r0, [r5, r4]
c0de9dca:	1928      	adds	r0, r5, r4
c0de9dcc:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0de9dce:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0de9dd0:	f7fc fc48 	bl	c0de6664 <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0de9dd4:	1ca0      	adds	r0, r4, #2
c0de9dd6:	b281      	uxth	r1, r0
c0de9dd8:	2020      	movs	r0, #32
c0de9dda:	f7fd fd57 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9dde:	f7fc fc71 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0de9de2:	4628      	mov	r0, r5
c0de9de4:	bdb0      	pop	{r4, r5, r7, pc}
c0de9de6:	46c0      	nop			; (mov r8, r8)
c0de9de8:	00000990 	.word	0x00000990

c0de9dec <io_seproxyhal_touch_address_cancel>:
}

unsigned int io_seproxyhal_touch_address_cancel(__attribute__((unused)) const bagl_element_t *e) {
c0de9dec:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = 0x69;
c0de9dee:	4808      	ldr	r0, [pc, #32]	; (c0de9e10 <io_seproxyhal_touch_address_cancel+0x24>)
c0de9df0:	4649      	mov	r1, r9
c0de9df2:	2269      	movs	r2, #105	; 0x69
c0de9df4:	540a      	strb	r2, [r1, r0]
c0de9df6:	1808      	adds	r0, r1, r0
c0de9df8:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0de9dfa:	7041      	strb	r1, [r0, #1]
    reset_app_context();
c0de9dfc:	f7fc fc32 	bl	c0de6664 <reset_app_context>
c0de9e00:	2020      	movs	r0, #32
c0de9e02:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0de9e04:	f7fd fd42 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9e08:	f7fc fc5c 	bl	c0de66c4 <ui_idle>
c0de9e0c:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0de9e0e:	bd80      	pop	{r7, pc}
c0de9e10:	00000990 	.word	0x00000990

c0de9e14 <io_seproxyhal_touch_privacy_ok>:
#include "shared_context.h"
#include "feature_getPublicKey.h"
#include "ui_callbacks.h"
#include "feature_performPrivacyOperation.h"

unsigned int io_seproxyhal_touch_privacy_ok(__attribute__((unused)) const bagl_element_t *e) {
c0de9e14:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_perform_privacy_operation();
    G_io_apdu_buffer[tx++] = 0x90;
c0de9e16:	480b      	ldr	r0, [pc, #44]	; (c0de9e44 <io_seproxyhal_touch_privacy_ok+0x30>)
c0de9e18:	4649      	mov	r1, r9
c0de9e1a:	180d      	adds	r5, r1, r0
    uint32_t tx = set_result_perform_privacy_operation();
c0de9e1c:	f7fc f81c 	bl	c0de5e58 <set_result_perform_privacy_operation>
c0de9e20:	4604      	mov	r4, r0
c0de9e22:	2090      	movs	r0, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0de9e24:	5528      	strb	r0, [r5, r4]
c0de9e26:	1928      	adds	r0, r5, r4
c0de9e28:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0de9e2a:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0de9e2c:	f7fc fc1a 	bl	c0de6664 <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0de9e30:	1ca0      	adds	r0, r4, #2
c0de9e32:	b281      	uxth	r1, r0
c0de9e34:	2020      	movs	r0, #32
c0de9e36:	f7fd fd29 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9e3a:	f7fc fc43 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0de9e3e:	4628      	mov	r0, r5
c0de9e40:	bdb0      	pop	{r4, r5, r7, pc}
c0de9e42:	46c0      	nop			; (mov r8, r8)
c0de9e44:	00000990 	.word	0x00000990

c0de9e48 <io_seproxyhal_touch_privacy_cancel>:
}

unsigned int io_seproxyhal_touch_privacy_cancel(__attribute__((unused)) const bagl_element_t *e) {
c0de9e48:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = 0x69;
c0de9e4a:	4808      	ldr	r0, [pc, #32]	; (c0de9e6c <io_seproxyhal_touch_privacy_cancel+0x24>)
c0de9e4c:	4649      	mov	r1, r9
c0de9e4e:	2269      	movs	r2, #105	; 0x69
c0de9e50:	540a      	strb	r2, [r1, r0]
c0de9e52:	1808      	adds	r0, r1, r0
c0de9e54:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0de9e56:	7041      	strb	r1, [r0, #1]
    reset_app_context();
c0de9e58:	f7fc fc04 	bl	c0de6664 <reset_app_context>
c0de9e5c:	2020      	movs	r0, #32
c0de9e5e:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0de9e60:	f7fd fd14 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9e64:	f7fc fc2e 	bl	c0de66c4 <ui_idle>
c0de9e68:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0de9e6a:	bd80      	pop	{r7, pc}
c0de9e6c:	00000990 	.word	0x00000990

c0de9e70 <io_seproxyhal_touch_signMessage_ok>:
#include "os_io_seproxyhal.h"
#include "shared_context.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_signMessage_ok(__attribute__((unused)) const bagl_element_t *e) {
c0de9e70:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de9e72:	b0b1      	sub	sp, #196	; 0xc4
    uint8_t privateKeyData[INT256_LENGTH];
    uint8_t signature[100];
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0de9e74:	f7fd fe94 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.messageSigningContext.bip32Path,
                               tmpCtx.messageSigningContext.pathLength,
c0de9e78:	492b      	ldr	r1, [pc, #172]	; (c0de9f28 <io_seproxyhal_touch_signMessage_ok+0xb8>)
c0de9e7a:	4648      	mov	r0, r9
c0de9e7c:	5c42      	ldrb	r2, [r0, r1]
c0de9e7e:	2400      	movs	r4, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de9e80:	9400      	str	r4, [sp, #0]
                               tmpCtx.messageSigningContext.pathLength,
c0de9e82:	1840      	adds	r0, r0, r1
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de9e84:	1d01      	adds	r1, r0, #4
c0de9e86:	2621      	movs	r6, #33	; 0x21
c0de9e88:	af27      	add	r7, sp, #156	; 0x9c
c0de9e8a:	4630      	mov	r0, r6
c0de9e8c:	463b      	mov	r3, r7
c0de9e8e:	f7ff f9b1 	bl	c0de91f4 <os_perso_derive_node_bip32>
                               privateKeyData,
                               NULL);
    io_seproxyhal_io_heartbeat();
c0de9e92:	f7fd fe85 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de9e96:	2520      	movs	r5, #32
c0de9e98:	ab04      	add	r3, sp, #16
  CX_THROW(cx_ecfp_init_private_key_no_throw(curve, rawkey, key_len, pvkey));
c0de9e9a:	4630      	mov	r0, r6
c0de9e9c:	4639      	mov	r1, r7
c0de9e9e:	462a      	mov	r2, r5
c0de9ea0:	f7f9 f8d4 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de9ea4:	2800      	cmp	r0, #0
c0de9ea6:	d13d      	bne.n	c0de9f24 <io_seproxyhal_touch_signMessage_ok+0xb4>
c0de9ea8:	a827      	add	r0, sp, #156	; 0x9c
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de9eaa:	4629      	mov	r1, r5
c0de9eac:	f003 fcc8 	bl	c0ded840 <explicit_bzero>
    unsigned int info = 0;
    io_seproxyhal_io_heartbeat();
c0de9eb0:	f7fd fe76 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de9eb4:	2064      	movs	r0, #100	; 0x64
  size_t sig_len_ = sig_len;
c0de9eb6:	9030      	str	r0, [sp, #192]	; 0xc0
c0de9eb8:	a82f      	add	r0, sp, #188	; 0xbc
  CX_THROW(cx_ecdsa_sign_no_throw(pvkey, mode, hashID, hash, hash_len, sig, &sig_len_, &info_));
c0de9eba:	9003      	str	r0, [sp, #12]
c0de9ebc:	a830      	add	r0, sp, #192	; 0xc0
c0de9ebe:	9002      	str	r0, [sp, #8]
c0de9ec0:	a80e      	add	r0, sp, #56	; 0x38
c0de9ec2:	9001      	str	r0, [sp, #4]
c0de9ec4:	9500      	str	r5, [sp, #0]
c0de9ec6:	4648      	mov	r0, r9
c0de9ec8:	4917      	ldr	r1, [pc, #92]	; (c0de9f28 <io_seproxyhal_touch_signMessage_ok+0xb8>)
c0de9eca:	1843      	adds	r3, r0, r1
c0de9ecc:	332c      	adds	r3, #44	; 0x2c
c0de9ece:	a804      	add	r0, sp, #16
c0de9ed0:	4916      	ldr	r1, [pc, #88]	; (c0de9f2c <io_seproxyhal_touch_signMessage_ok+0xbc>)
c0de9ed2:	2203      	movs	r2, #3
c0de9ed4:	f7f9 f8a2 	bl	c0de301c <cx_ecdsa_sign_no_throw>
c0de9ed8:	2800      	cmp	r0, #0
c0de9eda:	d123      	bne.n	c0de9f24 <io_seproxyhal_touch_signMessage_ok+0xb4>
    *info = (uint32_t)info_;
c0de9edc:	9d2f      	ldr	r5, [sp, #188]	; 0xbc
c0de9ede:	a804      	add	r0, sp, #16
c0de9ee0:	2128      	movs	r1, #40	; 0x28
                  tmpCtx.messageSigningContext.hash,
                  sizeof(tmpCtx.messageSigningContext.hash),
                  signature,
                  sizeof(signature),
                  &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0de9ee2:	f003 fcad 	bl	c0ded840 <explicit_bzero>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0de9ee6:	07e8      	lsls	r0, r5, #31
c0de9ee8:	d001      	beq.n	c0de9eee <io_seproxyhal_touch_signMessage_ok+0x7e>
c0de9eea:	201c      	movs	r0, #28
c0de9eec:	e000      	b.n	c0de9ef0 <io_seproxyhal_touch_signMessage_ok+0x80>
c0de9eee:	201b      	movs	r0, #27
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0de9ef0:	07a9      	lsls	r1, r5, #30
c0de9ef2:	d500      	bpl.n	c0de9ef6 <io_seproxyhal_touch_signMessage_ok+0x86>
c0de9ef4:	1c80      	adds	r0, r0, #2
c0de9ef6:	4d0e      	ldr	r5, [pc, #56]	; (c0de9f30 <io_seproxyhal_touch_signMessage_ok+0xc0>)
c0de9ef8:	464e      	mov	r6, r9
c0de9efa:	5570      	strb	r0, [r6, r5]
c0de9efc:	a80e      	add	r0, sp, #56	; 0x38
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0de9efe:	f7fc fc17 	bl	c0de6730 <format_signature_out>
c0de9f02:	1970      	adds	r0, r6, r5
c0de9f04:	2142      	movs	r1, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0de9f06:	5444      	strb	r4, [r0, r1]
c0de9f08:	2141      	movs	r1, #65	; 0x41
c0de9f0a:	2290      	movs	r2, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0de9f0c:	5442      	strb	r2, [r0, r1]
    reset_app_context();
c0de9f0e:	f7fc fba9 	bl	c0de6664 <reset_app_context>
c0de9f12:	2020      	movs	r0, #32
c0de9f14:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0de9f16:	f7fd fcb9 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9f1a:	f7fc fbd3 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0de9f1e:	4620      	mov	r0, r4
c0de9f20:	b031      	add	sp, #196	; 0xc4
c0de9f22:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0de9f24:	f7fd fa7f 	bl	c0de7426 <os_longjmp>
c0de9f28:	00000124 	.word	0x00000124
c0de9f2c:	00000601 	.word	0x00000601
c0de9f30:	00000990 	.word	0x00000990

c0de9f34 <io_seproxyhal_touch_signMessage_cancel>:
}

unsigned int io_seproxyhal_touch_signMessage_cancel(__attribute__((unused))
                                                    const bagl_element_t *e) {
c0de9f34:	b580      	push	{r7, lr}
    reset_app_context();
c0de9f36:	f7fc fb95 	bl	c0de6664 <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0de9f3a:	4807      	ldr	r0, [pc, #28]	; (c0de9f58 <io_seproxyhal_touch_signMessage_cancel+0x24>)
c0de9f3c:	4649      	mov	r1, r9
c0de9f3e:	2269      	movs	r2, #105	; 0x69
c0de9f40:	540a      	strb	r2, [r1, r0]
c0de9f42:	1808      	adds	r0, r1, r0
c0de9f44:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0de9f46:	7041      	strb	r1, [r0, #1]
c0de9f48:	2020      	movs	r0, #32
c0de9f4a:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0de9f4c:	f7fd fc9e 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0de9f50:	f7fc fbb8 	bl	c0de66c4 <ui_idle>
c0de9f54:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0de9f56:	bd80      	pop	{r7, pc}
c0de9f58:	00000990 	.word	0x00000990

c0de9f5c <io_seproxyhal_touch_signMessage712_v0_ok>:
#include "ui_callbacks.h"

static const uint8_t EIP_712_MAGIC[] = {0x19, 0x01};

unsigned int io_seproxyhal_touch_signMessage712_v0_ok(__attribute__((unused))
                                                      const bagl_element_t *e) {
c0de9f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0de9f5e:	b0bb      	sub	sp, #236	; 0xec
    uint8_t privateKeyData[INT256_LENGTH];
    uint8_t hash[INT256_LENGTH];
    uint8_t signature[100];
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0de9f60:	f7fd fe1e 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de9f64:	483d      	ldr	r0, [pc, #244]	; (c0dea05c <io_seproxyhal_touch_signMessage712_v0_ok+0x100>)
c0de9f66:	4649      	mov	r1, r9
c0de9f68:	1808      	adds	r0, r1, r0
c0de9f6a:	2101      	movs	r1, #1
c0de9f6c:	0209      	lsls	r1, r1, #8
c0de9f6e:	f7f9 f897 	bl	c0de30a0 <cx_keccak_init_no_throw>
c0de9f72:	2800      	cmp	r0, #0
c0de9f74:	d170      	bne.n	c0dea058 <io_seproxyhal_touch_signMessage712_v0_ok+0xfc>
c0de9f76:	2400      	movs	r4, #0
    cx_keccak_init(&global_sha3, 256);
    cx_hash((cx_hash_t *) &global_sha3,
c0de9f78:	9400      	str	r4, [sp, #0]
c0de9f7a:	493c      	ldr	r1, [pc, #240]	; (c0dea06c <io_seproxyhal_touch_signMessage712_v0_ok+0x110>)
c0de9f7c:	4479      	add	r1, pc
c0de9f7e:	2202      	movs	r2, #2
c0de9f80:	4e3b      	ldr	r6, [pc, #236]	; (c0dea070 <io_seproxyhal_touch_signMessage712_v0_ok+0x114>)
c0de9f82:	447e      	add	r6, pc
c0de9f84:	4620      	mov	r0, r4
c0de9f86:	4623      	mov	r3, r4
c0de9f88:	47b0      	blx	r6
            0,
            (uint8_t *) EIP_712_MAGIC,
            sizeof(EIP_712_MAGIC),
            NULL,
            0);
    cx_hash((cx_hash_t *) &global_sha3,
c0de9f8a:	9400      	str	r4, [sp, #0]
c0de9f8c:	4834      	ldr	r0, [pc, #208]	; (c0dea060 <io_seproxyhal_touch_signMessage712_v0_ok+0x104>)
c0de9f8e:	4649      	mov	r1, r9
c0de9f90:	9105      	str	r1, [sp, #20]
c0de9f92:	180f      	adds	r7, r1, r0
c0de9f94:	4639      	mov	r1, r7
c0de9f96:	312c      	adds	r1, #44	; 0x2c
c0de9f98:	2520      	movs	r5, #32
c0de9f9a:	4620      	mov	r0, r4
c0de9f9c:	462a      	mov	r2, r5
c0de9f9e:	4623      	mov	r3, r4
c0de9fa0:	47b0      	blx	r6
            0,
            tmpCtx.messageSigningContext712.domainHash,
            sizeof(tmpCtx.messageSigningContext712.domainHash),
            NULL,
            0);
    cx_hash((cx_hash_t *) &global_sha3,
c0de9fa2:	9500      	str	r5, [sp, #0]
c0de9fa4:	4639      	mov	r1, r7
c0de9fa6:	314c      	adds	r1, #76	; 0x4c
c0de9fa8:	2001      	movs	r0, #1
c0de9faa:	ab29      	add	r3, sp, #164	; 0xa4
c0de9fac:	462a      	mov	r2, r5
c0de9fae:	47b0      	blx	r6
            tmpCtx.messageSigningContext712.messageHash,
            sizeof(tmpCtx.messageSigningContext712.messageHash),
            hash,
            sizeof(hash));
    PRINTF("EIP712 hash to sign %.*H\n", 32, hash);
    io_seproxyhal_io_heartbeat();
c0de9fb0:	f7fd fdf6 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.messageSigningContext712.bip32Path,
                               tmpCtx.messageSigningContext712.pathLength,
c0de9fb4:	9805      	ldr	r0, [sp, #20]
c0de9fb6:	492a      	ldr	r1, [pc, #168]	; (c0dea060 <io_seproxyhal_touch_signMessage712_v0_ok+0x104>)
c0de9fb8:	5c42      	ldrb	r2, [r0, r1]
c0de9fba:	9405      	str	r4, [sp, #20]
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0de9fbc:	9400      	str	r4, [sp, #0]
c0de9fbe:	1d39      	adds	r1, r7, #4
c0de9fc0:	2621      	movs	r6, #33	; 0x21
c0de9fc2:	af31      	add	r7, sp, #196	; 0xc4
c0de9fc4:	4630      	mov	r0, r6
c0de9fc6:	463b      	mov	r3, r7
c0de9fc8:	f7ff f914 	bl	c0de91f4 <os_perso_derive_node_bip32>
                               privateKeyData,
                               NULL);
    io_seproxyhal_io_heartbeat();
c0de9fcc:	f7fd fde8 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de9fd0:	ab06      	add	r3, sp, #24
c0de9fd2:	4630      	mov	r0, r6
c0de9fd4:	4639      	mov	r1, r7
c0de9fd6:	462a      	mov	r2, r5
c0de9fd8:	f7f9 f838 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0de9fdc:	2800      	cmp	r0, #0
c0de9fde:	d13b      	bne.n	c0dea058 <io_seproxyhal_touch_signMessage712_v0_ok+0xfc>
c0de9fe0:	a831      	add	r0, sp, #196	; 0xc4
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0de9fe2:	4629      	mov	r1, r5
c0de9fe4:	f003 fc2c 	bl	c0ded840 <explicit_bzero>
    unsigned int info = 0;
    io_seproxyhal_io_heartbeat();
c0de9fe8:	f7fd fdda 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0de9fec:	2064      	movs	r0, #100	; 0x64
  size_t sig_len_ = sig_len;
c0de9fee:	903a      	str	r0, [sp, #232]	; 0xe8
c0de9ff0:	a839      	add	r0, sp, #228	; 0xe4
  CX_THROW(cx_ecdsa_sign_no_throw(pvkey, mode, hashID, hash, hash_len, sig, &sig_len_, &info_));
c0de9ff2:	9003      	str	r0, [sp, #12]
c0de9ff4:	a83a      	add	r0, sp, #232	; 0xe8
c0de9ff6:	9002      	str	r0, [sp, #8]
c0de9ff8:	a810      	add	r0, sp, #64	; 0x40
c0de9ffa:	9001      	str	r0, [sp, #4]
c0de9ffc:	9500      	str	r5, [sp, #0]
c0de9ffe:	a806      	add	r0, sp, #24
c0dea000:	4918      	ldr	r1, [pc, #96]	; (c0dea064 <io_seproxyhal_touch_signMessage712_v0_ok+0x108>)
c0dea002:	2203      	movs	r2, #3
c0dea004:	ab29      	add	r3, sp, #164	; 0xa4
c0dea006:	f7f9 f809 	bl	c0de301c <cx_ecdsa_sign_no_throw>
c0dea00a:	2800      	cmp	r0, #0
c0dea00c:	d124      	bne.n	c0dea058 <io_seproxyhal_touch_signMessage712_v0_ok+0xfc>
    *info = (uint32_t)info_;
c0dea00e:	9c39      	ldr	r4, [sp, #228]	; 0xe4
c0dea010:	a806      	add	r0, sp, #24
c0dea012:	2128      	movs	r1, #40	; 0x28
                  hash,
                  sizeof(hash),
                  signature,
                  sizeof(signature),
                  &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0dea014:	f003 fc14 	bl	c0ded840 <explicit_bzero>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0dea018:	07e0      	lsls	r0, r4, #31
c0dea01a:	d001      	beq.n	c0dea020 <io_seproxyhal_touch_signMessage712_v0_ok+0xc4>
c0dea01c:	201c      	movs	r0, #28
c0dea01e:	e000      	b.n	c0dea022 <io_seproxyhal_touch_signMessage712_v0_ok+0xc6>
c0dea020:	201b      	movs	r0, #27
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0dea022:	07a1      	lsls	r1, r4, #30
c0dea024:	d500      	bpl.n	c0dea028 <io_seproxyhal_touch_signMessage712_v0_ok+0xcc>
c0dea026:	1c80      	adds	r0, r0, #2
c0dea028:	4c0f      	ldr	r4, [pc, #60]	; (c0dea068 <io_seproxyhal_touch_signMessage712_v0_ok+0x10c>)
c0dea02a:	464d      	mov	r5, r9
c0dea02c:	5528      	strb	r0, [r5, r4]
c0dea02e:	a810      	add	r0, sp, #64	; 0x40
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0dea030:	f7fc fb7e 	bl	c0de6730 <format_signature_out>
c0dea034:	1928      	adds	r0, r5, r4
c0dea036:	2142      	movs	r1, #66	; 0x42
c0dea038:	9c05      	ldr	r4, [sp, #20]
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0dea03a:	5444      	strb	r4, [r0, r1]
c0dea03c:	2141      	movs	r1, #65	; 0x41
c0dea03e:	2290      	movs	r2, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0dea040:	5442      	strb	r2, [r0, r1]
    reset_app_context();
c0dea042:	f7fc fb0f 	bl	c0de6664 <reset_app_context>
c0dea046:	2020      	movs	r0, #32
c0dea048:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0dea04a:	f7fd fc1f 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0dea04e:	f7fc fb39 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0dea052:	4620      	mov	r0, r4
c0dea054:	b03b      	add	sp, #236	; 0xec
c0dea056:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dea058:	f7fd f9e5 	bl	c0de7426 <os_longjmp>
c0dea05c:	000007e8 	.word	0x000007e8
c0dea060:	00000124 	.word	0x00000124
c0dea064:	00000601 	.word	0x00000601
c0dea068:	00000990 	.word	0x00000990
c0dea06c:	0000600c 	.word	0x0000600c
c0dea070:	000000ef 	.word	0x000000ef

c0dea074 <cx_hash>:
{
c0dea074:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0dea076:	4614      	mov	r4, r2
c0dea078:	460a      	mov	r2, r1
c0dea07a:	4601      	mov	r1, r0
c0dea07c:	9806      	ldr	r0, [sp, #24]
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0dea07e:	9300      	str	r3, [sp, #0]
c0dea080:	9001      	str	r0, [sp, #4]
c0dea082:	4d07      	ldr	r5, [pc, #28]	; (c0dea0a0 <cx_hash+0x2c>)
c0dea084:	4648      	mov	r0, r9
c0dea086:	1940      	adds	r0, r0, r5
c0dea088:	4623      	mov	r3, r4
c0dea08a:	f7f8 fff7 	bl	c0de307c <cx_hash_no_throw>
c0dea08e:	2800      	cmp	r0, #0
c0dea090:	d104      	bne.n	c0dea09c <cx_hash+0x28>
  return cx_hash_get_size(hash);
c0dea092:	4648      	mov	r0, r9
c0dea094:	1940      	adds	r0, r0, r5
c0dea096:	f7f8 ffeb 	bl	c0de3070 <cx_hash_get_size>
c0dea09a:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
  CX_THROW(cx_hash_no_throw(hash, mode, in, len, out, out_len));
c0dea09c:	f7fd f9c3 	bl	c0de7426 <os_longjmp>
c0dea0a0:	000007e8 	.word	0x000007e8

c0dea0a4 <io_seproxyhal_touch_signMessage712_v0_cancel>:
}

unsigned int io_seproxyhal_touch_signMessage712_v0_cancel(__attribute__((unused))
                                                          const bagl_element_t *e) {
c0dea0a4:	b580      	push	{r7, lr}
    reset_app_context();
c0dea0a6:	f7fc fadd 	bl	c0de6664 <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0dea0aa:	4807      	ldr	r0, [pc, #28]	; (c0dea0c8 <io_seproxyhal_touch_signMessage712_v0_cancel+0x24>)
c0dea0ac:	4649      	mov	r1, r9
c0dea0ae:	2269      	movs	r2, #105	; 0x69
c0dea0b0:	540a      	strb	r2, [r1, r0]
c0dea0b2:	1808      	adds	r0, r1, r0
c0dea0b4:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0dea0b6:	7041      	strb	r1, [r0, #1]
c0dea0b8:	2020      	movs	r0, #32
c0dea0ba:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0dea0bc:	f7fd fbe6 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0dea0c0:	f7fc fb00 	bl	c0de66c4 <ui_idle>
c0dea0c4:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0dea0c6:	bd80      	pop	{r7, pc}
c0dea0c8:	00000990 	.word	0x00000990

c0dea0cc <io_seproxyhal_touch_tx_ok>:
#include "os_io_seproxyhal.h"
#include "shared_context.h"
#include "utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_tx_ok(__attribute__((unused)) const bagl_element_t *e) {
c0dea0cc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dea0ce:	b0b3      	sub	sp, #204	; 0xcc
    uint8_t privateKeyData[INT256_LENGTH];
    uint8_t signature[100];
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0dea0d0:	f7fd fd66 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0dea0d4:	4f3f      	ldr	r7, [pc, #252]	; (c0dea1d4 <io_seproxyhal_touch_tx_ok+0x108>)
c0dea0d6:	4648      	mov	r0, r9
c0dea0d8:	5dc2      	ldrb	r2, [r0, r7]
c0dea0da:	2100      	movs	r1, #0
c0dea0dc:	9105      	str	r1, [sp, #20]
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0dea0de:	9100      	str	r1, [sp, #0]
                               tmpCtx.transactionContext.pathLength,
c0dea0e0:	19c0      	adds	r0, r0, r7
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0dea0e2:	1d01      	adds	r1, r0, #4
c0dea0e4:	2521      	movs	r5, #33	; 0x21
c0dea0e6:	ae29      	add	r6, sp, #164	; 0xa4
c0dea0e8:	4628      	mov	r0, r5
c0dea0ea:	4633      	mov	r3, r6
c0dea0ec:	f7ff f882 	bl	c0de91f4 <os_perso_derive_node_bip32>
c0dea0f0:	2420      	movs	r4, #32
c0dea0f2:	ab06      	add	r3, sp, #24
c0dea0f4:	4628      	mov	r0, r5
c0dea0f6:	4631      	mov	r1, r6
c0dea0f8:	4622      	mov	r2, r4
c0dea0fa:	f7f8 ffa7 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0dea0fe:	2800      	cmp	r0, #0
c0dea100:	d162      	bne.n	c0dea1c8 <io_seproxyhal_touch_tx_ok+0xfc>
c0dea102:	a829      	add	r0, sp, #164	; 0xa4
                               privateKeyData,
                               NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0dea104:	4621      	mov	r1, r4
c0dea106:	f003 fb9b 	bl	c0ded840 <explicit_bzero>
    unsigned int info = 0;
    io_seproxyhal_io_heartbeat();
c0dea10a:	f7fd fd49 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0dea10e:	2064      	movs	r0, #100	; 0x64
  size_t sig_len_ = sig_len;
c0dea110:	9032      	str	r0, [sp, #200]	; 0xc8
c0dea112:	a831      	add	r0, sp, #196	; 0xc4
  CX_THROW(cx_ecdsa_sign_no_throw(pvkey, mode, hashID, hash, hash_len, sig, &sig_len_, &info_));
c0dea114:	9003      	str	r0, [sp, #12]
c0dea116:	a832      	add	r0, sp, #200	; 0xc8
c0dea118:	9002      	str	r0, [sp, #8]
c0dea11a:	a810      	add	r0, sp, #64	; 0x40
c0dea11c:	9001      	str	r0, [sp, #4]
c0dea11e:	9400      	str	r4, [sp, #0]
c0dea120:	4648      	mov	r0, r9
c0dea122:	19c3      	adds	r3, r0, r7
c0dea124:	332c      	adds	r3, #44	; 0x2c
c0dea126:	a806      	add	r0, sp, #24
c0dea128:	492b      	ldr	r1, [pc, #172]	; (c0dea1d8 <io_seproxyhal_touch_tx_ok+0x10c>)
c0dea12a:	2203      	movs	r2, #3
c0dea12c:	f7f8 ff76 	bl	c0de301c <cx_ecdsa_sign_no_throw>
c0dea130:	2800      	cmp	r0, #0
c0dea132:	d149      	bne.n	c0dea1c8 <io_seproxyhal_touch_tx_ok+0xfc>
    *info = (uint32_t)info_;
c0dea134:	9c31      	ldr	r4, [sp, #196]	; 0xc4
c0dea136:	a806      	add	r0, sp, #24
c0dea138:	2128      	movs	r1, #40	; 0x28
                  tmpCtx.transactionContext.hash,
                  sizeof(tmpCtx.transactionContext.hash),
                  signature,
                  sizeof(signature),
                  &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0dea13a:	f003 fb81 	bl	c0ded840 <explicit_bzero>
    if (txContext.txType == EIP1559 || txContext.txType == EIP2930) {
c0dea13e:	4827      	ldr	r0, [pc, #156]	; (c0dea1dc <io_seproxyhal_touch_tx_ok+0x110>)
c0dea140:	4649      	mov	r1, r9
c0dea142:	1808      	adds	r0, r1, r0
c0dea144:	213c      	movs	r1, #60	; 0x3c
c0dea146:	5c40      	ldrb	r0, [r0, r1]
c0dea148:	1e40      	subs	r0, r0, #1
c0dea14a:	2801      	cmp	r0, #1
c0dea14c:	d802      	bhi.n	c0dea154 <io_seproxyhal_touch_tx_ok+0x88>
c0dea14e:	2001      	movs	r0, #1
c0dea150:	4004      	ands	r4, r0
c0dea152:	e01b      	b.n	c0dea18c <io_seproxyhal_touch_tx_ok+0xc0>
        } else {
            G_io_apdu_buffer[0] = 0;
        }
    } else {
        // Parity is present in the sequence tag in the legacy API
        if (tmpContent.txContent.vLength == 0) {
c0dea154:	4822      	ldr	r0, [pc, #136]	; (c0dea1e0 <io_seproxyhal_touch_tx_ok+0x114>)
c0dea156:	4649      	mov	r1, r9
c0dea158:	1809      	adds	r1, r1, r0
c0dea15a:	22c2      	movs	r2, #194	; 0xc2
c0dea15c:	5c89      	ldrb	r1, [r1, r2]
c0dea15e:	2900      	cmp	r1, #0
c0dea160:	d00a      	beq.n	c0dea178 <io_seproxyhal_touch_tx_ok+0xac>
            // Note that this is wrong for a large v, but ledgerjs will recover.

            // Taking only the 4 highest bytes to not introduce breaking changes. In the future,
            // this should be updated.
            uint32_t v = (uint32_t) u64_from_BE(tmpContent.txContent.v,
                                                MIN(4, tmpContent.txContent.vLength));
c0dea162:	2904      	cmp	r1, #4
c0dea164:	d300      	bcc.n	c0dea168 <io_seproxyhal_touch_tx_ok+0x9c>
c0dea166:	2104      	movs	r1, #4
            uint32_t v = (uint32_t) u64_from_BE(tmpContent.txContent.v,
c0dea168:	464a      	mov	r2, r9
c0dea16a:	1810      	adds	r0, r2, r0
c0dea16c:	30ba      	adds	r0, #186	; 0xba
c0dea16e:	f002 f981 	bl	c0dec474 <u64_from_BE>
            G_io_apdu_buffer[0] = (v * 2) + 35;
c0dea172:	0040      	lsls	r0, r0, #1
c0dea174:	3023      	adds	r0, #35	; 0x23
c0dea176:	e000      	b.n	c0dea17a <io_seproxyhal_touch_tx_ok+0xae>
c0dea178:	201b      	movs	r0, #27
c0dea17a:	2101      	movs	r1, #1
        }
        if (info & CX_ECCINFO_PARITY_ODD) {
c0dea17c:	4021      	ands	r1, r4
c0dea17e:	1840      	adds	r0, r0, r1
c0dea180:	4918      	ldr	r1, [pc, #96]	; (c0dea1e4 <io_seproxyhal_touch_tx_ok+0x118>)
c0dea182:	464a      	mov	r2, r9
c0dea184:	5450      	strb	r0, [r2, r1]
            G_io_apdu_buffer[0]++;
        }
        if (info & CX_ECCINFO_xGTn) {
c0dea186:	07a1      	lsls	r1, r4, #30
c0dea188:	d503      	bpl.n	c0dea192 <io_seproxyhal_touch_tx_ok+0xc6>
            G_io_apdu_buffer[0] += 2;
c0dea18a:	1c84      	adds	r4, r0, #2
c0dea18c:	4815      	ldr	r0, [pc, #84]	; (c0dea1e4 <io_seproxyhal_touch_tx_ok+0x118>)
c0dea18e:	4649      	mov	r1, r9
c0dea190:	540c      	strb	r4, [r1, r0]
c0dea192:	a810      	add	r0, sp, #64	; 0x40
        }
    }
    format_signature_out(signature);
c0dea194:	f7fc facc 	bl	c0de6730 <format_signature_out>
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
c0dea198:	4812      	ldr	r0, [pc, #72]	; (c0dea1e4 <io_seproxyhal_touch_tx_ok+0x118>)
c0dea19a:	464c      	mov	r4, r9
c0dea19c:	1820      	adds	r0, r4, r0
c0dea19e:	2142      	movs	r1, #66	; 0x42
    G_io_apdu_buffer[tx++] = 0x00;
c0dea1a0:	9a05      	ldr	r2, [sp, #20]
c0dea1a2:	5442      	strb	r2, [r0, r1]
c0dea1a4:	2141      	movs	r1, #65	; 0x41
c0dea1a6:	2290      	movs	r2, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0dea1a8:	5442      	strb	r2, [r0, r1]
c0dea1aa:	2020      	movs	r0, #32
c0dea1ac:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0dea1ae:	f7fd fb6d 	bl	c0de788c <io_exchange>
    if (called_from_swap) {
c0dea1b2:	480d      	ldr	r0, [pc, #52]	; (c0dea1e8 <io_seproxyhal_touch_tx_ok+0x11c>)
c0dea1b4:	5c20      	ldrb	r0, [r4, r0]
c0dea1b6:	2800      	cmp	r0, #0
c0dea1b8:	d108      	bne.n	c0dea1cc <io_seproxyhal_touch_tx_ok+0x100>
        os_sched_exit(0);
    }
    reset_app_context();
c0dea1ba:	f7fc fa53 	bl	c0de6664 <reset_app_context>
    // Display back the original UX
    ui_idle();
c0dea1be:	f7fc fa81 	bl	c0de66c4 <ui_idle>
c0dea1c2:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0dea1c4:	b033      	add	sp, #204	; 0xcc
c0dea1c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dea1c8:	f7fd f92d 	bl	c0de7426 <os_longjmp>
c0dea1cc:	2000      	movs	r0, #0
        os_sched_exit(0);
c0dea1ce:	f7ff f889 	bl	c0de92e4 <os_sched_exit>
c0dea1d2:	46c0      	nop			; (mov r8, r8)
c0dea1d4:	00000124 	.word	0x00000124
c0dea1d8:	00000601 	.word	0x00000601
c0dea1dc:	0000022c 	.word	0x0000022c
c0dea1e0:	0000026c 	.word	0x0000026c
c0dea1e4:	00000990 	.word	0x00000990
c0dea1e8:	0000011d 	.word	0x0000011d

c0dea1ec <io_seproxyhal_touch_tx_cancel>:
}

unsigned int io_seproxyhal_touch_tx_cancel(__attribute__((unused)) const bagl_element_t *e) {
c0dea1ec:	b580      	push	{r7, lr}
    reset_app_context();
c0dea1ee:	f7fc fa39 	bl	c0de6664 <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0dea1f2:	4807      	ldr	r0, [pc, #28]	; (c0dea210 <io_seproxyhal_touch_tx_cancel+0x24>)
c0dea1f4:	4649      	mov	r1, r9
c0dea1f6:	2269      	movs	r2, #105	; 0x69
c0dea1f8:	540a      	strb	r2, [r1, r0]
c0dea1fa:	1808      	adds	r0, r1, r0
c0dea1fc:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0dea1fe:	7041      	strb	r1, [r0, #1]
c0dea200:	2020      	movs	r0, #32
c0dea202:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0dea204:	f7fd fb42 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0dea208:	f7fc fa5c 	bl	c0de66c4 <ui_idle>
c0dea20c:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0dea20e:	bd80      	pop	{r7, pc}
c0dea210:	00000990 	.word	0x00000990

c0dea214 <io_seproxyhal_touch_data_ok>:
}

unsigned int io_seproxyhal_touch_data_ok(__attribute__((unused)) const bagl_element_t *e) {
c0dea214:	b580      	push	{r7, lr}
    parserStatus_e txResult = USTREAM_FINISHED;
    txResult = continueTx(&txContext);
c0dea216:	480f      	ldr	r0, [pc, #60]	; (c0dea254 <io_seproxyhal_touch_data_ok+0x40>)
c0dea218:	4649      	mov	r1, r9
c0dea21a:	1808      	adds	r0, r1, r0
c0dea21c:	f7f9 ffe1 	bl	c0de41e2 <continueTx>
    switch (txResult) {
c0dea220:	2803      	cmp	r0, #3
c0dea222:	d008      	beq.n	c0dea236 <io_seproxyhal_touch_data_ok+0x22>
c0dea224:	2801      	cmp	r0, #1
c0dea226:	d012      	beq.n	c0dea24e <io_seproxyhal_touch_data_ok+0x3a>
c0dea228:	2802      	cmp	r0, #2
c0dea22a:	d00d      	beq.n	c0dea248 <io_seproxyhal_touch_data_ok+0x34>
c0dea22c:	2800      	cmp	r0, #0
c0dea22e:	d102      	bne.n	c0dea236 <io_seproxyhal_touch_data_ok+0x22>
c0dea230:	2009      	movs	r0, #9
c0dea232:	0300      	lsls	r0, r0, #12
c0dea234:	e003      	b.n	c0dea23e <io_seproxyhal_touch_data_ok+0x2a>
c0dea236:	f7fc fa15 	bl	c0de6664 <reset_app_context>
c0dea23a:	20d5      	movs	r0, #213	; 0xd5
c0dea23c:	01c0      	lsls	r0, r0, #7
c0dea23e:	f7fc fa69 	bl	c0de6714 <io_seproxyhal_send_status>
c0dea242:	f7fc fa3f 	bl	c0de66c4 <ui_idle>
c0dea246:	e002      	b.n	c0dea24e <io_seproxyhal_touch_data_ok+0x3a>
c0dea248:	2000      	movs	r0, #0
            io_seproxyhal_send_status(0x6A80);
            ui_idle();
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0dea24a:	f7fc f851 	bl	c0de62f0 <finalizeParsing>
c0dea24e:	2000      	movs	r0, #0
    }

    return 0;
c0dea250:	bd80      	pop	{r7, pc}
c0dea252:	46c0      	nop			; (mov r8, r8)
c0dea254:	0000022c 	.word	0x0000022c

c0dea258 <io_seproxyhal_touch_data_cancel>:
}

unsigned int io_seproxyhal_touch_data_cancel(__attribute__((unused)) const bagl_element_t *e) {
c0dea258:	b580      	push	{r7, lr}
    reset_app_context();
c0dea25a:	f7fc fa03 	bl	c0de6664 <reset_app_context>
c0dea25e:	4803      	ldr	r0, [pc, #12]	; (c0dea26c <io_seproxyhal_touch_data_cancel+0x14>)
    io_seproxyhal_send_status(0x6985);
c0dea260:	f7fc fa58 	bl	c0de6714 <io_seproxyhal_send_status>
    // Display back the original UX
    ui_idle();
c0dea264:	f7fc fa2e 	bl	c0de66c4 <ui_idle>
c0dea268:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0dea26a:	bd80      	pop	{r7, pc}
c0dea26c:	00006985 	.word	0x00006985

c0dea270 <io_seproxyhal_touch_stark_pubkey_ok>:

#include "shared_context.h"
#include "ui_callbacks.h"
#include "feature_stark_getPublicKey.h"

unsigned int io_seproxyhal_touch_stark_pubkey_ok(__attribute__((unused)) const bagl_element_t *e) {
c0dea270:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_stark_publicKey();
    G_io_apdu_buffer[tx++] = 0x90;
c0dea272:	480b      	ldr	r0, [pc, #44]	; (c0dea2a0 <io_seproxyhal_touch_stark_pubkey_ok+0x30>)
c0dea274:	4649      	mov	r1, r9
c0dea276:	180d      	adds	r5, r1, r0
    uint32_t tx = set_result_get_stark_publicKey();
c0dea278:	f7fc f9e2 	bl	c0de6640 <set_result_get_stark_publicKey>
c0dea27c:	4604      	mov	r4, r0
c0dea27e:	2090      	movs	r0, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0dea280:	5528      	strb	r0, [r5, r4]
c0dea282:	1928      	adds	r0, r5, r4
c0dea284:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0dea286:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0dea288:	f7fc f9ec 	bl	c0de6664 <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0dea28c:	1ca0      	adds	r0, r4, #2
c0dea28e:	b281      	uxth	r1, r0
c0dea290:	2020      	movs	r0, #32
c0dea292:	f7fd fafb 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0dea296:	f7fc fa15 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0dea29a:	4628      	mov	r0, r5
c0dea29c:	bdb0      	pop	{r4, r5, r7, pc}
c0dea29e:	46c0      	nop			; (mov r8, r8)
c0dea2a0:	00000990 	.word	0x00000990

c0dea2a4 <io_seproxyhal_touch_stark_ok>:
#include "os_io_seproxyhal.h"
#include "shared_context.h"
#include "stark_utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_ok(__attribute__((unused)) const bagl_element_t *e) {
c0dea2a4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dea2a6:	b09d      	sub	sp, #116	; 0x74
    uint8_t privateKeyData[32];
    uint8_t signature[72];
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0dea2a8:	f7fd fc7a 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
                          tmpCtx.transactionContext.pathLength,
c0dea2ac:	481a      	ldr	r0, [pc, #104]	; (c0dea318 <io_seproxyhal_touch_stark_ok+0x74>)
c0dea2ae:	464e      	mov	r6, r9
c0dea2b0:	5c31      	ldrb	r1, [r6, r0]
c0dea2b2:	1830      	adds	r0, r6, r0
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
c0dea2b4:	1d00      	adds	r0, r0, #4
c0dea2b6:	ac15      	add	r4, sp, #84	; 0x54
c0dea2b8:	4622      	mov	r2, r4
c0dea2ba:	f7fe f84d 	bl	c0de8358 <starkDerivePrivateKey>
                          privateKeyData);
    io_seproxyhal_io_heartbeat();
c0dea2be:	f7fd fc6f 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    stark_sign(signature,
               privateKeyData,
               dataContext.starkContext.w1,
               dataContext.starkContext.w2,
               dataContext.starkContext.w3,
               (dataContext.starkContext.conditional ? dataContext.starkContext.w4 : NULL));
c0dea2c2:	4816      	ldr	r0, [pc, #88]	; (c0dea31c <io_seproxyhal_touch_stark_ok+0x78>)
c0dea2c4:	1832      	adds	r2, r6, r0
c0dea2c6:	2080      	movs	r0, #128	; 0x80
c0dea2c8:	5c10      	ldrb	r0, [r2, r0]
c0dea2ca:	2800      	cmp	r0, #0
c0dea2cc:	d001      	beq.n	c0dea2d2 <io_seproxyhal_touch_stark_ok+0x2e>
c0dea2ce:	4610      	mov	r0, r2
c0dea2d0:	3060      	adds	r0, #96	; 0x60
    stark_sign(signature,
c0dea2d2:	4611      	mov	r1, r2
c0dea2d4:	3140      	adds	r1, #64	; 0x40
c0dea2d6:	9100      	str	r1, [sp, #0]
c0dea2d8:	9001      	str	r0, [sp, #4]
c0dea2da:	4613      	mov	r3, r2
c0dea2dc:	3320      	adds	r3, #32
c0dea2de:	ad03      	add	r5, sp, #12
c0dea2e0:	4628      	mov	r0, r5
c0dea2e2:	4621      	mov	r1, r4
c0dea2e4:	f7fe f98c 	bl	c0de8600 <stark_sign>
    G_io_apdu_buffer[0] = 0;
c0dea2e8:	4f0d      	ldr	r7, [pc, #52]	; (c0dea320 <io_seproxyhal_touch_stark_ok+0x7c>)
c0dea2ea:	2400      	movs	r4, #0
c0dea2ec:	55f4      	strb	r4, [r6, r7]
    format_signature_out(signature);
c0dea2ee:	4628      	mov	r0, r5
c0dea2f0:	f7fc fa1e 	bl	c0de6730 <format_signature_out>
    G_io_apdu_buffer[0] = 0;
c0dea2f4:	19f0      	adds	r0, r6, r7
c0dea2f6:	2142      	movs	r1, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0dea2f8:	5444      	strb	r4, [r0, r1]
c0dea2fa:	2141      	movs	r1, #65	; 0x41
c0dea2fc:	2290      	movs	r2, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0dea2fe:	5442      	strb	r2, [r0, r1]
    reset_app_context();
c0dea300:	f7fc f9b0 	bl	c0de6664 <reset_app_context>
c0dea304:	2020      	movs	r0, #32
c0dea306:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0dea308:	f7fd fac0 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0dea30c:	f7fc f9da 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0dea310:	4620      	mov	r0, r4
c0dea312:	b01d      	add	sp, #116	; 0x74
c0dea314:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dea316:	46c0      	nop			; (mov r8, r8)
c0dea318:	00000124 	.word	0x00000124
c0dea31c:	00000594 	.word	0x00000594
c0dea320:	00000990 	.word	0x00000990

c0dea324 <io_seproxyhal_touch_stark_unsafe_sign_ok>:
#include "shared_context.h"
#include "stark_utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_unsafe_sign_ok(__attribute__((unused))
                                                      const bagl_element_t *e) {
c0dea324:	b570      	push	{r4, r5, r6, lr}
c0dea326:	b0aa      	sub	sp, #168	; 0xa8
    cx_ecfp_private_key_t privateKey;
    uint8_t privateKeyData[INT256_LENGTH];
    uint8_t signature[72];
    unsigned int info = 0;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0dea328:	f7fd fc3a 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
                          tmpCtx.transactionContext.pathLength,
c0dea32c:	4820      	ldr	r0, [pc, #128]	; (c0dea3b0 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x8c>)
c0dea32e:	464a      	mov	r2, r9
c0dea330:	5c11      	ldrb	r1, [r2, r0]
c0dea332:	1810      	adds	r0, r2, r0
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
c0dea334:	1d00      	adds	r0, r0, #4
c0dea336:	ad16      	add	r5, sp, #88	; 0x58
c0dea338:	462a      	mov	r2, r5
c0dea33a:	f7fe f80d 	bl	c0de8358 <starkDerivePrivateKey>
                          privateKeyData);
    io_seproxyhal_io_heartbeat();
c0dea33e:	f7fd fc2f 	bl	c0de7ba0 <io_seproxyhal_io_heartbeat>
c0dea342:	2051      	movs	r0, #81	; 0x51
c0dea344:	2420      	movs	r4, #32
c0dea346:	ab1e      	add	r3, sp, #120	; 0x78
c0dea348:	4629      	mov	r1, r5
c0dea34a:	4622      	mov	r2, r4
c0dea34c:	f7f8 fe7e 	bl	c0de304c <cx_ecfp_init_private_key_no_throw>
c0dea350:	2800      	cmp	r0, #0
c0dea352:	d12b      	bne.n	c0dea3ac <io_seproxyhal_touch_stark_unsafe_sign_ok+0x88>
c0dea354:	2048      	movs	r0, #72	; 0x48
  size_t sig_len_ = sig_len;
c0dea356:	9029      	str	r0, [sp, #164]	; 0xa4
c0dea358:	a828      	add	r0, sp, #160	; 0xa0
  CX_THROW(cx_ecdsa_sign_no_throw(pvkey, mode, hashID, hash, hash_len, sig, &sig_len_, &info_));
c0dea35a:	9003      	str	r0, [sp, #12]
c0dea35c:	a829      	add	r0, sp, #164	; 0xa4
c0dea35e:	9002      	str	r0, [sp, #8]
c0dea360:	a804      	add	r0, sp, #16
c0dea362:	9001      	str	r0, [sp, #4]
c0dea364:	9400      	str	r4, [sp, #0]
c0dea366:	4813      	ldr	r0, [pc, #76]	; (c0dea3b4 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x90>)
c0dea368:	4649      	mov	r1, r9
c0dea36a:	180b      	adds	r3, r1, r0
c0dea36c:	3320      	adds	r3, #32
c0dea36e:	a81e      	add	r0, sp, #120	; 0x78
c0dea370:	4911      	ldr	r1, [pc, #68]	; (c0dea3b8 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x94>)
c0dea372:	2203      	movs	r2, #3
c0dea374:	f7f8 fe52 	bl	c0de301c <cx_ecdsa_sign_no_throw>
c0dea378:	2800      	cmp	r0, #0
c0dea37a:	d117      	bne.n	c0dea3ac <io_seproxyhal_touch_stark_unsafe_sign_ok+0x88>
                  dataContext.starkContext.w2,
                  sizeof(dataContext.starkContext.w2),
                  signature,
                  sizeof(signature),
                  &info);
    G_io_apdu_buffer[0] = 0;
c0dea37c:	4d0f      	ldr	r5, [pc, #60]	; (c0dea3bc <io_seproxyhal_touch_stark_unsafe_sign_ok+0x98>)
c0dea37e:	464e      	mov	r6, r9
c0dea380:	2400      	movs	r4, #0
c0dea382:	5574      	strb	r4, [r6, r5]
c0dea384:	a804      	add	r0, sp, #16
    format_signature_out(signature);
c0dea386:	f7fc f9d3 	bl	c0de6730 <format_signature_out>
    G_io_apdu_buffer[0] = 0;
c0dea38a:	1970      	adds	r0, r6, r5
c0dea38c:	2142      	movs	r1, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0dea38e:	5444      	strb	r4, [r0, r1]
c0dea390:	2141      	movs	r1, #65	; 0x41
c0dea392:	2290      	movs	r2, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0dea394:	5442      	strb	r2, [r0, r1]
    reset_app_context();
c0dea396:	f7fc f965 	bl	c0de6664 <reset_app_context>
c0dea39a:	2020      	movs	r0, #32
c0dea39c:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0dea39e:	f7fd fa75 	bl	c0de788c <io_exchange>
    // Display back the original UX
    ui_idle();
c0dea3a2:	f7fc f98f 	bl	c0de66c4 <ui_idle>
    return 0;  // do not redraw the widget
c0dea3a6:	4620      	mov	r0, r4
c0dea3a8:	b02a      	add	sp, #168	; 0xa8
c0dea3aa:	bd70      	pop	{r4, r5, r6, pc}
c0dea3ac:	f7fd f83b 	bl	c0de7426 <os_longjmp>
c0dea3b0:	00000124 	.word	0x00000124
c0dea3b4:	00000594 	.word	0x00000594
c0dea3b8:	00000601 	.word	0x00000601
c0dea3bc:	00000990 	.word	0x00000990

c0dea3c0 <ux_idle_flow_3_step_validateinit>:
    bn,
    {
      "Version",
      APPVERSION,
    });
UX_STEP_CB(
c0dea3c0:	b580      	push	{r7, lr}
c0dea3c2:	2000      	movs	r0, #0
c0dea3c4:	f000 f802 	bl	c0dea3cc <display_settings>
c0dea3c8:	bd80      	pop	{r7, pc}
c0dea3ca:	d4d4      	bmi.n	c0dea376 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x52>

c0dea3cc <display_settings>:
        &ux_settings_flow_2_step,
        &ux_settings_flow_3_step,
        &ux_settings_flow_4_step,
        &ux_settings_flow_5_step);

void display_settings(const ux_flow_step_t* const start_step) {
c0dea3cc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dea3ce:	b087      	sub	sp, #28
c0dea3d0:	9004      	str	r0, [sp, #16]
    strlcpy(strings.common.fullAddress,      (N_storage.dataAllowed     ? "Enabled"   : "NOT Enabled"  ), 12);
c0dea3d2:	4827      	ldr	r0, [pc, #156]	; (c0dea470 <display_settings+0xa4>)
c0dea3d4:	4478      	add	r0, pc
c0dea3d6:	4927      	ldr	r1, [pc, #156]	; (c0dea474 <display_settings+0xa8>)
c0dea3d8:	4479      	add	r1, pc
c0dea3da:	9006      	str	r0, [sp, #24]
c0dea3dc:	9105      	str	r1, [sp, #20]
c0dea3de:	4788      	blx	r1
c0dea3e0:	7800      	ldrb	r0, [r0, #0]
c0dea3e2:	4925      	ldr	r1, [pc, #148]	; (c0dea478 <display_settings+0xac>)
c0dea3e4:	4479      	add	r1, pc
c0dea3e6:	4a25      	ldr	r2, [pc, #148]	; (c0dea47c <display_settings+0xb0>)
c0dea3e8:	447a      	add	r2, pc
c0dea3ea:	2800      	cmp	r0, #0
c0dea3ec:	9103      	str	r1, [sp, #12]
c0dea3ee:	d000      	beq.n	c0dea3f2 <display_settings+0x26>
c0dea3f0:	4611      	mov	r1, r2
c0dea3f2:	9201      	str	r2, [sp, #4]
c0dea3f4:	481d      	ldr	r0, [pc, #116]	; (c0dea46c <display_settings+0xa0>)
c0dea3f6:	464a      	mov	r2, r9
c0dea3f8:	1814      	adds	r4, r2, r0
c0dea3fa:	220c      	movs	r2, #12
c0dea3fc:	4e20      	ldr	r6, [pc, #128]	; (c0dea480 <display_settings+0xb4>)
c0dea3fe:	447e      	add	r6, pc
c0dea400:	4620      	mov	r0, r4
c0dea402:	9202      	str	r2, [sp, #8]
c0dea404:	47b0      	blx	r6
    strlcpy(strings.common.fullAddress + 12, (N_storage.contractDetails ? "Displayed" : "NOT Displayed"), 14);
c0dea406:	9806      	ldr	r0, [sp, #24]
c0dea408:	9905      	ldr	r1, [sp, #20]
c0dea40a:	4788      	blx	r1
c0dea40c:	7840      	ldrb	r0, [r0, #1]
c0dea40e:	4f1d      	ldr	r7, [pc, #116]	; (c0dea484 <display_settings+0xb8>)
c0dea410:	447f      	add	r7, pc
c0dea412:	4a1d      	ldr	r2, [pc, #116]	; (c0dea488 <display_settings+0xbc>)
c0dea414:	447a      	add	r2, pc
c0dea416:	2800      	cmp	r0, #0
c0dea418:	4639      	mov	r1, r7
c0dea41a:	d000      	beq.n	c0dea41e <display_settings+0x52>
c0dea41c:	4611      	mov	r1, r2
c0dea41e:	9200      	str	r2, [sp, #0]
c0dea420:	4620      	mov	r0, r4
c0dea422:	300c      	adds	r0, #12
c0dea424:	250e      	movs	r5, #14
c0dea426:	462a      	mov	r2, r5
c0dea428:	47b0      	blx	r6
    strlcpy(strings.common.fullAddress + 26, (N_storage.displayNonce    ? "Displayed" : "NOT Displayed"), 14);
c0dea42a:	9806      	ldr	r0, [sp, #24]
c0dea42c:	9905      	ldr	r1, [sp, #20]
c0dea42e:	4788      	blx	r1
c0dea430:	7880      	ldrb	r0, [r0, #2]
c0dea432:	2800      	cmp	r0, #0
c0dea434:	d000      	beq.n	c0dea438 <display_settings+0x6c>
c0dea436:	9f00      	ldr	r7, [sp, #0]
c0dea438:	4620      	mov	r0, r4
c0dea43a:	301a      	adds	r0, #26
c0dea43c:	4639      	mov	r1, r7
c0dea43e:	462a      	mov	r2, r5
c0dea440:	47b0      	blx	r6
    strlcpy(strings.common.fullAddress + 40, (N_storage.requireOracle   ? "Enabled"   : "NOT Enabled"  ), 12);
c0dea442:	9806      	ldr	r0, [sp, #24]
c0dea444:	9905      	ldr	r1, [sp, #20]
c0dea446:	4788      	blx	r1
c0dea448:	78c0      	ldrb	r0, [r0, #3]
c0dea44a:	2800      	cmp	r0, #0
c0dea44c:	9903      	ldr	r1, [sp, #12]
c0dea44e:	d000      	beq.n	c0dea452 <display_settings+0x86>
c0dea450:	9901      	ldr	r1, [sp, #4]
c0dea452:	3428      	adds	r4, #40	; 0x28
c0dea454:	4620      	mov	r0, r4
c0dea456:	9a02      	ldr	r2, [sp, #8]
c0dea458:	47b0      	blx	r6
c0dea45a:	2000      	movs	r0, #0
    ux_flow_init(0, ux_settings_flow, start_step);
c0dea45c:	490b      	ldr	r1, [pc, #44]	; (c0dea48c <display_settings+0xc0>)
c0dea45e:	4479      	add	r1, pc
c0dea460:	9a04      	ldr	r2, [sp, #16]
c0dea462:	f002 fa8f 	bl	c0dec984 <ux_flow_init>
}
c0dea466:	b007      	add	sp, #28
c0dea468:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dea46a:	46c0      	nop			; (mov r8, r8)
c0dea46c:	000006ba 	.word	0x000006ba
c0dea470:	00007328 	.word	0x00007328
c0dea474:	ffffde69 	.word	0xffffde69
c0dea478:	00003a89 	.word	0x00003a89
c0dea47c:	00003b2c 	.word	0x00003b2c
c0dea480:	000037d3 	.word	0x000037d3
c0dea484:	00003a88 	.word	0x00003a88
c0dea488:	00003c8a 	.word	0x00003c8a
c0dea48c:	00005ce6 	.word	0x00005ce6

c0dea490 <ux_idle_flow_4_step_validateinit>:
UX_STEP_CB(
c0dea490:	20ff      	movs	r0, #255	; 0xff
c0dea492:	f7fe ff27 	bl	c0de92e4 <os_sched_exit>

c0dea496 <ux_settings_flow_1_step_validateinit>:
UX_STEP_CB(
c0dea496:	b580      	push	{r7, lr}
c0dea498:	f000 f802 	bl	c0dea4a0 <switch_settings_blind_signing>
c0dea49c:	bd80      	pop	{r7, pc}
c0dea49e:	d4d4      	bmi.n	c0dea44a <display_settings+0x7e>

c0dea4a0 <switch_settings_blind_signing>:

void switch_settings_blind_signing() {
c0dea4a0:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
    uint8_t value = (N_storage.dataAllowed ? 0 : 1);
c0dea4a2:	4c0b      	ldr	r4, [pc, #44]	; (c0dea4d0 <switch_settings_blind_signing+0x30>)
c0dea4a4:	447c      	add	r4, pc
c0dea4a6:	4620      	mov	r0, r4
c0dea4a8:	f7fd fecc 	bl	c0de8244 <pic>
c0dea4ac:	7800      	ldrb	r0, [r0, #0]
c0dea4ae:	4241      	negs	r1, r0
c0dea4b0:	4141      	adcs	r1, r0
c0dea4b2:	ad01      	add	r5, sp, #4
c0dea4b4:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.dataAllowed, (void*) &value, sizeof(uint8_t));
c0dea4b6:	4620      	mov	r0, r4
c0dea4b8:	f7fd fec4 	bl	c0de8244 <pic>
c0dea4bc:	2201      	movs	r2, #1
c0dea4be:	4629      	mov	r1, r5
c0dea4c0:	f7fe fe74 	bl	c0de91ac <nvm_write>
    display_settings(&ux_settings_flow_1_step);
c0dea4c4:	4803      	ldr	r0, [pc, #12]	; (c0dea4d4 <switch_settings_blind_signing+0x34>)
c0dea4c6:	4478      	add	r0, pc
c0dea4c8:	f7ff ff80 	bl	c0dea3cc <display_settings>
}
c0dea4cc:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0dea4ce:	46c0      	nop			; (mov r8, r8)
c0dea4d0:	00007258 	.word	0x00007258
c0dea4d4:	00005b96 	.word	0x00005b96

c0dea4d8 <ux_settings_flow_2_step_validateinit>:
UX_STEP_CB(
c0dea4d8:	b580      	push	{r7, lr}
c0dea4da:	f000 f801 	bl	c0dea4e0 <switch_settings_display_data>
c0dea4de:	bd80      	pop	{r7, pc}

c0dea4e0 <switch_settings_display_data>:

void switch_settings_display_data() {
c0dea4e0:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
    uint8_t value = (N_storage.contractDetails ? 0 : 1);
c0dea4e2:	4c0b      	ldr	r4, [pc, #44]	; (c0dea510 <switch_settings_display_data+0x30>)
c0dea4e4:	447c      	add	r4, pc
c0dea4e6:	4620      	mov	r0, r4
c0dea4e8:	f7fd feac 	bl	c0de8244 <pic>
c0dea4ec:	7840      	ldrb	r0, [r0, #1]
c0dea4ee:	4241      	negs	r1, r0
c0dea4f0:	4141      	adcs	r1, r0
c0dea4f2:	ad01      	add	r5, sp, #4
c0dea4f4:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.contractDetails, (void*) &value, sizeof(uint8_t));
c0dea4f6:	4620      	mov	r0, r4
c0dea4f8:	f7fd fea4 	bl	c0de8244 <pic>
c0dea4fc:	1c40      	adds	r0, r0, #1
c0dea4fe:	2201      	movs	r2, #1
c0dea500:	4629      	mov	r1, r5
c0dea502:	f7fe fe53 	bl	c0de91ac <nvm_write>
    display_settings(&ux_settings_flow_2_step);
c0dea506:	4803      	ldr	r0, [pc, #12]	; (c0dea514 <switch_settings_display_data+0x34>)
c0dea508:	4478      	add	r0, pc
c0dea50a:	f7ff ff5f 	bl	c0dea3cc <display_settings>
}
c0dea50e:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0dea510:	00007218 	.word	0x00007218
c0dea514:	00005b8c 	.word	0x00005b8c

c0dea518 <ux_settings_flow_3_step_validateinit>:
  UX_STEP_CB(
c0dea518:	b580      	push	{r7, lr}
c0dea51a:	f000 f801 	bl	c0dea520 <switch_settings_display_nonce>
c0dea51e:	bd80      	pop	{r7, pc}

c0dea520 <switch_settings_display_nonce>:

void switch_settings_display_nonce() {
c0dea520:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
    uint8_t value = (N_storage.displayNonce ? 0 : 1);
c0dea522:	4c0b      	ldr	r4, [pc, #44]	; (c0dea550 <switch_settings_display_nonce+0x30>)
c0dea524:	447c      	add	r4, pc
c0dea526:	4620      	mov	r0, r4
c0dea528:	f7fd fe8c 	bl	c0de8244 <pic>
c0dea52c:	7880      	ldrb	r0, [r0, #2]
c0dea52e:	4241      	negs	r1, r0
c0dea530:	4141      	adcs	r1, r0
c0dea532:	ad01      	add	r5, sp, #4
c0dea534:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.displayNonce, (void*) &value, sizeof(uint8_t));
c0dea536:	4620      	mov	r0, r4
c0dea538:	f7fd fe84 	bl	c0de8244 <pic>
c0dea53c:	1c80      	adds	r0, r0, #2
c0dea53e:	2201      	movs	r2, #1
c0dea540:	4629      	mov	r1, r5
c0dea542:	f7fe fe33 	bl	c0de91ac <nvm_write>
    display_settings(&ux_settings_flow_3_step);
c0dea546:	4803      	ldr	r0, [pc, #12]	; (c0dea554 <switch_settings_display_nonce+0x34>)
c0dea548:	4478      	add	r0, pc
c0dea54a:	f7ff ff3f 	bl	c0dea3cc <display_settings>
}
c0dea54e:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0dea550:	000071d8 	.word	0x000071d8
c0dea554:	00005b84 	.word	0x00005b84

c0dea558 <ux_settings_flow_4_step_validateinit>:
  UX_STEP_CB(
c0dea558:	b580      	push	{r7, lr}
c0dea55a:	f000 f801 	bl	c0dea560 <switch_settings_require_oracle>
c0dea55e:	bd80      	pop	{r7, pc}

c0dea560 <switch_settings_require_oracle>:

void switch_settings_require_oracle() {
c0dea560:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
    uint8_t value = (N_storage.requireOracle ? 0 : 1);
c0dea562:	4c0b      	ldr	r4, [pc, #44]	; (c0dea590 <switch_settings_require_oracle+0x30>)
c0dea564:	447c      	add	r4, pc
c0dea566:	4620      	mov	r0, r4
c0dea568:	f7fd fe6c 	bl	c0de8244 <pic>
c0dea56c:	78c0      	ldrb	r0, [r0, #3]
c0dea56e:	4241      	negs	r1, r0
c0dea570:	4141      	adcs	r1, r0
c0dea572:	ad01      	add	r5, sp, #4
c0dea574:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.requireOracle, (void*) &value, sizeof(uint8_t));
c0dea576:	4620      	mov	r0, r4
c0dea578:	f7fd fe64 	bl	c0de8244 <pic>
c0dea57c:	1cc0      	adds	r0, r0, #3
c0dea57e:	2201      	movs	r2, #1
c0dea580:	4629      	mov	r1, r5
c0dea582:	f7fe fe13 	bl	c0de91ac <nvm_write>
    display_settings(&ux_settings_flow_4_step);
c0dea586:	4803      	ldr	r0, [pc, #12]	; (c0dea594 <switch_settings_require_oracle+0x34>)
c0dea588:	4478      	add	r0, pc
c0dea58a:	f7ff ff1f 	bl	c0dea3cc <display_settings>
}
c0dea58e:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0dea590:	00007198 	.word	0x00007198
c0dea594:	00005b7c 	.word	0x00005b7c

c0dea598 <ux_settings_flow_5_step_validateinit>:
UX_STEP_CB(
c0dea598:	b580      	push	{r7, lr}
c0dea59a:	f7fc f893 	bl	c0de66c4 <ui_idle>
c0dea59e:	bd80      	pop	{r7, pc}

c0dea5a0 <ux_warning_contract_data_step_validateinit>:
    {
      "Error",
      "Blind signing must be enabled in Settings",
    });
#elif defined(TARGET_NANOX) || defined(TARGET_NANOS2)
UX_STEP_CB(
c0dea5a0:	b580      	push	{r7, lr}
c0dea5a2:	f7fc f88f 	bl	c0de66c4 <ui_idle>
c0dea5a6:	bd80      	pop	{r7, pc}

c0dea5a8 <ux_warning_oracle_data_step_validateinit>:
      &C_icon_crossmark,
      "Blind signing must be",
      "enabled in Settings",
    });

UX_STEP_CB(
c0dea5a8:	b580      	push	{r7, lr}
c0dea5aa:	f7fc f88b 	bl	c0de66c4 <ui_idle>
c0dea5ae:	bd80      	pop	{r7, pc}

c0dea5b0 <prepare_eth2_public_key>:
#ifdef HAVE_ETH2

#include "shared_context.h"
#include "ui_callbacks.h"

void prepare_eth2_public_key() {
c0dea5b0:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp, 100, "0x%.*H", 48, tmpCtx.publicKeyContext.publicKey.W);
c0dea5b2:	4807      	ldr	r0, [pc, #28]	; (c0dea5d0 <prepare_eth2_public_key+0x20>)
c0dea5b4:	4649      	mov	r1, r9
c0dea5b6:	1808      	adds	r0, r1, r0
c0dea5b8:	3008      	adds	r0, #8
c0dea5ba:	9000      	str	r0, [sp, #0]
c0dea5bc:	4805      	ldr	r0, [pc, #20]	; (c0dea5d4 <prepare_eth2_public_key+0x24>)
c0dea5be:	1808      	adds	r0, r1, r0
c0dea5c0:	2164      	movs	r1, #100	; 0x64
c0dea5c2:	4a05      	ldr	r2, [pc, #20]	; (c0dea5d8 <prepare_eth2_public_key+0x28>)
c0dea5c4:	447a      	add	r2, pc
c0dea5c6:	2330      	movs	r3, #48	; 0x30
c0dea5c8:	f7fd fc60 	bl	c0de7e8c <snprintf>
}
c0dea5cc:	bd8c      	pop	{r2, r3, r7, pc}
c0dea5ce:	46c0      	nop			; (mov r8, r8)
c0dea5d0:	00000124 	.word	0x00000124
c0dea5d4:	000006ba 	.word	0x000006ba
c0dea5d8:	00003b13 	.word	0x00003b13

c0dea5dc <ux_display_public_eth2_flow_2_step_init>:
    {
      &C_icon_eye,
      "Verify ETH2",
      "public key",
    });
UX_STEP_NOCB_INIT(
c0dea5dc:	b510      	push	{r4, lr}
c0dea5de:	4604      	mov	r4, r0
c0dea5e0:	f7ff ffe6 	bl	c0dea5b0 <prepare_eth2_public_key>
c0dea5e4:	4620      	mov	r0, r4
c0dea5e6:	f002 fb91 	bl	c0decd0c <ux_layout_paging_init>
c0dea5ea:	bd10      	pop	{r4, pc}

c0dea5ec <ux_display_public_eth2_flow_3_step_validateinit>:
    prepare_eth2_public_key(),
    {
      .title = "Public Key",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0dea5ec:	b580      	push	{r7, lr}
c0dea5ee:	2000      	movs	r0, #0
c0dea5f0:	f7ff fbc8 	bl	c0de9d84 <io_seproxyhal_touch_eth2_address_ok>
c0dea5f4:	bd80      	pop	{r7, pc}

c0dea5f6 <ux_display_public_eth2_flow_4_step_validateinit>:
    io_seproxyhal_touch_eth2_address_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0dea5f6:	b580      	push	{r7, lr}
c0dea5f8:	2000      	movs	r0, #0
c0dea5fa:	f7ff fbf7 	bl	c0de9dec <io_seproxyhal_touch_address_cancel>
c0dea5fe:	bd80      	pop	{r7, pc}

c0dea600 <ux_display_public_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Address",
      .text = strings.common.fullAddress,
    });
UX_STEP_CB(
c0dea600:	b580      	push	{r7, lr}
c0dea602:	2000      	movs	r0, #0
c0dea604:	f7ff fbd8 	bl	c0de9db8 <io_seproxyhal_touch_address_ok>
c0dea608:	bd80      	pop	{r7, pc}

c0dea60a <ux_display_public_flow_4_step_validateinit>:
    io_seproxyhal_touch_address_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0dea60a:	b580      	push	{r7, lr}
c0dea60c:	2000      	movs	r0, #0
c0dea60e:	f7ff fbed 	bl	c0de9dec <io_seproxyhal_touch_address_cancel>
c0dea612:	bd80      	pop	{r7, pc}

c0dea614 <ux_display_privacy_public_key_flow_4_step_validateinit>:
    bnnn_paging,
    {
      .title = "Key",
      .text = strings.common.fullAmount,
    });
UX_STEP_CB(
c0dea614:	b580      	push	{r7, lr}
c0dea616:	2000      	movs	r0, #0
c0dea618:	f7ff fbfc 	bl	c0de9e14 <io_seproxyhal_touch_privacy_ok>
c0dea61c:	bd80      	pop	{r7, pc}

c0dea61e <ux_display_privacy_public_key_flow_5_step_validateinit>:
    io_seproxyhal_touch_privacy_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0dea61e:	b580      	push	{r7, lr}
c0dea620:	2000      	movs	r0, #0
c0dea622:	f7ff fc11 	bl	c0de9e48 <io_seproxyhal_touch_privacy_cancel>
c0dea626:	bd80      	pop	{r7, pc}

c0dea628 <ux_sign_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Message",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0dea628:	b580      	push	{r7, lr}
c0dea62a:	2000      	movs	r0, #0
c0dea62c:	f7ff fc20 	bl	c0de9e70 <io_seproxyhal_touch_signMessage_ok>
c0dea630:	bd80      	pop	{r7, pc}

c0dea632 <ux_sign_flow_4_step_validateinit>:
    {
      &C_icon_validate_14,
      "Sign",
      "message",
    });
UX_STEP_CB(
c0dea632:	b580      	push	{r7, lr}
c0dea634:	2000      	movs	r0, #0
c0dea636:	f7ff fc7d 	bl	c0de9f34 <io_seproxyhal_touch_signMessage_cancel>
c0dea63a:	bd80      	pop	{r7, pc}

c0dea63c <prepare_domain_hash_v0>:
#include "shared_context.h"
#include "ui_callbacks.h"

void prepare_domain_hash_v0() {
c0dea63c:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp, 70, "0x%.*H", 32, tmpCtx.messageSigningContext712.domainHash);
c0dea63e:	4807      	ldr	r0, [pc, #28]	; (c0dea65c <prepare_domain_hash_v0+0x20>)
c0dea640:	4649      	mov	r1, r9
c0dea642:	1808      	adds	r0, r1, r0
c0dea644:	302c      	adds	r0, #44	; 0x2c
c0dea646:	9000      	str	r0, [sp, #0]
c0dea648:	4805      	ldr	r0, [pc, #20]	; (c0dea660 <prepare_domain_hash_v0+0x24>)
c0dea64a:	1808      	adds	r0, r1, r0
c0dea64c:	2146      	movs	r1, #70	; 0x46
c0dea64e:	4a05      	ldr	r2, [pc, #20]	; (c0dea664 <prepare_domain_hash_v0+0x28>)
c0dea650:	447a      	add	r2, pc
c0dea652:	2320      	movs	r3, #32
c0dea654:	f7fd fc1a 	bl	c0de7e8c <snprintf>
}
c0dea658:	bd8c      	pop	{r2, r3, r7, pc}
c0dea65a:	46c0      	nop			; (mov r8, r8)
c0dea65c:	00000124 	.word	0x00000124
c0dea660:	000006ba 	.word	0x000006ba
c0dea664:	00003a87 	.word	0x00003a87

c0dea668 <prepare_message_hash_v0>:

void prepare_message_hash_v0() {
c0dea668:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp, 70, "0x%.*H", 32, tmpCtx.messageSigningContext712.messageHash);
c0dea66a:	4807      	ldr	r0, [pc, #28]	; (c0dea688 <prepare_message_hash_v0+0x20>)
c0dea66c:	4649      	mov	r1, r9
c0dea66e:	1808      	adds	r0, r1, r0
c0dea670:	304c      	adds	r0, #76	; 0x4c
c0dea672:	9000      	str	r0, [sp, #0]
c0dea674:	4805      	ldr	r0, [pc, #20]	; (c0dea68c <prepare_message_hash_v0+0x24>)
c0dea676:	1808      	adds	r0, r1, r0
c0dea678:	2146      	movs	r1, #70	; 0x46
c0dea67a:	4a05      	ldr	r2, [pc, #20]	; (c0dea690 <prepare_message_hash_v0+0x28>)
c0dea67c:	447a      	add	r2, pc
c0dea67e:	2320      	movs	r3, #32
c0dea680:	f7fd fc04 	bl	c0de7e8c <snprintf>
}
c0dea684:	bd8c      	pop	{r2, r3, r7, pc}
c0dea686:	46c0      	nop			; (mov r8, r8)
c0dea688:	00000124 	.word	0x00000124
c0dea68c:	000006ba 	.word	0x000006ba
c0dea690:	00003a5b 	.word	0x00003a5b

c0dea694 <ux_sign_712_v0_flow_2_step_init>:
    {
      &C_icon_certificate,
      "Sign",
      "typed message",
    });
UX_STEP_NOCB_INIT(
c0dea694:	b510      	push	{r4, lr}
c0dea696:	4604      	mov	r4, r0
c0dea698:	f7ff ffd0 	bl	c0dea63c <prepare_domain_hash_v0>
c0dea69c:	4620      	mov	r0, r4
c0dea69e:	f002 fb35 	bl	c0decd0c <ux_layout_paging_init>
c0dea6a2:	bd10      	pop	{r4, pc}

c0dea6a4 <ux_sign_712_v0_flow_3_step_init>:
    prepare_domain_hash_v0(),
    {
      .title = "Domain hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_NOCB_INIT(
c0dea6a4:	b510      	push	{r4, lr}
c0dea6a6:	4604      	mov	r4, r0
c0dea6a8:	f7ff ffde 	bl	c0dea668 <prepare_message_hash_v0>
c0dea6ac:	4620      	mov	r0, r4
c0dea6ae:	f002 fb2d 	bl	c0decd0c <ux_layout_paging_init>
c0dea6b2:	bd10      	pop	{r4, pc}

c0dea6b4 <ux_sign_712_v0_flow_4_step_validateinit>:
    prepare_message_hash_v0(),
    {
      .title = "Message hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0dea6b4:	b580      	push	{r7, lr}
c0dea6b6:	2000      	movs	r0, #0
c0dea6b8:	f7ff fc50 	bl	c0de9f5c <io_seproxyhal_touch_signMessage712_v0_ok>
c0dea6bc:	bd80      	pop	{r7, pc}

c0dea6be <ux_sign_712_v0_flow_5_step_validateinit>:
    {
      &C_icon_validate_14,
      "Sign",
      "message",
    });
UX_STEP_CB(
c0dea6be:	b580      	push	{r7, lr}
c0dea6c0:	2000      	movs	r0, #0
c0dea6c2:	f7ff fcef 	bl	c0dea0a4 <io_seproxyhal_touch_signMessage712_v0_cancel>
c0dea6c6:	bd80      	pop	{r7, pc}

c0dea6c8 <ux_confirm_selector_flow_3_step_validateinit>:
    bn,
    {
      "Selector",
      strings.tmp.tmp
    });
UX_STEP_CB(
c0dea6c8:	b580      	push	{r7, lr}
c0dea6ca:	2000      	movs	r0, #0
c0dea6cc:	f7ff fda2 	bl	c0dea214 <io_seproxyhal_touch_data_ok>
c0dea6d0:	bd80      	pop	{r7, pc}

c0dea6d2 <ux_confirm_selector_flow_4_step_validateinit>:
    io_seproxyhal_touch_data_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0dea6d2:	b580      	push	{r7, lr}
c0dea6d4:	2000      	movs	r0, #0
c0dea6d6:	f7ff fdbf 	bl	c0dea258 <io_seproxyhal_touch_data_cancel>
c0dea6da:	bd80      	pop	{r7, pc}

c0dea6dc <ux_confirm_parameter_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Parameter",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0dea6dc:	b580      	push	{r7, lr}
c0dea6de:	2000      	movs	r0, #0
c0dea6e0:	f7ff fd98 	bl	c0dea214 <io_seproxyhal_touch_data_ok>
c0dea6e4:	bd80      	pop	{r7, pc}

c0dea6e6 <ux_confirm_parameter_flow_4_step_validateinit>:
    io_seproxyhal_touch_data_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0dea6e6:	b580      	push	{r7, lr}
c0dea6e8:	2000      	movs	r0, #0
c0dea6ea:	f7ff fdb5 	bl	c0dea258 <io_seproxyhal_touch_data_cancel>
c0dea6ee:	bd80      	pop	{r7, pc}

c0dea6f0 <ux_plugin_approval_id_step_init>:
    {
      .title = "Address",
      .text = strings.common.fullAddress,
    });

UX_STEP_NOCB_INIT(
c0dea6f0:	b510      	push	{r4, lr}
c0dea6f2:	4604      	mov	r4, r0
c0dea6f4:	f000 f984 	bl	c0deaa00 <plugin_ui_get_id>
c0dea6f8:	4620      	mov	r0, r4
c0dea6fa:	f002 fb07 	bl	c0decd0c <ux_layout_paging_init>
c0dea6fe:	bd10      	pop	{r4, pc}

c0dea700 <ux_plugin_approval_before_step_init>:
  {
    .title = strings.common.fullAddress,
    .text = strings.common.fullAmount
  });

UX_STEP_INIT(
c0dea700:	b580      	push	{r7, lr}
c0dea702:	2001      	movs	r0, #1
c0dea704:	f000 f9bc 	bl	c0deaa80 <display_next_plugin_item>
c0dea708:	bd80      	pop	{r7, pc}

c0dea70a <ux_plugin_approval_after_step_init>:
  {
    .title = strings.common.fullAddress,
    .text = strings.common.fullAmount
  });

UX_STEP_INIT(
c0dea70a:	b580      	push	{r7, lr}
c0dea70c:	2000      	movs	r0, #0
c0dea70e:	f000 f9b7 	bl	c0deaa80 <display_next_plugin_item>
c0dea712:	bd80      	pop	{r7, pc}

c0dea714 <ux_approval_accept_step_validateinit>:
    {
      .title = "Network",
      .text = strings.common.network_name,
    });

UX_STEP_CB(
c0dea714:	b580      	push	{r7, lr}
c0dea716:	2000      	movs	r0, #0
c0dea718:	f7ff fcd8 	bl	c0dea0cc <io_seproxyhal_touch_tx_ok>
c0dea71c:	bd80      	pop	{r7, pc}

c0dea71e <ux_approval_reject_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0dea71e:	b580      	push	{r7, lr}
c0dea720:	2000      	movs	r0, #0
c0dea722:	f7ff fd63 	bl	c0dea1ec <io_seproxyhal_touch_tx_cancel>
c0dea726:	bd80      	pop	{r7, pc}

c0dea728 <ux_approve_tx>:

// clang-format on

const ux_flow_step_t *ux_approval_tx_flow[15];

void ux_approve_tx(bool fromPlugin) {
c0dea728:	b570      	push	{r4, r5, r6, lr}
c0dea72a:	4604      	mov	r4, r0
    int step = 0;
    ux_approval_tx_flow[step++] = &ux_approval_review_step;
c0dea72c:	4d40      	ldr	r5, [pc, #256]	; (c0dea830 <ux_approve_tx+0x108>)
c0dea72e:	4648      	mov	r0, r9
c0dea730:	4942      	ldr	r1, [pc, #264]	; (c0dea83c <ux_approve_tx+0x114>)
c0dea732:	4479      	add	r1, pc
c0dea734:	5141      	str	r1, [r0, r5]

    if (N_storage.requireOracle) {
c0dea736:	4842      	ldr	r0, [pc, #264]	; (c0dea840 <ux_approve_tx+0x118>)
c0dea738:	4478      	add	r0, pc
c0dea73a:	f7fd fd83 	bl	c0de8244 <pic>
c0dea73e:	78c0      	ldrb	r0, [r0, #3]
c0dea740:	2800      	cmp	r0, #0
c0dea742:	d006      	beq.n	c0dea752 <ux_approve_tx+0x2a>
        ux_approval_tx_flow[step++] = &ux_approval_oracle_data;
c0dea744:	4648      	mov	r0, r9
c0dea746:	1940      	adds	r0, r0, r5
c0dea748:	493e      	ldr	r1, [pc, #248]	; (c0dea844 <ux_approve_tx+0x11c>)
c0dea74a:	4479      	add	r1, pc
c0dea74c:	6041      	str	r1, [r0, #4]
c0dea74e:	2602      	movs	r6, #2
c0dea750:	e000      	b.n	c0dea754 <ux_approve_tx+0x2c>
c0dea752:	2601      	movs	r6, #1
    }

    if (!fromPlugin && tmpContent.txContent.dataPresent && !N_storage.contractDetails) {
c0dea754:	4837      	ldr	r0, [pc, #220]	; (c0dea834 <ux_approve_tx+0x10c>)
c0dea756:	4649      	mov	r1, r9
c0dea758:	1808      	adds	r0, r1, r0
c0dea75a:	21c3      	movs	r1, #195	; 0xc3
c0dea75c:	5c40      	ldrb	r0, [r0, r1]
c0dea75e:	2800      	cmp	r0, #0
c0dea760:	d00f      	beq.n	c0dea782 <ux_approve_tx+0x5a>
c0dea762:	2c00      	cmp	r4, #0
c0dea764:	d10d      	bne.n	c0dea782 <ux_approve_tx+0x5a>
c0dea766:	4838      	ldr	r0, [pc, #224]	; (c0dea848 <ux_approve_tx+0x120>)
c0dea768:	4478      	add	r0, pc
c0dea76a:	f7fd fd6b 	bl	c0de8244 <pic>
c0dea76e:	7840      	ldrb	r0, [r0, #1]
c0dea770:	2800      	cmp	r0, #0
c0dea772:	d106      	bne.n	c0dea782 <ux_approve_tx+0x5a>
        ux_approval_tx_flow[step++] = &ux_approval_blind_signing_warning_step;
c0dea774:	4648      	mov	r0, r9
c0dea776:	1940      	adds	r0, r0, r5
c0dea778:	00b1      	lsls	r1, r6, #2
c0dea77a:	4a34      	ldr	r2, [pc, #208]	; (c0dea84c <ux_approve_tx+0x124>)
c0dea77c:	447a      	add	r2, pc
c0dea77e:	5042      	str	r2, [r0, r1]
c0dea780:	1c76      	adds	r6, r6, #1
c0dea782:	4648      	mov	r0, r9
c0dea784:	1940      	adds	r0, r0, r5
c0dea786:	00b1      	lsls	r1, r6, #2
c0dea788:	1842      	adds	r2, r0, r1
c0dea78a:	1c70      	adds	r0, r6, #1
    }

    if (fromPlugin) {
c0dea78c:	2c00      	cmp	r4, #0
c0dea78e:	d00f      	beq.n	c0dea7b0 <ux_approve_tx+0x88>
        // Add the special dynamic display logic
        ux_approval_tx_flow[step++] = &ux_plugin_approval_id_step;
c0dea790:	4b2f      	ldr	r3, [pc, #188]	; (c0dea850 <ux_approve_tx+0x128>)
c0dea792:	447b      	add	r3, pc
c0dea794:	6013      	str	r3, [r2, #0]
        ux_approval_tx_flow[step++] = &ux_plugin_approval_before_step;
        ux_approval_tx_flow[step++] = &ux_plugin_approval_display_step;
c0dea796:	464a      	mov	r2, r9
c0dea798:	1952      	adds	r2, r2, r5
c0dea79a:	1889      	adds	r1, r1, r2
c0dea79c:	4a2d      	ldr	r2, [pc, #180]	; (c0dea854 <ux_approve_tx+0x12c>)
c0dea79e:	447a      	add	r2, pc
        ux_approval_tx_flow[step++] = &ux_plugin_approval_after_step;
c0dea7a0:	4b2d      	ldr	r3, [pc, #180]	; (c0dea858 <ux_approve_tx+0x130>)
c0dea7a2:	447b      	add	r3, pc
        ux_approval_tx_flow[step++] = &ux_plugin_approval_display_step;
c0dea7a4:	608a      	str	r2, [r1, #8]
        ux_approval_tx_flow[step++] = &ux_plugin_approval_after_step;
c0dea7a6:	60cb      	str	r3, [r1, #12]
c0dea7a8:	1d34      	adds	r4, r6, #4
c0dea7aa:	492c      	ldr	r1, [pc, #176]	; (c0dea85c <ux_approve_tx+0x134>)
c0dea7ac:	4479      	add	r1, pc
c0dea7ae:	e005      	b.n	c0dea7bc <ux_approve_tx+0x94>
    } else {
        // We're in a regular transaction, just show the amount and the address
        ux_approval_tx_flow[step++] = &ux_approval_amount_step;
c0dea7b0:	492b      	ldr	r1, [pc, #172]	; (c0dea860 <ux_approve_tx+0x138>)
c0dea7b2:	4479      	add	r1, pc
c0dea7b4:	6011      	str	r1, [r2, #0]
        ux_approval_tx_flow[step++] = &ux_approval_address_step;
c0dea7b6:	1cb4      	adds	r4, r6, #2
c0dea7b8:	492a      	ldr	r1, [pc, #168]	; (c0dea864 <ux_approve_tx+0x13c>)
c0dea7ba:	4479      	add	r1, pc
        ux_approval_tx_flow[step++] = &ux_plugin_approval_before_step;
c0dea7bc:	464a      	mov	r2, r9
c0dea7be:	1952      	adds	r2, r2, r5
c0dea7c0:	0080      	lsls	r0, r0, #2
c0dea7c2:	5011      	str	r1, [r2, r0]
    }

    if (N_storage.displayNonce) {
c0dea7c4:	4828      	ldr	r0, [pc, #160]	; (c0dea868 <ux_approve_tx+0x140>)
c0dea7c6:	4478      	add	r0, pc
c0dea7c8:	f7fd fd3c 	bl	c0de8244 <pic>
c0dea7cc:	7880      	ldrb	r0, [r0, #2]
c0dea7ce:	2800      	cmp	r0, #0
c0dea7d0:	d006      	beq.n	c0dea7e0 <ux_approve_tx+0xb8>
        ux_approval_tx_flow[step++] = &ux_approval_nonce_step;
c0dea7d2:	4648      	mov	r0, r9
c0dea7d4:	1940      	adds	r0, r0, r5
c0dea7d6:	00a1      	lsls	r1, r4, #2
c0dea7d8:	4a24      	ldr	r2, [pc, #144]	; (c0dea86c <ux_approve_tx+0x144>)
c0dea7da:	447a      	add	r2, pc
c0dea7dc:	5042      	str	r2, [r0, r1]
c0dea7de:	1c64      	adds	r4, r4, #1
    }

    uint64_t chain_id = get_chain_id();
c0dea7e0:	f7fc fdc6 	bl	c0de7370 <get_chain_id>
c0dea7e4:	2201      	movs	r2, #1
    if (chainConfig->chainId == ETHEREUM_MAINNET_CHAINID && chain_id != chainConfig->chainId) {
c0dea7e6:	4050      	eors	r0, r2
c0dea7e8:	4308      	orrs	r0, r1
c0dea7ea:	d00e      	beq.n	c0dea80a <ux_approve_tx+0xe2>
c0dea7ec:	4812      	ldr	r0, [pc, #72]	; (c0dea838 <ux_approve_tx+0x110>)
c0dea7ee:	4649      	mov	r1, r9
c0dea7f0:	5808      	ldr	r0, [r1, r0]
c0dea7f2:	6901      	ldr	r1, [r0, #16]
c0dea7f4:	6940      	ldr	r0, [r0, #20]
c0dea7f6:	4051      	eors	r1, r2
c0dea7f8:	4301      	orrs	r1, r0
c0dea7fa:	d106      	bne.n	c0dea80a <ux_approve_tx+0xe2>
        ux_approval_tx_flow[step++] = &ux_approval_network_step;
c0dea7fc:	4648      	mov	r0, r9
c0dea7fe:	1940      	adds	r0, r0, r5
c0dea800:	00a1      	lsls	r1, r4, #2
c0dea802:	4a1b      	ldr	r2, [pc, #108]	; (c0dea870 <ux_approve_tx+0x148>)
c0dea804:	447a      	add	r2, pc
c0dea806:	5042      	str	r2, [r0, r1]
c0dea808:	1c64      	adds	r4, r4, #1
    }

    ux_approval_tx_flow[step++] = &ux_approval_fees_step;
c0dea80a:	4648      	mov	r0, r9
c0dea80c:	1941      	adds	r1, r0, r5
c0dea80e:	00a0      	lsls	r0, r4, #2
c0dea810:	4a18      	ldr	r2, [pc, #96]	; (c0dea874 <ux_approve_tx+0x14c>)
c0dea812:	447a      	add	r2, pc
c0dea814:	500a      	str	r2, [r1, r0]
c0dea816:	180a      	adds	r2, r1, r0
    ux_approval_tx_flow[step++] = &ux_approval_accept_step;
c0dea818:	4b17      	ldr	r3, [pc, #92]	; (c0dea878 <ux_approve_tx+0x150>)
c0dea81a:	447b      	add	r3, pc
    ux_approval_tx_flow[step++] = &ux_approval_reject_step;
c0dea81c:	4c17      	ldr	r4, [pc, #92]	; (c0dea87c <ux_approve_tx+0x154>)
c0dea81e:	447c      	add	r4, pc
c0dea820:	2000      	movs	r0, #0
c0dea822:	43c5      	mvns	r5, r0
    ux_approval_tx_flow[step++] = &ux_approval_accept_step;
c0dea824:	1d12      	adds	r2, r2, #4
c0dea826:	c238      	stmia	r2!, {r3, r4, r5}
    ux_approval_tx_flow[step++] = FLOW_END_STEP;

    ux_flow_init(0, ux_approval_tx_flow, NULL);
c0dea828:	4602      	mov	r2, r0
c0dea82a:	f002 f8ab 	bl	c0dec984 <ux_flow_init>
c0dea82e:	bd70      	pop	{r4, r5, r6, pc}
c0dea830:	00000bac 	.word	0x00000bac
c0dea834:	0000026c 	.word	0x0000026c
c0dea838:	00000590 	.word	0x00000590
c0dea83c:	00005fc2 	.word	0x00005fc2
c0dea840:	00006fc4 	.word	0x00006fc4
c0dea844:	0000610a 	.word	0x0000610a
c0dea848:	00006f94 	.word	0x00006f94
c0dea84c:	000060c0 	.word	0x000060c0
c0dea850:	00005faa 	.word	0x00005faa
c0dea854:	00005fc6 	.word	0x00005fc6
c0dea858:	00005fd2 	.word	0x00005fd2
c0dea85c:	00005fa0 	.word	0x00005fa0
c0dea860:	00005f5a 	.word	0x00005f5a
c0dea864:	00005f6a 	.word	0x00005f6a
c0dea868:	00006f36 	.word	0x00006f36
c0dea86c:	00006046 	.word	0x00006046
c0dea870:	00005fa0 	.word	0x00005fa0
c0dea874:	00005f7a 	.word	0x00005f7a
c0dea878:	00005fbe 	.word	0x00005fbe
c0dea87c:	00005fea 	.word	0x00005fea

c0dea880 <ux_display_stark_public_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Stark Key",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0dea880:	b580      	push	{r7, lr}
c0dea882:	2000      	movs	r0, #0
c0dea884:	f7ff fcf4 	bl	c0dea270 <io_seproxyhal_touch_stark_pubkey_ok>
c0dea888:	bd80      	pop	{r7, pc}

c0dea88a <ux_display_stark_public_flow_4_step_validateinit>:
    io_seproxyhal_touch_stark_pubkey_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0dea88a:	b580      	push	{r7, lr}
c0dea88c:	2000      	movs	r0, #0
c0dea88e:	f7ff faad 	bl	c0de9dec <io_seproxyhal_touch_address_cancel>
c0dea892:	bd80      	pop	{r7, pc}

c0dea894 <stark_sign_display_master_account>:
#include "ui_callbacks.h"
#include "ethUtils.h"

unsigned int io_seproxyhal_touch_stark_ok(const bagl_element_t *e);

void stark_sign_display_master_account() {
c0dea894:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp,
c0dea896:	4807      	ldr	r0, [pc, #28]	; (c0dea8b4 <stark_sign_display_master_account+0x20>)
c0dea898:	4649      	mov	r1, r9
c0dea89a:	1808      	adds	r0, r1, r0
c0dea89c:	3081      	adds	r0, #129	; 0x81
c0dea89e:	9000      	str	r0, [sp, #0]
c0dea8a0:	4805      	ldr	r0, [pc, #20]	; (c0dea8b8 <stark_sign_display_master_account+0x24>)
c0dea8a2:	1808      	adds	r0, r1, r0
c0dea8a4:	2101      	movs	r1, #1
c0dea8a6:	0209      	lsls	r1, r1, #8
c0dea8a8:	4a04      	ldr	r2, [pc, #16]	; (c0dea8bc <stark_sign_display_master_account+0x28>)
c0dea8aa:	447a      	add	r2, pc
c0dea8ac:	2320      	movs	r3, #32
c0dea8ae:	f7fd faed 	bl	c0de7e8c <snprintf>
             sizeof(strings.tmp.tmp),
             "0x%.*H",
             32,
             dataContext.starkContext.transferDestination);
}
c0dea8b2:	bd8c      	pop	{r2, r3, r7, pc}
c0dea8b4:	00000594 	.word	0x00000594
c0dea8b8:	000006ba 	.word	0x000006ba
c0dea8bc:	0000382d 	.word	0x0000382d

c0dea8c0 <stark_sign_display_condition_fact>:

void stark_sign_display_condition_fact() {
c0dea8c0:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.fact);
c0dea8c2:	4807      	ldr	r0, [pc, #28]	; (c0dea8e0 <stark_sign_display_condition_fact+0x20>)
c0dea8c4:	4649      	mov	r1, r9
c0dea8c6:	1808      	adds	r0, r1, r0
c0dea8c8:	30a1      	adds	r0, #161	; 0xa1
c0dea8ca:	9000      	str	r0, [sp, #0]
c0dea8cc:	4805      	ldr	r0, [pc, #20]	; (c0dea8e4 <stark_sign_display_condition_fact+0x24>)
c0dea8ce:	1808      	adds	r0, r1, r0
c0dea8d0:	2101      	movs	r1, #1
c0dea8d2:	0209      	lsls	r1, r1, #8
c0dea8d4:	4a04      	ldr	r2, [pc, #16]	; (c0dea8e8 <stark_sign_display_condition_fact+0x28>)
c0dea8d6:	447a      	add	r2, pc
c0dea8d8:	2320      	movs	r3, #32
c0dea8da:	f7fd fad7 	bl	c0de7e8c <snprintf>
}
c0dea8de:	bd8c      	pop	{r2, r3, r7, pc}
c0dea8e0:	00000594 	.word	0x00000594
c0dea8e4:	000006ba 	.word	0x000006ba
c0dea8e8:	00003801 	.word	0x00003801

c0dea8ec <ux_stark_limit_order_7_step_validateinit>:
    {
      .title = "Token Account",
      .text = strings.common.fullAddress
    });

UX_STEP_CB(
c0dea8ec:	b580      	push	{r7, lr}
c0dea8ee:	2000      	movs	r0, #0
c0dea8f0:	f7ff fcd8 	bl	c0dea2a4 <io_seproxyhal_touch_stark_ok>
c0dea8f4:	bd80      	pop	{r7, pc}

c0dea8f6 <ux_stark_limit_order_8_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0dea8f6:	b580      	push	{r7, lr}
c0dea8f8:	2000      	movs	r0, #0
c0dea8fa:	f7ff fc77 	bl	c0dea1ec <io_seproxyhal_touch_tx_cancel>
c0dea8fe:	bd80      	pop	{r7, pc}

c0dea900 <ux_stark_transfer_6_step_validateinit>:
    {
      .title = "Token Account",
      .text = strings.tmp.tmp2
    });

UX_STEP_CB(
c0dea900:	b580      	push	{r7, lr}
c0dea902:	2000      	movs	r0, #0
c0dea904:	f7ff fcce 	bl	c0dea2a4 <io_seproxyhal_touch_stark_ok>
c0dea908:	bd80      	pop	{r7, pc}

c0dea90a <ux_stark_transfer_7_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0dea90a:	b580      	push	{r7, lr}
c0dea90c:	2000      	movs	r0, #0
c0dea90e:	f7ff fc6d 	bl	c0dea1ec <io_seproxyhal_touch_tx_cancel>
c0dea912:	bd80      	pop	{r7, pc}

c0dea914 <ux_stark_conditional_transfer_4_step_init>:
    {
      &C_icon_crossmark,
      "Reject",
    });

UX_STEP_NOCB_INIT(
c0dea914:	b510      	push	{r4, lr}
c0dea916:	4604      	mov	r4, r0
c0dea918:	f7ff ffbc 	bl	c0dea894 <stark_sign_display_master_account>
c0dea91c:	4620      	mov	r0, r4
c0dea91e:	f002 f9f5 	bl	c0decd0c <ux_layout_paging_init>
c0dea922:	bd10      	pop	{r4, pc}

c0dea924 <ux_stark_conditional_transfer_8_step_init>:
    {
      .title = "Master Account",
      .text = strings.tmp.tmp
    });

UX_STEP_NOCB_INIT(
c0dea924:	b51c      	push	{r2, r3, r4, lr}
c0dea926:	4604      	mov	r4, r0
c0dea928:	480a      	ldr	r0, [pc, #40]	; (c0dea954 <ux_stark_conditional_transfer_8_step_init+0x30>)
c0dea92a:	464a      	mov	r2, r9
c0dea92c:	5810      	ldr	r0, [r2, r0]
c0dea92e:	6901      	ldr	r1, [r0, #16]
c0dea930:	6940      	ldr	r0, [r0, #20]
c0dea932:	9100      	str	r1, [sp, #0]
c0dea934:	9001      	str	r0, [sp, #4]
c0dea936:	4808      	ldr	r0, [pc, #32]	; (c0dea958 <ux_stark_conditional_transfer_8_step_init+0x34>)
c0dea938:	1811      	adds	r1, r2, r0
c0dea93a:	4808      	ldr	r0, [pc, #32]	; (c0dea95c <ux_stark_conditional_transfer_8_step_init+0x38>)
c0dea93c:	1813      	adds	r3, r2, r0
c0dea93e:	4808      	ldr	r0, [pc, #32]	; (c0dea960 <ux_stark_conditional_transfer_8_step_init+0x3c>)
c0dea940:	1810      	adds	r0, r2, r0
c0dea942:	30c1      	adds	r0, #193	; 0xc1
c0dea944:	2201      	movs	r2, #1
c0dea946:	0212      	lsls	r2, r2, #8
c0dea948:	f7f9 ff78 	bl	c0de483c <getEthDisplayableAddress>
c0dea94c:	4620      	mov	r0, r4
c0dea94e:	f002 f9dd 	bl	c0decd0c <ux_layout_paging_init>
c0dea952:	bd1c      	pop	{r2, r3, r4, pc}
c0dea954:	00000590 	.word	0x00000590
c0dea958:	000006ba 	.word	0x000006ba
c0dea95c:	000007e8 	.word	0x000007e8
c0dea960:	00000594 	.word	0x00000594

c0dea964 <ux_stark_conditional_transfer_9_step_init>:
    {
      .title = "Cond. Address",
      .text = strings.tmp.tmp
    });

UX_STEP_NOCB_INIT(
c0dea964:	b510      	push	{r4, lr}
c0dea966:	4604      	mov	r4, r0
c0dea968:	f7ff ffaa 	bl	c0dea8c0 <stark_sign_display_condition_fact>
c0dea96c:	4620      	mov	r0, r4
c0dea96e:	f002 f9cd 	bl	c0decd0c <ux_layout_paging_init>
c0dea972:	bd10      	pop	{r4, pc}

c0dea974 <stark_unsafe_sign_display_account>:
#include "shared_context.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_unsafe_sign_ok(const bagl_element_t *e);

void stark_unsafe_sign_display_account() {
c0dea974:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.w1);
c0dea976:	4807      	ldr	r0, [pc, #28]	; (c0dea994 <stark_unsafe_sign_display_account+0x20>)
c0dea978:	4649      	mov	r1, r9
c0dea97a:	1808      	adds	r0, r1, r0
c0dea97c:	9000      	str	r0, [sp, #0]
c0dea97e:	4806      	ldr	r0, [pc, #24]	; (c0dea998 <stark_unsafe_sign_display_account+0x24>)
c0dea980:	1808      	adds	r0, r1, r0
c0dea982:	2101      	movs	r1, #1
c0dea984:	0209      	lsls	r1, r1, #8
c0dea986:	4a05      	ldr	r2, [pc, #20]	; (c0dea99c <stark_unsafe_sign_display_account+0x28>)
c0dea988:	447a      	add	r2, pc
c0dea98a:	2320      	movs	r3, #32
c0dea98c:	f7fd fa7e 	bl	c0de7e8c <snprintf>
}
c0dea990:	bd8c      	pop	{r2, r3, r7, pc}
c0dea992:	46c0      	nop			; (mov r8, r8)
c0dea994:	00000594 	.word	0x00000594
c0dea998:	000006ba 	.word	0x000006ba
c0dea99c:	0000374f 	.word	0x0000374f

c0dea9a0 <stark_unsafe_sign_display_hash>:

void stark_unsafe_sign_display_hash() {
c0dea9a0:	b5e0      	push	{r5, r6, r7, lr}
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.w2);
c0dea9a2:	4807      	ldr	r0, [pc, #28]	; (c0dea9c0 <stark_unsafe_sign_display_hash+0x20>)
c0dea9a4:	4649      	mov	r1, r9
c0dea9a6:	1808      	adds	r0, r1, r0
c0dea9a8:	3020      	adds	r0, #32
c0dea9aa:	9000      	str	r0, [sp, #0]
c0dea9ac:	4805      	ldr	r0, [pc, #20]	; (c0dea9c4 <stark_unsafe_sign_display_hash+0x24>)
c0dea9ae:	1808      	adds	r0, r1, r0
c0dea9b0:	2101      	movs	r1, #1
c0dea9b2:	0209      	lsls	r1, r1, #8
c0dea9b4:	4a04      	ldr	r2, [pc, #16]	; (c0dea9c8 <stark_unsafe_sign_display_hash+0x28>)
c0dea9b6:	447a      	add	r2, pc
c0dea9b8:	2320      	movs	r3, #32
c0dea9ba:	f7fd fa67 	bl	c0de7e8c <snprintf>
}
c0dea9be:	bd8c      	pop	{r2, r3, r7, pc}
c0dea9c0:	00000594 	.word	0x00000594
c0dea9c4:	000006ba 	.word	0x000006ba
c0dea9c8:	00003721 	.word	0x00003721

c0dea9cc <ux_stark_unsafe_sign_2_step_init>:
      &C_icon_warning,
      "Unsafe",
      "Stark Sign",
    });

UX_STEP_NOCB_INIT(
c0dea9cc:	b510      	push	{r4, lr}
c0dea9ce:	4604      	mov	r4, r0
c0dea9d0:	f7ff ffd0 	bl	c0dea974 <stark_unsafe_sign_display_account>
c0dea9d4:	4620      	mov	r0, r4
c0dea9d6:	f002 f999 	bl	c0decd0c <ux_layout_paging_init>
c0dea9da:	bd10      	pop	{r4, pc}

c0dea9dc <ux_stark_unsafe_sign_3_step_init>:
  {
    .title = "From Account",
    .text = strings.tmp.tmp
  });

UX_STEP_NOCB_INIT(
c0dea9dc:	b510      	push	{r4, lr}
c0dea9de:	4604      	mov	r4, r0
c0dea9e0:	f7ff ffde 	bl	c0dea9a0 <stark_unsafe_sign_display_hash>
c0dea9e4:	4620      	mov	r0, r4
c0dea9e6:	f002 f991 	bl	c0decd0c <ux_layout_paging_init>
c0dea9ea:	bd10      	pop	{r4, pc}

c0dea9ec <ux_stark_unsafe_sign_4_step_validateinit>:
    .title = "Hash",
    .text = strings.tmp.tmp
  });


UX_STEP_CB(
c0dea9ec:	b580      	push	{r7, lr}
c0dea9ee:	2000      	movs	r0, #0
c0dea9f0:	f7ff fc98 	bl	c0dea324 <io_seproxyhal_touch_stark_unsafe_sign_ok>
c0dea9f4:	bd80      	pop	{r7, pc}

c0dea9f6 <ux_stark_unsafe_sign_5_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0dea9f6:	b580      	push	{r7, lr}
c0dea9f8:	2000      	movs	r0, #0
c0dea9fa:	f7ff fbf7 	bl	c0dea1ec <io_seproxyhal_touch_tx_cancel>
c0dea9fe:	bd80      	pop	{r7, pc}

c0deaa00 <plugin_ui_get_id>:
#include "ui_plugin.h"

// This function is not exported by the SDK
void ux_layout_paging_redisplay_by_addr(unsigned int stack_slot);

void plugin_ui_get_id() {
c0deaa00:	b510      	push	{r4, lr}
c0deaa02:	b08a      	sub	sp, #40	; 0x28
c0deaa04:	204f      	movs	r0, #79	; 0x4f
    ethQueryContractID_t pluginQueryContractID;
    eth_plugin_prepare_query_contract_ID(&pluginQueryContractID,
c0deaa06:	9000      	str	r0, [sp, #0]
c0deaa08:	480a      	ldr	r0, [pc, #40]	; (c0deaa34 <plugin_ui_get_id+0x34>)
c0deaa0a:	4649      	mov	r1, r9
c0deaa0c:	1809      	adds	r1, r1, r0
c0deaa0e:	460b      	mov	r3, r1
c0deaa10:	3335      	adds	r3, #53	; 0x35
c0deaa12:	ac02      	add	r4, sp, #8
c0deaa14:	2235      	movs	r2, #53	; 0x35
c0deaa16:	4620      	mov	r0, r4
c0deaa18:	f7f9 ffb3 	bl	c0de4982 <eth_plugin_prepare_query_contract_ID>
c0deaa1c:	20ff      	movs	r0, #255	; 0xff
c0deaa1e:	3006      	adds	r0, #6
                                         strings.common.fullAddress,
                                         sizeof(strings.common.fullAddress),
                                         strings.common.fullAmount,
                                         sizeof(strings.common.fullAmount));
    // Query the original contract for ID if it's not an internal alias
    if (!eth_plugin_call(ETH_PLUGIN_QUERY_CONTRACT_ID, (void *) &pluginQueryContractID)) {
c0deaa20:	4621      	mov	r1, r4
c0deaa22:	f7fa f8b1 	bl	c0de4b88 <eth_plugin_call>
c0deaa26:	2800      	cmp	r0, #0
c0deaa28:	d102      	bne.n	c0deaa30 <plugin_ui_get_id+0x30>
c0deaa2a:	2000      	movs	r0, #0
        PRINTF("Plugin query contract ID call failed\n");
        io_seproxyhal_touch_tx_cancel(NULL);
c0deaa2c:	f7ff fbde 	bl	c0dea1ec <io_seproxyhal_touch_tx_cancel>
    }
}
c0deaa30:	b00a      	add	sp, #40	; 0x28
c0deaa32:	bd10      	pop	{r4, pc}
c0deaa34:	000006ba 	.word	0x000006ba

c0deaa38 <plugin_ui_get_item>:

void plugin_ui_get_item() {
c0deaa38:	b510      	push	{r4, lr}
c0deaa3a:	b090      	sub	sp, #64	; 0x40
    ethQueryContractUI_t pluginQueryContractUI;
    eth_plugin_prepare_query_contract_UI(&pluginQueryContractUI,
                                         dataContext.tokenContext.pluginUiCurrentItem,
c0deaa3c:	480e      	ldr	r0, [pc, #56]	; (c0deaa78 <plugin_ui_get_item+0x40>)
c0deaa3e:	464a      	mov	r2, r9
c0deaa40:	1810      	adds	r0, r2, r0
c0deaa42:	2142      	movs	r1, #66	; 0x42
c0deaa44:	5c41      	ldrb	r1, [r0, r1]
c0deaa46:	204f      	movs	r0, #79	; 0x4f
    eth_plugin_prepare_query_contract_UI(&pluginQueryContractUI,
c0deaa48:	9001      	str	r0, [sp, #4]
c0deaa4a:	480c      	ldr	r0, [pc, #48]	; (c0deaa7c <plugin_ui_get_item+0x44>)
c0deaa4c:	1812      	adds	r2, r2, r0
c0deaa4e:	4610      	mov	r0, r2
c0deaa50:	3035      	adds	r0, #53	; 0x35
c0deaa52:	9000      	str	r0, [sp, #0]
c0deaa54:	ac02      	add	r4, sp, #8
c0deaa56:	2335      	movs	r3, #53	; 0x35
c0deaa58:	4620      	mov	r0, r4
c0deaa5a:	f7f9 ffa1 	bl	c0de49a0 <eth_plugin_prepare_query_contract_UI>
c0deaa5e:	2083      	movs	r0, #131	; 0x83
c0deaa60:	0040      	lsls	r0, r0, #1
                                         strings.common.fullAddress,
                                         sizeof(strings.common.fullAddress),
                                         strings.common.fullAmount,
                                         sizeof(strings.common.fullAmount));
    if (!eth_plugin_call(ETH_PLUGIN_QUERY_CONTRACT_UI, (void *) &pluginQueryContractUI)) {
c0deaa62:	4621      	mov	r1, r4
c0deaa64:	f7fa f890 	bl	c0de4b88 <eth_plugin_call>
c0deaa68:	2800      	cmp	r0, #0
c0deaa6a:	d102      	bne.n	c0deaa72 <plugin_ui_get_item+0x3a>
c0deaa6c:	2000      	movs	r0, #0
        PRINTF("Plugin query contract UI call failed\n");
        io_seproxyhal_touch_tx_cancel(NULL);
c0deaa6e:	f7ff fbbd 	bl	c0dea1ec <io_seproxyhal_touch_tx_cancel>
    }
}
c0deaa72:	b010      	add	sp, #64	; 0x40
c0deaa74:	bd10      	pop	{r4, pc}
c0deaa76:	46c0      	nop			; (mov r8, r8)
c0deaa78:	00000594 	.word	0x00000594
c0deaa7c:	000006ba 	.word	0x000006ba

c0deaa80 <display_next_plugin_item>:

void display_next_plugin_item(bool entering) {
c0deaa80:	b570      	push	{r4, r5, r6, lr}
c0deaa82:	4a27      	ldr	r2, [pc, #156]	; (c0deab20 <display_next_plugin_item+0xa0>)
c0deaa84:	4649      	mov	r1, r9
c0deaa86:	188b      	adds	r3, r1, r2
c0deaa88:	2143      	movs	r1, #67	; 0x43
c0deaa8a:	5c5b      	ldrb	r3, [r3, r1]
    if (entering) {
c0deaa8c:	2800      	cmp	r0, #0
c0deaa8e:	d008      	beq.n	c0deaaa2 <display_next_plugin_item+0x22>
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
            dataContext.tokenContext.pluginUiCurrentItem = 0;
            plugin_ui_get_item();
            ux_flow_next();
        } else {
            if (dataContext.tokenContext.pluginUiCurrentItem > 0) {
c0deaa90:	4648      	mov	r0, r9
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
c0deaa92:	2b01      	cmp	r3, #1
c0deaa94:	d10e      	bne.n	c0deaab4 <display_next_plugin_item+0x34>
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0deaa96:	1880      	adds	r0, r0, r2
c0deaa98:	2242      	movs	r2, #66	; 0x42
c0deaa9a:	2300      	movs	r3, #0
            dataContext.tokenContext.pluginUiCurrentItem = 0;
c0deaa9c:	5483      	strb	r3, [r0, r2]
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0deaa9e:	5443      	strb	r3, [r0, r1]
c0deaaa0:	e011      	b.n	c0deaac6 <display_next_plugin_item+0x46>
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
            plugin_ui_get_item();
            ux_flow_prev();
        } else {
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0deaaa2:	4648      	mov	r0, r9
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
c0deaaa4:	2b01      	cmp	r3, #1
c0deaaa6:	d111      	bne.n	c0deaacc <display_next_plugin_item+0x4c>
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0deaaa8:	1880      	adds	r0, r0, r2
c0deaaaa:	2200      	movs	r2, #0
c0deaaac:	5442      	strb	r2, [r0, r1]
            plugin_ui_get_item();
c0deaaae:	f7ff ffc3 	bl	c0deaa38 <plugin_ui_get_item>
c0deaab2:	e031      	b.n	c0deab18 <display_next_plugin_item+0x98>
            if (dataContext.tokenContext.pluginUiCurrentItem > 0) {
c0deaab4:	1883      	adds	r3, r0, r2
c0deaab6:	2042      	movs	r0, #66	; 0x42
c0deaab8:	5c1b      	ldrb	r3, [r3, r0]
c0deaaba:	2b00      	cmp	r3, #0
c0deaabc:	d026      	beq.n	c0deab0c <display_next_plugin_item+0x8c>
                dataContext.tokenContext.pluginUiCurrentItem--;
c0deaabe:	4649      	mov	r1, r9
c0deaac0:	1889      	adds	r1, r1, r2
c0deaac2:	1e5a      	subs	r2, r3, #1
c0deaac4:	540a      	strb	r2, [r1, r0]
c0deaac6:	f7ff ffb7 	bl	c0deaa38 <plugin_ui_get_item>
c0deaaca:	e01c      	b.n	c0deab06 <display_next_plugin_item+0x86>
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0deaacc:	1884      	adds	r4, r0, r2
c0deaace:	2042      	movs	r0, #66	; 0x42
c0deaad0:	5c23      	ldrb	r3, [r4, r0]
c0deaad2:	2541      	movs	r5, #65	; 0x41
                dataContext.tokenContext.pluginUiMaxItems - 1) {
c0deaad4:	5d64      	ldrb	r4, [r4, r5]
c0deaad6:	1e64      	subs	r4, r4, #1
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0deaad8:	429c      	cmp	r4, r3
c0deaada:	dd10      	ble.n	c0deaafe <display_next_plugin_item+0x7e>
                dataContext.tokenContext.pluginUiCurrentItem++;
c0deaadc:	464c      	mov	r4, r9
c0deaade:	18a1      	adds	r1, r4, r2
c0deaae0:	1c5a      	adds	r2, r3, #1
c0deaae2:	540a      	strb	r2, [r1, r0]
                plugin_ui_get_item();
                ux_flow_prev();
                // Reset multi page layout to the first page
                G_ux.layout_paging.current = 0;
c0deaae4:	4d0f      	ldr	r5, [pc, #60]	; (c0deab24 <display_next_plugin_item+0xa4>)
c0deaae6:	1966      	adds	r6, r4, r5
                plugin_ui_get_item();
c0deaae8:	f7ff ffa6 	bl	c0deaa38 <plugin_ui_get_item>
                ux_flow_prev();
c0deaaec:	f001 fe6a 	bl	c0dec7c4 <ux_flow_prev>
c0deaaf0:	2000      	movs	r0, #0
                G_ux.layout_paging.current = 0;
c0deaaf2:	60b0      	str	r0, [r6, #8]
                ux_layout_paging_redisplay_by_addr(G_ux.stack_count - 1);
c0deaaf4:	5d60      	ldrb	r0, [r4, r5]
c0deaaf6:	1e40      	subs	r0, r0, #1
c0deaaf8:	f002 f890 	bl	c0decc1c <ux_layout_paging_redisplay_by_addr>
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
                ux_flow_next();
            }
        }
    }
c0deaafc:	bd70      	pop	{r4, r5, r6, pc}
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0deaafe:	4648      	mov	r0, r9
c0deab00:	1880      	adds	r0, r0, r2
c0deab02:	2201      	movs	r2, #1
c0deab04:	5442      	strb	r2, [r0, r1]
c0deab06:	f001 fe57 	bl	c0dec7b8 <ux_flow_next>
c0deab0a:	bd70      	pop	{r4, r5, r6, pc}
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0deab0c:	464b      	mov	r3, r9
c0deab0e:	189a      	adds	r2, r3, r2
c0deab10:	2300      	movs	r3, #0
                dataContext.tokenContext.pluginUiCurrentItem = 0;
c0deab12:	5413      	strb	r3, [r2, r0]
c0deab14:	2001      	movs	r0, #1
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0deab16:	5450      	strb	r0, [r2, r1]
c0deab18:	f001 fe54 	bl	c0dec7c4 <ux_flow_prev>
c0deab1c:	bd70      	pop	{r4, r5, r6, pc}
c0deab1e:	46c0      	nop			; (mov r8, r8)
c0deab20:	00000594 	.word	0x00000594
c0deab24:	00000330 	.word	0x00000330

c0deab28 <readu128BE>:
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
}

void readu128BE(uint8_t *buffer, uint128_t *target) {
c0deab28:	b5b0      	push	{r4, r5, r7, lr}
c0deab2a:	460c      	mov	r4, r1
c0deab2c:	4605      	mov	r5, r0
    UPPER_P(target) = readUint64BE(buffer);
c0deab2e:	f000 f809 	bl	c0deab44 <readUint64BE>
c0deab32:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = readUint64BE(buffer + 8);
c0deab34:	3508      	adds	r5, #8
c0deab36:	4628      	mov	r0, r5
    UPPER_P(target) = readUint64BE(buffer);
c0deab38:	3c08      	subs	r4, #8
    LOWER_P(target) = readUint64BE(buffer + 8);
c0deab3a:	f000 f803 	bl	c0deab44 <readUint64BE>
c0deab3e:	60a0      	str	r0, [r4, #8]
c0deab40:	60e1      	str	r1, [r4, #12]
}
c0deab42:	bdb0      	pop	{r4, r5, r7, pc}

c0deab44 <readUint64BE>:
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
c0deab44:	7941      	ldrb	r1, [r0, #5]
c0deab46:	0409      	lsls	r1, r1, #16
c0deab48:	7902      	ldrb	r2, [r0, #4]
c0deab4a:	0612      	lsls	r2, r2, #24
c0deab4c:	1851      	adds	r1, r2, r1
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
c0deab4e:	7982      	ldrb	r2, [r0, #6]
c0deab50:	0212      	lsls	r2, r2, #8
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
c0deab52:	1889      	adds	r1, r1, r2
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
c0deab54:	79c2      	ldrb	r2, [r0, #7]
c0deab56:	188a      	adds	r2, r1, r2
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0deab58:	7801      	ldrb	r1, [r0, #0]
c0deab5a:	0609      	lsls	r1, r1, #24
c0deab5c:	7843      	ldrb	r3, [r0, #1]
c0deab5e:	041b      	lsls	r3, r3, #16
c0deab60:	1859      	adds	r1, r3, r1
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
c0deab62:	7883      	ldrb	r3, [r0, #2]
c0deab64:	021b      	lsls	r3, r3, #8
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0deab66:	18c9      	adds	r1, r1, r3
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
c0deab68:	78c0      	ldrb	r0, [r0, #3]
c0deab6a:	1809      	adds	r1, r1, r0
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0deab6c:	4610      	mov	r0, r2
c0deab6e:	4770      	bx	lr

c0deab70 <readu256BE>:

void readu256BE(uint8_t *buffer, uint256_t *target) {
c0deab70:	b5b0      	push	{r4, r5, r7, lr}
c0deab72:	460c      	mov	r4, r1
c0deab74:	4605      	mov	r5, r0
    readu128BE(buffer, &UPPER_P(target));
c0deab76:	f7ff ffd7 	bl	c0deab28 <readu128BE>
    readu128BE(buffer + 16, &LOWER_P(target));
c0deab7a:	3510      	adds	r5, #16
c0deab7c:	3410      	adds	r4, #16
c0deab7e:	4628      	mov	r0, r5
c0deab80:	4621      	mov	r1, r4
c0deab82:	f7ff ffd1 	bl	c0deab28 <readu128BE>
}
c0deab86:	bdb0      	pop	{r4, r5, r7, pc}

c0deab88 <shiftl128>:
void clear256(uint256_t *target) {
    clear128(&UPPER_P(target));
    clear128(&LOWER_P(target));
}

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
c0deab88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0deab8a:	4614      	mov	r4, r2
    if (value >= 128) {
c0deab8c:	2980      	cmp	r1, #128	; 0x80
c0deab8e:	d305      	bcc.n	c0deab9c <shiftl128+0x14>
c0deab90:	2000      	movs	r0, #0
c0deab92:	6020      	str	r0, [r4, #0]
c0deab94:	6060      	str	r0, [r4, #4]
c0deab96:	60a0      	str	r0, [r4, #8]
c0deab98:	60e0      	str	r0, [r4, #12]
        UPPER_P(target) = LOWER_P(number) << (value - 64);
        LOWER_P(target) = 0;
    } else {
        clear128(target);
    }
}
c0deab9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0deab9c:	460d      	mov	r5, r1
c0deab9e:	4606      	mov	r6, r0
    } else if (value == 64) {
c0deaba0:	2900      	cmp	r1, #0
c0deaba2:	d007      	beq.n	c0deabb4 <shiftl128+0x2c>
c0deaba4:	2d40      	cmp	r5, #64	; 0x40
c0deaba6:	d10c      	bne.n	c0deabc2 <shiftl128+0x3a>
        UPPER_P(target) = LOWER_P(number);
c0deaba8:	68b0      	ldr	r0, [r6, #8]
c0deabaa:	68f1      	ldr	r1, [r6, #12]
c0deabac:	2200      	movs	r2, #0
c0deabae:	c407      	stmia	r4!, {r0, r1, r2}
        LOWER_P(target) = 0;
c0deabb0:	6022      	str	r2, [r4, #0]
}
c0deabb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    UPPER_P(target) = UPPER_P(number);
c0deabb4:	ce03      	ldmia	r6!, {r0, r1}
c0deabb6:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0deabb8:	6830      	ldr	r0, [r6, #0]
c0deabba:	6871      	ldr	r1, [r6, #4]
c0deabbc:	6061      	str	r1, [r4, #4]
c0deabbe:	6020      	str	r0, [r4, #0]
}
c0deabc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if (value < 64) {
c0deabc2:	2d3f      	cmp	r5, #63	; 0x3f
c0deabc4:	d819      	bhi.n	c0deabfa <shiftl128+0x72>
        UPPER_P(target) = (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
c0deabc6:	ce03      	ldmia	r6!, {r0, r1}
c0deabc8:	462a      	mov	r2, r5
c0deabca:	3e08      	subs	r6, #8
c0deabcc:	f002 fcd0 	bl	c0ded570 <__aeabi_llsl>
c0deabd0:	4607      	mov	r7, r0
c0deabd2:	9100      	str	r1, [sp, #0]
c0deabd4:	2040      	movs	r0, #64	; 0x40
c0deabd6:	1b42      	subs	r2, r0, r5
c0deabd8:	68b0      	ldr	r0, [r6, #8]
c0deabda:	68f1      	ldr	r1, [r6, #12]
c0deabdc:	f002 fcbc 	bl	c0ded558 <__aeabi_llsr>
c0deabe0:	19c0      	adds	r0, r0, r7
c0deabe2:	6020      	str	r0, [r4, #0]
c0deabe4:	9800      	ldr	r0, [sp, #0]
c0deabe6:	4141      	adcs	r1, r0
c0deabe8:	6061      	str	r1, [r4, #4]
        LOWER_P(target) = (LOWER_P(number) << value);
c0deabea:	68b0      	ldr	r0, [r6, #8]
c0deabec:	68f1      	ldr	r1, [r6, #12]
c0deabee:	462a      	mov	r2, r5
c0deabf0:	f002 fcbe 	bl	c0ded570 <__aeabi_llsl>
c0deabf4:	60a0      	str	r0, [r4, #8]
c0deabf6:	60e1      	str	r1, [r4, #12]
}
c0deabf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if ((128 > value) && (value > 64)) {
c0deabfa:	2d40      	cmp	r5, #64	; 0x40
c0deabfc:	d0c8      	beq.n	c0deab90 <shiftl128+0x8>
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0deabfe:	68b0      	ldr	r0, [r6, #8]
c0deac00:	68f1      	ldr	r1, [r6, #12]
c0deac02:	2200      	movs	r2, #0
        LOWER_P(target) = 0;
c0deac04:	60a2      	str	r2, [r4, #8]
c0deac06:	60e2      	str	r2, [r4, #12]
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0deac08:	3d40      	subs	r5, #64	; 0x40
c0deac0a:	462a      	mov	r2, r5
c0deac0c:	f002 fcb0 	bl	c0ded570 <__aeabi_llsl>
c0deac10:	c403      	stmia	r4!, {r0, r1}
}
c0deac12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0deac14 <shiftl256>:

void shiftl256(uint256_t *number, uint32_t value, uint256_t *target) {
c0deac14:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deac16:	b097      	sub	sp, #92	; 0x5c
c0deac18:	4614      	mov	r4, r2
c0deac1a:	4605      	mov	r5, r0
    if (value >= 256) {
c0deac1c:	0a08      	lsrs	r0, r1, #8
c0deac1e:	d004      	beq.n	c0deac2a <shiftl256+0x16>
c0deac20:	2120      	movs	r1, #32
c0deac22:	4620      	mov	r0, r4
c0deac24:	f002 fdf6 	bl	c0ded814 <__aeabi_memclr>
c0deac28:	e084      	b.n	c0dead34 <shiftl256+0x120>
c0deac2a:	460e      	mov	r6, r1
        clear256(target);
    } else if (value == 128) {
c0deac2c:	2900      	cmp	r1, #0
c0deac2e:	d00f      	beq.n	c0deac50 <shiftl256+0x3c>
c0deac30:	2e80      	cmp	r6, #128	; 0x80
c0deac32:	d11e      	bne.n	c0deac72 <shiftl256+0x5e>
    UPPER_P(target) = UPPER_P(number);
c0deac34:	6928      	ldr	r0, [r5, #16]
c0deac36:	6969      	ldr	r1, [r5, #20]
c0deac38:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0deac3a:	69e8      	ldr	r0, [r5, #28]
c0deac3c:	2100      	movs	r1, #0
    UPPER_P(target) = UPPER_P(number);
c0deac3e:	3c08      	subs	r4, #8
    LOWER_P(target) = 0;
c0deac40:	61e1      	str	r1, [r4, #28]
c0deac42:	6161      	str	r1, [r4, #20]
    LOWER_P(target) = LOWER_P(number);
c0deac44:	69aa      	ldr	r2, [r5, #24]
c0deac46:	60e0      	str	r0, [r4, #12]
c0deac48:	60a2      	str	r2, [r4, #8]
    LOWER_P(target) = 0;
c0deac4a:	6121      	str	r1, [r4, #16]
c0deac4c:	61a1      	str	r1, [r4, #24]
c0deac4e:	e071      	b.n	c0dead34 <shiftl256+0x120>
    UPPER_P(target) = UPPER_P(number);
c0deac50:	cd03      	ldmia	r5!, {r0, r1}
c0deac52:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0deac54:	6828      	ldr	r0, [r5, #0]
c0deac56:	6869      	ldr	r1, [r5, #4]
c0deac58:	6061      	str	r1, [r4, #4]
c0deac5a:	6020      	str	r0, [r4, #0]
    UPPER_P(target) = UPPER_P(number);
c0deac5c:	3d08      	subs	r5, #8
c0deac5e:	3c08      	subs	r4, #8
c0deac60:	6928      	ldr	r0, [r5, #16]
c0deac62:	6969      	ldr	r1, [r5, #20]
c0deac64:	6161      	str	r1, [r4, #20]
c0deac66:	6120      	str	r0, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0deac68:	69a8      	ldr	r0, [r5, #24]
c0deac6a:	69e9      	ldr	r1, [r5, #28]
c0deac6c:	61e1      	str	r1, [r4, #28]
c0deac6e:	61a0      	str	r0, [r4, #24]
c0deac70:	e060      	b.n	c0dead34 <shiftl256+0x120>
        copy128(&UPPER_P(target), &LOWER_P(number));
        clear128(&LOWER_P(target));
    } else if (value == 0) {
        copy256(target, number);
    } else if (value < 128) {
c0deac72:	2e7f      	cmp	r6, #127	; 0x7f
c0deac74:	d850      	bhi.n	c0dead18 <shiftl256+0x104>
c0deac76:	aa12      	add	r2, sp, #72	; 0x48
        uint128_t tmp1;
        uint128_t tmp2;
        uint256_t result;
        shiftl128(&UPPER_P(number), value, &tmp1);
c0deac78:	4628      	mov	r0, r5
c0deac7a:	4631      	mov	r1, r6
c0deac7c:	f7ff ff84 	bl	c0deab88 <shiftl128>
c0deac80:	2080      	movs	r0, #128	; 0x80
        shiftr128(&LOWER_P(number), (128 - value), &tmp2);
c0deac82:	1b81      	subs	r1, r0, r6
c0deac84:	3510      	adds	r5, #16
c0deac86:	aa0e      	add	r2, sp, #56	; 0x38
c0deac88:	4628      	mov	r0, r5
c0deac8a:	f000 f855 	bl	c0dead38 <shiftr128>
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deac8e:	9914      	ldr	r1, [sp, #80]	; 0x50
c0deac90:	9103      	str	r1, [sp, #12]
c0deac92:	9810      	ldr	r0, [sp, #64]	; 0x40
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0deac94:	9004      	str	r0, [sp, #16]
c0deac96:	1840      	adds	r0, r0, r1
c0deac98:	9008      	str	r0, [sp, #32]
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deac9a:	9815      	ldr	r0, [sp, #84]	; 0x54
c0deac9c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0deac9e:	9202      	str	r2, [sp, #8]
c0deaca0:	4142      	adcs	r2, r0
c0deaca2:	9209      	str	r2, [sp, #36]	; 0x24
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deaca4:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0deaca6:	9105      	str	r1, [sp, #20]
c0deaca8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0deacaa:	9f12      	ldr	r7, [sp, #72]	; 0x48
c0deacac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0deacae:	19d9      	adds	r1, r3, r7
c0deacb0:	9b05      	ldr	r3, [sp, #20]
c0deacb2:	415a      	adcs	r2, r3
c0deacb4:	2300      	movs	r3, #0
c0deacb6:	9101      	str	r1, [sp, #4]
c0deacb8:	1c49      	adds	r1, r1, #1
c0deacba:	9105      	str	r1, [sp, #20]
c0deacbc:	9200      	str	r2, [sp, #0]
c0deacbe:	4617      	mov	r7, r2
c0deacc0:	415f      	adcs	r7, r3
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deacc2:	43c0      	mvns	r0, r0
c0deacc4:	9903      	ldr	r1, [sp, #12]
c0deacc6:	43c9      	mvns	r1, r1
c0deacc8:	9a04      	ldr	r2, [sp, #16]
c0deacca:	1a89      	subs	r1, r1, r2
c0deaccc:	9902      	ldr	r1, [sp, #8]
c0deacce:	4188      	sbcs	r0, r1
c0deacd0:	d200      	bcs.n	c0deacd4 <shiftl256+0xc0>
c0deacd2:	2301      	movs	r3, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deacd4:	2b00      	cmp	r3, #0
c0deacd6:	9805      	ldr	r0, [sp, #20]
c0deacd8:	d100      	bne.n	c0deacdc <shiftl256+0xc8>
c0deacda:	9f00      	ldr	r7, [sp, #0]
c0deacdc:	9707      	str	r7, [sp, #28]
c0deacde:	2b00      	cmp	r3, #0
c0deace0:	d100      	bne.n	c0deace4 <shiftl256+0xd0>
c0deace2:	9801      	ldr	r0, [sp, #4]
c0deace4:	9006      	str	r0, [sp, #24]
c0deace6:	aa06      	add	r2, sp, #24
        shiftl128(&LOWER_P(number), value, &LOWER(result));
c0deace8:	3210      	adds	r2, #16
c0deacea:	4628      	mov	r0, r5
c0deacec:	4631      	mov	r1, r6
c0deacee:	f7ff ff4b 	bl	c0deab88 <shiftl128>
    UPPER_P(target) = UPPER_P(number);
c0deacf2:	9807      	ldr	r0, [sp, #28]
c0deacf4:	9005      	str	r0, [sp, #20]
c0deacf6:	9906      	ldr	r1, [sp, #24]
    LOWER_P(target) = LOWER_P(number);
c0deacf8:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0deacfa:	9b08      	ldr	r3, [sp, #32]
    UPPER_P(target) = UPPER_P(number);
c0deacfc:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
c0deacfe:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    LOWER_P(target) = LOWER_P(number);
c0dead00:	9f0d      	ldr	r7, [sp, #52]	; 0x34
c0dead02:	980c      	ldr	r0, [sp, #48]	; 0x30
    UPPER_P(target) = UPPER_P(number);
c0dead04:	6021      	str	r1, [r4, #0]
c0dead06:	9905      	ldr	r1, [sp, #20]
c0dead08:	6061      	str	r1, [r4, #4]
    LOWER_P(target) = LOWER_P(number);
c0dead0a:	60a3      	str	r3, [r4, #8]
c0dead0c:	60e2      	str	r2, [r4, #12]
    UPPER_P(target) = UPPER_P(number);
c0dead0e:	6126      	str	r6, [r4, #16]
c0dead10:	6165      	str	r5, [r4, #20]
    LOWER_P(target) = LOWER_P(number);
c0dead12:	61a0      	str	r0, [r4, #24]
c0dead14:	61e7      	str	r7, [r4, #28]
c0dead16:	e00d      	b.n	c0dead34 <shiftl256+0x120>
    } else if ((256 > value) && (value > 128)) {
c0dead18:	2e80      	cmp	r6, #128	; 0x80
c0dead1a:	d081      	beq.n	c0deac20 <shiftl256+0xc>
        shiftl128(&LOWER_P(number), (value - 128), &UPPER_P(target));
c0dead1c:	3510      	adds	r5, #16
c0dead1e:	3e80      	subs	r6, #128	; 0x80
c0dead20:	4628      	mov	r0, r5
c0dead22:	4631      	mov	r1, r6
c0dead24:	4622      	mov	r2, r4
c0dead26:	f7ff ff2f 	bl	c0deab88 <shiftl128>
c0dead2a:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0dead2c:	6120      	str	r0, [r4, #16]
c0dead2e:	6160      	str	r0, [r4, #20]
c0dead30:	61a0      	str	r0, [r4, #24]
c0dead32:	61e0      	str	r0, [r4, #28]
}
c0dead34:	b017      	add	sp, #92	; 0x5c
c0dead36:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0dead38 <shiftr128>:
void shiftr128(uint128_t *number, uint32_t value, uint128_t *target) {
c0dead38:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0dead3a:	4614      	mov	r4, r2
    if (value >= 128) {
c0dead3c:	2980      	cmp	r1, #128	; 0x80
c0dead3e:	d305      	bcc.n	c0dead4c <shiftr128+0x14>
c0dead40:	2000      	movs	r0, #0
c0dead42:	6020      	str	r0, [r4, #0]
c0dead44:	6060      	str	r0, [r4, #4]
c0dead46:	60a0      	str	r0, [r4, #8]
c0dead48:	60e0      	str	r0, [r4, #12]
}
c0dead4a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0dead4c:	460d      	mov	r5, r1
c0dead4e:	4606      	mov	r6, r0
    } else if (value == 64) {
c0dead50:	2900      	cmp	r1, #0
c0dead52:	d006      	beq.n	c0dead62 <shiftr128+0x2a>
c0dead54:	2d40      	cmp	r5, #64	; 0x40
c0dead56:	d10c      	bne.n	c0dead72 <shiftr128+0x3a>
c0dead58:	2000      	movs	r0, #0
        UPPER_P(target) = 0;
c0dead5a:	6060      	str	r0, [r4, #4]
c0dead5c:	6020      	str	r0, [r4, #0]
        LOWER_P(target) = UPPER_P(number);
c0dead5e:	ce03      	ldmia	r6!, {r0, r1}
c0dead60:	e004      	b.n	c0dead6c <shiftr128+0x34>
    UPPER_P(target) = UPPER_P(number);
c0dead62:	ce03      	ldmia	r6!, {r0, r1}
c0dead64:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0dead66:	6830      	ldr	r0, [r6, #0]
c0dead68:	6871      	ldr	r1, [r6, #4]
    UPPER_P(target) = UPPER_P(number);
c0dead6a:	3c08      	subs	r4, #8
c0dead6c:	60e1      	str	r1, [r4, #12]
c0dead6e:	60a0      	str	r0, [r4, #8]
}
c0dead70:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    } else if (value < 64) {
c0dead72:	2d3f      	cmp	r5, #63	; 0x3f
c0dead74:	d81c      	bhi.n	c0deadb0 <shiftr128+0x78>
        UPPER(result) = UPPER_P(number) >> value;
c0dead76:	6837      	ldr	r7, [r6, #0]
c0dead78:	6871      	ldr	r1, [r6, #4]
c0dead7a:	9102      	str	r1, [sp, #8]
c0dead7c:	4638      	mov	r0, r7
c0dead7e:	462a      	mov	r2, r5
c0dead80:	f002 fbea 	bl	c0ded558 <__aeabi_llsr>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0dead84:	68b2      	ldr	r2, [r6, #8]
c0dead86:	68f3      	ldr	r3, [r6, #12]
    UPPER_P(target) = UPPER_P(number);
c0dead88:	c403      	stmia	r4!, {r0, r1}
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0dead8a:	4610      	mov	r0, r2
c0dead8c:	4619      	mov	r1, r3
c0dead8e:	462a      	mov	r2, r5
    UPPER_P(target) = UPPER_P(number);
c0dead90:	3c08      	subs	r4, #8
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0dead92:	f002 fbe1 	bl	c0ded558 <__aeabi_llsr>
c0dead96:	4606      	mov	r6, r0
c0dead98:	9101      	str	r1, [sp, #4]
c0dead9a:	2040      	movs	r0, #64	; 0x40
c0dead9c:	1b42      	subs	r2, r0, r5
c0dead9e:	4638      	mov	r0, r7
c0deada0:	9902      	ldr	r1, [sp, #8]
c0deada2:	f002 fbe5 	bl	c0ded570 <__aeabi_llsl>
c0deada6:	1830      	adds	r0, r6, r0
    LOWER_P(target) = LOWER_P(number);
c0deada8:	60a0      	str	r0, [r4, #8]
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0deadaa:	9801      	ldr	r0, [sp, #4]
c0deadac:	4141      	adcs	r1, r0
c0deadae:	e00a      	b.n	c0deadc6 <shiftr128+0x8e>
    } else if ((128 > value) && (value > 64)) {
c0deadb0:	2d40      	cmp	r5, #64	; 0x40
c0deadb2:	d0c5      	beq.n	c0dead40 <shiftr128+0x8>
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0deadb4:	ce03      	ldmia	r6!, {r0, r1}
c0deadb6:	2200      	movs	r2, #0
        UPPER_P(target) = 0;
c0deadb8:	6022      	str	r2, [r4, #0]
c0deadba:	6062      	str	r2, [r4, #4]
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0deadbc:	3d40      	subs	r5, #64	; 0x40
c0deadbe:	462a      	mov	r2, r5
c0deadc0:	f002 fbca 	bl	c0ded558 <__aeabi_llsr>
c0deadc4:	60a0      	str	r0, [r4, #8]
c0deadc6:	60e1      	str	r1, [r4, #12]
}
c0deadc8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

c0deadca <add128>:
void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
c0deadca:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
c0deadcc:	9203      	str	r2, [sp, #12]
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deadce:	6844      	ldr	r4, [r0, #4]
c0deadd0:	684d      	ldr	r5, [r1, #4]
c0deadd2:	6803      	ldr	r3, [r0, #0]
c0deadd4:	680e      	ldr	r6, [r1, #0]
c0deadd6:	18f2      	adds	r2, r6, r3
c0deadd8:	4165      	adcs	r5, r4
c0deadda:	2600      	movs	r6, #0
c0deaddc:	9200      	str	r2, [sp, #0]
c0deadde:	1c52      	adds	r2, r2, #1
c0deade0:	9202      	str	r2, [sp, #8]
c0deade2:	462f      	mov	r7, r5
c0deade4:	4177      	adcs	r7, r6
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deade6:	68ca      	ldr	r2, [r1, #12]
c0deade8:	9201      	str	r2, [sp, #4]
c0deadea:	68c4      	ldr	r4, [r0, #12]
c0deadec:	43e4      	mvns	r4, r4
c0deadee:	688a      	ldr	r2, [r1, #8]
c0deadf0:	6883      	ldr	r3, [r0, #8]
c0deadf2:	43db      	mvns	r3, r3
c0deadf4:	1a9a      	subs	r2, r3, r2
c0deadf6:	9a01      	ldr	r2, [sp, #4]
c0deadf8:	4194      	sbcs	r4, r2
c0deadfa:	d200      	bcs.n	c0deadfe <add128+0x34>
c0deadfc:	2601      	movs	r6, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deadfe:	2e00      	cmp	r6, #0
c0deae00:	9c03      	ldr	r4, [sp, #12]
c0deae02:	9a02      	ldr	r2, [sp, #8]
c0deae04:	d100      	bne.n	c0deae08 <add128+0x3e>
c0deae06:	462f      	mov	r7, r5
c0deae08:	6067      	str	r7, [r4, #4]
c0deae0a:	2e00      	cmp	r6, #0
c0deae0c:	d100      	bne.n	c0deae10 <add128+0x46>
c0deae0e:	9a00      	ldr	r2, [sp, #0]
c0deae10:	6022      	str	r2, [r4, #0]
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0deae12:	688a      	ldr	r2, [r1, #8]
c0deae14:	68c9      	ldr	r1, [r1, #12]
c0deae16:	6883      	ldr	r3, [r0, #8]
c0deae18:	68c0      	ldr	r0, [r0, #12]
c0deae1a:	18d2      	adds	r2, r2, r3
c0deae1c:	60a2      	str	r2, [r4, #8]
c0deae1e:	4148      	adcs	r0, r1
c0deae20:	60e0      	str	r0, [r4, #12]
}
c0deae22:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

c0deae24 <shiftr256>:
void shiftr256(uint256_t *number, uint32_t value, uint256_t *target) {
c0deae24:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deae26:	b093      	sub	sp, #76	; 0x4c
c0deae28:	4614      	mov	r4, r2
c0deae2a:	4605      	mov	r5, r0
    if (value >= 256) {
c0deae2c:	0a08      	lsrs	r0, r1, #8
c0deae2e:	d004      	beq.n	c0deae3a <shiftr256+0x16>
c0deae30:	2120      	movs	r1, #32
c0deae32:	4620      	mov	r0, r4
c0deae34:	f002 fcee 	bl	c0ded814 <__aeabi_memclr>
c0deae38:	e072      	b.n	c0deaf20 <shiftr256+0xfc>
c0deae3a:	460e      	mov	r6, r1
    } else if (value == 128) {
c0deae3c:	2900      	cmp	r1, #0
c0deae3e:	d00e      	beq.n	c0deae5e <shiftr256+0x3a>
c0deae40:	2e80      	cmp	r6, #128	; 0x80
c0deae42:	d11d      	bne.n	c0deae80 <shiftr256+0x5c>
    UPPER_P(target) = UPPER_P(number);
c0deae44:	cd03      	ldmia	r5!, {r0, r1}
c0deae46:	6161      	str	r1, [r4, #20]
c0deae48:	6120      	str	r0, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0deae4a:	6868      	ldr	r0, [r5, #4]
c0deae4c:	2100      	movs	r1, #0
    LOWER_P(target) = 0;
c0deae4e:	60e1      	str	r1, [r4, #12]
c0deae50:	6061      	str	r1, [r4, #4]
    LOWER_P(target) = LOWER_P(number);
c0deae52:	682a      	ldr	r2, [r5, #0]
c0deae54:	61e0      	str	r0, [r4, #28]
c0deae56:	61a2      	str	r2, [r4, #24]
    LOWER_P(target) = 0;
c0deae58:	6021      	str	r1, [r4, #0]
c0deae5a:	60a1      	str	r1, [r4, #8]
c0deae5c:	e060      	b.n	c0deaf20 <shiftr256+0xfc>
    UPPER_P(target) = UPPER_P(number);
c0deae5e:	cd03      	ldmia	r5!, {r0, r1}
c0deae60:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0deae62:	6828      	ldr	r0, [r5, #0]
c0deae64:	6869      	ldr	r1, [r5, #4]
c0deae66:	6061      	str	r1, [r4, #4]
c0deae68:	6020      	str	r0, [r4, #0]
    UPPER_P(target) = UPPER_P(number);
c0deae6a:	3d08      	subs	r5, #8
c0deae6c:	3c08      	subs	r4, #8
c0deae6e:	6928      	ldr	r0, [r5, #16]
c0deae70:	6969      	ldr	r1, [r5, #20]
c0deae72:	6161      	str	r1, [r4, #20]
c0deae74:	6120      	str	r0, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0deae76:	69a8      	ldr	r0, [r5, #24]
c0deae78:	69e9      	ldr	r1, [r5, #28]
c0deae7a:	61e1      	str	r1, [r4, #28]
c0deae7c:	61a0      	str	r0, [r4, #24]
c0deae7e:	e04f      	b.n	c0deaf20 <shiftr256+0xfc>
    } else if (value < 128) {
c0deae80:	2e7f      	cmp	r6, #127	; 0x7f
c0deae82:	d83f      	bhi.n	c0deaf04 <shiftr256+0xe0>
c0deae84:	aa02      	add	r2, sp, #8
        shiftr128(&UPPER_P(number), value, &UPPER(result));
c0deae86:	4628      	mov	r0, r5
c0deae88:	4631      	mov	r1, r6
c0deae8a:	f7ff ff55 	bl	c0dead38 <shiftr128>
        shiftr128(&LOWER_P(number), value, &tmp1);
c0deae8e:	4628      	mov	r0, r5
c0deae90:	3010      	adds	r0, #16
c0deae92:	aa0e      	add	r2, sp, #56	; 0x38
c0deae94:	4631      	mov	r1, r6
c0deae96:	f7ff ff4f 	bl	c0dead38 <shiftr128>
c0deae9a:	2080      	movs	r0, #128	; 0x80
        shiftl128(&UPPER_P(number), (128 - value), &tmp2);
c0deae9c:	1b81      	subs	r1, r0, r6
c0deae9e:	aa0a      	add	r2, sp, #40	; 0x28
c0deaea0:	4628      	mov	r0, r5
c0deaea2:	f7ff fe71 	bl	c0deab88 <shiftl128>
    UPPER_P(target) = UPPER_P(number);
c0deaea6:	9803      	ldr	r0, [sp, #12]
c0deaea8:	9902      	ldr	r1, [sp, #8]
    LOWER_P(target) = LOWER_P(number);
c0deaeaa:	9a05      	ldr	r2, [sp, #20]
c0deaeac:	9b04      	ldr	r3, [sp, #16]
    UPPER_P(target) = UPPER_P(number);
c0deaeae:	6021      	str	r1, [r4, #0]
c0deaeb0:	6060      	str	r0, [r4, #4]
    LOWER_P(target) = LOWER_P(number);
c0deaeb2:	60a3      	str	r3, [r4, #8]
c0deaeb4:	60e2      	str	r2, [r4, #12]
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deaeb6:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0deaeb8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0deaeba:	19b8      	adds	r0, r7, r6
    LOWER_P(target) = LOWER_P(number);
c0deaebc:	61a0      	str	r0, [r4, #24]
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deaebe:	9911      	ldr	r1, [sp, #68]	; 0x44
c0deaec0:	980d      	ldr	r0, [sp, #52]	; 0x34
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0deaec2:	4602      	mov	r2, r0
c0deaec4:	414a      	adcs	r2, r1
    LOWER_P(target) = LOWER_P(number);
c0deaec6:	61e2      	str	r2, [r4, #28]
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deaec8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0deaeca:	9201      	str	r2, [sp, #4]
c0deaecc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
c0deaece:	9d0e      	ldr	r5, [sp, #56]	; 0x38
c0deaed0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0deaed2:	195d      	adds	r5, r3, r5
c0deaed4:	9b01      	ldr	r3, [sp, #4]
c0deaed6:	415a      	adcs	r2, r3
c0deaed8:	2300      	movs	r3, #0
c0deaeda:	9500      	str	r5, [sp, #0]
c0deaedc:	1c6d      	adds	r5, r5, #1
c0deaede:	9501      	str	r5, [sp, #4]
c0deaee0:	4615      	mov	r5, r2
c0deaee2:	415d      	adcs	r5, r3
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0deaee4:	43c9      	mvns	r1, r1
c0deaee6:	43f6      	mvns	r6, r6
c0deaee8:	1bf6      	subs	r6, r6, r7
c0deaeea:	4181      	sbcs	r1, r0
c0deaeec:	d200      	bcs.n	c0deaef0 <shiftr256+0xcc>
c0deaeee:	2301      	movs	r3, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deaef0:	2b00      	cmp	r3, #0
c0deaef2:	9801      	ldr	r0, [sp, #4]
c0deaef4:	d100      	bne.n	c0deaef8 <shiftr256+0xd4>
c0deaef6:	4615      	mov	r5, r2
    UPPER_P(target) = UPPER_P(number);
c0deaef8:	6165      	str	r5, [r4, #20]
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0deaefa:	2b00      	cmp	r3, #0
c0deaefc:	d100      	bne.n	c0deaf00 <shiftr256+0xdc>
c0deaefe:	9800      	ldr	r0, [sp, #0]
    UPPER_P(target) = UPPER_P(number);
c0deaf00:	6120      	str	r0, [r4, #16]
c0deaf02:	e00d      	b.n	c0deaf20 <shiftr256+0xfc>
    } else if ((256 > value) && (value > 128)) {
c0deaf04:	2e80      	cmp	r6, #128	; 0x80
c0deaf06:	d093      	beq.n	c0deae30 <shiftr256+0xc>
        shiftr128(&UPPER_P(number), (value - 128), &LOWER_P(target));
c0deaf08:	3e80      	subs	r6, #128	; 0x80
c0deaf0a:	4622      	mov	r2, r4
c0deaf0c:	3210      	adds	r2, #16
c0deaf0e:	4628      	mov	r0, r5
c0deaf10:	4631      	mov	r1, r6
c0deaf12:	f7ff ff11 	bl	c0dead38 <shiftr128>
c0deaf16:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0deaf18:	6020      	str	r0, [r4, #0]
c0deaf1a:	6060      	str	r0, [r4, #4]
c0deaf1c:	60a0      	str	r0, [r4, #8]
c0deaf1e:	60e0      	str	r0, [r4, #12]
}
c0deaf20:	b013      	add	sp, #76	; 0x4c
c0deaf22:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0deaf24 <bits256>:
uint32_t bits256(uint256_t *number) {
c0deaf24:	b570      	push	{r4, r5, r6, lr}
c0deaf26:	6802      	ldr	r2, [r0, #0]
c0deaf28:	1d04      	adds	r4, r0, #4
c0deaf2a:	cc1a      	ldmia	r4, {r1, r3, r4}
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0deaf2c:	4625      	mov	r5, r4
c0deaf2e:	430d      	orrs	r5, r1
c0deaf30:	461e      	mov	r6, r3
c0deaf32:	4316      	orrs	r6, r2
c0deaf34:	432e      	orrs	r6, r5
c0deaf36:	d013      	beq.n	c0deaf60 <bits256+0x3c>
c0deaf38:	2080      	movs	r0, #128	; 0x80
c0deaf3a:	4615      	mov	r5, r2
c0deaf3c:	431d      	orrs	r5, r3
c0deaf3e:	460e      	mov	r6, r1
c0deaf40:	4326      	orrs	r6, r4
c0deaf42:	432e      	orrs	r6, r5
c0deaf44:	d024      	beq.n	c0deaf90 <bits256+0x6c>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0deaf46:	07d5      	lsls	r5, r2, #31
c0deaf48:	0866      	lsrs	r6, r4, #1
c0deaf4a:	19ad      	adds	r5, r5, r6
c0deaf4c:	085b      	lsrs	r3, r3, #1
c0deaf4e:	07e4      	lsls	r4, r4, #31
c0deaf50:	191b      	adds	r3, r3, r4
        UPPER(result) = UPPER_P(number) >> value;
c0deaf52:	0852      	lsrs	r2, r2, #1
c0deaf54:	07cc      	lsls	r4, r1, #31
c0deaf56:	1912      	adds	r2, r2, r4
            result++;
c0deaf58:	1c40      	adds	r0, r0, #1
        UPPER(result) = UPPER_P(number) >> value;
c0deaf5a:	0849      	lsrs	r1, r1, #1
c0deaf5c:	462c      	mov	r4, r5
c0deaf5e:	e7ec      	b.n	c0deaf3a <bits256+0x16>
    UPPER_P(target) = UPPER_P(number);
c0deaf60:	6902      	ldr	r2, [r0, #16]
c0deaf62:	4604      	mov	r4, r0
c0deaf64:	3414      	adds	r4, #20
c0deaf66:	cc1a      	ldmia	r4, {r1, r3, r4}
c0deaf68:	2000      	movs	r0, #0
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0deaf6a:	4615      	mov	r5, r2
c0deaf6c:	431d      	orrs	r5, r3
c0deaf6e:	460e      	mov	r6, r1
c0deaf70:	4326      	orrs	r6, r4
c0deaf72:	432e      	orrs	r6, r5
c0deaf74:	d00c      	beq.n	c0deaf90 <bits256+0x6c>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0deaf76:	07d5      	lsls	r5, r2, #31
c0deaf78:	0866      	lsrs	r6, r4, #1
c0deaf7a:	19ad      	adds	r5, r5, r6
c0deaf7c:	085b      	lsrs	r3, r3, #1
c0deaf7e:	07e4      	lsls	r4, r4, #31
c0deaf80:	191b      	adds	r3, r3, r4
        UPPER(result) = UPPER_P(number) >> value;
c0deaf82:	0852      	lsrs	r2, r2, #1
c0deaf84:	07cc      	lsls	r4, r1, #31
c0deaf86:	1912      	adds	r2, r2, r4
            result++;
c0deaf88:	1c40      	adds	r0, r0, #1
        UPPER(result) = UPPER_P(number) >> value;
c0deaf8a:	0849      	lsrs	r1, r1, #1
c0deaf8c:	462c      	mov	r4, r5
c0deaf8e:	e7ec      	b.n	c0deaf6a <bits256+0x46>
    return result;
c0deaf90:	bd70      	pop	{r4, r5, r6, pc}

c0deaf92 <equal256>:
bool equal256(uint256_t *number1, uint256_t *number2) {
c0deaf92:	b570      	push	{r4, r5, r6, lr}
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0deaf94:	c90c      	ldmia	r1!, {r2, r3}
c0deaf96:	c830      	ldmia	r0!, {r4, r5}
c0deaf98:	405d      	eors	r5, r3
c0deaf9a:	4054      	eors	r4, r2
c0deaf9c:	2200      	movs	r2, #0
c0deaf9e:	3808      	subs	r0, #8
c0deafa0:	3908      	subs	r1, #8
c0deafa2:	432c      	orrs	r4, r5
c0deafa4:	d118      	bne.n	c0deafd8 <equal256+0x46>
c0deafa6:	688b      	ldr	r3, [r1, #8]
c0deafa8:	68cc      	ldr	r4, [r1, #12]
c0deafaa:	6885      	ldr	r5, [r0, #8]
c0deafac:	68c6      	ldr	r6, [r0, #12]
c0deafae:	4066      	eors	r6, r4
c0deafb0:	405d      	eors	r5, r3
c0deafb2:	4335      	orrs	r5, r6
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
c0deafb4:	d110      	bne.n	c0deafd8 <equal256+0x46>
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0deafb6:	690b      	ldr	r3, [r1, #16]
c0deafb8:	694c      	ldr	r4, [r1, #20]
c0deafba:	6905      	ldr	r5, [r0, #16]
c0deafbc:	6946      	ldr	r6, [r0, #20]
c0deafbe:	4066      	eors	r6, r4
c0deafc0:	405d      	eors	r5, r3
c0deafc2:	4335      	orrs	r5, r6
c0deafc4:	d108      	bne.n	c0deafd8 <equal256+0x46>
c0deafc6:	698a      	ldr	r2, [r1, #24]
c0deafc8:	69c9      	ldr	r1, [r1, #28]
c0deafca:	6983      	ldr	r3, [r0, #24]
c0deafcc:	69c0      	ldr	r0, [r0, #28]
c0deafce:	4048      	eors	r0, r1
c0deafd0:	4053      	eors	r3, r2
c0deafd2:	4303      	orrs	r3, r0
c0deafd4:	425a      	negs	r2, r3
c0deafd6:	415a      	adcs	r2, r3
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
c0deafd8:	4610      	mov	r0, r2
c0deafda:	bd70      	pop	{r4, r5, r6, pc}

c0deafdc <gt256>:
bool gt256(uint256_t *number1, uint256_t *number2) {
c0deafdc:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0deafde:	680b      	ldr	r3, [r1, #0]
c0deafe0:	684a      	ldr	r2, [r1, #4]
c0deafe2:	6805      	ldr	r5, [r0, #0]
c0deafe4:	6844      	ldr	r4, [r0, #4]
c0deafe6:	4626      	mov	r6, r4
c0deafe8:	4056      	eors	r6, r2
c0deafea:	462f      	mov	r7, r5
c0deafec:	405f      	eors	r7, r3
c0deafee:	4337      	orrs	r7, r6
c0deaff0:	d11c      	bne.n	c0deb02c <gt256+0x50>
c0deaff2:	688b      	ldr	r3, [r1, #8]
c0deaff4:	68ca      	ldr	r2, [r1, #12]
c0deaff6:	6885      	ldr	r5, [r0, #8]
c0deaff8:	68c4      	ldr	r4, [r0, #12]
c0deaffa:	4626      	mov	r6, r4
c0deaffc:	4056      	eors	r6, r2
c0deaffe:	462f      	mov	r7, r5
c0deb000:	405f      	eors	r7, r3
c0deb002:	4337      	orrs	r7, r6
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0deb004:	d112      	bne.n	c0deb02c <gt256+0x50>
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0deb006:	690b      	ldr	r3, [r1, #16]
c0deb008:	694a      	ldr	r2, [r1, #20]
c0deb00a:	6905      	ldr	r5, [r0, #16]
c0deb00c:	6944      	ldr	r4, [r0, #20]
c0deb00e:	4626      	mov	r6, r4
c0deb010:	4056      	eors	r6, r2
c0deb012:	462f      	mov	r7, r5
c0deb014:	405f      	eors	r7, r3
c0deb016:	4337      	orrs	r7, r6
c0deb018:	d108      	bne.n	c0deb02c <gt256+0x50>
        return (LOWER_P(number1) > LOWER_P(number2));
c0deb01a:	6982      	ldr	r2, [r0, #24]
c0deb01c:	69c0      	ldr	r0, [r0, #28]
c0deb01e:	698b      	ldr	r3, [r1, #24]
c0deb020:	69c9      	ldr	r1, [r1, #28]
c0deb022:	1a9a      	subs	r2, r3, r2
c0deb024:	4181      	sbcs	r1, r0
c0deb026:	d204      	bcs.n	c0deb032 <gt256+0x56>
c0deb028:	2001      	movs	r0, #1
}
c0deb02a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0deb02c:	1b58      	subs	r0, r3, r5
c0deb02e:	41a2      	sbcs	r2, r4
c0deb030:	d3fa      	bcc.n	c0deb028 <gt256+0x4c>
c0deb032:	2000      	movs	r0, #0
c0deb034:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0deb036 <gte256>:
bool gte256(uint256_t *number1, uint256_t *number2) {
c0deb036:	b5b0      	push	{r4, r5, r7, lr}
c0deb038:	460c      	mov	r4, r1
c0deb03a:	4605      	mov	r5, r0
    return gt256(number1, number2) || equal256(number1, number2);
c0deb03c:	f7ff ffce 	bl	c0deafdc <gt256>
c0deb040:	2800      	cmp	r0, #0
c0deb042:	d001      	beq.n	c0deb048 <gte256+0x12>
c0deb044:	2001      	movs	r0, #1
c0deb046:	bdb0      	pop	{r4, r5, r7, pc}
c0deb048:	4628      	mov	r0, r5
c0deb04a:	4621      	mov	r1, r4
c0deb04c:	f7ff ffa1 	bl	c0deaf92 <equal256>
c0deb050:	bdb0      	pop	{r4, r5, r7, pc}

c0deb052 <add256>:

void add256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0deb052:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deb054:	b08b      	sub	sp, #44	; 0x2c
c0deb056:	4614      	mov	r4, r2
c0deb058:	460d      	mov	r5, r1
c0deb05a:	4607      	mov	r7, r0
    uint128_t tmp;
    add128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
c0deb05c:	f7ff feb5 	bl	c0deadca <add128>
    add128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
c0deb060:	4638      	mov	r0, r7
c0deb062:	3010      	adds	r0, #16
c0deb064:	3510      	adds	r5, #16
c0deb066:	aa06      	add	r2, sp, #24
c0deb068:	9001      	str	r0, [sp, #4]
c0deb06a:	4629      	mov	r1, r5
c0deb06c:	f7ff fead 	bl	c0deadca <add128>
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0deb070:	693e      	ldr	r6, [r7, #16]
c0deb072:	6978      	ldr	r0, [r7, #20]
c0deb074:	9907      	ldr	r1, [sp, #28]
c0deb076:	9000      	str	r0, [sp, #0]
c0deb078:	4048      	eors	r0, r1
c0deb07a:	9b06      	ldr	r3, [sp, #24]
c0deb07c:	4632      	mov	r2, r6
c0deb07e:	405a      	eors	r2, r3
c0deb080:	4302      	orrs	r2, r0
c0deb082:	d107      	bne.n	c0deb094 <add256+0x42>
        return (LOWER_P(number1) > LOWER_P(number2));
c0deb084:	69b8      	ldr	r0, [r7, #24]
c0deb086:	69f9      	ldr	r1, [r7, #28]
c0deb088:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0deb08a:	9b08      	ldr	r3, [sp, #32]
c0deb08c:	1a18      	subs	r0, r3, r0
c0deb08e:	418a      	sbcs	r2, r1
    if (gt128(&LOWER_P(number1), &tmp)) {
c0deb090:	d304      	bcc.n	c0deb09c <add256+0x4a>
c0deb092:	e00e      	b.n	c0deb0b2 <add256+0x60>
    return (UPPER_P(number1) > UPPER_P(number2));
c0deb094:	1b98      	subs	r0, r3, r6
c0deb096:	9800      	ldr	r0, [sp, #0]
c0deb098:	4181      	sbcs	r1, r0
    if (gt128(&LOWER_P(number1), &tmp)) {
c0deb09a:	d20a      	bcs.n	c0deb0b2 <add256+0x60>
c0deb09c:	2000      	movs	r0, #0
        uint128_t one;
        UPPER(one) = 0;
        LOWER(one) = 1;
c0deb09e:	9005      	str	r0, [sp, #20]
c0deb0a0:	2101      	movs	r1, #1
c0deb0a2:	9104      	str	r1, [sp, #16]
        UPPER(one) = 0;
c0deb0a4:	9003      	str	r0, [sp, #12]
c0deb0a6:	9002      	str	r0, [sp, #8]
c0deb0a8:	a902      	add	r1, sp, #8
        add128(&UPPER_P(target), &one, &UPPER_P(target));
c0deb0aa:	4620      	mov	r0, r4
c0deb0ac:	4622      	mov	r2, r4
c0deb0ae:	f7ff fe8c 	bl	c0deadca <add128>
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
c0deb0b2:	3410      	adds	r4, #16
c0deb0b4:	9801      	ldr	r0, [sp, #4]
c0deb0b6:	4629      	mov	r1, r5
c0deb0b8:	4622      	mov	r2, r4
c0deb0ba:	f7ff fe86 	bl	c0deadca <add128>
}
c0deb0be:	b00b      	add	sp, #44	; 0x2c
c0deb0c0:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0deb0c2 <minus128>:

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
c0deb0c2:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
c0deb0c4:	9203      	str	r2, [sp, #12]
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0deb0c6:	684c      	ldr	r4, [r1, #4]
c0deb0c8:	6845      	ldr	r5, [r0, #4]
c0deb0ca:	680b      	ldr	r3, [r1, #0]
c0deb0cc:	6806      	ldr	r6, [r0, #0]
c0deb0ce:	1af2      	subs	r2, r6, r3
c0deb0d0:	41a5      	sbcs	r5, r4
c0deb0d2:	2600      	movs	r6, #0
c0deb0d4:	9200      	str	r2, [sp, #0]
c0deb0d6:	1e52      	subs	r2, r2, #1
c0deb0d8:	9202      	str	r2, [sp, #8]
c0deb0da:	462f      	mov	r7, r5
c0deb0dc:	41b7      	sbcs	r7, r6
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0deb0de:	68ca      	ldr	r2, [r1, #12]
c0deb0e0:	9201      	str	r2, [sp, #4]
c0deb0e2:	68c4      	ldr	r4, [r0, #12]
c0deb0e4:	688a      	ldr	r2, [r1, #8]
c0deb0e6:	6883      	ldr	r3, [r0, #8]
c0deb0e8:	1a9a      	subs	r2, r3, r2
c0deb0ea:	9a01      	ldr	r2, [sp, #4]
c0deb0ec:	4194      	sbcs	r4, r2
c0deb0ee:	d200      	bcs.n	c0deb0f2 <minus128+0x30>
c0deb0f0:	2601      	movs	r6, #1
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0deb0f2:	2e00      	cmp	r6, #0
c0deb0f4:	9c03      	ldr	r4, [sp, #12]
c0deb0f6:	9a02      	ldr	r2, [sp, #8]
c0deb0f8:	d100      	bne.n	c0deb0fc <minus128+0x3a>
c0deb0fa:	462f      	mov	r7, r5
c0deb0fc:	6067      	str	r7, [r4, #4]
c0deb0fe:	2e00      	cmp	r6, #0
c0deb100:	d100      	bne.n	c0deb104 <minus128+0x42>
c0deb102:	9a00      	ldr	r2, [sp, #0]
c0deb104:	6022      	str	r2, [r4, #0]
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0deb106:	688a      	ldr	r2, [r1, #8]
c0deb108:	68c9      	ldr	r1, [r1, #12]
c0deb10a:	6883      	ldr	r3, [r0, #8]
c0deb10c:	68c0      	ldr	r0, [r0, #12]
c0deb10e:	1a9a      	subs	r2, r3, r2
c0deb110:	60a2      	str	r2, [r4, #8]
c0deb112:	4188      	sbcs	r0, r1
c0deb114:	60e0      	str	r0, [r4, #12]
}
c0deb116:	bdff      	pop	{r0, r1, r2, r3, r4, r5, r6, r7, pc}

c0deb118 <minus256>:

void minus256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0deb118:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deb11a:	b08f      	sub	sp, #60	; 0x3c
c0deb11c:	460d      	mov	r5, r1
c0deb11e:	4606      	mov	r6, r0
c0deb120:	9206      	str	r2, [sp, #24]
    uint128_t tmp;
    minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
c0deb122:	f7ff ffce 	bl	c0deb0c2 <minus128>
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0deb126:	696b      	ldr	r3, [r5, #20]
c0deb128:	6972      	ldr	r2, [r6, #20]
c0deb12a:	6929      	ldr	r1, [r5, #16]
c0deb12c:	6930      	ldr	r0, [r6, #16]
c0deb12e:	9008      	str	r0, [sp, #32]
c0deb130:	1a40      	subs	r0, r0, r1
c0deb132:	9207      	str	r2, [sp, #28]
c0deb134:	419a      	sbcs	r2, r3
c0deb136:	2300      	movs	r3, #0
c0deb138:	9000      	str	r0, [sp, #0]
c0deb13a:	1e40      	subs	r0, r0, #1
c0deb13c:	9009      	str	r0, [sp, #36]	; 0x24
c0deb13e:	4610      	mov	r0, r2
c0deb140:	4198      	sbcs	r0, r3
c0deb142:	9005      	str	r0, [sp, #20]
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0deb144:	69e8      	ldr	r0, [r5, #28]
c0deb146:	69f4      	ldr	r4, [r6, #28]
c0deb148:	69a9      	ldr	r1, [r5, #24]
c0deb14a:	69b7      	ldr	r7, [r6, #24]
c0deb14c:	9102      	str	r1, [sp, #8]
c0deb14e:	9701      	str	r7, [sp, #4]
c0deb150:	1a79      	subs	r1, r7, r1
c0deb152:	9403      	str	r4, [sp, #12]
c0deb154:	9004      	str	r0, [sp, #16]
c0deb156:	4184      	sbcs	r4, r0
c0deb158:	d200      	bcs.n	c0deb15c <minus256+0x44>
c0deb15a:	2301      	movs	r3, #1
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0deb15c:	2b00      	cmp	r3, #0
c0deb15e:	9c06      	ldr	r4, [sp, #24]
c0deb160:	d101      	bne.n	c0deb166 <minus256+0x4e>
c0deb162:	9800      	ldr	r0, [sp, #0]
c0deb164:	9009      	str	r0, [sp, #36]	; 0x24
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0deb166:	9909      	ldr	r1, [sp, #36]	; 0x24
c0deb168:	9808      	ldr	r0, [sp, #32]
c0deb16a:	4041      	eors	r1, r0
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0deb16c:	2b00      	cmp	r3, #0
c0deb16e:	9b05      	ldr	r3, [sp, #20]
c0deb170:	d100      	bne.n	c0deb174 <minus256+0x5c>
c0deb172:	4613      	mov	r3, r2
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0deb174:	461a      	mov	r2, r3
c0deb176:	9807      	ldr	r0, [sp, #28]
c0deb178:	4042      	eors	r2, r0
c0deb17a:	4311      	orrs	r1, r2
    minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
c0deb17c:	3510      	adds	r5, #16
c0deb17e:	3610      	adds	r6, #16
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0deb180:	2900      	cmp	r1, #0
c0deb182:	d107      	bne.n	c0deb194 <minus256+0x7c>
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0deb184:	9802      	ldr	r0, [sp, #8]
c0deb186:	9901      	ldr	r1, [sp, #4]
c0deb188:	1a08      	subs	r0, r1, r0
c0deb18a:	9804      	ldr	r0, [sp, #16]
c0deb18c:	9903      	ldr	r1, [sp, #12]
c0deb18e:	4181      	sbcs	r1, r0
    if (gt128(&tmp, &LOWER_P(number1))) {
c0deb190:	d305      	bcc.n	c0deb19e <minus256+0x86>
c0deb192:	e00f      	b.n	c0deb1b4 <minus256+0x9c>
    return (UPPER_P(number1) > UPPER_P(number2));
c0deb194:	9908      	ldr	r1, [sp, #32]
c0deb196:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0deb198:	1a89      	subs	r1, r1, r2
c0deb19a:	4198      	sbcs	r0, r3
    if (gt128(&tmp, &LOWER_P(number1))) {
c0deb19c:	d20a      	bcs.n	c0deb1b4 <minus256+0x9c>
c0deb19e:	2000      	movs	r0, #0
        uint128_t one;
        UPPER(one) = 0;
        LOWER(one) = 1;
c0deb1a0:	900d      	str	r0, [sp, #52]	; 0x34
c0deb1a2:	2101      	movs	r1, #1
c0deb1a4:	910c      	str	r1, [sp, #48]	; 0x30
        UPPER(one) = 0;
c0deb1a6:	900b      	str	r0, [sp, #44]	; 0x2c
c0deb1a8:	900a      	str	r0, [sp, #40]	; 0x28
c0deb1aa:	a90a      	add	r1, sp, #40	; 0x28
        minus128(&UPPER_P(target), &one, &UPPER_P(target));
c0deb1ac:	4620      	mov	r0, r4
c0deb1ae:	4622      	mov	r2, r4
c0deb1b0:	f7ff ff87 	bl	c0deb0c2 <minus128>
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
c0deb1b4:	3410      	adds	r4, #16
c0deb1b6:	4630      	mov	r0, r6
c0deb1b8:	4629      	mov	r1, r5
c0deb1ba:	4622      	mov	r2, r4
c0deb1bc:	f7ff ff81 	bl	c0deb0c2 <minus128>
}
c0deb1c0:	b00f      	add	sp, #60	; 0x3c
c0deb1c2:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0deb1c4 <write_u64_be>:
    buffer[2] = ((value >> 40) & 0xff);
    buffer[3] = ((value >> 32) & 0xff);
    buffer[4] = ((value >> 24) & 0xff);
    buffer[5] = ((value >> 16) & 0xff);
    buffer[6] = ((value >> 8) & 0xff);
    buffer[7] = (value & 0xff);
c0deb1c4:	71c2      	strb	r2, [r0, #7]
    buffer[3] = ((value >> 32) & 0xff);
c0deb1c6:	70c3      	strb	r3, [r0, #3]
    buffer[6] = ((value >> 8) & 0xff);
c0deb1c8:	0a11      	lsrs	r1, r2, #8
c0deb1ca:	7181      	strb	r1, [r0, #6]
    buffer[5] = ((value >> 16) & 0xff);
c0deb1cc:	0c11      	lsrs	r1, r2, #16
c0deb1ce:	7141      	strb	r1, [r0, #5]
    buffer[4] = ((value >> 24) & 0xff);
c0deb1d0:	0e11      	lsrs	r1, r2, #24
c0deb1d2:	7101      	strb	r1, [r0, #4]
    buffer[2] = ((value >> 40) & 0xff);
c0deb1d4:	0a19      	lsrs	r1, r3, #8
c0deb1d6:	7081      	strb	r1, [r0, #2]
    buffer[1] = ((value >> 48) & 0xff);
c0deb1d8:	0c19      	lsrs	r1, r3, #16
c0deb1da:	7041      	strb	r1, [r0, #1]
    buffer[0] = ((value >> 56) & 0xff);
c0deb1dc:	0e19      	lsrs	r1, r3, #24
c0deb1de:	7001      	strb	r1, [r0, #0]
}
c0deb1e0:	4770      	bx	lr

c0deb1e2 <read_u64_be>:

void read_u64_be(uint8_t *in, uint64_t *out) {
    uint8_t *out_ptr = (uint8_t *) out;
    *out_ptr++ = in[7];
c0deb1e2:	79c2      	ldrb	r2, [r0, #7]
c0deb1e4:	700a      	strb	r2, [r1, #0]
    *out_ptr++ = in[6];
c0deb1e6:	7982      	ldrb	r2, [r0, #6]
c0deb1e8:	704a      	strb	r2, [r1, #1]
    *out_ptr++ = in[5];
c0deb1ea:	7942      	ldrb	r2, [r0, #5]
c0deb1ec:	708a      	strb	r2, [r1, #2]
    *out_ptr++ = in[4];
c0deb1ee:	7902      	ldrb	r2, [r0, #4]
c0deb1f0:	70ca      	strb	r2, [r1, #3]
    *out_ptr++ = in[3];
c0deb1f2:	78c2      	ldrb	r2, [r0, #3]
c0deb1f4:	710a      	strb	r2, [r1, #4]
    *out_ptr++ = in[2];
c0deb1f6:	7882      	ldrb	r2, [r0, #2]
c0deb1f8:	714a      	strb	r2, [r1, #5]
    *out_ptr++ = in[1];
c0deb1fa:	7842      	ldrb	r2, [r0, #1]
c0deb1fc:	718a      	strb	r2, [r1, #6]
    *out_ptr = in[0];
c0deb1fe:	7800      	ldrb	r0, [r0, #0]
c0deb200:	71c8      	strb	r0, [r1, #7]
}
c0deb202:	4770      	bx	lr

c0deb204 <mul256>:

void mul256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0deb204:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deb206:	b0a5      	sub	sp, #148	; 0x94
c0deb208:	ab01      	add	r3, sp, #4
c0deb20a:	c307      	stmia	r3!, {r0, r1, r2}
c0deb20c:	a805      	add	r0, sp, #20
c0deb20e:	2140      	movs	r1, #64	; 0x40
    uint8_t num1[INT256_LENGTH], num2[INT256_LENGTH], result[INT256_LENGTH * 2];
    memset(&result, 0, sizeof(result));
c0deb210:	f002 fb00 	bl	c0ded814 <__aeabi_memclr>
c0deb214:	2500      	movs	r5, #0
c0deb216:	ae15      	add	r6, sp, #84	; 0x54
c0deb218:	ac1d      	add	r4, sp, #116	; 0x74
    for (uint8_t i = 0; i < 4; i++) {
c0deb21a:	2d04      	cmp	r5, #4
c0deb21c:	d01a      	beq.n	c0deb254 <mul256+0x50>
        write_u64_be(num1 + i * sizeof(uint64_t), number1->elements[i / 2].elements[i % 2]);
c0deb21e:	00ef      	lsls	r7, r5, #3
c0deb220:	2008      	movs	r0, #8
c0deb222:	9604      	str	r6, [sp, #16]
c0deb224:	463e      	mov	r6, r7
c0deb226:	4006      	ands	r6, r0
c0deb228:	4387      	bics	r7, r0
c0deb22a:	9801      	ldr	r0, [sp, #4]
c0deb22c:	19c0      	adds	r0, r0, r7
c0deb22e:	5982      	ldr	r2, [r0, r6]
c0deb230:	1980      	adds	r0, r0, r6
c0deb232:	6843      	ldr	r3, [r0, #4]
c0deb234:	4620      	mov	r0, r4
c0deb236:	f7ff ffc5 	bl	c0deb1c4 <write_u64_be>
        write_u64_be(num2 + i * sizeof(uint64_t), number2->elements[i / 2].elements[i % 2]);
c0deb23a:	9802      	ldr	r0, [sp, #8]
c0deb23c:	19c0      	adds	r0, r0, r7
c0deb23e:	5982      	ldr	r2, [r0, r6]
c0deb240:	1980      	adds	r0, r0, r6
c0deb242:	9e04      	ldr	r6, [sp, #16]
c0deb244:	6843      	ldr	r3, [r0, #4]
c0deb246:	4630      	mov	r0, r6
c0deb248:	f7ff ffbc 	bl	c0deb1c4 <write_u64_be>
    for (uint8_t i = 0; i < 4; i++) {
c0deb24c:	3408      	adds	r4, #8
c0deb24e:	3608      	adds	r6, #8
c0deb250:	1c6d      	adds	r5, r5, #1
c0deb252:	e7e2      	b.n	c0deb21a <mul256+0x16>
c0deb254:	a805      	add	r0, sp, #20
c0deb256:	a91d      	add	r1, sp, #116	; 0x74
c0deb258:	aa15      	add	r2, sp, #84	; 0x54
c0deb25a:	2320      	movs	r3, #32
  CX_THROW(cx_math_mult_no_throw(r, a, b, len));
c0deb25c:	f7f7 ff32 	bl	c0de30c4 <cx_math_mult_no_throw>
c0deb260:	2800      	cmp	r0, #0
c0deb262:	d113      	bne.n	c0deb28c <mul256+0x88>
c0deb264:	ac05      	add	r4, sp, #20
    }
    cx_math_mult(result, num1, num2, sizeof(num1));
    for (uint8_t i = 0; i < 4; i++) {
c0deb266:	3420      	adds	r4, #32
c0deb268:	2500      	movs	r5, #0
c0deb26a:	2d04      	cmp	r5, #4
c0deb26c:	d00c      	beq.n	c0deb288 <mul256+0x84>
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0deb26e:	0868      	lsrs	r0, r5, #1
c0deb270:	0100      	lsls	r0, r0, #4
c0deb272:	9903      	ldr	r1, [sp, #12]
c0deb274:	1808      	adds	r0, r1, r0
c0deb276:	07e9      	lsls	r1, r5, #31
c0deb278:	0f09      	lsrs	r1, r1, #28
c0deb27a:	1841      	adds	r1, r0, r1
c0deb27c:	4620      	mov	r0, r4
c0deb27e:	f7ff ffb0 	bl	c0deb1e2 <read_u64_be>
    for (uint8_t i = 0; i < 4; i++) {
c0deb282:	3408      	adds	r4, #8
c0deb284:	1c6d      	adds	r5, r5, #1
c0deb286:	e7f0      	b.n	c0deb26a <mul256+0x66>
    }
}
c0deb288:	b025      	add	sp, #148	; 0x94
c0deb28a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0deb28c:	f7fc f8cb 	bl	c0de7426 <os_longjmp>

c0deb290 <divmod256>:
        copy128(retDiv, &resDiv);
        copy128(retMod, &resMod);
    }
}

void divmod256(uint256_t *l, uint256_t *r, uint256_t *retDiv, uint256_t *retMod) {
c0deb290:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deb292:	b0ab      	sub	sp, #172	; 0xac
c0deb294:	461d      	mov	r5, r3
c0deb296:	9208      	str	r2, [sp, #32]
c0deb298:	460c      	mov	r4, r1
c0deb29a:	9109      	str	r1, [sp, #36]	; 0x24
c0deb29c:	4607      	mov	r7, r0
c0deb29e:	a80a      	add	r0, sp, #40	; 0x28
c0deb2a0:	2118      	movs	r1, #24
    uint256_t copyd, adder, resDiv, resMod;
    uint256_t one;
    clear256(&one);
    UPPER(LOWER(one)) = 0;
c0deb2a2:	f002 fab7 	bl	c0ded814 <__aeabi_memclr>
c0deb2a6:	2000      	movs	r0, #0
c0deb2a8:	9007      	str	r0, [sp, #28]
    LOWER(LOWER(one)) = 1;
c0deb2aa:	9011      	str	r0, [sp, #68]	; 0x44
c0deb2ac:	2001      	movs	r0, #1
c0deb2ae:	9010      	str	r0, [sp, #64]	; 0x40
    uint32_t diffBits = bits256(l) - bits256(r);
c0deb2b0:	4638      	mov	r0, r7
c0deb2b2:	f7ff fe37 	bl	c0deaf24 <bits256>
c0deb2b6:	9004      	str	r0, [sp, #16]
c0deb2b8:	4620      	mov	r0, r4
c0deb2ba:	f7ff fe33 	bl	c0deaf24 <bits256>
c0deb2be:	9003      	str	r0, [sp, #12]
    UPPER_P(target) = UPPER_P(number);
c0deb2c0:	cf41      	ldmia	r7!, {r0, r6}
    LOWER_P(target) = LOWER_P(number);
c0deb2c2:	6839      	ldr	r1, [r7, #0]
c0deb2c4:	9106      	str	r1, [sp, #24]
    UPPER_P(target) = UPPER_P(number);
c0deb2c6:	3f08      	subs	r7, #8
    LOWER_P(target) = LOWER_P(number);
c0deb2c8:	463c      	mov	r4, r7
c0deb2ca:	340c      	adds	r4, #12
c0deb2cc:	cc1e      	ldmia	r4, {r1, r2, r3, r4}
c0deb2ce:	9405      	str	r4, [sp, #20]
c0deb2d0:	69fc      	ldr	r4, [r7, #28]
c0deb2d2:	9601      	str	r6, [sp, #4]
    UPPER_P(target) = UPPER_P(number);
c0deb2d4:	9613      	str	r6, [sp, #76]	; 0x4c
c0deb2d6:	9002      	str	r0, [sp, #8]
c0deb2d8:	9012      	str	r0, [sp, #72]	; 0x48
    LOWER_P(target) = LOWER_P(number);
c0deb2da:	9115      	str	r1, [sp, #84]	; 0x54
c0deb2dc:	9806      	ldr	r0, [sp, #24]
c0deb2de:	9014      	str	r0, [sp, #80]	; 0x50
    UPPER_P(target) = UPPER_P(number);
c0deb2e0:	9317      	str	r3, [sp, #92]	; 0x5c
c0deb2e2:	9216      	str	r2, [sp, #88]	; 0x58
    LOWER_P(target) = LOWER_P(number);
c0deb2e4:	9419      	str	r4, [sp, #100]	; 0x64
c0deb2e6:	9c09      	ldr	r4, [sp, #36]	; 0x24
c0deb2e8:	9805      	ldr	r0, [sp, #20]
c0deb2ea:	9018      	str	r0, [sp, #96]	; 0x60
    clear256(&resDiv);
    copy256(&resMod, l);
    if (gt256(r, l)) {
c0deb2ec:	4620      	mov	r0, r4
c0deb2ee:	4639      	mov	r1, r7
c0deb2f0:	f7ff fe74 	bl	c0deafdc <gt256>
c0deb2f4:	2800      	cmp	r0, #0
c0deb2f6:	d014      	beq.n	c0deb322 <divmod256+0x92>
    UPPER_P(target) = UPPER_P(number);
c0deb2f8:	9802      	ldr	r0, [sp, #8]
c0deb2fa:	6028      	str	r0, [r5, #0]
c0deb2fc:	9801      	ldr	r0, [sp, #4]
c0deb2fe:	6068      	str	r0, [r5, #4]
    LOWER_P(target) = LOWER_P(number);
c0deb300:	68b8      	ldr	r0, [r7, #8]
c0deb302:	68f9      	ldr	r1, [r7, #12]
c0deb304:	60e9      	str	r1, [r5, #12]
c0deb306:	60a8      	str	r0, [r5, #8]
    UPPER_P(target) = UPPER_P(number);
c0deb308:	6938      	ldr	r0, [r7, #16]
c0deb30a:	6979      	ldr	r1, [r7, #20]
c0deb30c:	6169      	str	r1, [r5, #20]
c0deb30e:	6128      	str	r0, [r5, #16]
    LOWER_P(target) = LOWER_P(number);
c0deb310:	69b8      	ldr	r0, [r7, #24]
c0deb312:	69f9      	ldr	r1, [r7, #28]
c0deb314:	61e9      	str	r1, [r5, #28]
c0deb316:	61a8      	str	r0, [r5, #24]
c0deb318:	2120      	movs	r1, #32
    LOWER_P(target) = 0;
c0deb31a:	9808      	ldr	r0, [sp, #32]
c0deb31c:	f002 fa7a 	bl	c0ded814 <__aeabi_memclr>
c0deb320:	e078      	b.n	c0deb414 <divmod256+0x184>
c0deb322:	9502      	str	r5, [sp, #8]
c0deb324:	9804      	ldr	r0, [sp, #16]
c0deb326:	9903      	ldr	r1, [sp, #12]
c0deb328:	1a45      	subs	r5, r0, r1
c0deb32a:	af22      	add	r7, sp, #136	; 0x88
        copy256(retMod, l);
        clear256(retDiv);
    } else {
        shiftl256(r, diffBits, &copyd);
c0deb32c:	4620      	mov	r0, r4
c0deb32e:	4629      	mov	r1, r5
c0deb330:	463a      	mov	r2, r7
c0deb332:	f7ff fc6f 	bl	c0deac14 <shiftl256>
c0deb336:	a80a      	add	r0, sp, #40	; 0x28
c0deb338:	aa1a      	add	r2, sp, #104	; 0x68
        shiftl256(&one, diffBits, &adder);
c0deb33a:	4629      	mov	r1, r5
c0deb33c:	f7ff fc6a 	bl	c0deac14 <shiftl256>
c0deb340:	a912      	add	r1, sp, #72	; 0x48
        if (gt256(&copyd, &resMod)) {
c0deb342:	4638      	mov	r0, r7
c0deb344:	f7ff fe4a 	bl	c0deafdc <gt256>
c0deb348:	2800      	cmp	r0, #0
c0deb34a:	d00a      	beq.n	c0deb362 <divmod256+0xd2>
c0deb34c:	2501      	movs	r5, #1
c0deb34e:	a822      	add	r0, sp, #136	; 0x88
            shiftr256(&copyd, 1, &copyd);
c0deb350:	4629      	mov	r1, r5
c0deb352:	4602      	mov	r2, r0
c0deb354:	f7ff fd66 	bl	c0deae24 <shiftr256>
c0deb358:	a81a      	add	r0, sp, #104	; 0x68
            shiftr256(&adder, 1, &adder);
c0deb35a:	4629      	mov	r1, r5
c0deb35c:	4602      	mov	r2, r0
c0deb35e:	f7ff fd61 	bl	c0deae24 <shiftr256>
c0deb362:	9807      	ldr	r0, [sp, #28]
c0deb364:	4607      	mov	r7, r0
c0deb366:	4604      	mov	r4, r0
c0deb368:	4606      	mov	r6, r0
c0deb36a:	9006      	str	r0, [sp, #24]
c0deb36c:	9005      	str	r0, [sp, #20]
c0deb36e:	9004      	str	r0, [sp, #16]
c0deb370:	9003      	str	r0, [sp, #12]
c0deb372:	a812      	add	r0, sp, #72	; 0x48
        }
        while (gte256(&resMod, r)) {
c0deb374:	9909      	ldr	r1, [sp, #36]	; 0x24
c0deb376:	f7ff fe5e 	bl	c0deb036 <gte256>
c0deb37a:	2800      	cmp	r0, #0
c0deb37c:	9808      	ldr	r0, [sp, #32]
c0deb37e:	d030      	beq.n	c0deb3e2 <divmod256+0x152>
c0deb380:	a812      	add	r0, sp, #72	; 0x48
c0deb382:	a922      	add	r1, sp, #136	; 0x88
            if (gte256(&resMod, &copyd)) {
c0deb384:	f7ff fe57 	bl	c0deb036 <gte256>
c0deb388:	2800      	cmp	r0, #0
c0deb38a:	d01e      	beq.n	c0deb3ca <divmod256+0x13a>
c0deb38c:	a922      	add	r1, sp, #136	; 0x88
c0deb38e:	a812      	add	r0, sp, #72	; 0x48
                minus256(&resMod, &copyd, &resMod);
c0deb390:	4602      	mov	r2, r0
c0deb392:	f7ff fec1 	bl	c0deb118 <minus256>
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0deb396:	9821      	ldr	r0, [sp, #132]	; 0x84
c0deb398:	9903      	ldr	r1, [sp, #12]
c0deb39a:	4301      	orrs	r1, r0
c0deb39c:	9103      	str	r1, [sp, #12]
c0deb39e:	9820      	ldr	r0, [sp, #128]	; 0x80
c0deb3a0:	9904      	ldr	r1, [sp, #16]
c0deb3a2:	4301      	orrs	r1, r0
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0deb3a4:	9104      	str	r1, [sp, #16]
c0deb3a6:	981f      	ldr	r0, [sp, #124]	; 0x7c
c0deb3a8:	9905      	ldr	r1, [sp, #20]
c0deb3aa:	4301      	orrs	r1, r0
c0deb3ac:	9105      	str	r1, [sp, #20]
c0deb3ae:	981e      	ldr	r0, [sp, #120]	; 0x78
c0deb3b0:	9906      	ldr	r1, [sp, #24]
c0deb3b2:	4301      	orrs	r1, r0
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0deb3b4:	9106      	str	r1, [sp, #24]
c0deb3b6:	981d      	ldr	r0, [sp, #116]	; 0x74
c0deb3b8:	4306      	orrs	r6, r0
c0deb3ba:	981c      	ldr	r0, [sp, #112]	; 0x70
c0deb3bc:	4304      	orrs	r4, r0
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0deb3be:	981b      	ldr	r0, [sp, #108]	; 0x6c
c0deb3c0:	4307      	orrs	r7, r0
c0deb3c2:	981a      	ldr	r0, [sp, #104]	; 0x68
c0deb3c4:	9907      	ldr	r1, [sp, #28]
c0deb3c6:	4301      	orrs	r1, r0
c0deb3c8:	9107      	str	r1, [sp, #28]
c0deb3ca:	2501      	movs	r5, #1
c0deb3cc:	a822      	add	r0, sp, #136	; 0x88
                or256(&resDiv, &adder, &resDiv);
            }
            shiftr256(&copyd, 1, &copyd);
c0deb3ce:	4629      	mov	r1, r5
c0deb3d0:	4602      	mov	r2, r0
c0deb3d2:	f7ff fd27 	bl	c0deae24 <shiftr256>
c0deb3d6:	a81a      	add	r0, sp, #104	; 0x68
            shiftr256(&adder, 1, &adder);
c0deb3d8:	4629      	mov	r1, r5
c0deb3da:	4602      	mov	r2, r0
c0deb3dc:	f7ff fd22 	bl	c0deae24 <shiftr256>
c0deb3e0:	e7c7      	b.n	c0deb372 <divmod256+0xe2>
    UPPER_P(target) = UPPER_P(number);
c0deb3e2:	9907      	ldr	r1, [sp, #28]
c0deb3e4:	c082      	stmia	r0!, {r1, r7}
    LOWER_P(target) = LOWER_P(number);
c0deb3e6:	6004      	str	r4, [r0, #0]
c0deb3e8:	6046      	str	r6, [r0, #4]
    UPPER_P(target) = UPPER_P(number);
c0deb3ea:	9906      	ldr	r1, [sp, #24]
c0deb3ec:	3808      	subs	r0, #8
c0deb3ee:	6101      	str	r1, [r0, #16]
c0deb3f0:	9905      	ldr	r1, [sp, #20]
c0deb3f2:	6141      	str	r1, [r0, #20]
    LOWER_P(target) = LOWER_P(number);
c0deb3f4:	9904      	ldr	r1, [sp, #16]
c0deb3f6:	6181      	str	r1, [r0, #24]
c0deb3f8:	9903      	ldr	r1, [sp, #12]
c0deb3fa:	61c1      	str	r1, [r0, #28]
    UPPER_P(target) = UPPER_P(number);
c0deb3fc:	9812      	ldr	r0, [sp, #72]	; 0x48
c0deb3fe:	9009      	str	r0, [sp, #36]	; 0x24
c0deb400:	9813      	ldr	r0, [sp, #76]	; 0x4c
    LOWER_P(target) = LOWER_P(number);
c0deb402:	9008      	str	r0, [sp, #32]
c0deb404:	af14      	add	r7, sp, #80	; 0x50
c0deb406:	cffc      	ldmia	r7, {r2, r3, r4, r5, r6, r7}
c0deb408:	9802      	ldr	r0, [sp, #8]
    UPPER_P(target) = UPPER_P(number);
c0deb40a:	9909      	ldr	r1, [sp, #36]	; 0x24
c0deb40c:	6001      	str	r1, [r0, #0]
c0deb40e:	9908      	ldr	r1, [sp, #32]
c0deb410:	1d00      	adds	r0, r0, #4
c0deb412:	c0fe      	stmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
        }
        copy256(retDiv, &resDiv);
        copy256(retMod, &resMod);
    }
}
c0deb414:	b02b      	add	sp, #172	; 0xac
c0deb416:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0deb418 <reverseString>:

static void reverseString(char *str, uint32_t length) {
c0deb418:	b510      	push	{r4, lr}
    uint32_t i, j;
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0deb41a:	1e49      	subs	r1, r1, #1
c0deb41c:	2200      	movs	r2, #0
c0deb41e:	428a      	cmp	r2, r1
c0deb420:	d206      	bcs.n	c0deb430 <reverseString+0x18>
        uint8_t c;
        c = str[i];
c0deb422:	5c83      	ldrb	r3, [r0, r2]
        str[i] = str[j];
c0deb424:	5c44      	ldrb	r4, [r0, r1]
c0deb426:	5484      	strb	r4, [r0, r2]
        str[j] = c;
c0deb428:	5443      	strb	r3, [r0, r1]
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0deb42a:	1e49      	subs	r1, r1, #1
c0deb42c:	1c52      	adds	r2, r2, #1
c0deb42e:	e7f6      	b.n	c0deb41e <reverseString+0x6>
    }
}
c0deb430:	bd10      	pop	{r4, pc}
c0deb432:	d4d4      	bmi.n	c0deb3de <divmod256+0x14e>

c0deb434 <tostring256>:
    out[offset] = '\0';
    reverseString(out, offset);
    return true;
}

bool tostring256(uint256_t *number, uint32_t baseParam, char *out, uint32_t outLength) {
c0deb434:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deb436:	b09d      	sub	sp, #116	; 0x74
c0deb438:	9301      	str	r3, [sp, #4]
c0deb43a:	9203      	str	r2, [sp, #12]
c0deb43c:	9102      	str	r1, [sp, #8]
    UPPER_P(target) = UPPER_P(number);
c0deb43e:	c8fe      	ldmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0deb440:	6800      	ldr	r0, [r0, #0]
c0deb442:	901b      	str	r0, [sp, #108]	; 0x6c
    UPPER_P(target) = UPPER_P(number);
c0deb444:	a814      	add	r0, sp, #80	; 0x50
c0deb446:	c0fe      	stmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
c0deb448:	a80c      	add	r0, sp, #48	; 0x30
c0deb44a:	2120      	movs	r1, #32
    LOWER_P(target) = 0;
c0deb44c:	f002 f9e2 	bl	c0ded814 <__aeabi_memclr>
c0deb450:	a804      	add	r0, sp, #16
c0deb452:	2118      	movs	r1, #24
    uint256_t rMod;
    uint256_t base;
    copy256(&rDiv, number);
    clear256(&rMod);
    clear256(&base);
    UPPER(LOWER(base)) = 0;
c0deb454:	f002 f9de 	bl	c0ded814 <__aeabi_memclr>
c0deb458:	2000      	movs	r0, #0
    LOWER(LOWER(base)) = baseParam;
c0deb45a:	900b      	str	r0, [sp, #44]	; 0x2c
c0deb45c:	9902      	ldr	r1, [sp, #8]
c0deb45e:	910a      	str	r1, [sp, #40]	; 0x28
    uint32_t offset = 0;
    if ((baseParam < 2) || (baseParam > 16)) {
c0deb460:	1e89      	subs	r1, r1, #2
c0deb462:	290e      	cmp	r1, #14
c0deb464:	d82d      	bhi.n	c0deb4c2 <tostring256+0x8e>
c0deb466:	9801      	ldr	r0, [sp, #4]
c0deb468:	1e45      	subs	r5, r0, #1
c0deb46a:	2600      	movs	r6, #0
c0deb46c:	4c16      	ldr	r4, [pc, #88]	; (c0deb4c8 <tostring256+0x94>)
c0deb46e:	447c      	add	r4, pc
c0deb470:	9602      	str	r6, [sp, #8]
        return false;
    }
    do {
        if (offset > (outLength - 1)) {
c0deb472:	42ae      	cmp	r6, r5
c0deb474:	d824      	bhi.n	c0deb4c0 <tostring256+0x8c>
c0deb476:	a904      	add	r1, sp, #16
c0deb478:	a814      	add	r0, sp, #80	; 0x50
c0deb47a:	af0c      	add	r7, sp, #48	; 0x30
            return false;
        }
        divmod256(&rDiv, &base, &rDiv, &rMod);
c0deb47c:	4602      	mov	r2, r0
c0deb47e:	463b      	mov	r3, r7
c0deb480:	f7ff ff06 	bl	c0deb290 <divmod256>
        out[offset++] = HEXDIGITS[(uint8_t) LOWER(LOWER(rMod))];
c0deb484:	7e38      	ldrb	r0, [r7, #24]
c0deb486:	5c20      	ldrb	r0, [r4, r0]
c0deb488:	9903      	ldr	r1, [sp, #12]
c0deb48a:	5588      	strb	r0, [r1, r6]
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0deb48c:	981b      	ldr	r0, [sp, #108]	; 0x6c
c0deb48e:	9919      	ldr	r1, [sp, #100]	; 0x64
c0deb490:	4301      	orrs	r1, r0
c0deb492:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0deb494:	4308      	orrs	r0, r1
c0deb496:	9915      	ldr	r1, [sp, #84]	; 0x54
c0deb498:	4301      	orrs	r1, r0
c0deb49a:	981a      	ldr	r0, [sp, #104]	; 0x68
c0deb49c:	9a18      	ldr	r2, [sp, #96]	; 0x60
c0deb49e:	4302      	orrs	r2, r0
c0deb4a0:	9816      	ldr	r0, [sp, #88]	; 0x58
c0deb4a2:	4310      	orrs	r0, r2
c0deb4a4:	9a14      	ldr	r2, [sp, #80]	; 0x50
c0deb4a6:	4302      	orrs	r2, r0
c0deb4a8:	430a      	orrs	r2, r1
        out[offset++] = HEXDIGITS[(uint8_t) LOWER(LOWER(rMod))];
c0deb4aa:	1c76      	adds	r6, r6, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0deb4ac:	2a00      	cmp	r2, #0
c0deb4ae:	d1e0      	bne.n	c0deb472 <tostring256+0x3e>
c0deb4b0:	2100      	movs	r1, #0
c0deb4b2:	9803      	ldr	r0, [sp, #12]
    } while (!zero256(&rDiv));
    out[offset] = '\0';
c0deb4b4:	5581      	strb	r1, [r0, r6]
    reverseString(out, offset);
c0deb4b6:	4631      	mov	r1, r6
c0deb4b8:	f7ff ffae 	bl	c0deb418 <reverseString>
c0deb4bc:	2001      	movs	r0, #1
c0deb4be:	e000      	b.n	c0deb4c2 <tostring256+0x8e>
c0deb4c0:	9802      	ldr	r0, [sp, #8]
    return true;
}
c0deb4c2:	b01d      	add	sp, #116	; 0x74
c0deb4c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0deb4c6:	46c0      	nop			; (mov r8, r8)
c0deb4c8:	00002c70 	.word	0x00002c70

c0deb4cc <USBD_LL_Init>:
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  UNUSED(pdev);
  ep_in_stall = 0;
  ep_out_stall = 0;
c0deb4cc:	4903      	ldr	r1, [pc, #12]	; (c0deb4dc <USBD_LL_Init+0x10>)
  ep_in_stall = 0;
c0deb4ce:	464a      	mov	r2, r9
c0deb4d0:	2000      	movs	r0, #0
  ep_out_stall = 0;
c0deb4d2:	5050      	str	r0, [r2, r1]
  ep_in_stall = 0;
c0deb4d4:	4902      	ldr	r1, [pc, #8]	; (c0deb4e0 <USBD_LL_Init+0x14>)
c0deb4d6:	5050      	str	r0, [r2, r1]
  return USBD_OK;
c0deb4d8:	4770      	bx	lr
c0deb4da:	46c0      	nop			; (mov r8, r8)
c0deb4dc:	00000bec 	.word	0x00000bec
c0deb4e0:	00000be8 	.word	0x00000be8

c0deb4e4 <USBD_LL_DeInit>:
  * @brief  De-Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev)
{
c0deb4e4:	b510      	push	{r4, lr}
  UNUSED(pdev);
  // usb off
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0deb4e6:	4808      	ldr	r0, [pc, #32]	; (c0deb508 <USBD_LL_DeInit+0x24>)
c0deb4e8:	4649      	mov	r1, r9
c0deb4ea:	224f      	movs	r2, #79	; 0x4f
c0deb4ec:	540a      	strb	r2, [r1, r0]
c0deb4ee:	1808      	adds	r0, r1, r0
c0deb4f0:	2102      	movs	r1, #2
  G_io_seproxyhal_spi_buffer[1] = 0;
  G_io_seproxyhal_spi_buffer[2] = 1;
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0deb4f2:	70c1      	strb	r1, [r0, #3]
c0deb4f4:	2101      	movs	r1, #1
  G_io_seproxyhal_spi_buffer[2] = 1;
c0deb4f6:	7081      	strb	r1, [r0, #2]
c0deb4f8:	2400      	movs	r4, #0
  G_io_seproxyhal_spi_buffer[1] = 0;
c0deb4fa:	7044      	strb	r4, [r0, #1]
c0deb4fc:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 4);
c0deb4fe:	f7fd fefd 	bl	c0de92fc <io_seph_send>

  return USBD_OK; 
c0deb502:	4620      	mov	r0, r4
c0deb504:	bd10      	pop	{r4, pc}
c0deb506:	46c0      	nop			; (mov r8, r8)
c0deb508:	00000444 	.word	0x00000444

c0deb50c <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
c0deb50c:	b57c      	push	{r2, r3, r4, r5, r6, lr}
c0deb50e:	466d      	mov	r5, sp
c0deb510:	2400      	movs	r4, #0
  // reset address
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 2;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
  buffer[4] = 0;
c0deb512:	712c      	strb	r4, [r5, #4]
c0deb514:	2003      	movs	r0, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0deb516:	70e8      	strb	r0, [r5, #3]
c0deb518:	2002      	movs	r0, #2
  buffer[2] = 2;
c0deb51a:	70a8      	strb	r0, [r5, #2]
  buffer[1] = 0;
c0deb51c:	706c      	strb	r4, [r5, #1]
c0deb51e:	264f      	movs	r6, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0deb520:	702e      	strb	r6, [r5, #0]
c0deb522:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(buffer, 5);
c0deb524:	4628      	mov	r0, r5
c0deb526:	f7fd fee9 	bl	c0de92fc <io_seph_send>
c0deb52a:	2001      	movs	r0, #1
  
  // start usb operation
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 1;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_CONNECT;
c0deb52c:	70e8      	strb	r0, [r5, #3]
  buffer[2] = 1;
c0deb52e:	70a8      	strb	r0, [r5, #2]
  buffer[1] = 0;
c0deb530:	706c      	strb	r4, [r5, #1]
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0deb532:	702e      	strb	r6, [r5, #0]
c0deb534:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0deb536:	4628      	mov	r0, r5
c0deb538:	f7fd fee0 	bl	c0de92fc <io_seph_send>
  return USBD_OK; 
c0deb53c:	4620      	mov	r0, r4
c0deb53e:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}

c0deb540 <USBD_LL_Stop>:
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
c0deb540:	b51c      	push	{r2, r3, r4, lr}
c0deb542:	a801      	add	r0, sp, #4
c0deb544:	2102      	movs	r1, #2
  UNUSED(pdev);
  uint8_t buffer[4];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 1;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0deb546:	70c1      	strb	r1, [r0, #3]
c0deb548:	2101      	movs	r1, #1
  buffer[2] = 1;
c0deb54a:	7081      	strb	r1, [r0, #2]
c0deb54c:	2400      	movs	r4, #0
  buffer[1] = 0;
c0deb54e:	7044      	strb	r4, [r0, #1]
c0deb550:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0deb552:	7001      	strb	r1, [r0, #0]
c0deb554:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0deb556:	f7fd fed1 	bl	c0de92fc <io_seph_send>
  return USBD_OK; 
c0deb55a:	4620      	mov	r0, r4
c0deb55c:	bd1c      	pop	{r2, r3, r4, pc}
c0deb55e:	d4d4      	bmi.n	c0deb50a <USBD_LL_DeInit+0x26>

c0deb560 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
c0deb560:	b57c      	push	{r2, r3, r4, r5, r6, lr}
  uint8_t buffer[8];
  UNUSED(pdev);

  ep_in_stall = 0;
c0deb562:	4814      	ldr	r0, [pc, #80]	; (c0deb5b4 <USBD_LL_OpenEP+0x54>)
c0deb564:	464c      	mov	r4, r9
c0deb566:	2500      	movs	r5, #0
c0deb568:	5025      	str	r5, [r4, r0]
  ep_out_stall = 0;
c0deb56a:	4813      	ldr	r0, [pc, #76]	; (c0deb5b8 <USBD_LL_OpenEP+0x58>)
c0deb56c:	5025      	str	r5, [r4, r0]
c0deb56e:	466c      	mov	r4, sp
  buffer[1] = 0;
  buffer[2] = 5;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
  buffer[4] = 1;
  buffer[5] = ep_addr;
  buffer[6] = 0;
c0deb570:	71a5      	strb	r5, [r4, #6]
  buffer[5] = ep_addr;
c0deb572:	7161      	strb	r1, [r4, #5]
c0deb574:	2101      	movs	r1, #1
  buffer[4] = 1;
c0deb576:	7121      	strb	r1, [r4, #4]
c0deb578:	2004      	movs	r0, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0deb57a:	70e0      	strb	r0, [r4, #3]
c0deb57c:	2605      	movs	r6, #5
  buffer[2] = 5;
c0deb57e:	70a6      	strb	r6, [r4, #2]
  buffer[1] = 0;
c0deb580:	7065      	strb	r5, [r4, #1]
c0deb582:	254f      	movs	r5, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0deb584:	7025      	strb	r5, [r4, #0]
  switch(ep_type) {
c0deb586:	2a00      	cmp	r2, #0
c0deb588:	d00a      	beq.n	c0deb5a0 <USBD_LL_OpenEP+0x40>
c0deb58a:	2a03      	cmp	r2, #3
c0deb58c:	d005      	beq.n	c0deb59a <USBD_LL_OpenEP+0x3a>
c0deb58e:	2a02      	cmp	r2, #2
c0deb590:	d005      	beq.n	c0deb59e <USBD_LL_OpenEP+0x3e>
c0deb592:	2a01      	cmp	r2, #1
c0deb594:	d106      	bne.n	c0deb5a4 <USBD_LL_OpenEP+0x44>
c0deb596:	4601      	mov	r1, r0
c0deb598:	e002      	b.n	c0deb5a0 <USBD_LL_OpenEP+0x40>
c0deb59a:	2102      	movs	r1, #2
c0deb59c:	e000      	b.n	c0deb5a0 <USBD_LL_OpenEP+0x40>
c0deb59e:	2103      	movs	r1, #3
c0deb5a0:	4668      	mov	r0, sp
c0deb5a2:	7181      	strb	r1, [r0, #6]
c0deb5a4:	4668      	mov	r0, sp
      break;
    case USBD_EP_TYPE_INTR:
      buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT;
      break;
  }
  buffer[7] = ep_mps;
c0deb5a6:	71c3      	strb	r3, [r0, #7]
c0deb5a8:	2108      	movs	r1, #8
  io_seproxyhal_spi_send(buffer, 8);
c0deb5aa:	f7fd fea7 	bl	c0de92fc <io_seph_send>
c0deb5ae:	2000      	movs	r0, #0
  return USBD_OK; 
c0deb5b0:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
c0deb5b2:	46c0      	nop			; (mov r8, r8)
c0deb5b4:	00000be8 	.word	0x00000be8
c0deb5b8:	00000bec 	.word	0x00000bec

c0deb5bc <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{ 
c0deb5bc:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0deb5be:	460d      	mov	r5, r1
c0deb5c0:	4668      	mov	r0, sp
c0deb5c2:	2400      	movs	r4, #0
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = 0;
  buffer[2] = 3;
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
  buffer[5] = 0;
c0deb5c4:	7144      	strb	r4, [r0, #5]
c0deb5c6:	2140      	movs	r1, #64	; 0x40
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
c0deb5c8:	7101      	strb	r1, [r0, #4]
  buffer[3] = ep_addr;
c0deb5ca:	70c5      	strb	r5, [r0, #3]
c0deb5cc:	2103      	movs	r1, #3
  buffer[2] = 3;
c0deb5ce:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0deb5d0:	7044      	strb	r4, [r0, #1]
c0deb5d2:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0deb5d4:	7001      	strb	r1, [r0, #0]
c0deb5d6:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0deb5d8:	f7fd fe90 	bl	c0de92fc <io_seph_send>
  if (ep_addr & 0x80) {
c0deb5dc:	4648      	mov	r0, r9
c0deb5de:	0629      	lsls	r1, r5, #24
c0deb5e0:	d501      	bpl.n	c0deb5e6 <USBD_LL_StallEP+0x2a>
c0deb5e2:	4907      	ldr	r1, [pc, #28]	; (c0deb600 <USBD_LL_StallEP+0x44>)
c0deb5e4:	e000      	b.n	c0deb5e8 <USBD_LL_StallEP+0x2c>
c0deb5e6:	4905      	ldr	r1, [pc, #20]	; (c0deb5fc <USBD_LL_StallEP+0x40>)
c0deb5e8:	1840      	adds	r0, r0, r1
c0deb5ea:	6801      	ldr	r1, [r0, #0]
c0deb5ec:	227f      	movs	r2, #127	; 0x7f
c0deb5ee:	4015      	ands	r5, r2
c0deb5f0:	2201      	movs	r2, #1
c0deb5f2:	40aa      	lsls	r2, r5
c0deb5f4:	430a      	orrs	r2, r1
c0deb5f6:	6002      	str	r2, [r0, #0]
    ep_in_stall |= (1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall |= (1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0deb5f8:	4620      	mov	r0, r4
c0deb5fa:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0deb5fc:	00000bec 	.word	0x00000bec
c0deb600:	00000be8 	.word	0x00000be8

c0deb604 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0deb604:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0deb606:	460d      	mov	r5, r1
c0deb608:	4668      	mov	r0, sp
c0deb60a:	2400      	movs	r4, #0
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = 0;
  buffer[2] = 3;
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
  buffer[5] = 0;
c0deb60c:	7144      	strb	r4, [r0, #5]
c0deb60e:	2180      	movs	r1, #128	; 0x80
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
c0deb610:	7101      	strb	r1, [r0, #4]
  buffer[3] = ep_addr;
c0deb612:	70c5      	strb	r5, [r0, #3]
c0deb614:	2103      	movs	r1, #3
  buffer[2] = 3;
c0deb616:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0deb618:	7044      	strb	r4, [r0, #1]
c0deb61a:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0deb61c:	7001      	strb	r1, [r0, #0]
c0deb61e:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0deb620:	f7fd fe6c 	bl	c0de92fc <io_seph_send>
  if (ep_addr & 0x80) {
c0deb624:	4648      	mov	r0, r9
c0deb626:	0629      	lsls	r1, r5, #24
c0deb628:	d501      	bpl.n	c0deb62e <USBD_LL_ClearStallEP+0x2a>
c0deb62a:	4907      	ldr	r1, [pc, #28]	; (c0deb648 <USBD_LL_ClearStallEP+0x44>)
c0deb62c:	e000      	b.n	c0deb630 <USBD_LL_ClearStallEP+0x2c>
c0deb62e:	4905      	ldr	r1, [pc, #20]	; (c0deb644 <USBD_LL_ClearStallEP+0x40>)
c0deb630:	1840      	adds	r0, r0, r1
c0deb632:	6801      	ldr	r1, [r0, #0]
c0deb634:	227f      	movs	r2, #127	; 0x7f
c0deb636:	4015      	ands	r5, r2
c0deb638:	2201      	movs	r2, #1
c0deb63a:	40aa      	lsls	r2, r5
c0deb63c:	4391      	bics	r1, r2
c0deb63e:	6001      	str	r1, [r0, #0]
    ep_in_stall &= ~(1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall &= ~(1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0deb640:	4620      	mov	r0, r4
c0deb642:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
c0deb644:	00000bec 	.word	0x00000bec
c0deb648:	00000be8 	.word	0x00000be8

c0deb64c <USBD_LL_IsStallEP>:
c0deb64c:	4648      	mov	r0, r9
c0deb64e:	060a      	lsls	r2, r1, #24
c0deb650:	d501      	bpl.n	c0deb656 <USBD_LL_IsStallEP+0xa>
c0deb652:	4a06      	ldr	r2, [pc, #24]	; (c0deb66c <USBD_LL_IsStallEP+0x20>)
c0deb654:	e000      	b.n	c0deb658 <USBD_LL_IsStallEP+0xc>
c0deb656:	4a04      	ldr	r2, [pc, #16]	; (c0deb668 <USBD_LL_IsStallEP+0x1c>)
c0deb658:	1880      	adds	r0, r0, r2
c0deb65a:	7802      	ldrb	r2, [r0, #0]
c0deb65c:	207f      	movs	r0, #127	; 0x7f
c0deb65e:	4001      	ands	r1, r0
c0deb660:	2001      	movs	r0, #1
c0deb662:	4088      	lsls	r0, r1
c0deb664:	4010      	ands	r0, r2
  }
  else
  {
    return ep_out_stall & (1<<(ep_addr&0x7F));
  }
}
c0deb666:	4770      	bx	lr
c0deb668:	00000bec 	.word	0x00000bec
c0deb66c:	00000be8 	.word	0x00000be8

c0deb670 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
c0deb670:	b51c      	push	{r2, r3, r4, lr}
c0deb672:	4668      	mov	r0, sp
  uint8_t buffer[5];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 2;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
  buffer[4] = dev_addr;
c0deb674:	7101      	strb	r1, [r0, #4]
c0deb676:	2103      	movs	r1, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0deb678:	70c1      	strb	r1, [r0, #3]
c0deb67a:	2102      	movs	r1, #2
  buffer[2] = 2;
c0deb67c:	7081      	strb	r1, [r0, #2]
c0deb67e:	2400      	movs	r4, #0
  buffer[1] = 0;
c0deb680:	7044      	strb	r4, [r0, #1]
c0deb682:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0deb684:	7001      	strb	r1, [r0, #0]
c0deb686:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(buffer, 5);
c0deb688:	f7fd fe38 	bl	c0de92fc <io_seph_send>
  return USBD_OK; 
c0deb68c:	4620      	mov	r0, r4
c0deb68e:	bd1c      	pop	{r2, r3, r4, pc}

c0deb690 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
c0deb690:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0deb692:	461c      	mov	r4, r3
c0deb694:	4615      	mov	r5, r2
c0deb696:	4668      	mov	r0, sp
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = (3+size)>>8;
  buffer[2] = (3+size);
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
  buffer[5] = size;
c0deb698:	7143      	strb	r3, [r0, #5]
c0deb69a:	2220      	movs	r2, #32
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0deb69c:	7102      	strb	r2, [r0, #4]
  buffer[3] = ep_addr;
c0deb69e:	70c1      	strb	r1, [r0, #3]
c0deb6a0:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0deb6a2:	7001      	strb	r1, [r0, #0]
  buffer[1] = (3+size)>>8;
c0deb6a4:	1cd9      	adds	r1, r3, #3
  buffer[2] = (3+size);
c0deb6a6:	7081      	strb	r1, [r0, #2]
  buffer[1] = (3+size)>>8;
c0deb6a8:	0a09      	lsrs	r1, r1, #8
c0deb6aa:	7041      	strb	r1, [r0, #1]
c0deb6ac:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0deb6ae:	f7fd fe25 	bl	c0de92fc <io_seph_send>
  io_seproxyhal_spi_send(pbuf, size);
c0deb6b2:	4628      	mov	r0, r5
c0deb6b4:	4621      	mov	r1, r4
c0deb6b6:	f7fd fe21 	bl	c0de92fc <io_seph_send>
c0deb6ba:	2000      	movs	r0, #0
  return USBD_OK;   
c0deb6bc:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}

c0deb6be <USBD_LL_PrepareReceive>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,
                                           uint16_t  size)
{
c0deb6be:	b51c      	push	{r2, r3, r4, lr}
c0deb6c0:	4668      	mov	r0, sp
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = (3/*+size*/)>>8;
  buffer[2] = (3/*+size*/);
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
  buffer[5] = size; // expected size, not transmitted here !
c0deb6c2:	7142      	strb	r2, [r0, #5]
c0deb6c4:	2230      	movs	r2, #48	; 0x30
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
c0deb6c6:	7102      	strb	r2, [r0, #4]
  buffer[3] = ep_addr;
c0deb6c8:	70c1      	strb	r1, [r0, #3]
c0deb6ca:	2103      	movs	r1, #3
  buffer[2] = (3/*+size*/);
c0deb6cc:	7081      	strb	r1, [r0, #2]
c0deb6ce:	2400      	movs	r4, #0
  buffer[1] = (3/*+size*/)>>8;
c0deb6d0:	7044      	strb	r4, [r0, #1]
c0deb6d2:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0deb6d4:	7001      	strb	r1, [r0, #0]
c0deb6d6:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0deb6d8:	f7fd fe10 	bl	c0de92fc <io_seph_send>
  return USBD_OK;   
c0deb6dc:	4620      	mov	r0, r4
c0deb6de:	bd1c      	pop	{r2, r3, r4, pc}

c0deb6e0 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
c0deb6e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
c0deb6e2:	2800      	cmp	r0, #0
c0deb6e4:	d012      	beq.n	c0deb70c <USBD_Init+0x2c>
c0deb6e6:	4615      	mov	r5, r2
c0deb6e8:	460e      	mov	r6, r1
c0deb6ea:	4604      	mov	r4, r0
c0deb6ec:	4607      	mov	r7, r0
c0deb6ee:	379c      	adds	r7, #156	; 0x9c
c0deb6f0:	21d4      	movs	r1, #212	; 0xd4
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }

  memset(pdev, 0, sizeof(USBD_HandleTypeDef));
c0deb6f2:	f002 f88f 	bl	c0ded814 <__aeabi_memclr>
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
c0deb6f6:	2e00      	cmp	r6, #0
c0deb6f8:	d000      	beq.n	c0deb6fc <USBD_Init+0x1c>
  {
    pdev->pDesc = pdesc;
c0deb6fa:	617e      	str	r6, [r7, #20]
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  pdev->id = id;
c0deb6fc:	7025      	strb	r5, [r4, #0]
c0deb6fe:	2001      	movs	r0, #1
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0deb700:	7038      	strb	r0, [r7, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
c0deb702:	4620      	mov	r0, r4
c0deb704:	f7ff fee2 	bl	c0deb4cc <USBD_LL_Init>
c0deb708:	2000      	movs	r0, #0
  
  return USBD_OK; 
}
c0deb70a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0deb70c:	2002      	movs	r0, #2
c0deb70e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0deb710 <USBD_DeInit>:
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
c0deb710:	b5b0      	push	{r4, r5, r7, lr}
c0deb712:	4604      	mov	r4, r0
c0deb714:	209c      	movs	r0, #156	; 0x9c
c0deb716:	2101      	movs	r1, #1
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0deb718:	5421      	strb	r1, [r4, r0]
c0deb71a:	25b4      	movs	r5, #180	; 0xb4
  
  /* Free Class Resources */
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb71c:	2dcc      	cmp	r5, #204	; 0xcc
c0deb71e:	d00b      	beq.n	c0deb738 <USBD_DeInit+0x28>
    if(pdev->interfacesClass[intf].pClass != NULL) {
c0deb720:	5960      	ldr	r0, [r4, r5]
c0deb722:	2800      	cmp	r0, #0
c0deb724:	d006      	beq.n	c0deb734 <USBD_DeInit+0x24>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config);  
c0deb726:	6840      	ldr	r0, [r0, #4]
c0deb728:	f7fc fd8c 	bl	c0de8244 <pic>
c0deb72c:	4602      	mov	r2, r0
c0deb72e:	7921      	ldrb	r1, [r4, #4]
c0deb730:	4620      	mov	r0, r4
c0deb732:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb734:	3508      	adds	r5, #8
c0deb736:	e7f1      	b.n	c0deb71c <USBD_DeInit+0xc>
    }
  }
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
c0deb738:	4620      	mov	r0, r4
c0deb73a:	f7ff ff01 	bl	c0deb540 <USBD_LL_Stop>
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
c0deb73e:	4620      	mov	r0, r4
c0deb740:	f7ff fed0 	bl	c0deb4e4 <USBD_LL_DeInit>
c0deb744:	2000      	movs	r0, #0
  
  return USBD_OK;
c0deb746:	bdb0      	pop	{r4, r5, r7, pc}

c0deb748 <USBD_RegisterClassForInterface>:
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClassForInterface(uint8_t interfaceidx, USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
c0deb748:	2a00      	cmp	r2, #0
c0deb74a:	d008      	beq.n	c0deb75e <USBD_RegisterClassForInterface+0x16>
c0deb74c:	4603      	mov	r3, r0
c0deb74e:	2000      	movs	r0, #0
  {
    if (interfaceidx < USBD_MAX_NUM_INTERFACES) {
c0deb750:	2b02      	cmp	r3, #2
c0deb752:	d803      	bhi.n	c0deb75c <USBD_RegisterClassForInterface+0x14>
      /* link the class to the USB Device handle */
      pdev->interfacesClass[interfaceidx].pClass = pclass;
c0deb754:	00db      	lsls	r3, r3, #3
c0deb756:	18c9      	adds	r1, r1, r3
c0deb758:	23b4      	movs	r3, #180	; 0xb4
c0deb75a:	50ca      	str	r2, [r1, r3]
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  }
  
  return status;
c0deb75c:	4770      	bx	lr
c0deb75e:	2002      	movs	r0, #2
c0deb760:	4770      	bx	lr

c0deb762 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
c0deb762:	b580      	push	{r7, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
c0deb764:	f7ff fed2 	bl	c0deb50c <USBD_LL_Start>
c0deb768:	2000      	movs	r0, #0
  
  return USBD_OK;  
c0deb76a:	bd80      	pop	{r7, pc}

c0deb76c <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0deb76c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0deb76e:	460c      	mov	r4, r1
c0deb770:	4605      	mov	r5, r0
  /* Set configuration  and Start the Class*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb772:	4607      	mov	r7, r0
c0deb774:	37b4      	adds	r7, #180	; 0xb4
c0deb776:	2600      	movs	r6, #0
c0deb778:	2e03      	cmp	r6, #3
c0deb77a:	d010      	beq.n	c0deb79e <USBD_SetClassConfig+0x32>
    if(usbd_is_valid_intf(pdev, intf)) {
c0deb77c:	4628      	mov	r0, r5
c0deb77e:	4631      	mov	r1, r6
c0deb780:	f000 f965 	bl	c0deba4e <usbd_is_valid_intf>
c0deb784:	2800      	cmp	r0, #0
c0deb786:	d007      	beq.n	c0deb798 <USBD_SetClassConfig+0x2c>
      ((Init_t)PIC(pdev->interfacesClass[intf].pClass->Init))(pdev, cfgidx);
c0deb788:	6838      	ldr	r0, [r7, #0]
c0deb78a:	6800      	ldr	r0, [r0, #0]
c0deb78c:	f7fc fd5a 	bl	c0de8244 <pic>
c0deb790:	4602      	mov	r2, r0
c0deb792:	4628      	mov	r0, r5
c0deb794:	4621      	mov	r1, r4
c0deb796:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb798:	3708      	adds	r7, #8
c0deb79a:	1c76      	adds	r6, r6, #1
c0deb79c:	e7ec      	b.n	c0deb778 <USBD_SetClassConfig+0xc>
c0deb79e:	2000      	movs	r0, #0
    }
  }

  return USBD_OK; 
c0deb7a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0deb7a2 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0deb7a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0deb7a4:	460c      	mov	r4, r1
c0deb7a6:	4605      	mov	r5, r0
  /* Clear configuration  and De-initialize the Class process*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb7a8:	4607      	mov	r7, r0
c0deb7aa:	37b4      	adds	r7, #180	; 0xb4
c0deb7ac:	2600      	movs	r6, #0
c0deb7ae:	2e03      	cmp	r6, #3
c0deb7b0:	d010      	beq.n	c0deb7d4 <USBD_ClrClassConfig+0x32>
    if(usbd_is_valid_intf(pdev, intf)) {
c0deb7b2:	4628      	mov	r0, r5
c0deb7b4:	4631      	mov	r1, r6
c0deb7b6:	f000 f94a 	bl	c0deba4e <usbd_is_valid_intf>
c0deb7ba:	2800      	cmp	r0, #0
c0deb7bc:	d007      	beq.n	c0deb7ce <USBD_ClrClassConfig+0x2c>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, cfgidx);  
c0deb7be:	6838      	ldr	r0, [r7, #0]
c0deb7c0:	6840      	ldr	r0, [r0, #4]
c0deb7c2:	f7fc fd3f 	bl	c0de8244 <pic>
c0deb7c6:	4602      	mov	r2, r0
c0deb7c8:	4628      	mov	r0, r5
c0deb7ca:	4621      	mov	r1, r4
c0deb7cc:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb7ce:	3708      	adds	r7, #8
c0deb7d0:	1c76      	adds	r6, r6, #1
c0deb7d2:	e7ec      	b.n	c0deb7ae <USBD_ClrClassConfig+0xc>
c0deb7d4:	2000      	movs	r0, #0
    }
  }
  return USBD_OK;
c0deb7d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0deb7d8 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
c0deb7d8:	b570      	push	{r4, r5, r6, lr}
c0deb7da:	4604      	mov	r4, r0
c0deb7dc:	4606      	mov	r6, r0
c0deb7de:	3694      	adds	r6, #148	; 0x94
  USBD_ParseSetupRequest(&pdev->request, psetup);
c0deb7e0:	4635      	mov	r5, r6
c0deb7e2:	3514      	adds	r5, #20
c0deb7e4:	4628      	mov	r0, r5
c0deb7e6:	f000 fb5d 	bl	c0debea4 <USBD_ParseSetupRequest>
c0deb7ea:	2094      	movs	r0, #148	; 0x94
c0deb7ec:	2101      	movs	r1, #1
  
  pdev->ep0_state = USBD_EP0_SETUP;
c0deb7ee:	5021      	str	r1, [r4, r0]
c0deb7f0:	20ae      	movs	r0, #174	; 0xae
  pdev->ep0_data_len = pdev->request.wLength;
c0deb7f2:	5a20      	ldrh	r0, [r4, r0]
c0deb7f4:	6070      	str	r0, [r6, #4]
  
  switch (pdev->request.bmRequest & 0x1F) 
c0deb7f6:	7d31      	ldrb	r1, [r6, #20]
c0deb7f8:	201f      	movs	r0, #31
c0deb7fa:	4008      	ands	r0, r1
c0deb7fc:	2802      	cmp	r0, #2
c0deb7fe:	d008      	beq.n	c0deb812 <USBD_LL_SetupStage+0x3a>
c0deb800:	2801      	cmp	r0, #1
c0deb802:	d00b      	beq.n	c0deb81c <USBD_LL_SetupStage+0x44>
c0deb804:	2800      	cmp	r0, #0
c0deb806:	d10e      	bne.n	c0deb826 <USBD_LL_SetupStage+0x4e>
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
c0deb808:	4620      	mov	r0, r4
c0deb80a:	4629      	mov	r1, r5
c0deb80c:	f000 f92a 	bl	c0deba64 <USBD_StdDevReq>
c0deb810:	e00e      	b.n	c0deb830 <USBD_LL_SetupStage+0x58>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
c0deb812:	4620      	mov	r0, r4
c0deb814:	4629      	mov	r1, r5
c0deb816:	f000 fac4 	bl	c0debda2 <USBD_StdEPReq>
c0deb81a:	e009      	b.n	c0deb830 <USBD_LL_SetupStage+0x58>
    USBD_StdItfReq(pdev, &pdev->request);
c0deb81c:	4620      	mov	r0, r4
c0deb81e:	4629      	mov	r1, r5
c0deb820:	f000 fa9b 	bl	c0debd5a <USBD_StdItfReq>
c0deb824:	e004      	b.n	c0deb830 <USBD_LL_SetupStage+0x58>
c0deb826:	2080      	movs	r0, #128	; 0x80
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
c0deb828:	4001      	ands	r1, r0
c0deb82a:	4620      	mov	r0, r4
c0deb82c:	f7ff fec6 	bl	c0deb5bc <USBD_LL_StallEP>
c0deb830:	2000      	movs	r0, #0
    break;
  }  
  return USBD_OK;  
c0deb832:	bd70      	pop	{r4, r5, r6, pc}

c0deb834 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
c0deb834:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0deb836:	9202      	str	r2, [sp, #8]
c0deb838:	4606      	mov	r6, r0
c0deb83a:	4605      	mov	r5, r0
c0deb83c:	3594      	adds	r5, #148	; 0x94
c0deb83e:	9101      	str	r1, [sp, #4]
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
c0deb840:	2900      	cmp	r1, #0
c0deb842:	d01b      	beq.n	c0deb87c <USBD_LL_DataOutStage+0x48>
    }
  }
  else {

    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb844:	4634      	mov	r4, r6
c0deb846:	34b4      	adds	r4, #180	; 0xb4
c0deb848:	2700      	movs	r7, #0
c0deb84a:	2f03      	cmp	r7, #3
c0deb84c:	d046      	beq.n	c0deb8dc <USBD_LL_DataOutStage+0xa8>
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0deb84e:	4630      	mov	r0, r6
c0deb850:	4639      	mov	r1, r7
c0deb852:	f000 f8fc 	bl	c0deba4e <usbd_is_valid_intf>
c0deb856:	2800      	cmp	r0, #0
c0deb858:	d00d      	beq.n	c0deb876 <USBD_LL_DataOutStage+0x42>
c0deb85a:	6820      	ldr	r0, [r4, #0]
c0deb85c:	6980      	ldr	r0, [r0, #24]
c0deb85e:	2800      	cmp	r0, #0
c0deb860:	d009      	beq.n	c0deb876 <USBD_LL_DataOutStage+0x42>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0deb862:	7a29      	ldrb	r1, [r5, #8]
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0deb864:	2903      	cmp	r1, #3
c0deb866:	d106      	bne.n	c0deb876 <USBD_LL_DataOutStage+0x42>
      {
        ((DataOut_t)PIC(pdev->interfacesClass[intf].pClass->DataOut))(pdev, epnum, pdata); 
c0deb868:	f7fc fcec 	bl	c0de8244 <pic>
c0deb86c:	4603      	mov	r3, r0
c0deb86e:	4630      	mov	r0, r6
c0deb870:	9901      	ldr	r1, [sp, #4]
c0deb872:	9a02      	ldr	r2, [sp, #8]
c0deb874:	4798      	blx	r3
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb876:	3408      	adds	r4, #8
c0deb878:	1c7f      	adds	r7, r7, #1
c0deb87a:	e7e6      	b.n	c0deb84a <USBD_LL_DataOutStage+0x16>
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
c0deb87c:	6828      	ldr	r0, [r5, #0]
c0deb87e:	2803      	cmp	r0, #3
c0deb880:	d12c      	bne.n	c0deb8dc <USBD_LL_DataOutStage+0xa8>
      if(pep->rem_length > pep->maxpacket)
c0deb882:	6df1      	ldr	r1, [r6, #92]	; 0x5c
c0deb884:	6e30      	ldr	r0, [r6, #96]	; 0x60
c0deb886:	4281      	cmp	r1, r0
c0deb888:	d90a      	bls.n	c0deb8a0 <USBD_LL_DataOutStage+0x6c>
        pep->rem_length -=  pep->maxpacket;
c0deb88a:	1a09      	subs	r1, r1, r0
c0deb88c:	65f1      	str	r1, [r6, #92]	; 0x5c
                            MIN(pep->rem_length ,pep->maxpacket));
c0deb88e:	4281      	cmp	r1, r0
c0deb890:	d300      	bcc.n	c0deb894 <USBD_LL_DataOutStage+0x60>
c0deb892:	4601      	mov	r1, r0
        USBD_CtlContinueRx (pdev, 
c0deb894:	b28a      	uxth	r2, r1
c0deb896:	4630      	mov	r0, r6
c0deb898:	9902      	ldr	r1, [sp, #8]
c0deb89a:	f000 fd9f 	bl	c0dec3dc <USBD_CtlContinueRx>
c0deb89e:	e01d      	b.n	c0deb8dc <USBD_LL_DataOutStage+0xa8>
c0deb8a0:	462f      	mov	r7, r5
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb8a2:	4634      	mov	r4, r6
c0deb8a4:	34b4      	adds	r4, #180	; 0xb4
c0deb8a6:	2500      	movs	r5, #0
c0deb8a8:	2d03      	cmp	r5, #3
c0deb8aa:	d014      	beq.n	c0deb8d6 <USBD_LL_DataOutStage+0xa2>
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0deb8ac:	4630      	mov	r0, r6
c0deb8ae:	4629      	mov	r1, r5
c0deb8b0:	f000 f8cd 	bl	c0deba4e <usbd_is_valid_intf>
c0deb8b4:	2800      	cmp	r0, #0
c0deb8b6:	d00b      	beq.n	c0deb8d0 <USBD_LL_DataOutStage+0x9c>
c0deb8b8:	6820      	ldr	r0, [r4, #0]
c0deb8ba:	6900      	ldr	r0, [r0, #16]
c0deb8bc:	2800      	cmp	r0, #0
c0deb8be:	d007      	beq.n	c0deb8d0 <USBD_LL_DataOutStage+0x9c>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
c0deb8c0:	7a39      	ldrb	r1, [r7, #8]
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0deb8c2:	2903      	cmp	r1, #3
c0deb8c4:	d104      	bne.n	c0deb8d0 <USBD_LL_DataOutStage+0x9c>
            ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_RxReady))(pdev); 
c0deb8c6:	f7fc fcbd 	bl	c0de8244 <pic>
c0deb8ca:	4601      	mov	r1, r0
c0deb8cc:	4630      	mov	r0, r6
c0deb8ce:	4788      	blx	r1
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb8d0:	3408      	adds	r4, #8
c0deb8d2:	1c6d      	adds	r5, r5, #1
c0deb8d4:	e7e8      	b.n	c0deb8a8 <USBD_LL_DataOutStage+0x74>
        USBD_CtlSendStatus(pdev);
c0deb8d6:	4630      	mov	r0, r6
c0deb8d8:	f000 fd87 	bl	c0dec3ea <USBD_CtlSendStatus>
c0deb8dc:	2000      	movs	r0, #0
      }
    }
  }  
  return USBD_OK;
c0deb8de:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

c0deb8e0 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
c0deb8e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0deb8e2:	4607      	mov	r7, r0
c0deb8e4:	4606      	mov	r6, r0
c0deb8e6:	3694      	adds	r6, #148	; 0x94
c0deb8e8:	9100      	str	r1, [sp, #0]
  USBD_EndpointTypeDef    *pep;
  UNUSED(pdata);
    
  if(epnum == 0) 
c0deb8ea:	2900      	cmp	r1, #0
c0deb8ec:	d01b      	beq.n	c0deb926 <USBD_LL_DataInStage+0x46>
c0deb8ee:	4635      	mov	r5, r6
      pdev->dev_test_mode = 0;
    }
  }
  else {
    uint8_t intf;
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb8f0:	463c      	mov	r4, r7
c0deb8f2:	34b4      	adds	r4, #180	; 0xb4
c0deb8f4:	2600      	movs	r6, #0
c0deb8f6:	2e03      	cmp	r6, #3
c0deb8f8:	d061      	beq.n	c0deb9be <USBD_LL_DataInStage+0xde>
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0deb8fa:	4638      	mov	r0, r7
c0deb8fc:	4631      	mov	r1, r6
c0deb8fe:	f000 f8a6 	bl	c0deba4e <usbd_is_valid_intf>
c0deb902:	2800      	cmp	r0, #0
c0deb904:	d00c      	beq.n	c0deb920 <USBD_LL_DataInStage+0x40>
c0deb906:	6820      	ldr	r0, [r4, #0]
c0deb908:	6940      	ldr	r0, [r0, #20]
c0deb90a:	2800      	cmp	r0, #0
c0deb90c:	d008      	beq.n	c0deb920 <USBD_LL_DataInStage+0x40>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0deb90e:	7a29      	ldrb	r1, [r5, #8]
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0deb910:	2903      	cmp	r1, #3
c0deb912:	d105      	bne.n	c0deb920 <USBD_LL_DataInStage+0x40>
      {
        ((DataIn_t)PIC(pdev->interfacesClass[intf].pClass->DataIn))(pdev, epnum); 
c0deb914:	f7fc fc96 	bl	c0de8244 <pic>
c0deb918:	4602      	mov	r2, r0
c0deb91a:	4638      	mov	r0, r7
c0deb91c:	9900      	ldr	r1, [sp, #0]
c0deb91e:	4790      	blx	r2
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb920:	3408      	adds	r4, #8
c0deb922:	1c76      	adds	r6, r6, #1
c0deb924:	e7e7      	b.n	c0deb8f6 <USBD_LL_DataInStage+0x16>
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
c0deb926:	6830      	ldr	r0, [r6, #0]
c0deb928:	2802      	cmp	r0, #2
c0deb92a:	d142      	bne.n	c0deb9b2 <USBD_LL_DataInStage+0xd2>
      if(pep->rem_length > pep->maxpacket)
c0deb92c:	69f8      	ldr	r0, [r7, #28]
c0deb92e:	6a3d      	ldr	r5, [r7, #32]
c0deb930:	42a8      	cmp	r0, r5
c0deb932:	d909      	bls.n	c0deb948 <USBD_LL_DataInStage+0x68>
        pep->rem_length -=  pep->maxpacket;
c0deb934:	1b40      	subs	r0, r0, r5
c0deb936:	61f8      	str	r0, [r7, #28]
        pdev->pData = (uint8_t *)pdev->pData + pep->maxpacket;
c0deb938:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
c0deb93a:	1949      	adds	r1, r1, r5
c0deb93c:	63f1      	str	r1, [r6, #60]	; 0x3c
        USBD_CtlContinueSendData (pdev, 
c0deb93e:	b282      	uxth	r2, r0
c0deb940:	4638      	mov	r0, r7
c0deb942:	f000 fd3d 	bl	c0dec3c0 <USBD_CtlContinueSendData>
c0deb946:	e034      	b.n	c0deb9b2 <USBD_LL_DataInStage+0xd2>
c0deb948:	9600      	str	r6, [sp, #0]
        if((pep->total_length % pep->maxpacket == 0) &&
c0deb94a:	69be      	ldr	r6, [r7, #24]
c0deb94c:	4630      	mov	r0, r6
c0deb94e:	4629      	mov	r1, r5
c0deb950:	f001 fdfc 	bl	c0ded54c <__aeabi_uidivmod>
c0deb954:	42ae      	cmp	r6, r5
c0deb956:	d30e      	bcc.n	c0deb976 <USBD_LL_DataInStage+0x96>
c0deb958:	2900      	cmp	r1, #0
c0deb95a:	d10c      	bne.n	c0deb976 <USBD_LL_DataInStage+0x96>
             (pep->total_length < pdev->ep0_data_len ))
c0deb95c:	9800      	ldr	r0, [sp, #0]
c0deb95e:	6840      	ldr	r0, [r0, #4]
        if((pep->total_length % pep->maxpacket == 0) &&
c0deb960:	4286      	cmp	r6, r0
c0deb962:	d208      	bcs.n	c0deb976 <USBD_LL_DataInStage+0x96>
c0deb964:	2500      	movs	r5, #0
          USBD_CtlContinueSendData(pdev , NULL, 0);
c0deb966:	4638      	mov	r0, r7
c0deb968:	4629      	mov	r1, r5
c0deb96a:	462a      	mov	r2, r5
c0deb96c:	f000 fd28 	bl	c0dec3c0 <USBD_CtlContinueSendData>
c0deb970:	9e00      	ldr	r6, [sp, #0]
          pdev->ep0_data_len = 0;
c0deb972:	6075      	str	r5, [r6, #4]
c0deb974:	e01d      	b.n	c0deb9b2 <USBD_LL_DataInStage+0xd2>
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb976:	463c      	mov	r4, r7
c0deb978:	34b4      	adds	r4, #180	; 0xb4
c0deb97a:	2500      	movs	r5, #0
c0deb97c:	9e00      	ldr	r6, [sp, #0]
c0deb97e:	2d03      	cmp	r5, #3
c0deb980:	d014      	beq.n	c0deb9ac <USBD_LL_DataInStage+0xcc>
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0deb982:	4638      	mov	r0, r7
c0deb984:	4629      	mov	r1, r5
c0deb986:	f000 f862 	bl	c0deba4e <usbd_is_valid_intf>
c0deb98a:	2800      	cmp	r0, #0
c0deb98c:	d00b      	beq.n	c0deb9a6 <USBD_LL_DataInStage+0xc6>
c0deb98e:	6820      	ldr	r0, [r4, #0]
c0deb990:	68c0      	ldr	r0, [r0, #12]
c0deb992:	2800      	cmp	r0, #0
c0deb994:	d007      	beq.n	c0deb9a6 <USBD_LL_DataInStage+0xc6>
               (pdev->dev_state == USBD_STATE_CONFIGURED))
c0deb996:	7a31      	ldrb	r1, [r6, #8]
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0deb998:	2903      	cmp	r1, #3
c0deb99a:	d104      	bne.n	c0deb9a6 <USBD_LL_DataInStage+0xc6>
              ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_TxSent))(pdev); 
c0deb99c:	f7fc fc52 	bl	c0de8244 <pic>
c0deb9a0:	4601      	mov	r1, r0
c0deb9a2:	4638      	mov	r0, r7
c0deb9a4:	4788      	blx	r1
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb9a6:	3408      	adds	r4, #8
c0deb9a8:	1c6d      	adds	r5, r5, #1
c0deb9aa:	e7e8      	b.n	c0deb97e <USBD_LL_DataInStage+0x9e>
          USBD_CtlReceiveStatus(pdev);
c0deb9ac:	4638      	mov	r0, r7
c0deb9ae:	f000 fd28 	bl	c0dec402 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode == 1)
c0deb9b2:	7b30      	ldrb	r0, [r6, #12]
c0deb9b4:	2801      	cmp	r0, #1
c0deb9b6:	d102      	bne.n	c0deb9be <USBD_LL_DataInStage+0xde>
c0deb9b8:	4631      	mov	r1, r6
c0deb9ba:	2000      	movs	r0, #0
      pdev->dev_test_mode = 0;
c0deb9bc:	7330      	strb	r0, [r6, #12]
c0deb9be:	2000      	movs	r0, #0
      }
    }
  }
  return USBD_OK;
c0deb9c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0deb9c2 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
c0deb9c2:	b570      	push	{r4, r5, r6, lr}
c0deb9c4:	4604      	mov	r4, r0
c0deb9c6:	209c      	movs	r0, #156	; 0x9c
c0deb9c8:	2101      	movs	r1, #1
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
c0deb9ca:	5421      	strb	r1, [r4, r0]
c0deb9cc:	2040      	movs	r0, #64	; 0x40
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
c0deb9ce:	6220      	str	r0, [r4, #32]
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
c0deb9d0:	6620      	str	r0, [r4, #96]	; 0x60
 
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb9d2:	4626      	mov	r6, r4
c0deb9d4:	36b4      	adds	r6, #180	; 0xb4
c0deb9d6:	2500      	movs	r5, #0
c0deb9d8:	2d03      	cmp	r5, #3
c0deb9da:	d010      	beq.n	c0deb9fe <USBD_LL_Reset+0x3c>
    if( usbd_is_valid_intf(pdev, intf))
c0deb9dc:	4620      	mov	r0, r4
c0deb9de:	4629      	mov	r1, r5
c0deb9e0:	f000 f835 	bl	c0deba4e <usbd_is_valid_intf>
c0deb9e4:	2800      	cmp	r0, #0
c0deb9e6:	d007      	beq.n	c0deb9f8 <USBD_LL_Reset+0x36>
    {
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config); 
c0deb9e8:	6830      	ldr	r0, [r6, #0]
c0deb9ea:	6840      	ldr	r0, [r0, #4]
c0deb9ec:	f7fc fc2a 	bl	c0de8244 <pic>
c0deb9f0:	4602      	mov	r2, r0
c0deb9f2:	7921      	ldrb	r1, [r4, #4]
c0deb9f4:	4620      	mov	r0, r4
c0deb9f6:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deb9f8:	3608      	adds	r6, #8
c0deb9fa:	1c6d      	adds	r5, r5, #1
c0deb9fc:	e7ec      	b.n	c0deb9d8 <USBD_LL_Reset+0x16>
c0deb9fe:	2000      	movs	r0, #0
    }
  }
  
  return USBD_OK;
c0deba00:	bd70      	pop	{r4, r5, r6, pc}

c0deba02 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
c0deba02:	7401      	strb	r1, [r0, #16]
c0deba04:	2000      	movs	r0, #0
  return USBD_OK;
c0deba06:	4770      	bx	lr

c0deba08 <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
c0deba08:	2000      	movs	r0, #0
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_old_state =  pdev->dev_state;
  //pdev->dev_state  = USBD_STATE_SUSPENDED;
  return USBD_OK;
c0deba0a:	4770      	bx	lr

c0deba0c <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
c0deba0c:	2000      	movs	r0, #0
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_state = pdev->dev_old_state;  
  return USBD_OK;
c0deba0e:	4770      	bx	lr

c0deba10 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
c0deba10:	b570      	push	{r4, r5, r6, lr}
c0deba12:	4604      	mov	r4, r0
c0deba14:	209c      	movs	r0, #156	; 0x9c
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
c0deba16:	5c20      	ldrb	r0, [r4, r0]
c0deba18:	2803      	cmp	r0, #3
c0deba1a:	d116      	bne.n	c0deba4a <USBD_LL_SOF+0x3a>
  {
    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deba1c:	4626      	mov	r6, r4
c0deba1e:	36b4      	adds	r6, #180	; 0xb4
c0deba20:	2500      	movs	r5, #0
c0deba22:	2d03      	cmp	r5, #3
c0deba24:	d011      	beq.n	c0deba4a <USBD_LL_SOF+0x3a>
      if( usbd_is_valid_intf(pdev, intf) && pdev->interfacesClass[intf].pClass->SOF != NULL)
c0deba26:	4620      	mov	r0, r4
c0deba28:	4629      	mov	r1, r5
c0deba2a:	f000 f810 	bl	c0deba4e <usbd_is_valid_intf>
c0deba2e:	2800      	cmp	r0, #0
c0deba30:	d008      	beq.n	c0deba44 <USBD_LL_SOF+0x34>
c0deba32:	6830      	ldr	r0, [r6, #0]
c0deba34:	69c0      	ldr	r0, [r0, #28]
c0deba36:	2800      	cmp	r0, #0
c0deba38:	d004      	beq.n	c0deba44 <USBD_LL_SOF+0x34>
      {
        ((SOF_t)PIC(pdev->interfacesClass[intf].pClass->SOF))(pdev); 
c0deba3a:	f7fc fc03 	bl	c0de8244 <pic>
c0deba3e:	4601      	mov	r1, r0
c0deba40:	4620      	mov	r0, r4
c0deba42:	4788      	blx	r1
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0deba44:	3608      	adds	r6, #8
c0deba46:	1c6d      	adds	r5, r5, #1
c0deba48:	e7eb      	b.n	c0deba22 <USBD_LL_SOF+0x12>
c0deba4a:	2000      	movs	r0, #0
      }
    }
  }
  return USBD_OK;
c0deba4c:	bd70      	pop	{r4, r5, r6, pc}

c0deba4e <usbd_is_valid_intf>:
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0deba4e:	2902      	cmp	r1, #2
c0deba50:	d806      	bhi.n	c0deba60 <usbd_is_valid_intf+0x12>
c0deba52:	00c9      	lsls	r1, r1, #3
c0deba54:	1840      	adds	r0, r0, r1
c0deba56:	21b4      	movs	r1, #180	; 0xb4
c0deba58:	5840      	ldr	r0, [r0, r1]
c0deba5a:	1e41      	subs	r1, r0, #1
c0deba5c:	4188      	sbcs	r0, r1
c0deba5e:	4770      	bx	lr
c0deba60:	2000      	movs	r0, #0
c0deba62:	4770      	bx	lr

c0deba64 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
c0deba64:	b580      	push	{r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
c0deba66:	784a      	ldrb	r2, [r1, #1]
c0deba68:	2a00      	cmp	r2, #0
c0deba6a:	d00e      	beq.n	c0deba8a <USBD_StdDevReq+0x26>
c0deba6c:	2a01      	cmp	r2, #1
c0deba6e:	d00f      	beq.n	c0deba90 <USBD_StdDevReq+0x2c>
c0deba70:	2a03      	cmp	r2, #3
c0deba72:	d010      	beq.n	c0deba96 <USBD_StdDevReq+0x32>
c0deba74:	2a05      	cmp	r2, #5
c0deba76:	d011      	beq.n	c0deba9c <USBD_StdDevReq+0x38>
c0deba78:	2a09      	cmp	r2, #9
c0deba7a:	d012      	beq.n	c0debaa2 <USBD_StdDevReq+0x3e>
c0deba7c:	2a08      	cmp	r2, #8
c0deba7e:	d013      	beq.n	c0debaa8 <USBD_StdDevReq+0x44>
c0deba80:	2a06      	cmp	r2, #6
c0deba82:	d114      	bne.n	c0debaae <USBD_StdDevReq+0x4a>
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
c0deba84:	f000 f817 	bl	c0debab6 <USBD_GetDescriptor>
c0deba88:	e013      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
  case USB_REQ_GET_CONFIGURATION:                 
    USBD_GetConfig (pdev , req);
    break;
    
  case USB_REQ_GET_STATUS:                                  
    USBD_GetStatus (pdev , req);
c0deba8a:	f000 f8fc 	bl	c0debc86 <USBD_GetStatus>
c0deba8e:	e010      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
    break;
    
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
c0deba90:	f000 f93a 	bl	c0debd08 <USBD_ClrFeature>
c0deba94:	e00d      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
    USBD_SetFeature (pdev , req);    
c0deba96:	f000 f91a 	bl	c0debcce <USBD_SetFeature>
c0deba9a:	e00a      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
    USBD_SetAddress(pdev, req);
c0deba9c:	f000 f882 	bl	c0debba4 <USBD_SetAddress>
c0debaa0:	e007      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
    USBD_SetConfig (pdev , req);
c0debaa2:	f000 f8a2 	bl	c0debbea <USBD_SetConfig>
c0debaa6:	e004      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
    USBD_GetConfig (pdev , req);
c0debaa8:	f000 f8d6 	bl	c0debc58 <USBD_GetConfig>
c0debaac:	e001      	b.n	c0debab2 <USBD_StdDevReq+0x4e>
    break;
    
  default:  
    USBD_CtlError(pdev , req);
c0debaae:	f000 fbcd 	bl	c0dec24c <USBD_CtlError>
c0debab2:	2000      	movs	r0, #0
    break;
  }
  
  return ret;
c0debab4:	bd80      	pop	{r7, pc}

c0debab6 <USBD_GetDescriptor>:
* @param  req: usb request
* @retval status
*/
void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
c0debab6:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0debab8:	460d      	mov	r5, r1
c0debaba:	4604      	mov	r4, r0
c0debabc:	a801      	add	r0, sp, #4
c0debabe:	2100      	movs	r1, #0
  uint16_t len = 0;
c0debac0:	8001      	strh	r1, [r0, #0]
c0debac2:	4620      	mov	r0, r4
c0debac4:	30b0      	adds	r0, #176	; 0xb0
  uint8_t *pbuf = NULL;
  
    
  switch (req->wValue >> 8)
c0debac6:	886b      	ldrh	r3, [r5, #2]
c0debac8:	0a1a      	lsrs	r2, r3, #8
c0debaca:	2a01      	cmp	r2, #1
c0debacc:	d026      	beq.n	c0debb1c <USBD_GetDescriptor+0x66>
c0debace:	2a02      	cmp	r2, #2
c0debad0:	d02d      	beq.n	c0debb2e <USBD_GetDescriptor+0x78>
c0debad2:	2a03      	cmp	r2, #3
c0debad4:	d00a      	beq.n	c0debaec <USBD_GetDescriptor+0x36>
c0debad6:	2a06      	cmp	r2, #6
c0debad8:	d031      	beq.n	c0debb3e <USBD_GetDescriptor+0x88>
c0debada:	2a07      	cmp	r2, #7
c0debadc:	d016      	beq.n	c0debb0c <USBD_GetDescriptor+0x56>
c0debade:	2a0f      	cmp	r2, #15
c0debae0:	d130      	bne.n	c0debb44 <USBD_GetDescriptor+0x8e>
  { 
#if (USBD_LPM_ENABLED == 1)
  case USB_DESC_TYPE_BOS:
    if(pdev->pDesc->GetBOSDescriptor != NULL) {
c0debae2:	6800      	ldr	r0, [r0, #0]
c0debae4:	69c0      	ldr	r0, [r0, #28]
c0debae6:	2800      	cmp	r0, #0
c0debae8:	d11a      	bne.n	c0debb20 <USBD_GetDescriptor+0x6a>
c0debaea:	e02b      	b.n	c0debb44 <USBD_GetDescriptor+0x8e>
      }
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
c0debaec:	b2d9      	uxtb	r1, r3
c0debaee:	2905      	cmp	r1, #5
c0debaf0:	d049      	beq.n	c0debb86 <USBD_GetDescriptor+0xd0>
c0debaf2:	2901      	cmp	r1, #1
c0debaf4:	d04a      	beq.n	c0debb8c <USBD_GetDescriptor+0xd6>
c0debaf6:	2902      	cmp	r1, #2
c0debaf8:	d04b      	beq.n	c0debb92 <USBD_GetDescriptor+0xdc>
c0debafa:	2903      	cmp	r1, #3
c0debafc:	d04c      	beq.n	c0debb98 <USBD_GetDescriptor+0xe2>
c0debafe:	2904      	cmp	r1, #4
c0debb00:	d04d      	beq.n	c0debb9e <USBD_GetDescriptor+0xe8>
c0debb02:	2900      	cmp	r1, #0
c0debb04:	d11e      	bne.n	c0debb44 <USBD_GetDescriptor+0x8e>
    {
    case USBD_IDX_LANGID_STR:
     pbuf = ((GetLangIDStrDescriptor_t)PIC(pdev->pDesc->GetLangIDStrDescriptor))(pdev->dev_speed, &len);        
c0debb06:	6800      	ldr	r0, [r0, #0]
c0debb08:	6840      	ldr	r0, [r0, #4]
c0debb0a:	e009      	b.n	c0debb20 <USBD_GetDescriptor+0x6a>
    {
      goto default_error;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0debb0c:	7c21      	ldrb	r1, [r4, #16]
c0debb0e:	2900      	cmp	r1, #0
c0debb10:	d118      	bne.n	c0debb44 <USBD_GetDescriptor+0x8e>
c0debb12:	6840      	ldr	r0, [r0, #4]
c0debb14:	2800      	cmp	r0, #0
c0debb16:	d015      	beq.n	c0debb44 <USBD_GetDescriptor+0x8e>
    {
      pbuf   = (uint8_t *)((GetOtherSpeedConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetOtherSpeedConfigDescriptor))(&len);
c0debb18:	6b00      	ldr	r0, [r0, #48]	; 0x30
c0debb1a:	e01e      	b.n	c0debb5a <USBD_GetDescriptor+0xa4>
    pbuf = ((GetDeviceDescriptor_t)PIC(pdev->pDesc->GetDeviceDescriptor))(pdev->dev_speed, &len);
c0debb1c:	6800      	ldr	r0, [r0, #0]
c0debb1e:	6800      	ldr	r0, [r0, #0]
c0debb20:	f7fc fb90 	bl	c0de8244 <pic>
c0debb24:	4602      	mov	r2, r0
c0debb26:	7c20      	ldrb	r0, [r4, #16]
c0debb28:	a901      	add	r1, sp, #4
c0debb2a:	4790      	blx	r2
c0debb2c:	e01a      	b.n	c0debb64 <USBD_GetDescriptor+0xae>
    if(pdev->interfacesClass[0].pClass != NULL) {
c0debb2e:	6840      	ldr	r0, [r0, #4]
c0debb30:	2800      	cmp	r0, #0
c0debb32:	d018      	beq.n	c0debb66 <USBD_GetDescriptor+0xb0>
      if(pdev->dev_speed == USBD_SPEED_HIGH )   
c0debb34:	7c21      	ldrb	r1, [r4, #16]
c0debb36:	2900      	cmp	r1, #0
c0debb38:	d00e      	beq.n	c0debb58 <USBD_GetDescriptor+0xa2>
        pbuf   = (uint8_t *)((GetFSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetFSConfigDescriptor))(&len);
c0debb3a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
c0debb3c:	e00d      	b.n	c0debb5a <USBD_GetDescriptor+0xa4>
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL )   
c0debb3e:	7c21      	ldrb	r1, [r4, #16]
c0debb40:	2900      	cmp	r1, #0
c0debb42:	d004      	beq.n	c0debb4e <USBD_GetDescriptor+0x98>
      goto default_error;
    }

  default: 
  default_error:
     USBD_CtlError(pdev , req);
c0debb44:	4620      	mov	r0, r4
c0debb46:	4629      	mov	r1, r5
c0debb48:	f000 fb80 	bl	c0dec24c <USBD_CtlError>
    USBD_CtlSendData (pdev, 
                      pbuf,
                      len);
  }
  
}
c0debb4c:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL )   
c0debb4e:	6840      	ldr	r0, [r0, #4]
c0debb50:	2800      	cmp	r0, #0
c0debb52:	d0f7      	beq.n	c0debb44 <USBD_GetDescriptor+0x8e>
      pbuf   = (uint8_t *)((GetDeviceQualifierDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetDeviceQualifierDescriptor))(&len);
c0debb54:	6b40      	ldr	r0, [r0, #52]	; 0x34
c0debb56:	e000      	b.n	c0debb5a <USBD_GetDescriptor+0xa4>
        pbuf   = (uint8_t *)((GetHSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetHSConfigDescriptor))(&len);
c0debb58:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0debb5a:	f7fc fb73 	bl	c0de8244 <pic>
c0debb5e:	4601      	mov	r1, r0
c0debb60:	a801      	add	r0, sp, #4
c0debb62:	4788      	blx	r1
c0debb64:	4601      	mov	r1, r0
c0debb66:	a801      	add	r0, sp, #4
  if((len != 0)&& (req->wLength != 0))
c0debb68:	8802      	ldrh	r2, [r0, #0]
c0debb6a:	2a00      	cmp	r2, #0
c0debb6c:	d0ee      	beq.n	c0debb4c <USBD_GetDescriptor+0x96>
c0debb6e:	88e8      	ldrh	r0, [r5, #6]
c0debb70:	2800      	cmp	r0, #0
c0debb72:	d0eb      	beq.n	c0debb4c <USBD_GetDescriptor+0x96>
    len = MIN(len , req->wLength);
c0debb74:	4282      	cmp	r2, r0
c0debb76:	d300      	bcc.n	c0debb7a <USBD_GetDescriptor+0xc4>
c0debb78:	4602      	mov	r2, r0
c0debb7a:	a801      	add	r0, sp, #4
c0debb7c:	8002      	strh	r2, [r0, #0]
    USBD_CtlSendData (pdev, 
c0debb7e:	4620      	mov	r0, r4
c0debb80:	f000 fc08 	bl	c0dec394 <USBD_CtlSendData>
}
c0debb84:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}
      pbuf = ((GetInterfaceStrDescriptor_t)PIC(pdev->pDesc->GetInterfaceStrDescriptor))(pdev->dev_speed, &len);
c0debb86:	6800      	ldr	r0, [r0, #0]
c0debb88:	6980      	ldr	r0, [r0, #24]
c0debb8a:	e7c9      	b.n	c0debb20 <USBD_GetDescriptor+0x6a>
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
c0debb8c:	6800      	ldr	r0, [r0, #0]
c0debb8e:	6880      	ldr	r0, [r0, #8]
c0debb90:	e7c6      	b.n	c0debb20 <USBD_GetDescriptor+0x6a>
      pbuf = ((GetProductStrDescriptor_t)PIC(pdev->pDesc->GetProductStrDescriptor))(pdev->dev_speed, &len);
c0debb92:	6800      	ldr	r0, [r0, #0]
c0debb94:	68c0      	ldr	r0, [r0, #12]
c0debb96:	e7c3      	b.n	c0debb20 <USBD_GetDescriptor+0x6a>
      pbuf = ((GetSerialStrDescriptor_t)PIC(pdev->pDesc->GetSerialStrDescriptor))(pdev->dev_speed, &len);
c0debb98:	6800      	ldr	r0, [r0, #0]
c0debb9a:	6900      	ldr	r0, [r0, #16]
c0debb9c:	e7c0      	b.n	c0debb20 <USBD_GetDescriptor+0x6a>
      pbuf = ((GetConfigurationStrDescriptor_t)PIC(pdev->pDesc->GetConfigurationStrDescriptor))(pdev->dev_speed, &len);
c0debb9e:	6800      	ldr	r0, [r0, #0]
c0debba0:	6940      	ldr	r0, [r0, #20]
c0debba2:	e7bd      	b.n	c0debb20 <USBD_GetDescriptor+0x6a>

c0debba4 <USBD_SetAddress>:
* @param  req: usb request
* @retval status
*/
void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0debba4:	b570      	push	{r4, r5, r6, lr}
c0debba6:	4604      	mov	r4, r0
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
c0debba8:	8888      	ldrh	r0, [r1, #4]
c0debbaa:	2800      	cmp	r0, #0
c0debbac:	d107      	bne.n	c0debbbe <USBD_SetAddress+0x1a>
c0debbae:	88c8      	ldrh	r0, [r1, #6]
c0debbb0:	2800      	cmp	r0, #0
c0debbb2:	d104      	bne.n	c0debbbe <USBD_SetAddress+0x1a>
c0debbb4:	4626      	mov	r6, r4
c0debbb6:	369c      	adds	r6, #156	; 0x9c
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
c0debbb8:	7830      	ldrb	r0, [r6, #0]
c0debbba:	2803      	cmp	r0, #3
c0debbbc:	d103      	bne.n	c0debbc6 <USBD_SetAddress+0x22>
c0debbbe:	4620      	mov	r0, r4
c0debbc0:	f000 fb44 	bl	c0dec24c <USBD_CtlError>
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
  } 
}
c0debbc4:	bd70      	pop	{r4, r5, r6, pc}
c0debbc6:	7888      	ldrb	r0, [r1, #2]
c0debbc8:	257f      	movs	r5, #127	; 0x7f
c0debbca:	4005      	ands	r5, r0
      pdev->dev_address = dev_addr;
c0debbcc:	70b5      	strb	r5, [r6, #2]
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
c0debbce:	4620      	mov	r0, r4
c0debbd0:	4629      	mov	r1, r5
c0debbd2:	f7ff fd4d 	bl	c0deb670 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
c0debbd6:	4620      	mov	r0, r4
c0debbd8:	f000 fc07 	bl	c0dec3ea <USBD_CtlSendStatus>
      if (dev_addr != 0) 
c0debbdc:	2d00      	cmp	r5, #0
c0debbde:	d001      	beq.n	c0debbe4 <USBD_SetAddress+0x40>
c0debbe0:	2002      	movs	r0, #2
c0debbe2:	e000      	b.n	c0debbe6 <USBD_SetAddress+0x42>
c0debbe4:	2001      	movs	r0, #1
c0debbe6:	7030      	strb	r0, [r6, #0]
}
c0debbe8:	bd70      	pop	{r4, r5, r6, pc}

c0debbea <USBD_SetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0debbea:	b570      	push	{r4, r5, r6, lr}
c0debbec:	460d      	mov	r5, r1
c0debbee:	4604      	mov	r4, r0
  
  uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
c0debbf0:	788e      	ldrb	r6, [r1, #2]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
c0debbf2:	2e02      	cmp	r6, #2
c0debbf4:	d21c      	bcs.n	c0debc30 <USBD_SetConfig+0x46>
c0debbf6:	209c      	movs	r0, #156	; 0x9c
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
c0debbf8:	5c21      	ldrb	r1, [r4, r0]
c0debbfa:	4620      	mov	r0, r4
c0debbfc:	309c      	adds	r0, #156	; 0x9c
c0debbfe:	2903      	cmp	r1, #3
c0debc00:	d006      	beq.n	c0debc10 <USBD_SetConfig+0x26>
c0debc02:	2902      	cmp	r1, #2
c0debc04:	d114      	bne.n	c0debc30 <USBD_SetConfig+0x46>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
c0debc06:	2e00      	cmp	r6, #0
c0debc08:	d022      	beq.n	c0debc50 <USBD_SetConfig+0x66>
c0debc0a:	2103      	movs	r1, #3
      {                                                                               
        pdev->dev_config = cfgidx;
        pdev->dev_state = USBD_STATE_CONFIGURED;
c0debc0c:	7001      	strb	r1, [r0, #0]
c0debc0e:	e008      	b.n	c0debc22 <USBD_SetConfig+0x38>
      }
      USBD_CtlSendStatus(pdev);
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
c0debc10:	2e00      	cmp	r6, #0
c0debc12:	d012      	beq.n	c0debc3a <USBD_SetConfig+0x50>
        pdev->dev_state = USBD_STATE_ADDRESSED;
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
      } 
      else  if (cfgidx != pdev->dev_config) 
c0debc14:	6860      	ldr	r0, [r4, #4]
c0debc16:	42b0      	cmp	r0, r6
c0debc18:	d01a      	beq.n	c0debc50 <USBD_SetConfig+0x66>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
c0debc1a:	b2c1      	uxtb	r1, r0
c0debc1c:	4620      	mov	r0, r4
c0debc1e:	f7ff fdc0 	bl	c0deb7a2 <USBD_ClrClassConfig>
c0debc22:	6066      	str	r6, [r4, #4]
c0debc24:	4620      	mov	r0, r4
c0debc26:	4631      	mov	r1, r6
c0debc28:	f7ff fda0 	bl	c0deb76c <USBD_SetClassConfig>
c0debc2c:	2802      	cmp	r0, #2
c0debc2e:	d10f      	bne.n	c0debc50 <USBD_SetConfig+0x66>
c0debc30:	4620      	mov	r0, r4
c0debc32:	4629      	mov	r1, r5
c0debc34:	f000 fb0a 	bl	c0dec24c <USBD_CtlError>
    default:          
       USBD_CtlError(pdev , req);                     
      break;
    }
  }
}
c0debc38:	bd70      	pop	{r4, r5, r6, pc}
c0debc3a:	2100      	movs	r1, #0
        pdev->dev_config = cfgidx;          
c0debc3c:	6061      	str	r1, [r4, #4]
c0debc3e:	2102      	movs	r1, #2
        pdev->dev_state = USBD_STATE_ADDRESSED;
c0debc40:	7001      	strb	r1, [r0, #0]
        USBD_ClrClassConfig(pdev , cfgidx);
c0debc42:	4620      	mov	r0, r4
c0debc44:	4631      	mov	r1, r6
c0debc46:	f7ff fdac 	bl	c0deb7a2 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
c0debc4a:	4620      	mov	r0, r4
c0debc4c:	f000 fbcd 	bl	c0dec3ea <USBD_CtlSendStatus>
c0debc50:	4620      	mov	r0, r4
c0debc52:	f000 fbca 	bl	c0dec3ea <USBD_CtlSendStatus>
}
c0debc56:	bd70      	pop	{r4, r5, r6, pc}

c0debc58 <USBD_GetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0debc58:	b580      	push	{r7, lr}

  if (req->wLength != 1) 
c0debc5a:	88ca      	ldrh	r2, [r1, #6]
c0debc5c:	2a01      	cmp	r2, #1
c0debc5e:	d10a      	bne.n	c0debc76 <USBD_GetConfig+0x1e>
c0debc60:	229c      	movs	r2, #156	; 0x9c
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
c0debc62:	5c82      	ldrb	r2, [r0, r2]
c0debc64:	2a03      	cmp	r2, #3
c0debc66:	d009      	beq.n	c0debc7c <USBD_GetConfig+0x24>
c0debc68:	2a02      	cmp	r2, #2
c0debc6a:	d104      	bne.n	c0debc76 <USBD_GetConfig+0x1e>
c0debc6c:	2100      	movs	r1, #0
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
c0debc6e:	6081      	str	r1, [r0, #8]
c0debc70:	4601      	mov	r1, r0
c0debc72:	3108      	adds	r1, #8
c0debc74:	e003      	b.n	c0debc7e <USBD_GetConfig+0x26>
c0debc76:	f000 fae9 	bl	c0dec24c <USBD_CtlError>
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}
c0debc7a:	bd80      	pop	{r7, pc}
                        (uint8_t *)&pdev->dev_config,
c0debc7c:	1d01      	adds	r1, r0, #4
c0debc7e:	2201      	movs	r2, #1
c0debc80:	f000 fb88 	bl	c0dec394 <USBD_CtlSendData>
}
c0debc84:	bd80      	pop	{r7, pc}

c0debc86 <USBD_GetStatus>:
* @param  req: usb request
* @retval status
*/
void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0debc86:	b5b0      	push	{r4, r5, r7, lr}
c0debc88:	4604      	mov	r4, r0
c0debc8a:	209c      	movs	r0, #156	; 0x9c
  
    
  switch (pdev->dev_state) 
c0debc8c:	5c20      	ldrb	r0, [r4, r0]
c0debc8e:	22fe      	movs	r2, #254	; 0xfe
c0debc90:	4002      	ands	r2, r0
c0debc92:	2a02      	cmp	r2, #2
c0debc94:	d10f      	bne.n	c0debcb6 <USBD_GetStatus+0x30>
c0debc96:	4620      	mov	r0, r4
c0debc98:	309c      	adds	r0, #156	; 0x9c
c0debc9a:	2101      	movs	r1, #1
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0debc9c:	60e1      	str	r1, [r4, #12]
c0debc9e:	4625      	mov	r5, r4
c0debca0:	350c      	adds	r5, #12
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0debca2:	6880      	ldr	r0, [r0, #8]
c0debca4:	2800      	cmp	r0, #0
c0debca6:	d00a      	beq.n	c0debcbe <USBD_GetStatus+0x38>
c0debca8:	4620      	mov	r0, r4
c0debcaa:	f000 fbaa 	bl	c0dec402 <USBD_CtlReceiveStatus>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0debcae:	68e1      	ldr	r1, [r4, #12]
c0debcb0:	2002      	movs	r0, #2
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0debcb2:	4308      	orrs	r0, r1
c0debcb4:	e004      	b.n	c0debcc0 <USBD_GetStatus+0x3a>
                      (uint8_t *)& pdev->dev_config_status,
                      2);
    break;
    
  default :
    USBD_CtlError(pdev , req);                        
c0debcb6:	4620      	mov	r0, r4
c0debcb8:	f000 fac8 	bl	c0dec24c <USBD_CtlError>
    break;
  }
}
c0debcbc:	bdb0      	pop	{r4, r5, r7, pc}
c0debcbe:	2003      	movs	r0, #3
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0debcc0:	60e0      	str	r0, [r4, #12]
c0debcc2:	2202      	movs	r2, #2
    USBD_CtlSendData (pdev, 
c0debcc4:	4620      	mov	r0, r4
c0debcc6:	4629      	mov	r1, r5
c0debcc8:	f000 fb64 	bl	c0dec394 <USBD_CtlSendData>
}
c0debccc:	bdb0      	pop	{r4, r5, r7, pc}

c0debcce <USBD_SetFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0debcce:	b5b0      	push	{r4, r5, r7, lr}
c0debcd0:	4604      	mov	r4, r0

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
c0debcd2:	8848      	ldrh	r0, [r1, #2]
c0debcd4:	2801      	cmp	r0, #1
c0debcd6:	d116      	bne.n	c0debd06 <USBD_SetFeature+0x38>
c0debcd8:	460d      	mov	r5, r1
c0debcda:	20a4      	movs	r0, #164	; 0xa4
c0debcdc:	2101      	movs	r1, #1
  {
    pdev->dev_remote_wakeup = 1;  
c0debcde:	5021      	str	r1, [r4, r0]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0debce0:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0debce2:	2802      	cmp	r0, #2
c0debce4:	d80c      	bhi.n	c0debd00 <USBD_SetFeature+0x32>
c0debce6:	00c0      	lsls	r0, r0, #3
c0debce8:	1820      	adds	r0, r4, r0
c0debcea:	21b4      	movs	r1, #180	; 0xb4
c0debcec:	5840      	ldr	r0, [r0, r1]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0debcee:	2800      	cmp	r0, #0
c0debcf0:	d006      	beq.n	c0debd00 <USBD_SetFeature+0x32>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0debcf2:	6880      	ldr	r0, [r0, #8]
c0debcf4:	f7fc faa6 	bl	c0de8244 <pic>
c0debcf8:	4602      	mov	r2, r0
c0debcfa:	4620      	mov	r0, r4
c0debcfc:	4629      	mov	r1, r5
c0debcfe:	4790      	blx	r2
    }
    USBD_CtlSendStatus(pdev);
c0debd00:	4620      	mov	r0, r4
c0debd02:	f000 fb72 	bl	c0dec3ea <USBD_CtlSendStatus>
  }

}
c0debd06:	bdb0      	pop	{r4, r5, r7, pc}

c0debd08 <USBD_ClrFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0debd08:	b5b0      	push	{r4, r5, r7, lr}
c0debd0a:	460d      	mov	r5, r1
c0debd0c:	4604      	mov	r4, r0
c0debd0e:	209c      	movs	r0, #156	; 0x9c
  switch (pdev->dev_state)
c0debd10:	5c20      	ldrb	r0, [r4, r0]
c0debd12:	21fe      	movs	r1, #254	; 0xfe
c0debd14:	4001      	ands	r1, r0
c0debd16:	2902      	cmp	r1, #2
c0debd18:	d11a      	bne.n	c0debd50 <USBD_ClrFeature+0x48>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
c0debd1a:	8868      	ldrh	r0, [r5, #2]
c0debd1c:	2801      	cmp	r0, #1
c0debd1e:	d11b      	bne.n	c0debd58 <USBD_ClrFeature+0x50>
c0debd20:	4620      	mov	r0, r4
c0debd22:	309c      	adds	r0, #156	; 0x9c
c0debd24:	2100      	movs	r1, #0
    {
      pdev->dev_remote_wakeup = 0; 
c0debd26:	6081      	str	r1, [r0, #8]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0debd28:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0debd2a:	2802      	cmp	r0, #2
c0debd2c:	d80c      	bhi.n	c0debd48 <USBD_ClrFeature+0x40>
c0debd2e:	00c0      	lsls	r0, r0, #3
c0debd30:	1820      	adds	r0, r4, r0
c0debd32:	21b4      	movs	r1, #180	; 0xb4
c0debd34:	5840      	ldr	r0, [r0, r1]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0debd36:	2800      	cmp	r0, #0
c0debd38:	d006      	beq.n	c0debd48 <USBD_ClrFeature+0x40>
        ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0debd3a:	6880      	ldr	r0, [r0, #8]
c0debd3c:	f7fc fa82 	bl	c0de8244 <pic>
c0debd40:	4602      	mov	r2, r0
c0debd42:	4620      	mov	r0, r4
c0debd44:	4629      	mov	r1, r5
c0debd46:	4790      	blx	r2
      }
      USBD_CtlSendStatus(pdev);
c0debd48:	4620      	mov	r0, r4
c0debd4a:	f000 fb4e 	bl	c0dec3ea <USBD_CtlSendStatus>
    
  default :
     USBD_CtlError(pdev , req);
    break;
  }
}
c0debd4e:	bdb0      	pop	{r4, r5, r7, pc}
     USBD_CtlError(pdev , req);
c0debd50:	4620      	mov	r0, r4
c0debd52:	4629      	mov	r1, r5
c0debd54:	f000 fa7a 	bl	c0dec24c <USBD_CtlError>
}
c0debd58:	bdb0      	pop	{r4, r5, r7, pc}

c0debd5a <USBD_StdItfReq>:
{
c0debd5a:	b5b0      	push	{r4, r5, r7, lr}
c0debd5c:	460d      	mov	r5, r1
c0debd5e:	4604      	mov	r4, r0
c0debd60:	209c      	movs	r0, #156	; 0x9c
  switch (pdev->dev_state) 
c0debd62:	5c20      	ldrb	r0, [r4, r0]
c0debd64:	2803      	cmp	r0, #3
c0debd66:	d116      	bne.n	c0debd96 <USBD_StdItfReq+0x3c>
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0debd68:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0debd6a:	2802      	cmp	r0, #2
c0debd6c:	d813      	bhi.n	c0debd96 <USBD_StdItfReq+0x3c>
c0debd6e:	00c0      	lsls	r0, r0, #3
c0debd70:	1820      	adds	r0, r4, r0
c0debd72:	21b4      	movs	r1, #180	; 0xb4
c0debd74:	5840      	ldr	r0, [r0, r1]
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0debd76:	2800      	cmp	r0, #0
c0debd78:	d00d      	beq.n	c0debd96 <USBD_StdItfReq+0x3c>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0debd7a:	6880      	ldr	r0, [r0, #8]
c0debd7c:	f7fc fa62 	bl	c0de8244 <pic>
c0debd80:	4602      	mov	r2, r0
c0debd82:	4620      	mov	r0, r4
c0debd84:	4629      	mov	r1, r5
c0debd86:	4790      	blx	r2
      if((req->wLength == 0)&& (ret == USBD_OK))
c0debd88:	88e8      	ldrh	r0, [r5, #6]
c0debd8a:	2800      	cmp	r0, #0
c0debd8c:	d107      	bne.n	c0debd9e <USBD_StdItfReq+0x44>
         USBD_CtlSendStatus(pdev);
c0debd8e:	4620      	mov	r0, r4
c0debd90:	f000 fb2b 	bl	c0dec3ea <USBD_CtlSendStatus>
c0debd94:	e003      	b.n	c0debd9e <USBD_StdItfReq+0x44>
c0debd96:	4620      	mov	r0, r4
c0debd98:	4629      	mov	r1, r5
c0debd9a:	f000 fa57 	bl	c0dec24c <USBD_CtlError>
c0debd9e:	2000      	movs	r0, #0
  return USBD_OK;
c0debda0:	bdb0      	pop	{r4, r5, r7, pc}

c0debda2 <USBD_StdEPReq>:
{
c0debda2:	b5bc      	push	{r2, r3, r4, r5, r7, lr}
c0debda4:	460d      	mov	r5, r1
c0debda6:	4604      	mov	r4, r0
  ep_addr  = LOBYTE(req->wIndex);
c0debda8:	7909      	ldrb	r1, [r1, #4]
c0debdaa:	207f      	movs	r0, #127	; 0x7f
  if ((ep_addr & 0x7F) > IO_USB_MAX_ENDPOINTS) {
c0debdac:	4008      	ands	r0, r1
c0debdae:	2805      	cmp	r0, #5
c0debdb0:	d304      	bcc.n	c0debdbc <USBD_StdEPReq+0x1a>
c0debdb2:	4620      	mov	r0, r4
c0debdb4:	4629      	mov	r1, r5
c0debdb6:	f000 fa49 	bl	c0dec24c <USBD_CtlError>
c0debdba:	e071      	b.n	c0debea0 <USBD_StdEPReq+0xfe>
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0debdbc:	2902      	cmp	r1, #2
c0debdbe:	d812      	bhi.n	c0debde6 <USBD_StdEPReq+0x44>
c0debdc0:	782a      	ldrb	r2, [r5, #0]
c0debdc2:	2360      	movs	r3, #96	; 0x60
c0debdc4:	4013      	ands	r3, r2
c0debdc6:	2b20      	cmp	r3, #32
c0debdc8:	d10d      	bne.n	c0debde6 <USBD_StdEPReq+0x44>
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0debdca:	00ca      	lsls	r2, r1, #3
c0debdcc:	18a2      	adds	r2, r4, r2
c0debdce:	23b4      	movs	r3, #180	; 0xb4
c0debdd0:	58d2      	ldr	r2, [r2, r3]
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0debdd2:	2a00      	cmp	r2, #0
c0debdd4:	d007      	beq.n	c0debde6 <USBD_StdEPReq+0x44>
    ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0debdd6:	6890      	ldr	r0, [r2, #8]
c0debdd8:	f7fc fa34 	bl	c0de8244 <pic>
c0debddc:	4602      	mov	r2, r0
c0debdde:	4620      	mov	r0, r4
c0debde0:	4629      	mov	r1, r5
c0debde2:	4790      	blx	r2
c0debde4:	e05c      	b.n	c0debea0 <USBD_StdEPReq+0xfe>
  switch (req->bRequest) 
c0debde6:	786a      	ldrb	r2, [r5, #1]
c0debde8:	2a00      	cmp	r2, #0
c0debdea:	d00a      	beq.n	c0debe02 <USBD_StdEPReq+0x60>
c0debdec:	2a01      	cmp	r2, #1
c0debdee:	d011      	beq.n	c0debe14 <USBD_StdEPReq+0x72>
c0debdf0:	2a03      	cmp	r2, #3
c0debdf2:	d155      	bne.n	c0debea0 <USBD_StdEPReq+0xfe>
c0debdf4:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0debdf6:	5c20      	ldrb	r0, [r4, r0]
c0debdf8:	2803      	cmp	r0, #3
c0debdfa:	d01a      	beq.n	c0debe32 <USBD_StdEPReq+0x90>
c0debdfc:	2802      	cmp	r0, #2
c0debdfe:	d00f      	beq.n	c0debe20 <USBD_StdEPReq+0x7e>
c0debe00:	e7d7      	b.n	c0debdb2 <USBD_StdEPReq+0x10>
c0debe02:	229c      	movs	r2, #156	; 0x9c
    switch (pdev->dev_state) 
c0debe04:	5ca2      	ldrb	r2, [r4, r2]
c0debe06:	2a03      	cmp	r2, #3
c0debe08:	d02e      	beq.n	c0debe68 <USBD_StdEPReq+0xc6>
c0debe0a:	2a02      	cmp	r2, #2
c0debe0c:	d1d1      	bne.n	c0debdb2 <USBD_StdEPReq+0x10>
      if ((ep_addr & 0x7F) != 0x00) 
c0debe0e:	2800      	cmp	r0, #0
c0debe10:	d10b      	bne.n	c0debe2a <USBD_StdEPReq+0x88>
c0debe12:	e045      	b.n	c0debea0 <USBD_StdEPReq+0xfe>
c0debe14:	229c      	movs	r2, #156	; 0x9c
    switch (pdev->dev_state) 
c0debe16:	5ca2      	ldrb	r2, [r4, r2]
c0debe18:	2a03      	cmp	r2, #3
c0debe1a:	d031      	beq.n	c0debe80 <USBD_StdEPReq+0xde>
c0debe1c:	2a02      	cmp	r2, #2
c0debe1e:	d1c8      	bne.n	c0debdb2 <USBD_StdEPReq+0x10>
c0debe20:	2080      	movs	r0, #128	; 0x80
c0debe22:	460a      	mov	r2, r1
c0debe24:	4302      	orrs	r2, r0
c0debe26:	2a80      	cmp	r2, #128	; 0x80
c0debe28:	d03a      	beq.n	c0debea0 <USBD_StdEPReq+0xfe>
c0debe2a:	4620      	mov	r0, r4
c0debe2c:	f7ff fbc6 	bl	c0deb5bc <USBD_LL_StallEP>
c0debe30:	e036      	b.n	c0debea0 <USBD_StdEPReq+0xfe>
      if (req->wValue == USB_FEATURE_EP_HALT)
c0debe32:	8868      	ldrh	r0, [r5, #2]
c0debe34:	2800      	cmp	r0, #0
c0debe36:	d107      	bne.n	c0debe48 <USBD_StdEPReq+0xa6>
c0debe38:	2080      	movs	r0, #128	; 0x80
c0debe3a:	4308      	orrs	r0, r1
c0debe3c:	2880      	cmp	r0, #128	; 0x80
c0debe3e:	d003      	beq.n	c0debe48 <USBD_StdEPReq+0xa6>
          USBD_LL_StallEP(pdev , ep_addr);
c0debe40:	4620      	mov	r0, r4
c0debe42:	f7ff fbbb 	bl	c0deb5bc <USBD_LL_StallEP>
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0debe46:	7929      	ldrb	r1, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0debe48:	2902      	cmp	r1, #2
c0debe4a:	d826      	bhi.n	c0debe9a <USBD_StdEPReq+0xf8>
c0debe4c:	00c8      	lsls	r0, r1, #3
c0debe4e:	1820      	adds	r0, r4, r0
c0debe50:	21b4      	movs	r1, #180	; 0xb4
c0debe52:	5840      	ldr	r0, [r0, r1]
c0debe54:	2800      	cmp	r0, #0
c0debe56:	d020      	beq.n	c0debe9a <USBD_StdEPReq+0xf8>
c0debe58:	6880      	ldr	r0, [r0, #8]
c0debe5a:	f7fc f9f3 	bl	c0de8244 <pic>
c0debe5e:	4602      	mov	r2, r0
c0debe60:	4620      	mov	r0, r4
c0debe62:	4629      	mov	r1, r5
c0debe64:	4790      	blx	r2
c0debe66:	e018      	b.n	c0debe9a <USBD_StdEPReq+0xf8>
        unsigned short status = USBD_LL_IsStallEP(pdev, ep_addr)? 1 : 0;        
c0debe68:	4620      	mov	r0, r4
c0debe6a:	f7ff fbef 	bl	c0deb64c <USBD_LL_IsStallEP>
c0debe6e:	1e41      	subs	r1, r0, #1
c0debe70:	4188      	sbcs	r0, r1
c0debe72:	a901      	add	r1, sp, #4
c0debe74:	8008      	strh	r0, [r1, #0]
c0debe76:	2202      	movs	r2, #2
        USBD_CtlSendData (pdev,
c0debe78:	4620      	mov	r0, r4
c0debe7a:	f000 fa8b 	bl	c0dec394 <USBD_CtlSendData>
c0debe7e:	e00f      	b.n	c0debea0 <USBD_StdEPReq+0xfe>
      if (req->wValue == USB_FEATURE_EP_HALT)
c0debe80:	886a      	ldrh	r2, [r5, #2]
c0debe82:	2a00      	cmp	r2, #0
c0debe84:	d10c      	bne.n	c0debea0 <USBD_StdEPReq+0xfe>
        if ((ep_addr & 0x7F) != 0x00) 
c0debe86:	2800      	cmp	r0, #0
c0debe88:	d007      	beq.n	c0debe9a <USBD_StdEPReq+0xf8>
          USBD_LL_ClearStallEP(pdev , ep_addr);
c0debe8a:	4620      	mov	r0, r4
c0debe8c:	f7ff fbba 	bl	c0deb604 <USBD_LL_ClearStallEP>
          if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0debe90:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0debe92:	2802      	cmp	r0, #2
c0debe94:	d801      	bhi.n	c0debe9a <USBD_StdEPReq+0xf8>
c0debe96:	00c0      	lsls	r0, r0, #3
c0debe98:	e7d9      	b.n	c0debe4e <USBD_StdEPReq+0xac>
c0debe9a:	4620      	mov	r0, r4
c0debe9c:	f000 faa5 	bl	c0dec3ea <USBD_CtlSendStatus>
c0debea0:	2000      	movs	r0, #0
}
c0debea2:	bdbc      	pop	{r2, r3, r4, r5, r7, pc}

c0debea4 <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
c0debea4:	780a      	ldrb	r2, [r1, #0]
c0debea6:	7002      	strb	r2, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
c0debea8:	784a      	ldrb	r2, [r1, #1]
c0debeaa:	7042      	strb	r2, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
c0debeac:	788a      	ldrb	r2, [r1, #2]
c0debeae:	78cb      	ldrb	r3, [r1, #3]
c0debeb0:	021b      	lsls	r3, r3, #8
c0debeb2:	189a      	adds	r2, r3, r2
c0debeb4:	8042      	strh	r2, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
c0debeb6:	790a      	ldrb	r2, [r1, #4]
c0debeb8:	794b      	ldrb	r3, [r1, #5]
c0debeba:	021b      	lsls	r3, r3, #8
c0debebc:	189a      	adds	r2, r3, r2
c0debebe:	8082      	strh	r2, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
c0debec0:	798a      	ldrb	r2, [r1, #6]
c0debec2:	79c9      	ldrb	r1, [r1, #7]
c0debec4:	0209      	lsls	r1, r1, #8
c0debec6:	1889      	adds	r1, r1, r2
c0debec8:	80c1      	strh	r1, [r0, #6]

}
c0debeca:	4770      	bx	lr

c0debecc <USBD_CtlStall>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/
void USBD_CtlStall( USBD_HandleTypeDef *pdev)
{
c0debecc:	b510      	push	{r4, lr}
c0debece:	4604      	mov	r4, r0
c0debed0:	2180      	movs	r1, #128	; 0x80
  USBD_LL_StallEP(pdev , 0x80);
c0debed2:	f7ff fb73 	bl	c0deb5bc <USBD_LL_StallEP>
c0debed6:	2100      	movs	r1, #0
  USBD_LL_StallEP(pdev , 0);
c0debed8:	4620      	mov	r0, r4
c0debeda:	f7ff fb6f 	bl	c0deb5bc <USBD_LL_StallEP>
}
c0debede:	bd10      	pop	{r4, pc}

c0debee0 <USBD_HID_Setup>:
  * @param  req: usb requests
  * @retval status
  */
uint8_t  USBD_HID_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0debee0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0debee2:	460e      	mov	r6, r1
c0debee4:	4605      	mov	r5, r0
c0debee6:	a802      	add	r0, sp, #8
c0debee8:	2400      	movs	r4, #0
  uint16_t len = 0;
c0debeea:	8004      	strh	r4, [r0, #0]
c0debeec:	a801      	add	r0, sp, #4
  uint8_t  *pbuf = NULL;

  uint8_t val = 0;
c0debeee:	7004      	strb	r4, [r0, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
c0debef0:	7809      	ldrb	r1, [r1, #0]
c0debef2:	2060      	movs	r0, #96	; 0x60
c0debef4:	4008      	ands	r0, r1
c0debef6:	d010      	beq.n	c0debf1a <USBD_HID_Setup+0x3a>
c0debef8:	2820      	cmp	r0, #32
c0debefa:	d137      	bne.n	c0debf6c <USBD_HID_Setup+0x8c>
  {
  case USB_REQ_TYPE_CLASS :  
    switch (req->bRequest)
c0debefc:	7870      	ldrb	r0, [r6, #1]
c0debefe:	4601      	mov	r1, r0
c0debf00:	390a      	subs	r1, #10
c0debf02:	2902      	cmp	r1, #2
c0debf04:	d332      	bcc.n	c0debf6c <USBD_HID_Setup+0x8c>
c0debf06:	2802      	cmp	r0, #2
c0debf08:	d01b      	beq.n	c0debf42 <USBD_HID_Setup+0x62>
c0debf0a:	2803      	cmp	r0, #3
c0debf0c:	d019      	beq.n	c0debf42 <USBD_HID_Setup+0x62>
                        (uint8_t *)&val,
                        1);      
      break;      
      
    default:
      USBD_CtlError (pdev, req);
c0debf0e:	4628      	mov	r0, r5
c0debf10:	4631      	mov	r1, r6
c0debf12:	f000 f99b 	bl	c0dec24c <USBD_CtlError>
c0debf16:	2402      	movs	r4, #2
c0debf18:	e028      	b.n	c0debf6c <USBD_HID_Setup+0x8c>
      return USBD_FAIL; 
    }
    break;
    
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
c0debf1a:	7870      	ldrb	r0, [r6, #1]
c0debf1c:	280b      	cmp	r0, #11
c0debf1e:	d013      	beq.n	c0debf48 <USBD_HID_Setup+0x68>
c0debf20:	280a      	cmp	r0, #10
c0debf22:	d00e      	beq.n	c0debf42 <USBD_HID_Setup+0x62>
c0debf24:	2806      	cmp	r0, #6
c0debf26:	d121      	bne.n	c0debf6c <USBD_HID_Setup+0x8c>
    {
    case USB_REQ_GET_DESCRIPTOR: 
      // 0x22
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0debf28:	78f0      	ldrb	r0, [r6, #3]
c0debf2a:	2400      	movs	r4, #0
c0debf2c:	2821      	cmp	r0, #33	; 0x21
c0debf2e:	d00f      	beq.n	c0debf50 <USBD_HID_Setup+0x70>
c0debf30:	2822      	cmp	r0, #34	; 0x22
      
      //USBD_CtlReceiveStatus(pdev);
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
c0debf32:	4622      	mov	r2, r4
c0debf34:	4621      	mov	r1, r4
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0debf36:	d116      	bne.n	c0debf66 <USBD_HID_Setup+0x86>
c0debf38:	af02      	add	r7, sp, #8
        pbuf =  USBD_HID_GetReportDescriptor_impl(&len);
c0debf3a:	4638      	mov	r0, r7
c0debf3c:	f000 f84e 	bl	c0debfdc <USBD_HID_GetReportDescriptor_impl>
c0debf40:	e00a      	b.n	c0debf58 <USBD_HID_Setup+0x78>
c0debf42:	a901      	add	r1, sp, #4
c0debf44:	2201      	movs	r2, #1
c0debf46:	e00e      	b.n	c0debf66 <USBD_HID_Setup+0x86>
      break;

    case USB_REQ_SET_INTERFACE :
      //hhid->AltSetting = (uint8_t)(req->wValue);
      USBD_CtlSendStatus(pdev);
c0debf48:	4628      	mov	r0, r5
c0debf4a:	f000 fa4e 	bl	c0dec3ea <USBD_CtlSendStatus>
c0debf4e:	e00d      	b.n	c0debf6c <USBD_HID_Setup+0x8c>
c0debf50:	af02      	add	r7, sp, #8
        pbuf = USBD_HID_GetHidDescriptor_impl(&len);
c0debf52:	4638      	mov	r0, r7
c0debf54:	f000 f826 	bl	c0debfa4 <USBD_HID_GetHidDescriptor_impl>
c0debf58:	4601      	mov	r1, r0
c0debf5a:	883a      	ldrh	r2, [r7, #0]
c0debf5c:	88f0      	ldrh	r0, [r6, #6]
c0debf5e:	4282      	cmp	r2, r0
c0debf60:	d300      	bcc.n	c0debf64 <USBD_HID_Setup+0x84>
c0debf62:	4602      	mov	r2, r0
c0debf64:	803a      	strh	r2, [r7, #0]
c0debf66:	4628      	mov	r0, r5
c0debf68:	f000 fa14 	bl	c0dec394 <USBD_CtlSendData>
      
    }
  }

  return USBD_OK;
}
c0debf6c:	4620      	mov	r0, r4
c0debf6e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

c0debf70 <USBD_HID_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0debf70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0debf72:	4604      	mov	r4, r0
c0debf74:	2182      	movs	r1, #130	; 0x82
c0debf76:	2603      	movs	r6, #3
c0debf78:	2540      	movs	r5, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0debf7a:	4632      	mov	r2, r6
c0debf7c:	462b      	mov	r3, r5
c0debf7e:	f7ff faef 	bl	c0deb560 <USBD_LL_OpenEP>
c0debf82:	2702      	movs	r7, #2
                 HID_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0debf84:	4620      	mov	r0, r4
c0debf86:	4639      	mov	r1, r7
c0debf88:	4632      	mov	r2, r6
c0debf8a:	462b      	mov	r3, r5
c0debf8c:	f7ff fae8 	bl	c0deb560 <USBD_LL_OpenEP>
                 HID_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR, HID_EPOUT_SIZE);
c0debf90:	4620      	mov	r0, r4
c0debf92:	4639      	mov	r1, r7
c0debf94:	462a      	mov	r2, r5
c0debf96:	f7ff fb92 	bl	c0deb6be <USBD_LL_PrepareReceive>
c0debf9a:	2000      	movs	r0, #0
  USBD_LL_Transmit (pdev, 
                    HID_EPIN_ADDR,                                      
                    NULL,
                    0);
  */
  return USBD_OK;
c0debf9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

c0debf9e <USBD_HID_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
c0debf9e:	2000      	movs	r0, #0
  
  // /* Close HID EP OUT */
  // USBD_LL_CloseEP(pdev,
  //                 HID_EPOUT_ADDR);
  
  return USBD_OK;
c0debfa0:	4770      	bx	lr
c0debfa2:	d4d4      	bmi.n	c0debf4e <USBD_HID_Setup+0x6e>

c0debfa4 <USBD_HID_GetHidDescriptor_impl>:
  *length = sizeof (USBD_CfgDesc);
  return (uint8_t*)USBD_CfgDesc;
}

uint8_t* USBD_HID_GetHidDescriptor_impl(uint16_t* len) {
  switch (USBD_Device.request.wIndex&0xFF) {
c0debfa4:	490a      	ldr	r1, [pc, #40]	; (c0debfd0 <USBD_HID_GetHidDescriptor_impl+0x2c>)
c0debfa6:	464a      	mov	r2, r9
c0debfa8:	1851      	adds	r1, r2, r1
c0debfaa:	22ac      	movs	r2, #172	; 0xac
c0debfac:	5c89      	ldrb	r1, [r1, r2]
c0debfae:	2209      	movs	r2, #9
c0debfb0:	2901      	cmp	r1, #1
c0debfb2:	d004      	beq.n	c0debfbe <USBD_HID_GetHidDescriptor_impl+0x1a>
c0debfb4:	2900      	cmp	r1, #0
c0debfb6:	d105      	bne.n	c0debfc4 <USBD_HID_GetHidDescriptor_impl+0x20>
c0debfb8:	4907      	ldr	r1, [pc, #28]	; (c0debfd8 <USBD_HID_GetHidDescriptor_impl+0x34>)
c0debfba:	4479      	add	r1, pc
c0debfbc:	e004      	b.n	c0debfc8 <USBD_HID_GetHidDescriptor_impl+0x24>
c0debfbe:	4905      	ldr	r1, [pc, #20]	; (c0debfd4 <USBD_HID_GetHidDescriptor_impl+0x30>)
c0debfc0:	4479      	add	r1, pc
c0debfc2:	e001      	b.n	c0debfc8 <USBD_HID_GetHidDescriptor_impl+0x24>
c0debfc4:	2200      	movs	r2, #0
c0debfc6:	4611      	mov	r1, r2
c0debfc8:	8002      	strh	r2, [r0, #0]
      return (uint8_t*)USBD_HID_Desc_kbd; 
#endif // HAVE_USB_HIDKBD
  }
  *len = 0;
  return 0;
}
c0debfca:	4608      	mov	r0, r1
c0debfcc:	4770      	bx	lr
c0debfce:	46c0      	nop			; (mov r8, r8)
c0debfd0:	00000bf0 	.word	0x00000bf0
c0debfd4:	00004d28 	.word	0x00004d28
c0debfd8:	00004d3a 	.word	0x00004d3a

c0debfdc <USBD_HID_GetReportDescriptor_impl>:

uint8_t* USBD_HID_GetReportDescriptor_impl(uint16_t* len) {
c0debfdc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0debfde:	4603      	mov	r3, r0
  switch (USBD_Device.request.wIndex&0xFF) {
c0debfe0:	4815      	ldr	r0, [pc, #84]	; (c0dec038 <USBD_HID_GetReportDescriptor_impl+0x5c>)
c0debfe2:	4649      	mov	r1, r9
c0debfe4:	1809      	adds	r1, r1, r0
c0debfe6:	22ac      	movs	r2, #172	; 0xac
c0debfe8:	5c89      	ldrb	r1, [r1, r2]
c0debfea:	2722      	movs	r7, #34	; 0x22
c0debfec:	2900      	cmp	r1, #0
c0debfee:	d01c      	beq.n	c0dec02a <USBD_HID_GetReportDescriptor_impl+0x4e>
c0debff0:	2901      	cmp	r1, #1
c0debff2:	d11d      	bne.n	c0dec030 <USBD_HID_GetReportDescriptor_impl+0x54>
#ifdef HAVE_IO_U2F
  case U2F_INTF:

    // very dirty work due to lack of callback when USB_HID_Init is called
    USBD_LL_OpenEP(&USBD_Device,
c0debff4:	4649      	mov	r1, r9
c0debff6:	180d      	adds	r5, r1, r0
c0debff8:	2181      	movs	r1, #129	; 0x81
c0debffa:	2203      	movs	r2, #3
c0debffc:	9201      	str	r2, [sp, #4]
c0debffe:	2640      	movs	r6, #64	; 0x40
c0dec000:	4628      	mov	r0, r5
c0dec002:	9302      	str	r3, [sp, #8]
c0dec004:	4633      	mov	r3, r6
c0dec006:	f7ff faab 	bl	c0deb560 <USBD_LL_OpenEP>
c0dec00a:	2401      	movs	r4, #1
                   U2F_EPIN_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPIN_SIZE);
    
    USBD_LL_OpenEP(&USBD_Device,
c0dec00c:	4628      	mov	r0, r5
c0dec00e:	4621      	mov	r1, r4
c0dec010:	9a01      	ldr	r2, [sp, #4]
c0dec012:	4633      	mov	r3, r6
c0dec014:	f7ff faa4 	bl	c0deb560 <USBD_LL_OpenEP>
                   U2F_EPOUT_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPOUT_SIZE);

    /* Prepare Out endpoint to receive 1st packet */ 
    USBD_LL_PrepareReceive(&USBD_Device, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0dec018:	4628      	mov	r0, r5
c0dec01a:	4621      	mov	r1, r4
c0dec01c:	4632      	mov	r2, r6
c0dec01e:	f7ff fb4e 	bl	c0deb6be <USBD_LL_PrepareReceive>
c0dec022:	9b02      	ldr	r3, [sp, #8]
c0dec024:	4806      	ldr	r0, [pc, #24]	; (c0dec040 <USBD_HID_GetReportDescriptor_impl+0x64>)
c0dec026:	4478      	add	r0, pc
c0dec028:	e004      	b.n	c0dec034 <USBD_HID_GetReportDescriptor_impl+0x58>
c0dec02a:	4804      	ldr	r0, [pc, #16]	; (c0dec03c <USBD_HID_GetReportDescriptor_impl+0x60>)
c0dec02c:	4478      	add	r0, pc
c0dec02e:	e001      	b.n	c0dec034 <USBD_HID_GetReportDescriptor_impl+0x58>
c0dec030:	2700      	movs	r7, #0
c0dec032:	4638      	mov	r0, r7
c0dec034:	801f      	strh	r7, [r3, #0]
    return (uint8_t*)HID_ReportDesc_kbd;
#endif // HAVE_USB_HIDKBD
  }
  *len = 0;
  return 0;
}
c0dec036:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0dec038:	00000bf0 	.word	0x00000bf0
c0dec03c:	00004cf3 	.word	0x00004cf3
c0dec040:	00004cd7 	.word	0x00004cd7

c0dec044 <USBD_U2F_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_U2F_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0dec044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0dec046:	4604      	mov	r4, r0
c0dec048:	2181      	movs	r1, #129	; 0x81
c0dec04a:	2603      	movs	r6, #3
c0dec04c:	2540      	movs	r5, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0dec04e:	4632      	mov	r2, r6
c0dec050:	462b      	mov	r3, r5
c0dec052:	f7ff fa85 	bl	c0deb560 <USBD_LL_OpenEP>
c0dec056:	2701      	movs	r7, #1
                 U2F_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0dec058:	4620      	mov	r0, r4
c0dec05a:	4639      	mov	r1, r7
c0dec05c:	4632      	mov	r2, r6
c0dec05e:	462b      	mov	r3, r5
c0dec060:	f7ff fa7e 	bl	c0deb560 <USBD_LL_OpenEP>
                 U2F_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0dec064:	4620      	mov	r0, r4
c0dec066:	4639      	mov	r1, r7
c0dec068:	462a      	mov	r2, r5
c0dec06a:	f7ff fb28 	bl	c0deb6be <USBD_LL_PrepareReceive>
c0dec06e:	2000      	movs	r0, #0

  return USBD_OK;
c0dec070:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec072:	d4d4      	bmi.n	c0dec01e <USBD_HID_GetReportDescriptor_impl+0x42>

c0dec074 <USBD_U2F_DataIn_impl>:
}

uint8_t  USBD_U2F_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0dec074:	b580      	push	{r7, lr}
  UNUSED(pdev);
  // only the data hid endpoint will receive data
  switch (epnum) {
c0dec076:	2901      	cmp	r1, #1
c0dec078:	d105      	bne.n	c0dec086 <USBD_U2F_DataIn_impl+0x12>
  // FIDO endpoint
  case (U2F_EPIN_ADDR&0x7F):
    // advance the u2f sending machine state
    u2f_transport_sent(&G_io_u2f, U2F_MEDIA_USB);
c0dec07a:	4804      	ldr	r0, [pc, #16]	; (c0dec08c <USBD_U2F_DataIn_impl+0x18>)
c0dec07c:	4649      	mov	r1, r9
c0dec07e:	1808      	adds	r0, r1, r0
c0dec080:	2101      	movs	r1, #1
c0dec082:	f7fd fb5f 	bl	c0de9744 <u2f_transport_sent>
c0dec086:	2000      	movs	r0, #0
    break;
  } 
  return USBD_OK;
c0dec088:	bd80      	pop	{r7, pc}
c0dec08a:	46c0      	nop			; (mov r8, r8)
c0dec08c:	00000b10 	.word	0x00000b10

c0dec090 <USBD_U2F_DataOut_impl>:
}

uint8_t  USBD_U2F_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0dec090:	b5b0      	push	{r4, r5, r7, lr}
  switch (epnum) {
c0dec092:	2901      	cmp	r1, #1
c0dec094:	d110      	bne.n	c0dec0b8 <USBD_U2F_DataOut_impl+0x28>
c0dec096:	4614      	mov	r4, r2
c0dec098:	2501      	movs	r5, #1
c0dec09a:	2240      	movs	r2, #64	; 0x40
  // FIDO endpoint
  case (U2F_EPOUT_ADDR&0x7F):
      USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR , U2F_EPOUT_SIZE);
c0dec09c:	4629      	mov	r1, r5
c0dec09e:	f7ff fb0e 	bl	c0deb6be <USBD_LL_PrepareReceive>
      u2f_transport_received(&G_io_u2f, buffer, io_seproxyhal_get_ep_rx_size(U2F_EPOUT_ADDR), U2F_MEDIA_USB);
c0dec0a2:	4628      	mov	r0, r5
c0dec0a4:	f7fb fa0e 	bl	c0de74c4 <io_seproxyhal_get_ep_rx_size>
c0dec0a8:	4602      	mov	r2, r0
c0dec0aa:	4804      	ldr	r0, [pc, #16]	; (c0dec0bc <USBD_U2F_DataOut_impl+0x2c>)
c0dec0ac:	4649      	mov	r1, r9
c0dec0ae:	1808      	adds	r0, r1, r0
c0dec0b0:	4621      	mov	r1, r4
c0dec0b2:	462b      	mov	r3, r5
c0dec0b4:	f7fd fc7a 	bl	c0de99ac <u2f_transport_received>
c0dec0b8:	2000      	movs	r0, #0
    break;
  }

  return USBD_OK;
c0dec0ba:	bdb0      	pop	{r4, r5, r7, pc}
c0dec0bc:	00000b10 	.word	0x00000b10

c0dec0c0 <USBD_HID_DataIn_impl>:
}
#endif // HAVE_IO_U2F

uint8_t  USBD_HID_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0dec0c0:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0dec0c2:	2902      	cmp	r1, #2
c0dec0c4:	d103      	bne.n	c0dec0ce <USBD_HID_DataIn_impl+0xe>
    // HID gen endpoint
    case (HID_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data);
c0dec0c6:	4803      	ldr	r0, [pc, #12]	; (c0dec0d4 <USBD_HID_DataIn_impl+0x14>)
c0dec0c8:	4478      	add	r0, pc
c0dec0ca:	f7fb fe57 	bl	c0de7d7c <io_usb_hid_sent>
c0dec0ce:	2000      	movs	r0, #0
      break;
  }

  return USBD_OK;
c0dec0d0:	bd80      	pop	{r7, pc}
c0dec0d2:	46c0      	nop			; (mov r8, r8)
c0dec0d4:	ffffb4e1 	.word	0xffffb4e1

c0dec0d8 <USBD_HID_DataOut_impl>:
}

uint8_t  USBD_HID_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0dec0d8:	b5b0      	push	{r4, r5, r7, lr}
  // only the data hid endpoint will receive data
  switch (epnum) {
c0dec0da:	2902      	cmp	r1, #2
c0dec0dc:	d11e      	bne.n	c0dec11c <USBD_HID_DataOut_impl+0x44>
c0dec0de:	4614      	mov	r4, r2
c0dec0e0:	2102      	movs	r1, #2
c0dec0e2:	2240      	movs	r2, #64	; 0x40

  // HID gen endpoint
  case (HID_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR , HID_EPOUT_SIZE);
c0dec0e4:	f7ff faeb 	bl	c0deb6be <USBD_LL_PrepareReceive>

#ifndef HAVE_USB_HIDKBD
    // avoid troubles when an apdu has not been replied yet
    if (G_io_app.apdu_media == IO_APDU_MEDIA_NONE) {      
c0dec0e8:	4d0d      	ldr	r5, [pc, #52]	; (c0dec120 <USBD_HID_DataOut_impl+0x48>)
c0dec0ea:	4648      	mov	r0, r9
c0dec0ec:	1940      	adds	r0, r0, r5
c0dec0ee:	7980      	ldrb	r0, [r0, #6]
c0dec0f0:	2800      	cmp	r0, #0
c0dec0f2:	d113      	bne.n	c0dec11c <USBD_HID_DataOut_impl+0x44>
c0dec0f4:	2002      	movs	r0, #2
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data, buffer, io_seproxyhal_get_ep_rx_size(HID_EPOUT_ADDR))) {
c0dec0f6:	f7fb f9e5 	bl	c0de74c4 <io_seproxyhal_get_ep_rx_size>
c0dec0fa:	4602      	mov	r2, r0
c0dec0fc:	480a      	ldr	r0, [pc, #40]	; (c0dec128 <USBD_HID_DataOut_impl+0x50>)
c0dec0fe:	4478      	add	r0, pc
c0dec100:	4621      	mov	r1, r4
c0dec102:	f7fb fd65 	bl	c0de7bd0 <io_usb_hid_receive>
c0dec106:	2802      	cmp	r0, #2
c0dec108:	d108      	bne.n	c0dec11c <USBD_HID_DataOut_impl+0x44>
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
c0dec10a:	4648      	mov	r0, r9
c0dec10c:	2107      	movs	r1, #7
          G_io_app.apdu_state = APDU_USB_HID; // for next call to io_exchange
c0dec10e:	5541      	strb	r1, [r0, r5]
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
c0dec110:	1941      	adds	r1, r0, r5
c0dec112:	2201      	movs	r2, #1
c0dec114:	718a      	strb	r2, [r1, #6]
          G_io_app.apdu_length = G_io_usb_hid_total_length;
c0dec116:	4a03      	ldr	r2, [pc, #12]	; (c0dec124 <USBD_HID_DataOut_impl+0x4c>)
c0dec118:	5880      	ldr	r0, [r0, r2]
c0dec11a:	8048      	strh	r0, [r1, #2]
c0dec11c:	2000      	movs	r0, #0
    }
#endif // HAVE_USB_HIDKBD
    break;
  }

  return USBD_OK;
c0dec11e:	bdb0      	pop	{r4, r5, r7, pc}
c0dec120:	00000ae4 	.word	0x00000ae4
c0dec124:	00000b9c 	.word	0x00000b9c
c0dec128:	ffffb4ab 	.word	0xffffb4ab

c0dec12c <USBD_WEBUSB_Init>:

#ifdef HAVE_WEBUSB

uint8_t  USBD_WEBUSB_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0dec12c:	b570      	push	{r4, r5, r6, lr}
c0dec12e:	4604      	mov	r4, r0
c0dec130:	2183      	movs	r1, #131	; 0x83
c0dec132:	2503      	movs	r5, #3
c0dec134:	2640      	movs	r6, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0dec136:	462a      	mov	r2, r5
c0dec138:	4633      	mov	r3, r6
c0dec13a:	f7ff fa11 	bl	c0deb560 <USBD_LL_OpenEP>
                 WEBUSB_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0dec13e:	4620      	mov	r0, r4
c0dec140:	4629      	mov	r1, r5
c0dec142:	462a      	mov	r2, r5
c0dec144:	4633      	mov	r3, r6
c0dec146:	f7ff fa0b 	bl	c0deb560 <USBD_LL_OpenEP>
                 WEBUSB_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0dec14a:	4620      	mov	r0, r4
c0dec14c:	4629      	mov	r1, r5
c0dec14e:	4632      	mov	r2, r6
c0dec150:	f7ff fab5 	bl	c0deb6be <USBD_LL_PrepareReceive>
c0dec154:	2000      	movs	r0, #0

  return USBD_OK;
c0dec156:	bd70      	pop	{r4, r5, r6, pc}

c0dec158 <USBD_WEBUSB_DeInit>:
}

uint8_t  USBD_WEBUSB_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx) {
c0dec158:	2000      	movs	r0, #0
  UNUSED(pdev);
  UNUSED(cfgidx);
  return USBD_OK;
c0dec15a:	4770      	bx	lr

c0dec15c <USBD_WEBUSB_Setup>:
}

uint8_t  USBD_WEBUSB_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0dec15c:	2000      	movs	r0, #0
  UNUSED(pdev);
  UNUSED(req);
  return USBD_OK;
c0dec15e:	4770      	bx	lr

c0dec160 <USBD_WEBUSB_DataIn>:
}

uint8_t  USBD_WEBUSB_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0dec160:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0dec162:	2903      	cmp	r1, #3
c0dec164:	d103      	bne.n	c0dec16e <USBD_WEBUSB_DataIn+0xe>
    // HID gen endpoint
    case (WEBUSB_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data_ep0x83);
c0dec166:	4803      	ldr	r0, [pc, #12]	; (c0dec174 <USBD_WEBUSB_DataIn+0x14>)
c0dec168:	4478      	add	r0, pc
c0dec16a:	f7fb fe07 	bl	c0de7d7c <io_usb_hid_sent>
c0dec16e:	2000      	movs	r0, #0
      break;
  }
  return USBD_OK;
c0dec170:	bd80      	pop	{r7, pc}
c0dec172:	46c0      	nop			; (mov r8, r8)
c0dec174:	ffffb451 	.word	0xffffb451

c0dec178 <USBD_WEBUSB_DataOut>:
}

uint8_t USBD_WEBUSB_DataOut (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0dec178:	b5b0      	push	{r4, r5, r7, lr}
  // only the data hid endpoint will receive data
  switch (epnum) {
c0dec17a:	2903      	cmp	r1, #3
c0dec17c:	d11e      	bne.n	c0dec1bc <USBD_WEBUSB_DataOut+0x44>
c0dec17e:	4614      	mov	r4, r2
c0dec180:	2103      	movs	r1, #3
c0dec182:	2240      	movs	r2, #64	; 0x40

  // HID gen endpoint
  case (WEBUSB_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0dec184:	f7ff fa9b 	bl	c0deb6be <USBD_LL_PrepareReceive>

    // avoid troubles when an apdu has not been replied yet
    if (G_io_app.apdu_media == IO_APDU_MEDIA_NONE) {      
c0dec188:	4d0d      	ldr	r5, [pc, #52]	; (c0dec1c0 <USBD_WEBUSB_DataOut+0x48>)
c0dec18a:	4648      	mov	r0, r9
c0dec18c:	1940      	adds	r0, r0, r5
c0dec18e:	7980      	ldrb	r0, [r0, #6]
c0dec190:	2800      	cmp	r0, #0
c0dec192:	d113      	bne.n	c0dec1bc <USBD_WEBUSB_DataOut+0x44>
c0dec194:	2003      	movs	r0, #3
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data_ep0x83, buffer, io_seproxyhal_get_ep_rx_size(WEBUSB_EPOUT_ADDR))) {
c0dec196:	f7fb f995 	bl	c0de74c4 <io_seproxyhal_get_ep_rx_size>
c0dec19a:	4602      	mov	r2, r0
c0dec19c:	480a      	ldr	r0, [pc, #40]	; (c0dec1c8 <USBD_WEBUSB_DataOut+0x50>)
c0dec19e:	4478      	add	r0, pc
c0dec1a0:	4621      	mov	r1, r4
c0dec1a2:	f7fb fd15 	bl	c0de7bd0 <io_usb_hid_receive>
c0dec1a6:	2802      	cmp	r0, #2
c0dec1a8:	d108      	bne.n	c0dec1bc <USBD_WEBUSB_DataOut+0x44>
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
c0dec1aa:	4648      	mov	r0, r9
c0dec1ac:	210b      	movs	r1, #11
          G_io_app.apdu_state = APDU_USB_WEBUSB; // for next call to io_exchange
c0dec1ae:	5541      	strb	r1, [r0, r5]
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
c0dec1b0:	1941      	adds	r1, r0, r5
c0dec1b2:	2205      	movs	r2, #5
c0dec1b4:	718a      	strb	r2, [r1, #6]
          G_io_app.apdu_length = G_io_usb_hid_total_length;
c0dec1b6:	4a03      	ldr	r2, [pc, #12]	; (c0dec1c4 <USBD_WEBUSB_DataOut+0x4c>)
c0dec1b8:	5880      	ldr	r0, [r0, r2]
c0dec1ba:	8048      	strh	r0, [r1, #2]
c0dec1bc:	2000      	movs	r0, #0
      }
    }
    break;
  }

  return USBD_OK;
c0dec1be:	bdb0      	pop	{r4, r5, r7, pc}
c0dec1c0:	00000ae4 	.word	0x00000ae4
c0dec1c4:	00000b9c 	.word	0x00000b9c
c0dec1c8:	ffffb41b 	.word	0xffffb41b

c0dec1cc <USBD_DeviceDescriptor>:
{
c0dec1cc:	2012      	movs	r0, #18
  *length = sizeof(USBD_DeviceDesc);
c0dec1ce:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_DeviceDesc;
c0dec1d0:	4801      	ldr	r0, [pc, #4]	; (c0dec1d8 <USBD_DeviceDescriptor+0xc>)
c0dec1d2:	4478      	add	r0, pc
c0dec1d4:	4770      	bx	lr
c0dec1d6:	46c0      	nop			; (mov r8, r8)
c0dec1d8:	00004dca 	.word	0x00004dca

c0dec1dc <USBD_LangIDStrDescriptor>:
{
c0dec1dc:	2004      	movs	r0, #4
  *length = sizeof(USBD_LangIDDesc);  
c0dec1de:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_LangIDDesc;
c0dec1e0:	4801      	ldr	r0, [pc, #4]	; (c0dec1e8 <USBD_LangIDStrDescriptor+0xc>)
c0dec1e2:	4478      	add	r0, pc
c0dec1e4:	4770      	bx	lr
c0dec1e6:	46c0      	nop			; (mov r8, r8)
c0dec1e8:	00004dcc 	.word	0x00004dcc

c0dec1ec <USBD_ManufacturerStrDescriptor>:
{
c0dec1ec:	200e      	movs	r0, #14
  *length = sizeof(USBD_MANUFACTURER_STRING);
c0dec1ee:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_MANUFACTURER_STRING;
c0dec1f0:	4801      	ldr	r0, [pc, #4]	; (c0dec1f8 <USBD_ManufacturerStrDescriptor+0xc>)
c0dec1f2:	4478      	add	r0, pc
c0dec1f4:	4770      	bx	lr
c0dec1f6:	46c0      	nop			; (mov r8, r8)
c0dec1f8:	00004dc0 	.word	0x00004dc0

c0dec1fc <USBD_ProductStrDescriptor>:
{
c0dec1fc:	200e      	movs	r0, #14
  *length = sizeof(USBD_PRODUCT_FS_STRING);
c0dec1fe:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_PRODUCT_FS_STRING;
c0dec200:	4801      	ldr	r0, [pc, #4]	; (c0dec208 <USBD_ProductStrDescriptor+0xc>)
c0dec202:	4478      	add	r0, pc
c0dec204:	4770      	bx	lr
c0dec206:	46c0      	nop			; (mov r8, r8)
c0dec208:	00004dbe 	.word	0x00004dbe

c0dec20c <USBD_SerialStrDescriptor>:
{
c0dec20c:	200a      	movs	r0, #10
  *length = sizeof(USB_SERIAL_STRING);
c0dec20e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USB_SERIAL_STRING;
c0dec210:	4801      	ldr	r0, [pc, #4]	; (c0dec218 <USBD_SerialStrDescriptor+0xc>)
c0dec212:	4478      	add	r0, pc
c0dec214:	4770      	bx	lr
c0dec216:	46c0      	nop			; (mov r8, r8)
c0dec218:	00004dbc 	.word	0x00004dbc

c0dec21c <USBD_ConfigStrDescriptor>:
{
c0dec21c:	200e      	movs	r0, #14
  *length = sizeof(USBD_CONFIGURATION_FS_STRING);
c0dec21e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_CONFIGURATION_FS_STRING;
c0dec220:	4801      	ldr	r0, [pc, #4]	; (c0dec228 <USBD_ConfigStrDescriptor+0xc>)
c0dec222:	4478      	add	r0, pc
c0dec224:	4770      	bx	lr
c0dec226:	46c0      	nop			; (mov r8, r8)
c0dec228:	00004d9e 	.word	0x00004d9e

c0dec22c <USBD_InterfaceStrDescriptor>:
{
c0dec22c:	200e      	movs	r0, #14
  *length = sizeof(USBD_INTERFACE_FS_STRING);
c0dec22e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_INTERFACE_FS_STRING;
c0dec230:	4801      	ldr	r0, [pc, #4]	; (c0dec238 <USBD_InterfaceStrDescriptor+0xc>)
c0dec232:	4478      	add	r0, pc
c0dec234:	4770      	bx	lr
c0dec236:	46c0      	nop			; (mov r8, r8)
c0dec238:	00004d8e 	.word	0x00004d8e

c0dec23c <USBD_BOSDescriptor>:
};

#endif // HAVE_WEBUSB

static uint8_t *USBD_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
c0dec23c:	2039      	movs	r0, #57	; 0x39
  UNUSED(speed);
#ifdef HAVE_WEBUSB
  *length = sizeof(C_usb_bos);
c0dec23e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)C_usb_bos;
c0dec240:	4801      	ldr	r0, [pc, #4]	; (c0dec248 <USBD_BOSDescriptor+0xc>)
c0dec242:	4478      	add	r0, pc
c0dec244:	4770      	bx	lr
c0dec246:	46c0      	nop			; (mov r8, r8)
c0dec248:	00004aff 	.word	0x00004aff

c0dec24c <USBD_CtlError>:
  '4', 0x00, '6', 0x00, '7', 0x00, '6', 0x00, '5', 0x00, '7', 0x00,
  '2', 0x00, '}', 0x00, 0x00, 0x00, 0x00, 0x00 // propertyData, double unicode nul terminated
};

// upon unsupported request, check for webusb request
void USBD_CtlError( USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req) {
c0dec24c:	b580      	push	{r7, lr}
    USBD_CtlSendData (pdev, (unsigned char*)C_webusb_url_descriptor, MIN(req->wLength, sizeof(C_webusb_url_descriptor)));
  }
  else 
#endif // WEBUSB_URL_SIZE_B
    // SETUP (LE): 0x80 0x06 0x03 0x77 0x00 0x00 0xXX 0xXX
    if ((req->bmRequest & 0x80) 
c0dec24e:	780a      	ldrb	r2, [r1, #0]
c0dec250:	b252      	sxtb	r2, r2
    && req->bRequest == USB_REQ_GET_DESCRIPTOR 
c0dec252:	2a00      	cmp	r2, #0
c0dec254:	d402      	bmi.n	c0dec25c <USBD_CtlError+0x10>
      && req->bRequest == WINUSB_VENDOR_CODE
      && req->wIndex == MS_OS_20_DESCRIPTOR_INDEX) {
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_request_descriptor, MIN(req->wLength, sizeof(C_winusb_request_descriptor)));
  }
  else {
    USBD_CtlStall(pdev);
c0dec256:	f7ff fe39 	bl	c0debecc <USBD_CtlStall>
  }
}
c0dec25a:	bd80      	pop	{r7, pc}
    && req->bRequest == USB_REQ_GET_DESCRIPTOR 
c0dec25c:	784a      	ldrb	r2, [r1, #1]
    && (req->wValue>>8) == USB_DESC_TYPE_STRING 
c0dec25e:	2a77      	cmp	r2, #119	; 0x77
c0dec260:	d00c      	beq.n	c0dec27c <USBD_CtlError+0x30>
c0dec262:	2a06      	cmp	r2, #6
c0dec264:	d1f7      	bne.n	c0dec256 <USBD_CtlError+0xa>
c0dec266:	884a      	ldrh	r2, [r1, #2]
c0dec268:	4b14      	ldr	r3, [pc, #80]	; (c0dec2bc <USBD_CtlError+0x70>)
    && (req->wValue & 0xFF) == 0xEE) {
c0dec26a:	429a      	cmp	r2, r3
c0dec26c:	d1f3      	bne.n	c0dec256 <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_string_descriptor, MIN(req->wLength, sizeof(C_winusb_string_descriptor)));
c0dec26e:	88ca      	ldrh	r2, [r1, #6]
c0dec270:	2a12      	cmp	r2, #18
c0dec272:	d300      	bcc.n	c0dec276 <USBD_CtlError+0x2a>
c0dec274:	2212      	movs	r2, #18
c0dec276:	4912      	ldr	r1, [pc, #72]	; (c0dec2c0 <USBD_CtlError+0x74>)
c0dec278:	4479      	add	r1, pc
c0dec27a:	e01c      	b.n	c0dec2b6 <USBD_CtlError+0x6a>
    && req->wIndex == WINUSB_GET_COMPATIBLE_ID_FEATURE) {
c0dec27c:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80) 
c0dec27e:	2a04      	cmp	r2, #4
c0dec280:	d106      	bne.n	c0dec290 <USBD_CtlError+0x44>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_wcid, MIN(req->wLength, sizeof(C_winusb_wcid)));
c0dec282:	88ca      	ldrh	r2, [r1, #6]
c0dec284:	2a28      	cmp	r2, #40	; 0x28
c0dec286:	d300      	bcc.n	c0dec28a <USBD_CtlError+0x3e>
c0dec288:	2228      	movs	r2, #40	; 0x28
c0dec28a:	490e      	ldr	r1, [pc, #56]	; (c0dec2c4 <USBD_CtlError+0x78>)
c0dec28c:	4479      	add	r1, pc
c0dec28e:	e012      	b.n	c0dec2b6 <USBD_CtlError+0x6a>
    && req->wIndex == WINUSB_GET_EXTENDED_PROPERTIES_OS_FEATURE 
c0dec290:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80) 
c0dec292:	2a05      	cmp	r2, #5
c0dec294:	d106      	bne.n	c0dec2a4 <USBD_CtlError+0x58>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_guid, MIN(req->wLength, sizeof(C_winusb_guid)));
c0dec296:	88ca      	ldrh	r2, [r1, #6]
c0dec298:	2a92      	cmp	r2, #146	; 0x92
c0dec29a:	d300      	bcc.n	c0dec29e <USBD_CtlError+0x52>
c0dec29c:	2292      	movs	r2, #146	; 0x92
c0dec29e:	490a      	ldr	r1, [pc, #40]	; (c0dec2c8 <USBD_CtlError+0x7c>)
c0dec2a0:	4479      	add	r1, pc
c0dec2a2:	e008      	b.n	c0dec2b6 <USBD_CtlError+0x6a>
      && req->wIndex == MS_OS_20_DESCRIPTOR_INDEX) {
c0dec2a4:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80)
c0dec2a6:	2a07      	cmp	r2, #7
c0dec2a8:	d1d5      	bne.n	c0dec256 <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_request_descriptor, MIN(req->wLength, sizeof(C_winusb_request_descriptor)));
c0dec2aa:	88ca      	ldrh	r2, [r1, #6]
c0dec2ac:	2ab2      	cmp	r2, #178	; 0xb2
c0dec2ae:	d300      	bcc.n	c0dec2b2 <USBD_CtlError+0x66>
c0dec2b0:	22b2      	movs	r2, #178	; 0xb2
c0dec2b2:	4906      	ldr	r1, [pc, #24]	; (c0dec2cc <USBD_CtlError+0x80>)
c0dec2b4:	4479      	add	r1, pc
c0dec2b6:	f000 f86d 	bl	c0dec394 <USBD_CtlSendData>
}
c0dec2ba:	bd80      	pop	{r7, pc}
c0dec2bc:	000003ee 	.word	0x000003ee
c0dec2c0:	00004b24 	.word	0x00004b24
c0dec2c4:	00004d4c 	.word	0x00004d4c
c0dec2c8:	00004b0e 	.word	0x00004b0e
c0dec2cc:	00004b8c 	.word	0x00004b8c

c0dec2d0 <USB_power>:
  // nothing to do ?
  return 0;
}
#endif // HAVE_USB_CLASS_CCID

void USB_power(unsigned char enabled) {
c0dec2d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0dec2d2:	4604      	mov	r4, r0
  memset(&USBD_Device, 0, sizeof(USBD_Device));
c0dec2d4:	4d1e      	ldr	r5, [pc, #120]	; (c0dec350 <USB_power+0x80>)
c0dec2d6:	464e      	mov	r6, r9
c0dec2d8:	1970      	adds	r0, r6, r5
c0dec2da:	21d4      	movs	r1, #212	; 0xd4
c0dec2dc:	f001 fa9a 	bl	c0ded814 <__aeabi_memclr>

  // init timeouts and other global fields
  memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
c0dec2e0:	481c      	ldr	r0, [pc, #112]	; (c0dec354 <USB_power+0x84>)
c0dec2e2:	1830      	adds	r0, r6, r0
c0dec2e4:	2100      	movs	r1, #0
c0dec2e6:	60c1      	str	r1, [r0, #12]
  memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
c0dec2e8:	6101      	str	r1, [r0, #16]
c0dec2ea:	6141      	str	r1, [r0, #20]

  if (enabled) {
c0dec2ec:	2c00      	cmp	r4, #0
c0dec2ee:	d029      	beq.n	c0dec344 <USB_power+0x74>
    memset(&USBD_Device, 0, sizeof(USBD_Device));
c0dec2f0:	464e      	mov	r6, r9
c0dec2f2:	1974      	adds	r4, r6, r5
c0dec2f4:	21d4      	movs	r1, #212	; 0xd4
c0dec2f6:	4620      	mov	r0, r4
c0dec2f8:	f001 fa8c 	bl	c0ded814 <__aeabi_memclr>
    /* Init Device Library */
    USBD_Init(&USBD_Device, (USBD_DescriptorsTypeDef*)&HID_Desc, 0);
c0dec2fc:	4918      	ldr	r1, [pc, #96]	; (c0dec360 <USB_power+0x90>)
c0dec2fe:	4479      	add	r1, pc
c0dec300:	2500      	movs	r5, #0
c0dec302:	4620      	mov	r0, r4
c0dec304:	462a      	mov	r2, r5
c0dec306:	f7ff f9eb 	bl	c0deb6e0 <USBD_Init>
    
    /* Register the HID class */
    USBD_RegisterClassForInterface(HID_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_HID);
c0dec30a:	4a16      	ldr	r2, [pc, #88]	; (c0dec364 <USB_power+0x94>)
c0dec30c:	447a      	add	r2, pc
c0dec30e:	4f16      	ldr	r7, [pc, #88]	; (c0dec368 <USB_power+0x98>)
c0dec310:	447f      	add	r7, pc
c0dec312:	4628      	mov	r0, r5
c0dec314:	4621      	mov	r1, r4
c0dec316:	47b8      	blx	r7
c0dec318:	2001      	movs	r0, #1
#ifdef HAVE_IO_U2F
    USBD_RegisterClassForInterface(U2F_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_U2F);
c0dec31a:	4a14      	ldr	r2, [pc, #80]	; (c0dec36c <USB_power+0x9c>)
c0dec31c:	447a      	add	r2, pc
c0dec31e:	4621      	mov	r1, r4
c0dec320:	47b8      	blx	r7
    // initialize the U2F tunnel transport
    u2f_transport_init(&G_io_u2f, G_io_apdu_buffer, IO_APDU_BUFFER_SIZE);
c0dec322:	480d      	ldr	r0, [pc, #52]	; (c0dec358 <USB_power+0x88>)
c0dec324:	1830      	adds	r0, r6, r0
c0dec326:	490d      	ldr	r1, [pc, #52]	; (c0dec35c <USB_power+0x8c>)
c0dec328:	1871      	adds	r1, r6, r1
c0dec32a:	22ff      	movs	r2, #255	; 0xff
c0dec32c:	3252      	adds	r2, #82	; 0x52
c0dec32e:	f7fd f9fd 	bl	c0de972c <u2f_transport_init>
c0dec332:	2002      	movs	r0, #2
#ifdef HAVE_USB_CLASS_CCID
    USBD_RegisterClassForInterface(CCID_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_CCID);
#endif // HAVE_USB_CLASS_CCID

#ifdef HAVE_WEBUSB
    USBD_RegisterClassForInterface(WEBUSB_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_WEBUSB);
c0dec334:	4a0e      	ldr	r2, [pc, #56]	; (c0dec370 <USB_power+0xa0>)
c0dec336:	447a      	add	r2, pc
c0dec338:	4621      	mov	r1, r4
c0dec33a:	47b8      	blx	r7
#endif // HAVE_WEBUSB

    /* Start Device Process */
    USBD_Start(&USBD_Device);
c0dec33c:	4620      	mov	r0, r4
c0dec33e:	f7ff fa10 	bl	c0deb762 <USBD_Start>
  }
  else {
    USBD_DeInit(&USBD_Device);
  }
}
c0dec342:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBD_DeInit(&USBD_Device);
c0dec344:	4648      	mov	r0, r9
c0dec346:	1940      	adds	r0, r0, r5
c0dec348:	f7ff f9e2 	bl	c0deb710 <USBD_DeInit>
}
c0dec34c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec34e:	46c0      	nop			; (mov r8, r8)
c0dec350:	00000bf0 	.word	0x00000bf0
c0dec354:	00000ae4 	.word	0x00000ae4
c0dec358:	00000b10 	.word	0x00000b10
c0dec35c:	00000990 	.word	0x00000990
c0dec360:	00004a7e 	.word	0x00004a7e
c0dec364:	00004be8 	.word	0x00004be8
c0dec368:	fffff435 	.word	0xfffff435
c0dec36c:	00004c10 	.word	0x00004c10
c0dec370:	00004c2e 	.word	0x00004c2e

c0dec374 <USBD_GetCfgDesc_impl>:
{
c0dec374:	2160      	movs	r1, #96	; 0x60
  *length = sizeof (USBD_CfgDesc);
c0dec376:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_CfgDesc;
c0dec378:	4801      	ldr	r0, [pc, #4]	; (c0dec380 <USBD_GetCfgDesc_impl+0xc>)
c0dec37a:	4478      	add	r0, pc
c0dec37c:	4770      	bx	lr
c0dec37e:	46c0      	nop			; (mov r8, r8)
c0dec380:	00004c86 	.word	0x00004c86

c0dec384 <USBD_GetDeviceQualifierDesc_impl>:
{
c0dec384:	210a      	movs	r1, #10
  *length = sizeof (USBD_DeviceQualifierDesc);
c0dec386:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_DeviceQualifierDesc;
c0dec388:	4801      	ldr	r0, [pc, #4]	; (c0dec390 <USBD_GetDeviceQualifierDesc_impl+0xc>)
c0dec38a:	4478      	add	r0, pc
c0dec38c:	4770      	bx	lr
c0dec38e:	46c0      	nop			; (mov r8, r8)
c0dec390:	00004cd6 	.word	0x00004cd6

c0dec394 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
c0dec394:	b5b0      	push	{r4, r5, r7, lr}
c0dec396:	460c      	mov	r4, r1
c0dec398:	2194      	movs	r1, #148	; 0x94
c0dec39a:	2302      	movs	r3, #2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
c0dec39c:	5043      	str	r3, [r0, r1]
  pdev->ep_in[0].total_length = len;
c0dec39e:	6182      	str	r2, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
c0dec3a0:	61c2      	str	r2, [r0, #28]
c0dec3a2:	4601      	mov	r1, r0
c0dec3a4:	3194      	adds	r1, #148	; 0x94
  // store the continuation data if needed
  pdev->pData = pbuf;
c0dec3a6:	63cc      	str	r4, [r1, #60]	; 0x3c
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));  
c0dec3a8:	6a01      	ldr	r1, [r0, #32]
c0dec3aa:	4291      	cmp	r1, r2
c0dec3ac:	d800      	bhi.n	c0dec3b0 <USBD_CtlSendData+0x1c>
c0dec3ae:	460a      	mov	r2, r1
c0dec3b0:	b293      	uxth	r3, r2
c0dec3b2:	2500      	movs	r5, #0
c0dec3b4:	4629      	mov	r1, r5
c0dec3b6:	4622      	mov	r2, r4
c0dec3b8:	f7ff f96a 	bl	c0deb690 <USBD_LL_Transmit>
  
  return USBD_OK;
c0dec3bc:	4628      	mov	r0, r5
c0dec3be:	bdb0      	pop	{r4, r5, r7, pc}

c0dec3c0 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
c0dec3c0:	b5b0      	push	{r4, r5, r7, lr}
c0dec3c2:	460c      	mov	r4, r1
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));   
c0dec3c4:	6a01      	ldr	r1, [r0, #32]
c0dec3c6:	4291      	cmp	r1, r2
c0dec3c8:	d800      	bhi.n	c0dec3cc <USBD_CtlContinueSendData+0xc>
c0dec3ca:	460a      	mov	r2, r1
c0dec3cc:	b293      	uxth	r3, r2
c0dec3ce:	2500      	movs	r5, #0
c0dec3d0:	4629      	mov	r1, r5
c0dec3d2:	4622      	mov	r2, r4
c0dec3d4:	f7ff f95c 	bl	c0deb690 <USBD_LL_Transmit>
  return USBD_OK;
c0dec3d8:	4628      	mov	r0, r5
c0dec3da:	bdb0      	pop	{r4, r5, r7, pc}

c0dec3dc <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
c0dec3dc:	b510      	push	{r4, lr}
c0dec3de:	2400      	movs	r4, #0
  UNUSED(pbuf);
  USBD_LL_PrepareReceive (pdev,
c0dec3e0:	4621      	mov	r1, r4
c0dec3e2:	f7ff f96c 	bl	c0deb6be <USBD_LL_PrepareReceive>
                          0,                                            
                          len);
  return USBD_OK;
c0dec3e6:	4620      	mov	r0, r4
c0dec3e8:	bd10      	pop	{r4, pc}

c0dec3ea <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
c0dec3ea:	b510      	push	{r4, lr}
c0dec3ec:	2194      	movs	r1, #148	; 0x94
c0dec3ee:	2204      	movs	r2, #4

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
c0dec3f0:	5042      	str	r2, [r0, r1]
c0dec3f2:	2400      	movs	r4, #0
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
c0dec3f4:	4621      	mov	r1, r4
c0dec3f6:	4622      	mov	r2, r4
c0dec3f8:	4623      	mov	r3, r4
c0dec3fa:	f7ff f949 	bl	c0deb690 <USBD_LL_Transmit>
  
  return USBD_OK;
c0dec3fe:	4620      	mov	r0, r4
c0dec400:	bd10      	pop	{r4, pc}

c0dec402 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
c0dec402:	b510      	push	{r4, lr}
c0dec404:	2194      	movs	r1, #148	; 0x94
c0dec406:	2205      	movs	r2, #5
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
c0dec408:	5042      	str	r2, [r0, r1]
c0dec40a:	2400      	movs	r4, #0
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
c0dec40c:	4621      	mov	r1, r4
c0dec40e:	4622      	mov	r2, r4
c0dec410:	f7ff f955 	bl	c0deb6be <USBD_LL_PrepareReceive>
                    0,
                    0);  

  return USBD_OK;
c0dec414:	4620      	mov	r0, r4
c0dec416:	bd10      	pop	{r4, pc}

c0dec418 <array_hexstr>:
#include "utils.h"

static const unsigned char hex_digits[] =
    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

void array_hexstr(char *strbuf, const void *bin, unsigned int len) {
c0dec418:	b5b0      	push	{r4, r5, r7, lr}
c0dec41a:	4b0a      	ldr	r3, [pc, #40]	; (c0dec444 <array_hexstr+0x2c>)
c0dec41c:	447b      	add	r3, pc
    while (len--) {
c0dec41e:	2a00      	cmp	r2, #0
c0dec420:	d00c      	beq.n	c0dec43c <array_hexstr+0x24>
        *strbuf++ = hex_digits[((*((char *) bin)) >> 4) & 0xF];
c0dec422:	780c      	ldrb	r4, [r1, #0]
c0dec424:	0924      	lsrs	r4, r4, #4
c0dec426:	5d1c      	ldrb	r4, [r3, r4]
c0dec428:	7004      	strb	r4, [r0, #0]
        *strbuf++ = hex_digits[(*((char *) bin)) & 0xF];
c0dec42a:	780c      	ldrb	r4, [r1, #0]
c0dec42c:	250f      	movs	r5, #15
c0dec42e:	4025      	ands	r5, r4
c0dec430:	5d5c      	ldrb	r4, [r3, r5]
c0dec432:	7044      	strb	r4, [r0, #1]
        bin = (const void *) ((unsigned int) bin + 1);
c0dec434:	1c49      	adds	r1, r1, #1
        *strbuf++ = hex_digits[(*((char *) bin)) & 0xF];
c0dec436:	1c80      	adds	r0, r0, #2
    while (len--) {
c0dec438:	1e52      	subs	r2, r2, #1
c0dec43a:	e7f0      	b.n	c0dec41e <array_hexstr+0x6>
c0dec43c:	2100      	movs	r1, #0
    }
    *strbuf = 0;  // EOS
c0dec43e:	7001      	strb	r1, [r0, #0]
}
c0dec440:	bdb0      	pop	{r4, r5, r7, pc}
c0dec442:	46c0      	nop			; (mov r8, r8)
c0dec444:	00003955 	.word	0x00003955

c0dec448 <convertUint256BE>:

void convertUint256BE(uint8_t *data, uint32_t length, uint256_t *target) {
c0dec448:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dec44a:	b089      	sub	sp, #36	; 0x24
c0dec44c:	4614      	mov	r4, r2
c0dec44e:	460d      	mov	r5, r1
c0dec450:	4606      	mov	r6, r0
c0dec452:	af01      	add	r7, sp, #4
c0dec454:	2120      	movs	r1, #32
    uint8_t tmp[INT256_LENGTH];
    memset(tmp, 0, 32);
c0dec456:	4638      	mov	r0, r7
c0dec458:	f001 f9dc 	bl	c0ded814 <__aeabi_memclr>
    memmove(tmp + 32 - length, data, length);
c0dec45c:	1b78      	subs	r0, r7, r5
c0dec45e:	3020      	adds	r0, #32
c0dec460:	4631      	mov	r1, r6
c0dec462:	462a      	mov	r2, r5
c0dec464:	f001 f9dc 	bl	c0ded820 <__aeabi_memcpy>
    readu256BE(tmp, target);
c0dec468:	4638      	mov	r0, r7
c0dec46a:	4621      	mov	r1, r4
c0dec46c:	f7fe fb80 	bl	c0deab70 <readu256BE>
}
c0dec470:	b009      	add	sp, #36	; 0x24
c0dec472:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0dec474 <u64_from_BE>:
        }
    }
    return -1;
}

uint64_t u64_from_BE(uint8_t *in, uint8_t size) {
c0dec474:	b570      	push	{r4, r5, r6, lr}
c0dec476:	2400      	movs	r4, #0
c0dec478:	4623      	mov	r3, r4
c0dec47a:	4622      	mov	r2, r4
    uint8_t i = 0;
    uint64_t res = 0;

    while (i < size && i < sizeof(res)) {
c0dec47c:	428c      	cmp	r4, r1
c0dec47e:	d20a      	bcs.n	c0dec496 <u64_from_BE+0x22>
c0dec480:	2c07      	cmp	r4, #7
c0dec482:	d808      	bhi.n	c0dec496 <u64_from_BE+0x22>
        res <<= 8;
        res |= in[i];
c0dec484:	5d05      	ldrb	r5, [r0, r4]
        res <<= 8;
c0dec486:	021e      	lsls	r6, r3, #8
        res |= in[i];
c0dec488:	1975      	adds	r5, r6, r5
        res <<= 8;
c0dec48a:	0e1b      	lsrs	r3, r3, #24
c0dec48c:	0212      	lsls	r2, r2, #8
c0dec48e:	18d2      	adds	r2, r2, r3
        i++;
c0dec490:	1c64      	adds	r4, r4, #1
c0dec492:	462b      	mov	r3, r5
c0dec494:	e7f2      	b.n	c0dec47c <u64_from_BE+0x8>
    }

    return res;
c0dec496:	4618      	mov	r0, r3
c0dec498:	4611      	mov	r1, r2
c0dec49a:	bd70      	pop	{r4, r5, r6, pc}

c0dec49c <uint256_to_decimal>:
}

bool uint256_to_decimal(const uint8_t *value, size_t value_len, char *out, size_t out_len) {
c0dec49c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dec49e:	b08b      	sub	sp, #44	; 0x2c
c0dec4a0:	9201      	str	r2, [sp, #4]
    if (value_len > INT256_LENGTH) {
c0dec4a2:	2920      	cmp	r1, #32
c0dec4a4:	d815      	bhi.n	c0dec4d2 <uint256_to_decimal+0x36>
c0dec4a6:	460e      	mov	r6, r1
c0dec4a8:	4607      	mov	r7, r0
c0dec4aa:	9300      	str	r3, [sp, #0]
c0dec4ac:	ad03      	add	r5, sp, #12
c0dec4ae:	2120      	movs	r1, #32
        // value len is bigger than INT256_LENGTH ?!
        return false;
    }

    uint16_t n[16] = {0};
c0dec4b0:	4628      	mov	r0, r5
c0dec4b2:	f001 f9af 	bl	c0ded814 <__aeabi_memclr>
    // Copy and right-align the number
    memcpy((uint8_t *) n + INT256_LENGTH - value_len, value, value_len);
c0dec4b6:	1ba8      	subs	r0, r5, r6
c0dec4b8:	3020      	adds	r0, #32
c0dec4ba:	4639      	mov	r1, r7
c0dec4bc:	4632      	mov	r2, r6
c0dec4be:	f001 f9af 	bl	c0ded820 <__aeabi_memcpy>

    // Special case when value is 0
    if (allzeroes(n, INT256_LENGTH)) {
c0dec4c2:	4628      	mov	r0, r5
c0dec4c4:	f000 f84a 	bl	c0dec55c <allzeroes>
c0dec4c8:	2800      	cmp	r0, #0
c0dec4ca:	d004      	beq.n	c0dec4d6 <uint256_to_decimal+0x3a>
c0dec4cc:	9a00      	ldr	r2, [sp, #0]
        if (out_len < 2) {
c0dec4ce:	2a02      	cmp	r2, #2
c0dec4d0:	d22d      	bcs.n	c0dec52e <uint256_to_decimal+0x92>
c0dec4d2:	2000      	movs	r0, #0
c0dec4d4:	e03d      	b.n	c0dec552 <uint256_to_decimal+0xb6>
c0dec4d6:	2000      	movs	r0, #0
c0dec4d8:	9b00      	ldr	r3, [sp, #0]
        strlcpy(out, "0", out_len);
        return true;
    }

    uint16_t *p = n;
    for (int i = 0; i < 16; i++) {
c0dec4da:	2820      	cmp	r0, #32
c0dec4dc:	d005      	beq.n	c0dec4ea <uint256_to_decimal+0x4e>
c0dec4de:	a903      	add	r1, sp, #12
        n[i] = __builtin_bswap16(*p++);
c0dec4e0:	5a0a      	ldrh	r2, [r1, r0]
c0dec4e2:	ba52      	rev16	r2, r2
c0dec4e4:	520a      	strh	r2, [r1, r0]
    for (int i = 0; i < 16; i++) {
c0dec4e6:	1c80      	adds	r0, r0, #2
c0dec4e8:	e7f7      	b.n	c0dec4da <uint256_to_decimal+0x3e>
c0dec4ea:	461c      	mov	r4, r3
c0dec4ec:	a803      	add	r0, sp, #12
    }
    int pos = out_len;
    while (!allzeroes(n, sizeof(n))) {
c0dec4ee:	f000 f835 	bl	c0dec55c <allzeroes>
c0dec4f2:	2800      	cmp	r0, #0
c0dec4f4:	d121      	bne.n	c0dec53a <uint256_to_decimal+0x9e>
        if (pos == 0) {
c0dec4f6:	2c00      	cmp	r4, #0
c0dec4f8:	d0eb      	beq.n	c0dec4d2 <uint256_to_decimal+0x36>
c0dec4fa:	9402      	str	r4, [sp, #8]
c0dec4fc:	2400      	movs	r4, #0
c0dec4fe:	4620      	mov	r0, r4
            return false;
        }
        pos -= 1;
        unsigned int carry = 0;
        for (int i = 0; i < 16; i++) {
c0dec500:	2c20      	cmp	r4, #32
c0dec502:	d00d      	beq.n	c0dec520 <uint256_to_decimal+0x84>
c0dec504:	af03      	add	r7, sp, #12
            int rem = ((carry << 16) | n[i]) % 10;
c0dec506:	5b39      	ldrh	r1, [r7, r4]
c0dec508:	0400      	lsls	r0, r0, #16
c0dec50a:	1845      	adds	r5, r0, r1
c0dec50c:	260a      	movs	r6, #10
            n[i] = ((carry << 16) | n[i]) / 10;
c0dec50e:	4628      	mov	r0, r5
c0dec510:	4631      	mov	r1, r6
c0dec512:	f000 ff95 	bl	c0ded440 <__udivsi3>
c0dec516:	5338      	strh	r0, [r7, r4]
c0dec518:	4346      	muls	r6, r0
c0dec51a:	1ba8      	subs	r0, r5, r6
        for (int i = 0; i < 16; i++) {
c0dec51c:	1ca4      	adds	r4, r4, #2
c0dec51e:	e7ef      	b.n	c0dec500 <uint256_to_decimal+0x64>
c0dec520:	2130      	movs	r1, #48	; 0x30
            carry = rem;
        }
        out[pos] = '0' + carry;
c0dec522:	4308      	orrs	r0, r1
c0dec524:	9c02      	ldr	r4, [sp, #8]
        pos -= 1;
c0dec526:	1e64      	subs	r4, r4, #1
        out[pos] = '0' + carry;
c0dec528:	9901      	ldr	r1, [sp, #4]
c0dec52a:	5508      	strb	r0, [r1, r4]
c0dec52c:	e7de      	b.n	c0dec4ec <uint256_to_decimal+0x50>
        strlcpy(out, "0", out_len);
c0dec52e:	490a      	ldr	r1, [pc, #40]	; (c0dec558 <uint256_to_decimal+0xbc>)
c0dec530:	4479      	add	r1, pc
c0dec532:	9801      	ldr	r0, [sp, #4]
c0dec534:	f001 fb4e 	bl	c0dedbd4 <strlcpy>
c0dec538:	e00a      	b.n	c0dec550 <uint256_to_decimal+0xb4>
c0dec53a:	4622      	mov	r2, r4
c0dec53c:	9c01      	ldr	r4, [sp, #4]
    }
    memmove(out, out + pos, out_len - pos);
c0dec53e:	18a1      	adds	r1, r4, r2
c0dec540:	9800      	ldr	r0, [sp, #0]
c0dec542:	1a85      	subs	r5, r0, r2
c0dec544:	4620      	mov	r0, r4
c0dec546:	462a      	mov	r2, r5
c0dec548:	f001 f96e 	bl	c0ded828 <__aeabi_memmove>
c0dec54c:	2000      	movs	r0, #0
    out[out_len - pos] = 0;
c0dec54e:	5560      	strb	r0, [r4, r5]
c0dec550:	2001      	movs	r0, #1
    return true;
}
c0dec552:	b00b      	add	sp, #44	; 0x2c
c0dec554:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dec556:	46c0      	nop			; (mov r8, r8)
c0dec558:	00001b19 	.word	0x00001b19

c0dec55c <allzeroes>:
static __attribute__((no_instrument_function)) inline int allzeroes(void *buf, size_t n) {
c0dec55c:	2100      	movs	r1, #0
    for (size_t i = 0; i < n; ++i) {
c0dec55e:	2920      	cmp	r1, #32
c0dec560:	d005      	beq.n	c0dec56e <allzeroes+0x12>
        if (p[i]) {
c0dec562:	5c42      	ldrb	r2, [r0, r1]
    for (size_t i = 0; i < n; ++i) {
c0dec564:	1c49      	adds	r1, r1, #1
        if (p[i]) {
c0dec566:	2a00      	cmp	r2, #0
c0dec568:	d0f9      	beq.n	c0dec55e <allzeroes+0x2>
c0dec56a:	2000      	movs	r0, #0
}
c0dec56c:	4770      	bx	lr
c0dec56e:	2001      	movs	r0, #1
c0dec570:	4770      	bx	lr

c0dec572 <amountToString>:
void amountToString(const uint8_t *amount,
                    uint8_t amount_size,
                    uint8_t decimals,
                    const char *ticker,
                    char *out_buffer,
                    size_t out_buffer_size) {
c0dec572:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dec574:	b09d      	sub	sp, #116	; 0x74
c0dec576:	9303      	str	r3, [sp, #12]
c0dec578:	9202      	str	r2, [sp, #8]
c0dec57a:	460c      	mov	r4, r1
c0dec57c:	4606      	mov	r6, r0
c0dec57e:	af04      	add	r7, sp, #16
c0dec580:	2564      	movs	r5, #100	; 0x64
    char tmp_buffer[100] = {0};
c0dec582:	4638      	mov	r0, r7
c0dec584:	4629      	mov	r1, r5
c0dec586:	f001 f945 	bl	c0ded814 <__aeabi_memclr>

    if (uint256_to_decimal(amount, amount_size, tmp_buffer, sizeof(tmp_buffer)) == false) {
c0dec58a:	4630      	mov	r0, r6
c0dec58c:	4621      	mov	r1, r4
c0dec58e:	463a      	mov	r2, r7
c0dec590:	462b      	mov	r3, r5
c0dec592:	f7ff ff83 	bl	c0dec49c <uint256_to_decimal>
c0dec596:	2800      	cmp	r0, #0
c0dec598:	d026      	beq.n	c0dec5e8 <amountToString+0x76>
c0dec59a:	9d23      	ldr	r5, [sp, #140]	; 0x8c
c0dec59c:	9e22      	ldr	r6, [sp, #136]	; 0x88
c0dec59e:	af04      	add	r7, sp, #16
c0dec5a0:	2164      	movs	r1, #100	; 0x64
        THROW(EXCEPTION_OVERFLOW);
    }

    uint8_t amount_len = strnlen(tmp_buffer, sizeof(tmp_buffer));
c0dec5a2:	4638      	mov	r0, r7
c0dec5a4:	f001 fbba 	bl	c0dedd1c <strnlen>
c0dec5a8:	9001      	str	r0, [sp, #4]
c0dec5aa:	210c      	movs	r1, #12
    uint8_t ticker_len = strnlen(ticker, MAX_TICKER_LEN);
c0dec5ac:	9803      	ldr	r0, [sp, #12]
c0dec5ae:	f001 fbb5 	bl	c0dedd1c <strnlen>

    memcpy(out_buffer, ticker, MIN(out_buffer_size, ticker_len));
c0dec5b2:	b2c4      	uxtb	r4, r0
c0dec5b4:	42ac      	cmp	r4, r5
c0dec5b6:	462a      	mov	r2, r5
c0dec5b8:	d800      	bhi.n	c0dec5bc <amountToString+0x4a>
c0dec5ba:	4622      	mov	r2, r4
c0dec5bc:	4630      	mov	r0, r6
c0dec5be:	9903      	ldr	r1, [sp, #12]
c0dec5c0:	f001 f92e 	bl	c0ded820 <__aeabi_memcpy>

    if (adjustDecimals(tmp_buffer,
c0dec5c4:	9802      	ldr	r0, [sp, #8]
c0dec5c6:	9000      	str	r0, [sp, #0]
                       amount_len,
                       out_buffer + ticker_len,
c0dec5c8:	1932      	adds	r2, r6, r4
                       out_buffer_size - ticker_len - 1,
c0dec5ca:	43e0      	mvns	r0, r4
c0dec5cc:	1943      	adds	r3, r0, r5
                       amount_len,
c0dec5ce:	9801      	ldr	r0, [sp, #4]
c0dec5d0:	b2c1      	uxtb	r1, r0
    if (adjustDecimals(tmp_buffer,
c0dec5d2:	4638      	mov	r0, r7
c0dec5d4:	f7f8 f94c 	bl	c0de4870 <adjustDecimals>
c0dec5d8:	2800      	cmp	r0, #0
c0dec5da:	d005      	beq.n	c0dec5e8 <amountToString+0x76>
                       decimals) == false) {
        THROW(EXCEPTION_OVERFLOW);
    }

    out_buffer[out_buffer_size - 1] = '\0';
c0dec5dc:	19a8      	adds	r0, r5, r6
c0dec5de:	1e40      	subs	r0, r0, #1
c0dec5e0:	2100      	movs	r1, #0
c0dec5e2:	7001      	strb	r1, [r0, #0]
}
c0dec5e4:	b01d      	add	sp, #116	; 0x74
c0dec5e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dec5e8:	2007      	movs	r0, #7
c0dec5ea:	f7fa ff1c 	bl	c0de7426 <os_longjmp>

c0dec5ee <parse_swap_config>:

bool parse_swap_config(const uint8_t *config, uint8_t config_len, char *ticker, uint8_t *decimals) {
c0dec5ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0dec5f0:	4605      	mov	r5, r0
c0dec5f2:	2000      	movs	r0, #0
    uint8_t ticker_len, offset = 0;
    if (config_len == 0) {
c0dec5f4:	2900      	cmp	r1, #0
c0dec5f6:	d019      	beq.n	c0dec62c <parse_swap_config+0x3e>
c0dec5f8:	460e      	mov	r6, r1
        return false;
    }
    ticker_len = config[offset++];
c0dec5fa:	782c      	ldrb	r4, [r5, #0]
    if (ticker_len == 0 || ticker_len > MAX_TICKER_LEN - 2 || config_len - offset < ticker_len) {
c0dec5fc:	428c      	cmp	r4, r1
c0dec5fe:	d215      	bcs.n	c0dec62c <parse_swap_config+0x3e>
c0dec600:	1e61      	subs	r1, r4, #1
c0dec602:	2909      	cmp	r1, #9
c0dec604:	d812      	bhi.n	c0dec62c <parse_swap_config+0x3e>
c0dec606:	4617      	mov	r7, r2
        return false;
    }
    memcpy(ticker, config + offset, ticker_len);
c0dec608:	1c69      	adds	r1, r5, #1
c0dec60a:	4610      	mov	r0, r2
c0dec60c:	4622      	mov	r2, r4
c0dec60e:	9300      	str	r3, [sp, #0]
c0dec610:	f001 f906 	bl	c0ded820 <__aeabi_memcpy>
c0dec614:	9b00      	ldr	r3, [sp, #0]
    offset += ticker_len;
c0dec616:	1c61      	adds	r1, r4, #1
c0dec618:	2000      	movs	r0, #0
    ticker[ticker_len] = ' ';
    ticker[ticker_len + 1] = '\0';
c0dec61a:	5478      	strb	r0, [r7, r1]
c0dec61c:	2220      	movs	r2, #32
    ticker[ticker_len] = ' ';
c0dec61e:	553a      	strb	r2, [r7, r4]

    if (config_len - offset < 1) {
c0dec620:	b2c9      	uxtb	r1, r1
c0dec622:	42b1      	cmp	r1, r6
c0dec624:	d202      	bcs.n	c0dec62c <parse_swap_config+0x3e>
        return false;
    }
    *decimals = config[offset];
c0dec626:	5c68      	ldrb	r0, [r5, r1]
c0dec628:	7018      	strb	r0, [r3, #0]
c0dec62a:	2001      	movs	r0, #1
    return true;
}
c0dec62c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec62e:	d4d4      	bmi.n	c0dec5da <amountToString+0x68>

c0dec630 <ux_flow_is_first>:
	}
	return 1;
}

// to hide the left tick or not
unsigned int ux_flow_is_first(void) {
c0dec630:	b510      	push	{r4, lr}
  // no previous ?
  unsigned int top_stack_slot = G_ux.stack_count - 1;
  if (!ux_flow_check_valid() || G_ux.flow_stack[top_stack_slot].steps == NULL ||
c0dec632:	f000 f829 	bl	c0dec688 <ux_flow_check_valid>
c0dec636:	4601      	mov	r1, r0
c0dec638:	2001      	movs	r0, #1
c0dec63a:	2900      	cmp	r1, #0
c0dec63c:	d017      	beq.n	c0dec66e <ux_flow_is_first+0x3e>
  unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec63e:	4a11      	ldr	r2, [pc, #68]	; (c0dec684 <ux_flow_is_first+0x54>)
c0dec640:	4649      	mov	r1, r9
c0dec642:	188c      	adds	r4, r1, r2
c0dec644:	5c89      	ldrb	r1, [r1, r2]
c0dec646:	1e49      	subs	r1, r1, #1
c0dec648:	230c      	movs	r3, #12
  if (!ux_flow_check_valid() || G_ux.flow_stack[top_stack_slot].steps == NULL ||
c0dec64a:	434b      	muls	r3, r1
c0dec64c:	18e1      	adds	r1, r4, r3
c0dec64e:	6a09      	ldr	r1, [r1, #32]
c0dec650:	2900      	cmp	r1, #0
c0dec652:	d00c      	beq.n	c0dec66e <ux_flow_is_first+0x3e>
      (G_ux.flow_stack[top_stack_slot].index == 0 &&
c0dec654:	464c      	mov	r4, r9
c0dec656:	18a2      	adds	r2, r4, r2
c0dec658:	18d2      	adds	r2, r2, r3
c0dec65a:	8d13      	ldrh	r3, [r2, #40]	; 0x28
c0dec65c:	8c92      	ldrh	r2, [r2, #36]	; 0x24
c0dec65e:	2a00      	cmp	r2, #0
c0dec660:	d106      	bne.n	c0dec670 <ux_flow_is_first+0x40>
       G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].length - 1] != FLOW_LOOP)) {
c0dec662:	009c      	lsls	r4, r3, #2
c0dec664:	1864      	adds	r4, r4, r1
c0dec666:	1f24      	subs	r4, r4, #4
c0dec668:	6824      	ldr	r4, [r4, #0]
  if (!ux_flow_check_valid() || G_ux.flow_stack[top_stack_slot].steps == NULL ||
c0dec66a:	1ce4      	adds	r4, r4, #3
c0dec66c:	d000      	beq.n	c0dec670 <ux_flow_is_first+0x40>
    return 1;
  }

  // not the first, for sure
  return 0;
}
c0dec66e:	bd10      	pop	{r4, pc}
  if (G_ux.flow_stack[top_stack_slot].length > 0 &&
c0dec670:	429a      	cmp	r2, r3
c0dec672:	d205      	bcs.n	c0dec680 <ux_flow_is_first+0x50>
      G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index - 1] == FLOW_BARRIER) {
c0dec674:	0092      	lsls	r2, r2, #2
c0dec676:	1851      	adds	r1, r2, r1
c0dec678:	1f09      	subs	r1, r1, #4
c0dec67a:	6809      	ldr	r1, [r1, #0]
  if (G_ux.flow_stack[top_stack_slot].length > 0 &&
c0dec67c:	1c89      	adds	r1, r1, #2
c0dec67e:	d0f6      	beq.n	c0dec66e <ux_flow_is_first+0x3e>
c0dec680:	2000      	movs	r0, #0
}
c0dec682:	bd10      	pop	{r4, pc}
c0dec684:	00000330 	.word	0x00000330

c0dec688 <ux_flow_check_valid>:
	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec688:	4907      	ldr	r1, [pc, #28]	; (c0dec6a8 <ux_flow_check_valid+0x20>)
c0dec68a:	4648      	mov	r0, r9
c0dec68c:	5c40      	ldrb	r0, [r0, r1]
		|| G_ux.flow_stack[top_stack_slot].length == 0) {
c0dec68e:	2801      	cmp	r0, #1
c0dec690:	d901      	bls.n	c0dec696 <ux_flow_check_valid+0xe>
c0dec692:	2000      	movs	r0, #0
}
c0dec694:	4770      	bx	lr
		|| G_ux.flow_stack[top_stack_slot].length == 0) {
c0dec696:	464a      	mov	r2, r9
c0dec698:	1851      	adds	r1, r2, r1
c0dec69a:	220c      	movs	r2, #12
	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec69c:	4342      	muls	r2, r0
		|| G_ux.flow_stack[top_stack_slot].length == 0) {
c0dec69e:	1850      	adds	r0, r2, r1
c0dec6a0:	8b80      	ldrh	r0, [r0, #28]
c0dec6a2:	1e41      	subs	r1, r0, #1
c0dec6a4:	4188      	sbcs	r0, r1
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0dec6a6:	4770      	bx	lr
c0dec6a8:	00000330 	.word	0x00000330

c0dec6ac <ux_flow_is_last>:

unsigned int ux_flow_is_last(void){
c0dec6ac:	b5b0      	push	{r4, r5, r7, lr}
	// last ?
  	unsigned int top_stack_slot = G_ux.stack_count - 1;

	if (!ux_flow_check_valid()
c0dec6ae:	f7ff ffeb 	bl	c0dec688 <ux_flow_check_valid>
c0dec6b2:	4601      	mov	r1, r0
c0dec6b4:	2001      	movs	r0, #1
		|| G_ux.flow_stack[top_stack_slot].steps == NULL
c0dec6b6:	2900      	cmp	r1, #0
c0dec6b8:	d020      	beq.n	c0dec6fc <ux_flow_is_last+0x50>
  	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec6ba:	4a11      	ldr	r2, [pc, #68]	; (c0dec700 <ux_flow_is_last+0x54>)
c0dec6bc:	4649      	mov	r1, r9
c0dec6be:	188c      	adds	r4, r1, r2
c0dec6c0:	5c89      	ldrb	r1, [r1, r2]
c0dec6c2:	1e49      	subs	r1, r1, #1
c0dec6c4:	230c      	movs	r3, #12
		|| G_ux.flow_stack[top_stack_slot].steps == NULL
c0dec6c6:	434b      	muls	r3, r1
c0dec6c8:	18e1      	adds	r1, r4, r3
c0dec6ca:	6a09      	ldr	r1, [r1, #32]
		|| G_ux.flow_stack[top_stack_slot].length == 0
c0dec6cc:	2900      	cmp	r1, #0
c0dec6ce:	d015      	beq.n	c0dec6fc <ux_flow_is_last+0x50>
c0dec6d0:	464c      	mov	r4, r9
c0dec6d2:	18a4      	adds	r4, r4, r2
c0dec6d4:	18e4      	adds	r4, r4, r3
c0dec6d6:	8d24      	ldrh	r4, [r4, #40]	; 0x28
		|| G_ux.flow_stack[top_stack_slot].index >= G_ux.flow_stack[top_stack_slot].length -1) {
c0dec6d8:	2c00      	cmp	r4, #0
c0dec6da:	d00f      	beq.n	c0dec6fc <ux_flow_is_last+0x50>
c0dec6dc:	464d      	mov	r5, r9
c0dec6de:	18aa      	adds	r2, r5, r2
c0dec6e0:	18d2      	adds	r2, r2, r3
c0dec6e2:	8c92      	ldrh	r2, [r2, #36]	; 0x24
c0dec6e4:	1e63      	subs	r3, r4, #1
	if (!ux_flow_check_valid()
c0dec6e6:	4293      	cmp	r3, r2
c0dec6e8:	dd08      	ble.n	c0dec6fc <ux_flow_is_last+0x50>
		return 1;
	}

	// followed by a flow barrier ?
	if (G_ux.flow_stack[top_stack_slot].length > 0
		&& G_ux.flow_stack[top_stack_slot].index < G_ux.flow_stack[top_stack_slot].length - 2
c0dec6ea:	1ea3      	subs	r3, r4, #2
		&& G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index+1] == FLOW_BARRIER) {
c0dec6ec:	4293      	cmp	r3, r2
c0dec6ee:	dd04      	ble.n	c0dec6fa <ux_flow_is_last+0x4e>
c0dec6f0:	0092      	lsls	r2, r2, #2
c0dec6f2:	1851      	adds	r1, r2, r1
c0dec6f4:	6849      	ldr	r1, [r1, #4]
	if (G_ux.flow_stack[top_stack_slot].length > 0
c0dec6f6:	1c89      	adds	r1, r1, #2
c0dec6f8:	d000      	beq.n	c0dec6fc <ux_flow_is_last+0x50>
c0dec6fa:	2000      	movs	r0, #0
		return 1;
	}

	// is not last
	return 0;
}
c0dec6fc:	bdb0      	pop	{r4, r5, r7, pc}
c0dec6fe:	46c0      	nop			; (mov r8, r8)
c0dec700:	00000330 	.word	0x00000330

c0dec704 <ux_flow_direction>:

ux_flow_direction_t ux_flow_direction(void) {
  	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec704:	490b      	ldr	r1, [pc, #44]	; (c0dec734 <ux_flow_direction+0x30>)
c0dec706:	4648      	mov	r0, r9
c0dec708:	5c40      	ldrb	r0, [r0, r1]

	if (G_ux.stack_count) {
c0dec70a:	2800      	cmp	r0, #0
c0dec70c:	d00e      	beq.n	c0dec72c <ux_flow_direction+0x28>
		if (G_ux.flow_stack[top_stack_slot].index > G_ux.flow_stack[top_stack_slot].prev_index) {
c0dec70e:	464a      	mov	r2, r9
c0dec710:	1851      	adds	r1, r2, r1
c0dec712:	220c      	movs	r2, #12
  	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec714:	4342      	muls	r2, r0
		if (G_ux.flow_stack[top_stack_slot].index > G_ux.flow_stack[top_stack_slot].prev_index) {
c0dec716:	1851      	adds	r1, r2, r1
c0dec718:	8b48      	ldrh	r0, [r1, #26]
c0dec71a:	8b09      	ldrh	r1, [r1, #24]
c0dec71c:	4281      	cmp	r1, r0
c0dec71e:	d901      	bls.n	c0dec724 <ux_flow_direction+0x20>
c0dec720:	2001      	movs	r0, #1
c0dec722:	e004      	b.n	c0dec72e <ux_flow_direction+0x2a>
		return FLOW_DIRECTION_FORWARD;
		}
		else if (G_ux.flow_stack[top_stack_slot].index < G_ux.flow_stack[top_stack_slot].prev_index) {
c0dec724:	4281      	cmp	r1, r0
c0dec726:	d201      	bcs.n	c0dec72c <ux_flow_direction+0x28>
c0dec728:	20ff      	movs	r0, #255	; 0xff
c0dec72a:	e000      	b.n	c0dec72e <ux_flow_direction+0x2a>
c0dec72c:	2000      	movs	r0, #0
			return FLOW_DIRECTION_BACKWARD;
		}
	}
  return FLOW_DIRECTION_START;
}
c0dec72e:	b240      	sxtb	r0, r0
c0dec730:	4770      	bx	lr
c0dec732:	46c0      	nop			; (mov r8, r8)
c0dec734:	00000330 	.word	0x00000330

c0dec738 <ux_flow_next_internal>:
			           STEPSPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->validate_flow),
			           (const ux_flow_step_t*) PIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->params));
	}
}

static void ux_flow_next_internal(unsigned int display_step) {
c0dec738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0dec73a:	4604      	mov	r4, r0
  	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec73c:	4d1d      	ldr	r5, [pc, #116]	; (c0dec7b4 <ux_flow_next_internal+0x7c>)
c0dec73e:	4648      	mov	r0, r9
c0dec740:	5d46      	ldrb	r6, [r0, r5]

	// last reached already (need validation, not next)
	if (!ux_flow_check_valid()
c0dec742:	f7ff ffa1 	bl	c0dec688 <ux_flow_check_valid>
		|| G_ux.flow_stack[top_stack_slot].steps == NULL
c0dec746:	2800      	cmp	r0, #0
c0dec748:	d033      	beq.n	c0dec7b2 <ux_flow_next_internal+0x7a>
c0dec74a:	1e70      	subs	r0, r6, #1
c0dec74c:	210c      	movs	r1, #12
c0dec74e:	4341      	muls	r1, r0
c0dec750:	464a      	mov	r2, r9
c0dec752:	1952      	adds	r2, r2, r5
c0dec754:	1852      	adds	r2, r2, r1
c0dec756:	6a12      	ldr	r2, [r2, #32]
		|| G_ux.flow_stack[top_stack_slot].length <= 1
c0dec758:	2a00      	cmp	r2, #0
c0dec75a:	d02a      	beq.n	c0dec7b2 <ux_flow_next_internal+0x7a>
c0dec75c:	464b      	mov	r3, r9
c0dec75e:	195b      	adds	r3, r3, r5
c0dec760:	185b      	adds	r3, r3, r1
c0dec762:	8d1f      	ldrh	r7, [r3, #40]	; 0x28
		|| G_ux.flow_stack[top_stack_slot].index >= G_ux.flow_stack[top_stack_slot].length -1) {
c0dec764:	2f02      	cmp	r7, #2
c0dec766:	d324      	bcc.n	c0dec7b2 <ux_flow_next_internal+0x7a>
c0dec768:	464b      	mov	r3, r9
c0dec76a:	195b      	adds	r3, r3, r5
c0dec76c:	185e      	adds	r6, r3, r1
c0dec76e:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
c0dec770:	9400      	str	r4, [sp, #0]
c0dec772:	1e7c      	subs	r4, r7, #1
	if (!ux_flow_check_valid()
c0dec774:	429c      	cmp	r4, r3
c0dec776:	dd1c      	ble.n	c0dec7b2 <ux_flow_next_internal+0x7a>
c0dec778:	3624      	adds	r6, #36	; 0x24
		return;
	}

	// followed by a flow barrier ? => need validation instead of next
	if (G_ux.flow_stack[top_stack_slot].index <= G_ux.flow_stack[top_stack_slot].length - 2) {
c0dec77a:	1ebc      	subs	r4, r7, #2
c0dec77c:	429c      	cmp	r4, r3
c0dec77e:	db0d      	blt.n	c0dec79c <ux_flow_next_internal+0x64>
		if (G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index+1] == FLOW_BARRIER) {
c0dec780:	009c      	lsls	r4, r3, #2
c0dec782:	18a2      	adds	r2, r4, r2
c0dec784:	6852      	ldr	r2, [r2, #4]
c0dec786:	1c94      	adds	r4, r2, #2
c0dec788:	d013      	beq.n	c0dec7b2 <ux_flow_next_internal+0x7a>
c0dec78a:	1cd2      	adds	r2, r2, #3
c0dec78c:	d106      	bne.n	c0dec79c <ux_flow_next_internal+0x64>
c0dec78e:	2200      	movs	r2, #0
		}

		// followed by a flow barrier ? => need validation instead of next
		if (G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index+1] == FLOW_LOOP) {
			// display first step, fake direction as forward
			G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index = 0;
c0dec790:	8032      	strh	r2, [r6, #0]
c0dec792:	464b      	mov	r3, r9
c0dec794:	195b      	adds	r3, r3, r5
c0dec796:	1859      	adds	r1, r3, r1
c0dec798:	84ca      	strh	r2, [r1, #38]	; 0x26
c0dec79a:	e008      	b.n	c0dec7ae <ux_flow_next_internal+0x76>
		}
	}

	// advance flow pointer and display it (skip META STEPS)
	G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index;
	G_ux.flow_stack[top_stack_slot].index++;
c0dec79c:	1c5a      	adds	r2, r3, #1
c0dec79e:	8032      	strh	r2, [r6, #0]
	G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index;
c0dec7a0:	464a      	mov	r2, r9
c0dec7a2:	1952      	adds	r2, r2, r5
c0dec7a4:	1851      	adds	r1, r2, r1
c0dec7a6:	84cb      	strh	r3, [r1, #38]	; 0x26
	if (display_step) {
c0dec7a8:	9900      	ldr	r1, [sp, #0]
c0dec7aa:	2900      	cmp	r1, #0
c0dec7ac:	d001      	beq.n	c0dec7b2 <ux_flow_next_internal+0x7a>
c0dec7ae:	f000 f847 	bl	c0dec840 <ux_flow_engine_init_step>
		ux_flow_engine_init_step(top_stack_slot);
	}
}
c0dec7b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec7b4:	00000330 	.word	0x00000330

c0dec7b8 <ux_flow_next>:

void ux_flow_next_no_display(void) {
	ux_flow_next_internal(0);
}

void ux_flow_next(void) {
c0dec7b8:	b580      	push	{r7, lr}
c0dec7ba:	2001      	movs	r0, #1
	ux_flow_next_internal(1);
c0dec7bc:	f7ff ffbc 	bl	c0dec738 <ux_flow_next_internal>
}
c0dec7c0:	bd80      	pop	{r7, pc}
c0dec7c2:	d4d4      	bmi.n	c0dec76e <ux_flow_next_internal+0x36>

c0dec7c4 <ux_flow_prev>:

void ux_flow_prev(void) {
c0dec7c4:	b570      	push	{r4, r5, r6, lr}
	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec7c6:	4c1d      	ldr	r4, [pc, #116]	; (c0dec83c <ux_flow_prev+0x78>)
c0dec7c8:	4648      	mov	r0, r9
c0dec7ca:	5d05      	ldrb	r5, [r0, r4]

	// first reached already
	if (!ux_flow_check_valid()
c0dec7cc:	f7ff ff5c 	bl	c0dec688 <ux_flow_check_valid>
		|| G_ux.flow_stack[top_stack_slot].steps == NULL
c0dec7d0:	2800      	cmp	r0, #0
c0dec7d2:	d028      	beq.n	c0dec826 <ux_flow_prev+0x62>
c0dec7d4:	1e68      	subs	r0, r5, #1
c0dec7d6:	210c      	movs	r1, #12
c0dec7d8:	4341      	muls	r1, r0
c0dec7da:	464a      	mov	r2, r9
c0dec7dc:	1912      	adds	r2, r2, r4
c0dec7de:	1852      	adds	r2, r2, r1
c0dec7e0:	6a15      	ldr	r5, [r2, #32]
		|| G_ux.flow_stack[top_stack_slot].length <= 1
c0dec7e2:	2d00      	cmp	r5, #0
c0dec7e4:	d01f      	beq.n	c0dec826 <ux_flow_prev+0x62>
c0dec7e6:	464a      	mov	r2, r9
c0dec7e8:	1912      	adds	r2, r2, r4
c0dec7ea:	1852      	adds	r2, r2, r1
c0dec7ec:	8d12      	ldrh	r2, [r2, #40]	; 0x28
		|| (G_ux.flow_stack[top_stack_slot].index == 0
c0dec7ee:	2a02      	cmp	r2, #2
c0dec7f0:	d319      	bcc.n	c0dec826 <ux_flow_prev+0x62>
c0dec7f2:	464b      	mov	r3, r9
c0dec7f4:	191b      	adds	r3, r3, r4
c0dec7f6:	185b      	adds	r3, r3, r1
c0dec7f8:	8c9e      	ldrh	r6, [r3, #36]	; 0x24
c0dec7fa:	3324      	adds	r3, #36	; 0x24
			  && G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].length-1] != FLOW_LOOP)) {
c0dec7fc:	2e00      	cmp	r6, #0
c0dec7fe:	d00c      	beq.n	c0dec81a <ux_flow_prev+0x56>
		ux_flow_engine_init_step(top_stack_slot);
		return;
	}

	// previous item is a flow barrier ?
	if (G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index-1] == FLOW_BARRIER) {
c0dec800:	00b2      	lsls	r2, r6, #2
c0dec802:	1952      	adds	r2, r2, r5
c0dec804:	1f12      	subs	r2, r2, #4
c0dec806:	6812      	ldr	r2, [r2, #0]
c0dec808:	1c92      	adds	r2, r2, #2
c0dec80a:	d00c      	beq.n	c0dec826 <ux_flow_prev+0x62>
		return;
	}

	// advance flow pointer and display it (skip META STEPS)
	G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index;
	G_ux.flow_stack[top_stack_slot].index--;
c0dec80c:	1e72      	subs	r2, r6, #1
c0dec80e:	801a      	strh	r2, [r3, #0]
	G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index;
c0dec810:	464a      	mov	r2, r9
c0dec812:	1912      	adds	r2, r2, r4
c0dec814:	1851      	adds	r1, r2, r1
c0dec816:	84ce      	strh	r6, [r1, #38]	; 0x26
c0dec818:	e00d      	b.n	c0dec836 <ux_flow_prev+0x72>
			  && G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].length-1] != FLOW_LOOP)) {
c0dec81a:	0096      	lsls	r6, r2, #2
c0dec81c:	1975      	adds	r5, r6, r5
c0dec81e:	1f2d      	subs	r5, r5, #4
c0dec820:	682d      	ldr	r5, [r5, #0]
	if (!ux_flow_check_valid()
c0dec822:	1ced      	adds	r5, r5, #3
c0dec824:	d000      	beq.n	c0dec828 <ux_flow_prev+0x64>

	ux_flow_engine_init_step(top_stack_slot);
}
c0dec826:	bd70      	pop	{r4, r5, r6, pc}
		G_ux.flow_stack[top_stack_slot].index = G_ux.flow_stack[top_stack_slot].length-2;
c0dec828:	1e95      	subs	r5, r2, #2
c0dec82a:	801d      	strh	r5, [r3, #0]
		G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index+1;
c0dec82c:	464b      	mov	r3, r9
c0dec82e:	191b      	adds	r3, r3, r4
c0dec830:	1859      	adds	r1, r3, r1
c0dec832:	1e52      	subs	r2, r2, #1
c0dec834:	84ca      	strh	r2, [r1, #38]	; 0x26
c0dec836:	f000 f803 	bl	c0dec840 <ux_flow_engine_init_step>
}
c0dec83a:	bd70      	pop	{r4, r5, r6, pc}
c0dec83c:	00000330 	.word	0x00000330

c0dec840 <ux_flow_engine_init_step>:
static void ux_flow_engine_init_step(unsigned int stack_slot) {
c0dec840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0dec842:	4604      	mov	r4, r0
c0dec844:	200c      	movs	r0, #12
	if (G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] == FLOW_END_STEP) {
c0dec846:	4360      	muls	r0, r4
c0dec848:	4919      	ldr	r1, [pc, #100]	; (c0dec8b0 <ux_flow_engine_init_step+0x70>)
c0dec84a:	464a      	mov	r2, r9
c0dec84c:	1851      	adds	r1, r2, r1
c0dec84e:	180e      	adds	r6, r1, r0
c0dec850:	6a30      	ldr	r0, [r6, #32]
c0dec852:	8cb1      	ldrh	r1, [r6, #36]	; 0x24
c0dec854:	0089      	lsls	r1, r1, #2
c0dec856:	5840      	ldr	r0, [r0, r1]
c0dec858:	2103      	movs	r1, #3
c0dec85a:	43c9      	mvns	r1, r1
c0dec85c:	4288      	cmp	r0, r1
c0dec85e:	d826      	bhi.n	c0dec8ae <ux_flow_engine_init_step+0x6e>
c0dec860:	4637      	mov	r7, r6
c0dec862:	3724      	adds	r7, #36	; 0x24
c0dec864:	3620      	adds	r6, #32
	if (STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->init) {
c0dec866:	f7fb fced 	bl	c0de8244 <pic>
c0dec86a:	6831      	ldr	r1, [r6, #0]
c0dec86c:	883a      	ldrh	r2, [r7, #0]
c0dec86e:	0092      	lsls	r2, r2, #2
c0dec870:	5889      	ldr	r1, [r1, r2]
c0dec872:	6805      	ldr	r5, [r0, #0]
c0dec874:	4608      	mov	r0, r1
c0dec876:	f7fb fce5 	bl	c0de8244 <pic>
c0dec87a:	2d00      	cmp	r5, #0
c0dec87c:	d006      	beq.n	c0dec88c <ux_flow_engine_init_step+0x4c>
		INITPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->init)(stack_slot);
c0dec87e:	6800      	ldr	r0, [r0, #0]
c0dec880:	f7fb fce0 	bl	c0de8244 <pic>
c0dec884:	4601      	mov	r1, r0
c0dec886:	4620      	mov	r0, r4
c0dec888:	4788      	blx	r1
}
c0dec88a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			           STEPSPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->validate_flow),
c0dec88c:	6880      	ldr	r0, [r0, #8]
c0dec88e:	4d09      	ldr	r5, [pc, #36]	; (c0dec8b4 <ux_flow_engine_init_step+0x74>)
c0dec890:	447d      	add	r5, pc
c0dec892:	47a8      	blx	r5
c0dec894:	9000      	str	r0, [sp, #0]
			           (const ux_flow_step_t*) PIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->params));
c0dec896:	6830      	ldr	r0, [r6, #0]
c0dec898:	8839      	ldrh	r1, [r7, #0]
c0dec89a:	0089      	lsls	r1, r1, #2
c0dec89c:	5840      	ldr	r0, [r0, r1]
c0dec89e:	47a8      	blx	r5
c0dec8a0:	6840      	ldr	r0, [r0, #4]
c0dec8a2:	47a8      	blx	r5
c0dec8a4:	4602      	mov	r2, r0
		ux_flow_init(stack_slot,
c0dec8a6:	4620      	mov	r0, r4
c0dec8a8:	9900      	ldr	r1, [sp, #0]
c0dec8aa:	f000 f86b 	bl	c0dec984 <ux_flow_init>
}
c0dec8ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec8b0:	00000330 	.word	0x00000330
c0dec8b4:	ffffb9b1 	.word	0xffffb9b1

c0dec8b8 <ux_flow_validate>:

void ux_flow_validate(void) {
c0dec8b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0dec8ba:	4d31      	ldr	r5, [pc, #196]	; (c0dec980 <ux_flow_validate+0xc8>)
c0dec8bc:	4648      	mov	r0, r9
c0dec8be:	5d44      	ldrb	r4, [r0, r5]

	// no flow ?
	if (!ux_flow_check_valid()
c0dec8c0:	f7ff fee2 	bl	c0dec688 <ux_flow_check_valid>
	  || G_ux.flow_stack[top_stack_slot].steps == NULL
c0dec8c4:	2800      	cmp	r0, #0
c0dec8c6:	d05a      	beq.n	c0dec97e <ux_flow_validate+0xc6>
c0dec8c8:	1e63      	subs	r3, r4, #1
c0dec8ca:	260c      	movs	r6, #12
c0dec8cc:	435e      	muls	r6, r3
c0dec8ce:	4648      	mov	r0, r9
c0dec8d0:	1940      	adds	r0, r0, r5
c0dec8d2:	1984      	adds	r4, r0, r6
c0dec8d4:	6a20      	ldr	r0, [r4, #32]
		|| G_ux.flow_stack[top_stack_slot].length == 0
c0dec8d6:	2800      	cmp	r0, #0
c0dec8d8:	d051      	beq.n	c0dec97e <ux_flow_validate+0xc6>
c0dec8da:	4649      	mov	r1, r9
c0dec8dc:	1949      	adds	r1, r1, r5
c0dec8de:	198f      	adds	r7, r1, r6
c0dec8e0:	8d39      	ldrh	r1, [r7, #40]	; 0x28
		|| G_ux.flow_stack[top_stack_slot].index >= G_ux.flow_stack[top_stack_slot].length) {
c0dec8e2:	2900      	cmp	r1, #0
c0dec8e4:	d04b      	beq.n	c0dec97e <ux_flow_validate+0xc6>
c0dec8e6:	464a      	mov	r2, r9
c0dec8e8:	1952      	adds	r2, r2, r5
c0dec8ea:	1995      	adds	r5, r2, r6
c0dec8ec:	8caa      	ldrh	r2, [r5, #36]	; 0x24
	if (!ux_flow_check_valid()
c0dec8ee:	428a      	cmp	r2, r1
c0dec8f0:	d245      	bcs.n	c0dec97e <ux_flow_validate+0xc6>
c0dec8f2:	9300      	str	r3, [sp, #0]
c0dec8f4:	3420      	adds	r4, #32
c0dec8f6:	3524      	adds	r5, #36	; 0x24
		return;
	}

	// no validation flow ?
	if (STEPPIC(G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index])->validate_flow != NULL) {
c0dec8f8:	0091      	lsls	r1, r2, #2
c0dec8fa:	5840      	ldr	r0, [r0, r1]
c0dec8fc:	f7fb fca2 	bl	c0de8244 <pic>
c0dec900:	6880      	ldr	r0, [r0, #8]
c0dec902:	2800      	cmp	r0, #0
c0dec904:	d00e      	beq.n	c0dec924 <ux_flow_validate+0x6c>
		// execute validation flow
		ux_flow_init(top_stack_slot, STEPSPIC(STEPPIC(G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index])->validate_flow), NULL);
c0dec906:	6820      	ldr	r0, [r4, #0]
c0dec908:	8829      	ldrh	r1, [r5, #0]
c0dec90a:	0089      	lsls	r1, r1, #2
c0dec90c:	5840      	ldr	r0, [r0, r1]
c0dec90e:	f7fb fc99 	bl	c0de8244 <pic>
c0dec912:	6880      	ldr	r0, [r0, #8]
c0dec914:	f7fb fc96 	bl	c0de8244 <pic>
c0dec918:	4601      	mov	r1, r0
c0dec91a:	2200      	movs	r2, #0
c0dec91c:	9800      	ldr	r0, [sp, #0]
c0dec91e:	f000 f831 	bl	c0dec984 <ux_flow_init>
				// execute reached step
				ux_flow_engine_init_step(top_stack_slot);
			}
		}
	}
}
c0dec922:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec924:	3728      	adds	r7, #40	; 0x28
		if (G_ux.flow_stack[top_stack_slot].length > 0
c0dec926:	8838      	ldrh	r0, [r7, #0]
			&& G_ux.flow_stack[top_stack_slot].index <= G_ux.flow_stack[top_stack_slot].length - 2) {
c0dec928:	2800      	cmp	r0, #0
c0dec92a:	d028      	beq.n	c0dec97e <ux_flow_validate+0xc6>
c0dec92c:	1e81      	subs	r1, r0, #2
c0dec92e:	8828      	ldrh	r0, [r5, #0]
		if (G_ux.flow_stack[top_stack_slot].length > 0
c0dec930:	4281      	cmp	r1, r0
c0dec932:	db24      	blt.n	c0dec97e <ux_flow_validate+0xc6>
			if (G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index+1] == FLOW_BARRIER) {
c0dec934:	6822      	ldr	r2, [r4, #0]
c0dec936:	0083      	lsls	r3, r0, #2
c0dec938:	189b      	adds	r3, r3, r2
c0dec93a:	685b      	ldr	r3, [r3, #4]
c0dec93c:	1cdc      	adds	r4, r3, #3
c0dec93e:	d00f      	beq.n	c0dec960 <ux_flow_validate+0xa8>
c0dec940:	1c9b      	adds	r3, r3, #2
c0dec942:	4b0f      	ldr	r3, [pc, #60]	; (c0dec980 <ux_flow_validate+0xc8>)
c0dec944:	d11b      	bne.n	c0dec97e <ux_flow_validate+0xc6>
c0dec946:	462c      	mov	r4, r5
c0dec948:	461d      	mov	r5, r3
					&& G_ux.flow_stack[top_stack_slot].index <= G_ux.flow_stack[top_stack_slot].length - 2
c0dec94a:	b283      	uxth	r3, r0
					&& G_ux.flow_stack[top_stack_slot].steps[G_ux.flow_stack[top_stack_slot].index+1] == FLOW_BARRIER) {
c0dec94c:	4299      	cmp	r1, r3
c0dec94e:	db0d      	blt.n	c0dec96c <ux_flow_validate+0xb4>
c0dec950:	009b      	lsls	r3, r3, #2
c0dec952:	189b      	adds	r3, r3, r2
c0dec954:	685b      	ldr	r3, [r3, #4]
				while (G_ux.flow_stack[top_stack_slot].length > 0
c0dec956:	1c9b      	adds	r3, r3, #2
c0dec958:	d108      	bne.n	c0dec96c <ux_flow_validate+0xb4>
					G_ux.flow_stack[top_stack_slot].index++;
c0dec95a:	1c40      	adds	r0, r0, #1
c0dec95c:	8020      	strh	r0, [r4, #0]
c0dec95e:	e7f4      	b.n	c0dec94a <ux_flow_validate+0x92>
c0dec960:	2000      	movs	r0, #0
				G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index = 0;
c0dec962:	8028      	strh	r0, [r5, #0]
c0dec964:	4649      	mov	r1, r9
c0dec966:	4a06      	ldr	r2, [pc, #24]	; (c0dec980 <ux_flow_validate+0xc8>)
c0dec968:	1889      	adds	r1, r1, r2
c0dec96a:	e003      	b.n	c0dec974 <ux_flow_validate+0xbc>
				G_ux.flow_stack[top_stack_slot].index++;
c0dec96c:	1c41      	adds	r1, r0, #1
c0dec96e:	8021      	strh	r1, [r4, #0]
				G_ux.flow_stack[top_stack_slot].prev_index = G_ux.flow_stack[top_stack_slot].index;
c0dec970:	4649      	mov	r1, r9
c0dec972:	1949      	adds	r1, r1, r5
c0dec974:	1989      	adds	r1, r1, r6
c0dec976:	84c8      	strh	r0, [r1, #38]	; 0x26
c0dec978:	9800      	ldr	r0, [sp, #0]
c0dec97a:	f7ff ff61 	bl	c0dec840 <ux_flow_engine_init_step>
}
c0dec97e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec980:	00000330 	.word	0x00000330

c0dec984 <ux_flow_init>:
}

/**
 * Last step is marked with a FLOW_END_STEP value
 */
void ux_flow_init(unsigned int stack_slot, const ux_flow_step_t* const * steps, const ux_flow_step_t* const start_step) {
c0dec984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (stack_slot >= UX_STACK_SLOT_COUNT) {
c0dec986:	2800      	cmp	r0, #0
c0dec988:	d000      	beq.n	c0dec98c <ux_flow_init+0x8>
		}

		// init step
		ux_flow_engine_init_step(stack_slot);
	}
}
c0dec98a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0dec98c:	4614      	mov	r4, r2
c0dec98e:	460d      	mov	r5, r1
	G_ux.flow_stack[stack_slot].steps = NULL;
c0dec990:	4e1c      	ldr	r6, [pc, #112]	; (c0deca04 <ux_flow_init+0x80>)
c0dec992:	4648      	mov	r0, r9
c0dec994:	1980      	adds	r0, r0, r6
c0dec996:	3008      	adds	r0, #8
c0dec998:	2122      	movs	r1, #34	; 0x22
c0dec99a:	f000 ff3b 	bl	c0ded814 <__aeabi_memclr>
	if (steps) {
c0dec99e:	2d00      	cmp	r5, #0
c0dec9a0:	d0f3      	beq.n	c0dec98a <ux_flow_init+0x6>
		G_ux.flow_stack[stack_slot].steps = STEPSPIC(steps);
c0dec9a2:	4648      	mov	r0, r9
c0dec9a4:	1987      	adds	r7, r0, r6
c0dec9a6:	4628      	mov	r0, r5
c0dec9a8:	f7fb fc4c 	bl	c0de8244 <pic>
c0dec9ac:	6238      	str	r0, [r7, #32]
		while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].length] != FLOW_END_STEP) {
c0dec9ae:	8d39      	ldrh	r1, [r7, #40]	; 0x28
c0dec9b0:	b28a      	uxth	r2, r1
c0dec9b2:	0092      	lsls	r2, r2, #2
c0dec9b4:	5882      	ldr	r2, [r0, r2]
c0dec9b6:	1c52      	adds	r2, r2, #1
c0dec9b8:	d004      	beq.n	c0dec9c4 <ux_flow_init+0x40>
			G_ux.flow_stack[stack_slot].length++;
c0dec9ba:	464a      	mov	r2, r9
c0dec9bc:	1992      	adds	r2, r2, r6
c0dec9be:	1c49      	adds	r1, r1, #1
c0dec9c0:	8511      	strh	r1, [r2, #40]	; 0x28
c0dec9c2:	e7f5      	b.n	c0dec9b0 <ux_flow_init+0x2c>
		if (start_step != NULL) {
c0dec9c4:	2c00      	cmp	r4, #0
c0dec9c6:	d019      	beq.n	c0dec9fc <ux_flow_init+0x78>
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0dec9c8:	4648      	mov	r0, r9
c0dec9ca:	1985      	adds	r5, r0, r6
			const ux_flow_step_t* const start_step2  = STEPPIC(start_step);
c0dec9cc:	4620      	mov	r0, r4
c0dec9ce:	f7fb fc39 	bl	c0de8244 <pic>
c0dec9d2:	4604      	mov	r4, r0
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0dec9d4:	8ca8      	ldrh	r0, [r5, #36]	; 0x24
c0dec9d6:	4649      	mov	r1, r9
c0dec9d8:	1989      	adds	r1, r1, r6
c0dec9da:	6a09      	ldr	r1, [r1, #32]
c0dec9dc:	b280      	uxth	r0, r0
c0dec9de:	0080      	lsls	r0, r0, #2
c0dec9e0:	5808      	ldr	r0, [r1, r0]
				 && STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index]) != start_step2) {
c0dec9e2:	1c41      	adds	r1, r0, #1
c0dec9e4:	d00a      	beq.n	c0dec9fc <ux_flow_init+0x78>
c0dec9e6:	f7fb fc2d 	bl	c0de8244 <pic>
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0dec9ea:	42a0      	cmp	r0, r4
c0dec9ec:	d006      	beq.n	c0dec9fc <ux_flow_init+0x78>
				G_ux.flow_stack[stack_slot].prev_index = G_ux.flow_stack[stack_slot].index;
c0dec9ee:	4648      	mov	r0, r9
c0dec9f0:	1981      	adds	r1, r0, r6
c0dec9f2:	8c88      	ldrh	r0, [r1, #36]	; 0x24
c0dec9f4:	84c8      	strh	r0, [r1, #38]	; 0x26
				G_ux.flow_stack[stack_slot].index++;
c0dec9f6:	1c40      	adds	r0, r0, #1
c0dec9f8:	8488      	strh	r0, [r1, #36]	; 0x24
c0dec9fa:	e7ec      	b.n	c0dec9d6 <ux_flow_init+0x52>
c0dec9fc:	2000      	movs	r0, #0
		ux_flow_engine_init_step(stack_slot);
c0dec9fe:	f7ff ff1f 	bl	c0dec840 <ux_flow_engine_init_step>
}
c0deca02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0deca04:	00000330 	.word	0x00000330

c0deca08 <ux_flow_button_callback>:
  if (stack_slot < UX_STACK_SLOT_COUNT) {
    memset(&G_ux.flow_stack[stack_slot], 0, sizeof(G_ux.flow_stack[stack_slot]));
  }
}

unsigned int ux_flow_button_callback(unsigned int button_mask, unsigned int button_mask_counter) {
c0deca08:	b580      	push	{r7, lr}
c0deca0a:	4909      	ldr	r1, [pc, #36]	; (c0deca30 <ux_flow_button_callback+0x28>)
  UNUSED(button_mask_counter);
  switch(button_mask) {
c0deca0c:	4288      	cmp	r0, r1
c0deca0e:	d008      	beq.n	c0deca22 <ux_flow_button_callback+0x1a>
c0deca10:	4908      	ldr	r1, [pc, #32]	; (c0deca34 <ux_flow_button_callback+0x2c>)
c0deca12:	4288      	cmp	r0, r1
c0deca14:	d008      	beq.n	c0deca28 <ux_flow_button_callback+0x20>
c0deca16:	4908      	ldr	r1, [pc, #32]	; (c0deca38 <ux_flow_button_callback+0x30>)
c0deca18:	4288      	cmp	r0, r1
c0deca1a:	d107      	bne.n	c0deca2c <ux_flow_button_callback+0x24>
    case BUTTON_EVT_RELEASED|BUTTON_LEFT:
      ux_flow_prev();
c0deca1c:	f7ff fed2 	bl	c0dec7c4 <ux_flow_prev>
c0deca20:	e004      	b.n	c0deca2c <ux_flow_button_callback+0x24>
      break;
    case BUTTON_EVT_RELEASED|BUTTON_RIGHT:
      ux_flow_next();
      break;
    case BUTTON_EVT_RELEASED|BUTTON_LEFT|BUTTON_RIGHT:
      ux_flow_validate();
c0deca22:	f7ff ff49 	bl	c0dec8b8 <ux_flow_validate>
c0deca26:	e001      	b.n	c0deca2c <ux_flow_button_callback+0x24>
      ux_flow_next();
c0deca28:	f7ff fec6 	bl	c0dec7b8 <ux_flow_next>
c0deca2c:	2000      	movs	r0, #0
      break;
  }
  return 0;
c0deca2e:	bd80      	pop	{r7, pc}
c0deca30:	80000003 	.word	0x80000003
c0deca34:	80000002 	.word	0x80000002
c0deca38:	80000001 	.word	0x80000001

c0deca3c <ux_stack_get_step_params>:
}

void* ux_stack_get_step_params(unsigned int stack_slot) {
c0deca3c:	b5b0      	push	{r4, r5, r7, lr}
c0deca3e:	4601      	mov	r1, r0
c0deca40:	2000      	movs	r0, #0
	if (stack_slot >= UX_STACK_SLOT_COUNT) {
c0deca42:	2900      	cmp	r1, #0
c0deca44:	d000      	beq.n	c0deca48 <ux_stack_get_step_params+0xc>
	if (G_ux.flow_stack[stack_slot].index >= G_ux.flow_stack[stack_slot].length) {
		return NULL;
	}

	return (void*)PIC(STEPPIC(STEPSPIC(G_ux.flow_stack[stack_slot].steps)[G_ux.flow_stack[stack_slot].index])->params);
}
c0deca46:	bdb0      	pop	{r4, r5, r7, pc}
	if (G_ux.flow_stack[stack_slot].length == 0) {
c0deca48:	4909      	ldr	r1, [pc, #36]	; (c0deca70 <ux_stack_get_step_params+0x34>)
c0deca4a:	464a      	mov	r2, r9
c0deca4c:	1852      	adds	r2, r2, r1
c0deca4e:	8d13      	ldrh	r3, [r2, #40]	; 0x28
	if (G_ux.flow_stack[stack_slot].index >= G_ux.flow_stack[stack_slot].length) {
c0deca50:	8c92      	ldrh	r2, [r2, #36]	; 0x24
	if (G_ux.flow_stack[stack_slot].length == 0) {
c0deca52:	429a      	cmp	r2, r3
c0deca54:	d2f7      	bcs.n	c0deca46 <ux_stack_get_step_params+0xa>
	return (void*)PIC(STEPPIC(STEPSPIC(G_ux.flow_stack[stack_slot].steps)[G_ux.flow_stack[stack_slot].index])->params);
c0deca56:	4648      	mov	r0, r9
c0deca58:	1844      	adds	r4, r0, r1
c0deca5a:	6a20      	ldr	r0, [r4, #32]
c0deca5c:	4d05      	ldr	r5, [pc, #20]	; (c0deca74 <ux_stack_get_step_params+0x38>)
c0deca5e:	447d      	add	r5, pc
c0deca60:	47a8      	blx	r5
c0deca62:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
c0deca64:	0089      	lsls	r1, r1, #2
c0deca66:	5840      	ldr	r0, [r0, r1]
c0deca68:	47a8      	blx	r5
c0deca6a:	6840      	ldr	r0, [r0, #4]
c0deca6c:	47a8      	blx	r5
}
c0deca6e:	bdb0      	pop	{r4, r5, r7, pc}
c0deca70:	00000330 	.word	0x00000330
c0deca74:	ffffb7e3 	.word	0xffffb7e3

c0deca78 <ux_stack_get_current_step_params>:

void* ux_stack_get_current_step_params(void) {
c0deca78:	b580      	push	{r7, lr}
	unsigned int top_stack_slot = G_ux.stack_count - 1;
c0deca7a:	4803      	ldr	r0, [pc, #12]	; (c0deca88 <ux_stack_get_current_step_params+0x10>)
c0deca7c:	4649      	mov	r1, r9
c0deca7e:	5c08      	ldrb	r0, [r1, r0]
c0deca80:	1e40      	subs	r0, r0, #1

	return ux_stack_get_step_params(top_stack_slot);
c0deca82:	f7ff ffdb 	bl	c0deca3c <ux_stack_get_step_params>
c0deca86:	bd80      	pop	{r7, pc}
c0deca88:	00000330 	.word	0x00000330

c0deca8c <ux_layout_bb_init_common>:
#else
  #error "BAGL_WIDTH/BAGL_HEIGHT not defined"
#endif
};

void ux_layout_bb_init_common(unsigned int stack_slot) {
c0deca8c:	b510      	push	{r4, lr}
c0deca8e:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0deca90:	f000 fc4c 	bl	c0ded32c <ux_stack_init>
c0deca94:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bb_elements;
c0deca96:	4360      	muls	r0, r4
c0deca98:	4909      	ldr	r1, [pc, #36]	; (c0decac0 <ux_layout_bb_init_common+0x34>)
c0deca9a:	464a      	mov	r2, r9
c0deca9c:	1851      	adds	r1, r2, r1
c0deca9e:	1808      	adds	r0, r1, r0
c0decaa0:	21d4      	movs	r1, #212	; 0xd4
c0decaa2:	2205      	movs	r2, #5
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_bb_elements);
c0decaa4:	5442      	strb	r2, [r0, r1]
c0decaa6:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bb_elements;
c0decaa8:	4a06      	ldr	r2, [pc, #24]	; (c0decac4 <ux_layout_bb_init_common+0x38>)
c0decaaa:	447a      	add	r2, pc
c0decaac:	5042      	str	r2, [r0, r1]
c0decaae:	21e0      	movs	r1, #224	; 0xe0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0decab0:	4a05      	ldr	r2, [pc, #20]	; (c0decac8 <ux_layout_bb_init_common+0x3c>)
c0decab2:	447a      	add	r2, pc
c0decab4:	5042      	str	r2, [r0, r1]
c0decab6:	21cd      	movs	r1, #205	; 0xcd
c0decab8:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0decaba:	5442      	strb	r2, [r0, r1]
}
c0decabc:	bd10      	pop	{r4, pc}
c0decabe:	46c0      	nop			; (mov r8, r8)
c0decac0:	00000330 	.word	0x00000330
c0decac4:	000045c2 	.word	0x000045c2
c0decac8:	ffffff53 	.word	0xffffff53

c0decacc <ux_layout_bn_prepro>:
 * 1 bold text line
 * 1 text lines
 * Uses layout from ux_layout_bb
 */

const bagl_element_t* ux_layout_bn_prepro(const bagl_element_t* element) {
c0decacc:	b580      	push	{r7, lr}
  const bagl_element_t* e = ux_layout_strings_prepro(element);
c0decace:	f000 fbb7 	bl	c0ded240 <ux_layout_strings_prepro>
  if (e && G_ux.tmp_element.component.userid == 0x11) {
c0decad2:	2800      	cmp	r0, #0
c0decad4:	d00b      	beq.n	c0decaee <ux_layout_bn_prepro+0x22>
c0decad6:	4906      	ldr	r1, [pc, #24]	; (c0decaf0 <ux_layout_bn_prepro+0x24>)
c0decad8:	464a      	mov	r2, r9
c0decada:	1852      	adds	r2, r2, r1
c0decadc:	23ad      	movs	r3, #173	; 0xad
c0decade:	5cd2      	ldrb	r2, [r2, r3]
c0decae0:	2a11      	cmp	r2, #17
c0decae2:	d104      	bne.n	c0decaee <ux_layout_bn_prepro+0x22>
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0decae4:	464a      	mov	r2, r9
c0decae6:	1851      	adds	r1, r2, r1
c0decae8:	22c4      	movs	r2, #196	; 0xc4
c0decaea:	4b02      	ldr	r3, [pc, #8]	; (c0decaf4 <ux_layout_bn_prepro+0x28>)
c0decaec:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0decaee:	bd80      	pop	{r7, pc}
c0decaf0:	00000330 	.word	0x00000330
c0decaf4:	0000800a 	.word	0x0000800a

c0decaf8 <ux_layout_bn_init>:
}

void ux_layout_bn_init(unsigned int stack_slot) { 
c0decaf8:	b510      	push	{r4, lr}
c0decafa:	4604      	mov	r4, r0
  ux_layout_bb_init_common(stack_slot);
c0decafc:	f7ff ffc6 	bl	c0deca8c <ux_layout_bb_init_common>
c0decb00:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_bn_prepro;
c0decb02:	4360      	muls	r0, r4
c0decb04:	4905      	ldr	r1, [pc, #20]	; (c0decb1c <ux_layout_bn_init+0x24>)
c0decb06:	464a      	mov	r2, r9
c0decb08:	1851      	adds	r1, r2, r1
c0decb0a:	1808      	adds	r0, r1, r0
c0decb0c:	21dc      	movs	r1, #220	; 0xdc
c0decb0e:	4a04      	ldr	r2, [pc, #16]	; (c0decb20 <ux_layout_bn_init+0x28>)
c0decb10:	447a      	add	r2, pc
c0decb12:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0decb14:	4620      	mov	r0, r4
c0decb16:	f000 fbdb 	bl	c0ded2d0 <ux_stack_display>
}
c0decb1a:	bd10      	pop	{r4, pc}
c0decb1c:	00000330 	.word	0x00000330
c0decb20:	ffffffb9 	.word	0xffffffb9

c0decb24 <ux_layout_bnnn_init>:
  }
  return &G_ux.tmp_element;
}
*/

void ux_layout_bnnn_init(unsigned int stack_slot) {
c0decb24:	b510      	push	{r4, lr}
c0decb26:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0decb28:	f000 fc00 	bl	c0ded32c <ux_stack_init>
c0decb2c:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bnnn_elements;
c0decb2e:	4360      	muls	r0, r4
c0decb30:	490c      	ldr	r1, [pc, #48]	; (c0decb64 <ux_layout_bnnn_init+0x40>)
c0decb32:	464a      	mov	r2, r9
c0decb34:	1851      	adds	r1, r2, r1
c0decb36:	1808      	adds	r0, r1, r0
c0decb38:	21d4      	movs	r1, #212	; 0xd4
c0decb3a:	2207      	movs	r2, #7
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_bnnn_elements);
c0decb3c:	5442      	strb	r2, [r0, r1]
c0decb3e:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bnnn_elements;
c0decb40:	4a09      	ldr	r2, [pc, #36]	; (c0decb68 <ux_layout_bnnn_init+0x44>)
c0decb42:	447a      	add	r2, pc
c0decb44:	5042      	str	r2, [r0, r1]
c0decb46:	21e0      	movs	r1, #224	; 0xe0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_strings_prepro;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0decb48:	4a08      	ldr	r2, [pc, #32]	; (c0decb6c <ux_layout_bnnn_init+0x48>)
c0decb4a:	447a      	add	r2, pc
c0decb4c:	5042      	str	r2, [r0, r1]
c0decb4e:	21dc      	movs	r1, #220	; 0xdc
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_strings_prepro;
c0decb50:	4a07      	ldr	r2, [pc, #28]	; (c0decb70 <ux_layout_bnnn_init+0x4c>)
c0decb52:	447a      	add	r2, pc
c0decb54:	5042      	str	r2, [r0, r1]
c0decb56:	21cd      	movs	r1, #205	; 0xcd
c0decb58:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0decb5a:	5442      	strb	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0decb5c:	4620      	mov	r0, r4
c0decb5e:	f000 fbb7 	bl	c0ded2d0 <ux_stack_display>
}
c0decb62:	bd10      	pop	{r4, pc}
c0decb64:	00000330 	.word	0x00000330
c0decb68:	000045ca 	.word	0x000045ca
c0decb6c:	fffffebb 	.word	0xfffffebb
c0decb70:	000006eb 	.word	0x000006eb

c0decb74 <ux_layout_nn_prepro>:
/*********************************************************************************
 * 2 text lines
 * Uses bb layout
 */

const bagl_element_t* ux_layout_nn_prepro(const bagl_element_t* element) {
c0decb74:	b580      	push	{r7, lr}
  const bagl_element_t* e = ux_layout_strings_prepro(element);
c0decb76:	f000 fb63 	bl	c0ded240 <ux_layout_strings_prepro>
  if (e && G_ux.tmp_element.component.userid >= 0x10) {
c0decb7a:	2800      	cmp	r0, #0
c0decb7c:	d00b      	beq.n	c0decb96 <ux_layout_nn_prepro+0x22>
c0decb7e:	4906      	ldr	r1, [pc, #24]	; (c0decb98 <ux_layout_nn_prepro+0x24>)
c0decb80:	464a      	mov	r2, r9
c0decb82:	1852      	adds	r2, r2, r1
c0decb84:	23ad      	movs	r3, #173	; 0xad
c0decb86:	5cd2      	ldrb	r2, [r2, r3]
c0decb88:	2a10      	cmp	r2, #16
c0decb8a:	d304      	bcc.n	c0decb96 <ux_layout_nn_prepro+0x22>
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0decb8c:	464a      	mov	r2, r9
c0decb8e:	1851      	adds	r1, r2, r1
c0decb90:	22c4      	movs	r2, #196	; 0xc4
c0decb92:	4b02      	ldr	r3, [pc, #8]	; (c0decb9c <ux_layout_nn_prepro+0x28>)
c0decb94:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0decb96:	bd80      	pop	{r7, pc}
c0decb98:	00000330 	.word	0x00000330
c0decb9c:	0000800a 	.word	0x0000800a

c0decba0 <ux_layout_nn_init>:
}

void ux_layout_nn_init(unsigned int stack_slot) {
c0decba0:	b510      	push	{r4, lr}
c0decba2:	4604      	mov	r4, r0
  ux_layout_bb_init_common(stack_slot);
c0decba4:	f7ff ff72 	bl	c0deca8c <ux_layout_bb_init_common>
c0decba8:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_nn_prepro;
c0decbaa:	4360      	muls	r0, r4
c0decbac:	4905      	ldr	r1, [pc, #20]	; (c0decbc4 <ux_layout_nn_init+0x24>)
c0decbae:	464a      	mov	r2, r9
c0decbb0:	1851      	adds	r1, r2, r1
c0decbb2:	1808      	adds	r0, r1, r0
c0decbb4:	21dc      	movs	r1, #220	; 0xdc
c0decbb6:	4a04      	ldr	r2, [pc, #16]	; (c0decbc8 <ux_layout_nn_init+0x28>)
c0decbb8:	447a      	add	r2, pc
c0decbba:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0decbbc:	4620      	mov	r0, r4
c0decbbe:	f000 fb87 	bl	c0ded2d0 <ux_stack_display>
}
c0decbc2:	bd10      	pop	{r4, pc}
c0decbc4:	00000330 	.word	0x00000330
c0decbc8:	ffffffb9 	.word	0xffffffb9

c0decbcc <ux_layout_paging_redisplay_common>:

  return ux_layout_paging_prepro_common(element, params->get_title(), params->get_text());
}

// redisplay current page
void ux_layout_paging_redisplay_common(unsigned int stack_slot, const char* text, button_push_callback_t button_callback, bagl_element_callback_t prepro) {
c0decbcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0decbce:	9300      	str	r3, [sp, #0]
c0decbd0:	4616      	mov	r6, r2
c0decbd2:	460f      	mov	r7, r1
c0decbd4:	4605      	mov	r5, r0
c0decbd6:	2024      	movs	r0, #36	; 0x24
  ux_stack_slot_t* slot = &G_ux.stack[stack_slot];
#if (BAGL_WIDTH==128 && BAGL_HEIGHT==64)
  slot->element_arrays[0].element_array = ux_layout_paging_elements;
c0decbd8:	4368      	muls	r0, r5
c0decbda:	490e      	ldr	r1, [pc, #56]	; (c0decc14 <ux_layout_paging_redisplay_common+0x48>)
c0decbdc:	464a      	mov	r2, r9
c0decbde:	1852      	adds	r2, r2, r1
c0decbe0:	1814      	adds	r4, r2, r0
c0decbe2:	20d4      	movs	r0, #212	; 0xd4
c0decbe4:	2107      	movs	r1, #7
  slot->element_arrays[0].element_array_count = ARRAYLEN(ux_layout_paging_elements);
c0decbe6:	5421      	strb	r1, [r4, r0]
c0decbe8:	20d0      	movs	r0, #208	; 0xd0
  slot->element_arrays[0].element_array = ux_layout_paging_elements;
c0decbea:	490b      	ldr	r1, [pc, #44]	; (c0decc18 <ux_layout_paging_redisplay_common+0x4c>)
c0decbec:	4479      	add	r1, pc
c0decbee:	5021      	str	r1, [r4, r0]
c0decbf0:	20cd      	movs	r0, #205	; 0xcd
c0decbf2:	2101      	movs	r1, #1
  slot->element_arrays_count = 1;
c0decbf4:	5421      	strb	r1, [r4, r0]
  ux_layout_bb_init_common(stack_slot);
#endif // (BAGL_WIDTH==128 && BAGL_HEIGHT==64)

  // request offsets and lengths of lines for the current page
  ux_layout_paging_compute(text, 
                           G_ux.layout_paging.current, 
c0decbf6:	6891      	ldr	r1, [r2, #8]
c0decbf8:	3208      	adds	r2, #8
c0decbfa:	230a      	movs	r3, #10
  ux_layout_paging_compute(text, 
c0decbfc:	4638      	mov	r0, r7
c0decbfe:	f000 f97d 	bl	c0decefc <ux_layout_paging_compute>
c0decc02:	20e0      	movs	r0, #224	; 0xe0
                           &G_ux.layout_paging,
                           LINE_FONT);

  slot->screen_before_element_display_callback = prepro;
  slot->button_push_callback = button_callback;
c0decc04:	5026      	str	r6, [r4, r0]
c0decc06:	20dc      	movs	r0, #220	; 0xdc
  slot->screen_before_element_display_callback = prepro;
c0decc08:	9900      	ldr	r1, [sp, #0]
c0decc0a:	5021      	str	r1, [r4, r0]
  ux_stack_display(stack_slot);
c0decc0c:	4628      	mov	r0, r5
c0decc0e:	f000 fb5f 	bl	c0ded2d0 <ux_stack_display>
}
c0decc12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0decc14:	00000330 	.word	0x00000330
c0decc18:	00004600 	.word	0x00004600

c0decc1c <ux_layout_paging_redisplay_by_addr>:

static unsigned int ux_layout_paging_button_callback_by_addr(unsigned int button_mask, unsigned int button_mask_counter);
static unsigned int ux_layout_paging_button_callback_by_func(unsigned int button_mask, unsigned int button_mask_counter);


void ux_layout_paging_redisplay_by_addr(unsigned int stack_slot) {
c0decc1c:	b510      	push	{r4, lr}
c0decc1e:	4604      	mov	r4, r0
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_current_step_params();
c0decc20:	f7ff ff2a 	bl	c0deca78 <ux_stack_get_current_step_params>
  ux_layout_paging_redisplay_common(stack_slot, params->text, ux_layout_paging_button_callback_by_addr, ux_layout_paging_prepro_by_addr);
c0decc24:	6841      	ldr	r1, [r0, #4]
c0decc26:	4a04      	ldr	r2, [pc, #16]	; (c0decc38 <ux_layout_paging_redisplay_by_addr+0x1c>)
c0decc28:	447a      	add	r2, pc
c0decc2a:	4b04      	ldr	r3, [pc, #16]	; (c0decc3c <ux_layout_paging_redisplay_by_addr+0x20>)
c0decc2c:	447b      	add	r3, pc
c0decc2e:	4620      	mov	r0, r4
c0decc30:	f7ff ffcc 	bl	c0decbcc <ux_layout_paging_redisplay_common>
}
c0decc34:	bd10      	pop	{r4, pc}
c0decc36:	46c0      	nop			; (mov r8, r8)
c0decc38:	00000015 	.word	0x00000015
c0decc3c:	00000025 	.word	0x00000025

c0decc40 <ux_layout_paging_button_callback_by_addr>:
      break;
  }
  return 0;
}

static unsigned int ux_layout_paging_button_callback_by_addr(unsigned int button_mask, unsigned int button_mask_counter) {
c0decc40:	b580      	push	{r7, lr}
  return ux_layout_paging_button_callback_common(button_mask, button_mask_counter, ux_layout_paging_redisplay_by_addr);
c0decc42:	4903      	ldr	r1, [pc, #12]	; (c0decc50 <ux_layout_paging_button_callback_by_addr+0x10>)
c0decc44:	4479      	add	r1, pc
c0decc46:	f000 f917 	bl	c0dece78 <ux_layout_paging_button_callback_common>
c0decc4a:	2000      	movs	r0, #0
c0decc4c:	bd80      	pop	{r7, pc}
c0decc4e:	46c0      	nop			; (mov r8, r8)
c0decc50:	ffffffd5 	.word	0xffffffd5

c0decc54 <ux_layout_paging_prepro_by_addr>:
static const bagl_element_t* ux_layout_paging_prepro_by_addr(const bagl_element_t* element) {
c0decc54:	b510      	push	{r4, lr}
c0decc56:	4604      	mov	r4, r0
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_current_step_params();
c0decc58:	f7ff ff0e 	bl	c0deca78 <ux_stack_get_current_step_params>
  return ux_layout_paging_prepro_common(element, params->title, params->text);
c0decc5c:	c806      	ldmia	r0!, {r1, r2}
c0decc5e:	4620      	mov	r0, r4
c0decc60:	f000 f862 	bl	c0decd28 <ux_layout_paging_prepro_common>
c0decc64:	bd10      	pop	{r4, pc}
c0decc66:	d4d4      	bmi.n	c0decc12 <ux_layout_paging_redisplay_common+0x46>

c0decc68 <ux_layout_paging_init_common>:
static unsigned int ux_layout_paging_button_callback_by_func(unsigned int button_mask, unsigned int button_mask_counter) {
  return ux_layout_paging_button_callback_common(button_mask, button_mask_counter, ux_layout_paging_redisplay_by_func);
}


void ux_layout_paging_init_common(unsigned int stack_slot, const char* text, ux_layout_paging_redisplay_t redisplay) {
c0decc68:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0decc6a:	9201      	str	r2, [sp, #4]
c0decc6c:	460e      	mov	r6, r1
c0decc6e:	9002      	str	r0, [sp, #8]

  // At this very moment, we don't want to get rid of the format, but keep
  // the one which has just been set (in case of direction backward or forward).
  unsigned int backup_format = G_ux.layout_paging.format;
c0decc70:	4d24      	ldr	r5, [pc, #144]	; (c0decd04 <ux_layout_paging_init_common+0x9c>)
c0decc72:	4648      	mov	r0, r9
c0decc74:	1940      	adds	r0, r0, r5
c0decc76:	7c04      	ldrb	r4, [r0, #16]
c0decc78:	2000      	movs	r0, #0
c0decc7a:	43c7      	mvns	r7, r0

  // depending flow browsing direction, select the correct page to display
  switch(ux_flow_direction()) {
c0decc7c:	f7ff fd42 	bl	c0dec704 <ux_flow_direction>
c0decc80:	2801      	cmp	r0, #1
c0decc82:	d00c      	beq.n	c0decc9e <ux_layout_paging_init_common+0x36>
c0decc84:	1c40      	adds	r0, r0, #1
c0decc86:	d110      	bne.n	c0deccaa <ux_layout_paging_init_common+0x42>
  ux_layout_xx_paging_init(stack_slot, PAGING_FORMAT_BB);
}

// function callable externally which reset the paging (to be called before init when willing to redisplay the first page)
void ux_layout_paging_reset(void) {
  memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0decc88:	4648      	mov	r0, r9
c0decc8a:	491e      	ldr	r1, [pc, #120]	; (c0decd04 <ux_layout_paging_init_common+0x9c>)
c0decc8c:	1845      	adds	r5, r0, r1
c0decc8e:	4628      	mov	r0, r5
c0decc90:	300c      	adds	r0, #12
c0decc92:	2114      	movs	r1, #20
c0decc94:	f000 fdbe 	bl	c0ded814 <__aeabi_memclr>
      G_ux.layout_paging.current = -1UL;
c0decc98:	60af      	str	r7, [r5, #8]
c0decc9a:	4d1a      	ldr	r5, [pc, #104]	; (c0decd04 <ux_layout_paging_init_common+0x9c>)
c0decc9c:	e005      	b.n	c0deccaa <ux_layout_paging_init_common+0x42>
  memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0decc9e:	4648      	mov	r0, r9
c0decca0:	1940      	adds	r0, r0, r5
c0decca2:	3008      	adds	r0, #8
c0decca4:	2118      	movs	r1, #24
c0decca6:	f000 fdb5 	bl	c0ded814 <__aeabi_memclr>
  G_ux.layout_paging.format = backup_format;
c0deccaa:	4648      	mov	r0, r9
c0deccac:	1945      	adds	r5, r0, r5
c0deccae:	742c      	strb	r4, [r5, #16]
  ux_stack_init(stack_slot);
c0deccb0:	9802      	ldr	r0, [sp, #8]
c0deccb2:	f000 fb3b 	bl	c0ded32c <ux_stack_init>
c0deccb6:	2011      	movs	r0, #17
c0deccb8:	0100      	lsls	r0, r0, #4
  if ((text == NULL) && (G_ux.externalText == NULL)) {
c0deccba:	5828      	ldr	r0, [r5, r0]
c0deccbc:	4330      	orrs	r0, r6
c0deccbe:	d101      	bne.n	c0deccc4 <ux_layout_paging_init_common+0x5c>
c0deccc0:	4e11      	ldr	r6, [pc, #68]	; (c0decd08 <ux_layout_paging_init_common+0xa0>)
c0deccc2:	447e      	add	r6, pc
c0deccc4:	9c01      	ldr	r4, [sp, #4]
  G_ux.layout_paging.format = backup_format;
c0deccc6:	462a      	mov	r2, r5
c0deccc8:	3208      	adds	r2, #8
c0deccca:	230a      	movs	r3, #10
  G_ux.layout_paging.count = ux_layout_paging_compute(text, -1UL, &G_ux.layout_paging, LINE_FONT); // at least one page
c0decccc:	4630      	mov	r0, r6
c0deccce:	4639      	mov	r1, r7
c0deccd0:	f000 f914 	bl	c0decefc <ux_layout_paging_compute>
c0deccd4:	60e8      	str	r0, [r5, #12]
  if (G_ux.layout_paging.count == 0) {
c0deccd6:	2800      	cmp	r0, #0
c0deccd8:	d00a      	beq.n	c0deccf0 <ux_layout_paging_init_common+0x88>
  if (G_ux.layout_paging.count && G_ux.layout_paging.current > G_ux.layout_paging.count-1UL) {
c0deccda:	4649      	mov	r1, r9
c0deccdc:	4a09      	ldr	r2, [pc, #36]	; (c0decd04 <ux_layout_paging_init_common+0x9c>)
c0deccde:	1889      	adds	r1, r1, r2
c0decce0:	6889      	ldr	r1, [r1, #8]
c0decce2:	1e40      	subs	r0, r0, #1
c0decce4:	4281      	cmp	r1, r0
c0decce6:	d90a      	bls.n	c0deccfe <ux_layout_paging_init_common+0x96>
    G_ux.layout_paging.current = G_ux.layout_paging.count-1;
c0decce8:	4649      	mov	r1, r9
c0deccea:	1889      	adds	r1, r1, r2
c0deccec:	6088      	str	r0, [r1, #8]
c0deccee:	e006      	b.n	c0deccfe <ux_layout_paging_init_common+0x96>
  memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0deccf0:	4648      	mov	r0, r9
c0deccf2:	4904      	ldr	r1, [pc, #16]	; (c0decd04 <ux_layout_paging_init_common+0x9c>)
c0deccf4:	1840      	adds	r0, r0, r1
c0deccf6:	3008      	adds	r0, #8
c0deccf8:	2118      	movs	r1, #24
c0deccfa:	f000 fd8b 	bl	c0ded814 <__aeabi_memclr>
  redisplay(stack_slot);
c0deccfe:	9802      	ldr	r0, [sp, #8]
c0decd00:	47a0      	blx	r4
}
c0decd02:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0decd04:	00000330 	.word	0x00000330
c0decd08:	0000159e 	.word	0x0000159e

c0decd0c <ux_layout_paging_init>:
void ux_layout_paging_init(unsigned int stack_slot) {
c0decd0c:	b510      	push	{r4, lr}
c0decd0e:	4604      	mov	r4, r0
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_step_params(stack_slot);
c0decd10:	f7ff fe94 	bl	c0deca3c <ux_stack_get_step_params>
  ux_layout_paging_init_common(stack_slot, params->text, ux_layout_paging_redisplay_by_addr);
c0decd14:	6841      	ldr	r1, [r0, #4]
c0decd16:	4a03      	ldr	r2, [pc, #12]	; (c0decd24 <ux_layout_paging_init+0x18>)
c0decd18:	447a      	add	r2, pc
c0decd1a:	4620      	mov	r0, r4
c0decd1c:	f7ff ffa4 	bl	c0decc68 <ux_layout_paging_init_common>
}
c0decd20:	bd10      	pop	{r4, pc}
c0decd22:	46c0      	nop			; (mov r8, r8)
c0decd24:	ffffff01 	.word	0xffffff01

c0decd28 <ux_layout_paging_prepro_common>:
                                                            const char* text) {
c0decd28:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
c0decd2a:	4614      	mov	r4, r2
c0decd2c:	460d      	mov	r5, r1
c0decd2e:	4606      	mov	r6, r0
  memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0decd30:	4f4b      	ldr	r7, [pc, #300]	; (c0dece60 <ux_layout_paging_prepro_common+0x138>)
c0decd32:	4648      	mov	r0, r9
c0decd34:	19c0      	adds	r0, r0, r7
c0decd36:	30ac      	adds	r0, #172	; 0xac
c0decd38:	2220      	movs	r2, #32
c0decd3a:	4631      	mov	r1, r6
c0decd3c:	f000 fd74 	bl	c0ded828 <__aeabi_memmove>
  switch (element->component.userid) {
c0decd40:	7870      	ldrb	r0, [r6, #1]
c0decd42:	4601      	mov	r1, r0
c0decd44:	3911      	subs	r1, #17
c0decd46:	2903      	cmp	r1, #3
c0decd48:	d30f      	bcc.n	c0decd6a <ux_layout_paging_prepro_common+0x42>
c0decd4a:	2810      	cmp	r0, #16
c0decd4c:	d024      	beq.n	c0decd98 <ux_layout_paging_prepro_common+0x70>
c0decd4e:	2802      	cmp	r0, #2
c0decd50:	d035      	beq.n	c0decdbe <ux_layout_paging_prepro_common+0x96>
c0decd52:	2801      	cmp	r0, #1
c0decd54:	d17f      	bne.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
      if (ux_flow_is_first() && G_ux.layout_paging.current == 0) {
c0decd56:	f7ff fc6b 	bl	c0dec630 <ux_flow_is_first>
c0decd5a:	2800      	cmp	r0, #0
c0decd5c:	d07b      	beq.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
c0decd5e:	4648      	mov	r0, r9
c0decd60:	19c0      	adds	r0, r0, r7
c0decd62:	6880      	ldr	r0, [r0, #8]
c0decd64:	2800      	cmp	r0, #0
c0decd66:	d035      	beq.n	c0decdd4 <ux_layout_paging_prepro_common+0xac>
c0decd68:	e075      	b.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
c0decd6a:	260f      	movs	r6, #15
      unsigned int lineidx = (element->component.userid&0xF)-1;
c0decd6c:	4030      	ands	r0, r6
c0decd6e:	1e40      	subs	r0, r0, #1
        lineidx < UX_LAYOUT_PAGING_LINE_COUNT && 
c0decd70:	2802      	cmp	r0, #2
c0decd72:	d870      	bhi.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
        G_ux.layout_paging.lengths[lineidx]) {
c0decd74:	4649      	mov	r1, r9
c0decd76:	19c9      	adds	r1, r1, r7
c0decd78:	0042      	lsls	r2, r0, #1
c0decd7a:	1888      	adds	r0, r1, r2
c0decd7c:	8b05      	ldrh	r5, [r0, #24]
        lineidx < UX_LAYOUT_PAGING_LINE_COUNT && 
c0decd7e:	2d00      	cmp	r5, #0
c0decd80:	d069      	beq.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
        SPRINTF(G_ux.string_buffer, 
c0decd82:	2d7f      	cmp	r5, #127	; 0x7f
c0decd84:	d300      	bcc.n	c0decd88 <ux_layout_paging_prepro_common+0x60>
c0decd86:	257f      	movs	r5, #127	; 0x7f
c0decd88:	2c00      	cmp	r4, #0
c0decd8a:	d025      	beq.n	c0decdd8 <ux_layout_paging_prepro_common+0xb0>
c0decd8c:	4620      	mov	r0, r4
c0decd8e:	4614      	mov	r4, r2
c0decd90:	f7fb fa58 	bl	c0de8244 <pic>
c0decd94:	4622      	mov	r2, r4
c0decd96:	e024      	b.n	c0decde2 <ux_layout_paging_prepro_common+0xba>
        SPRINTF(G_ux.string_buffer, "%d/%d", G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0decd98:	4648      	mov	r0, r9
      if (title) {
c0decd9a:	2d00      	cmp	r5, #0
c0decd9c:	d03c      	beq.n	c0dece18 <ux_layout_paging_prepro_common+0xf0>
        SPRINTF(G_ux.string_buffer, (G_ux.layout_paging.count>1)?"%s (%d/%d)":"%s", STRPIC(title), G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0decd9e:	19c4      	adds	r4, r0, r7
c0decda0:	68e6      	ldr	r6, [r4, #12]
c0decda2:	4628      	mov	r0, r5
c0decda4:	f7fb fa4e 	bl	c0de8244 <pic>
c0decda8:	4603      	mov	r3, r0
c0decdaa:	68a0      	ldr	r0, [r4, #8]
c0decdac:	68e1      	ldr	r1, [r4, #12]
c0decdae:	1c40      	adds	r0, r0, #1
c0decdb0:	9000      	str	r0, [sp, #0]
c0decdb2:	9101      	str	r1, [sp, #4]
c0decdb4:	2e01      	cmp	r6, #1
c0decdb6:	d839      	bhi.n	c0dece2c <ux_layout_paging_prepro_common+0x104>
c0decdb8:	4a2c      	ldr	r2, [pc, #176]	; (c0dece6c <ux_layout_paging_prepro_common+0x144>)
c0decdba:	447a      	add	r2, pc
c0decdbc:	e038      	b.n	c0dece30 <ux_layout_paging_prepro_common+0x108>
      if (ux_flow_is_last() && G_ux.layout_paging.current == G_ux.layout_paging.count -1 ) {
c0decdbe:	f7ff fc75 	bl	c0dec6ac <ux_flow_is_last>
c0decdc2:	2800      	cmp	r0, #0
c0decdc4:	d047      	beq.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
c0decdc6:	4648      	mov	r0, r9
c0decdc8:	19c0      	adds	r0, r0, r7
c0decdca:	6881      	ldr	r1, [r0, #8]
c0decdcc:	68c0      	ldr	r0, [r0, #12]
c0decdce:	1e40      	subs	r0, r0, #1
c0decdd0:	4281      	cmp	r1, r0
c0decdd2:	d140      	bne.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
c0decdd4:	2000      	movs	r0, #0
}
c0decdd6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        SPRINTF(G_ux.string_buffer, 
c0decdd8:	4648      	mov	r0, r9
c0decdda:	19c0      	adds	r0, r0, r7
c0decddc:	2111      	movs	r1, #17
c0decdde:	0109      	lsls	r1, r1, #4
c0decde0:	5840      	ldr	r0, [r0, r1]
c0decde2:	4649      	mov	r1, r9
c0decde4:	19cf      	adds	r7, r1, r7
c0decde6:	18b9      	adds	r1, r7, r2
c0decde8:	8a49      	ldrh	r1, [r1, #18]
c0decdea:	1840      	adds	r0, r0, r1
c0decdec:	9000      	str	r0, [sp, #0]
c0decdee:	463c      	mov	r4, r7
c0decdf0:	342c      	adds	r4, #44	; 0x2c
c0decdf2:	2180      	movs	r1, #128	; 0x80
c0decdf4:	4a1f      	ldr	r2, [pc, #124]	; (c0dece74 <ux_layout_paging_prepro_common+0x14c>)
c0decdf6:	447a      	add	r2, pc
c0decdf8:	4620      	mov	r0, r4
c0decdfa:	462b      	mov	r3, r5
c0decdfc:	f7fb f846 	bl	c0de7e8c <snprintf>
c0dece00:	20c8      	movs	r0, #200	; 0xc8
        G_ux.tmp_element.text = G_ux.string_buffer;
c0dece02:	503c      	str	r4, [r7, r0]
        G_ux.tmp_element.component.font_id = ((G_ux.layout_paging.format & PAGING_FORMAT_NB) == PAGING_FORMAT_NB) ?
c0dece04:	7c39      	ldrb	r1, [r7, #16]
c0dece06:	4031      	ands	r1, r6
c0dece08:	4816      	ldr	r0, [pc, #88]	; (c0dece64 <ux_layout_paging_prepro_common+0x13c>)
c0dece0a:	290f      	cmp	r1, #15
c0dece0c:	d000      	beq.n	c0dece10 <ux_layout_paging_prepro_common+0xe8>
c0dece0e:	1c80      	adds	r0, r0, #2
c0dece10:	21c4      	movs	r1, #196	; 0xc4
c0dece12:	5278      	strh	r0, [r7, r1]
c0dece14:	4f12      	ldr	r7, [pc, #72]	; (c0dece60 <ux_layout_paging_prepro_common+0x138>)
c0dece16:	e01e      	b.n	c0dece56 <ux_layout_paging_prepro_common+0x12e>
        SPRINTF(G_ux.string_buffer, "%d/%d", G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0dece18:	19c0      	adds	r0, r0, r7
c0dece1a:	6881      	ldr	r1, [r0, #8]
c0dece1c:	68c2      	ldr	r2, [r0, #12]
c0dece1e:	9200      	str	r2, [sp, #0]
c0dece20:	302c      	adds	r0, #44	; 0x2c
c0dece22:	1c4b      	adds	r3, r1, #1
c0dece24:	2180      	movs	r1, #128	; 0x80
c0dece26:	4a12      	ldr	r2, [pc, #72]	; (c0dece70 <ux_layout_paging_prepro_common+0x148>)
c0dece28:	447a      	add	r2, pc
c0dece2a:	e004      	b.n	c0dece36 <ux_layout_paging_prepro_common+0x10e>
c0dece2c:	4a0e      	ldr	r2, [pc, #56]	; (c0dece68 <ux_layout_paging_prepro_common+0x140>)
c0dece2e:	447a      	add	r2, pc
        SPRINTF(G_ux.string_buffer, (G_ux.layout_paging.count>1)?"%s (%d/%d)":"%s", STRPIC(title), G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0dece30:	342c      	adds	r4, #44	; 0x2c
c0dece32:	2180      	movs	r1, #128	; 0x80
c0dece34:	4620      	mov	r0, r4
c0dece36:	f7fb f829 	bl	c0de7e8c <snprintf>
      G_ux.tmp_element.component.font_id = ((G_ux.layout_paging.format & PAGING_FORMAT_BN) == PAGING_FORMAT_BN) ? 
c0dece3a:	4648      	mov	r0, r9
c0dece3c:	19c0      	adds	r0, r0, r7
      G_ux.tmp_element.text = G_ux.string_buffer;
c0dece3e:	4601      	mov	r1, r0
c0dece40:	312c      	adds	r1, #44	; 0x2c
c0dece42:	22c8      	movs	r2, #200	; 0xc8
c0dece44:	5081      	str	r1, [r0, r2]
      G_ux.tmp_element.component.font_id = ((G_ux.layout_paging.format & PAGING_FORMAT_BN) == PAGING_FORMAT_BN) ? 
c0dece46:	7c01      	ldrb	r1, [r0, #16]
c0dece48:	090a      	lsrs	r2, r1, #4
c0dece4a:	4906      	ldr	r1, [pc, #24]	; (c0dece64 <ux_layout_paging_prepro_common+0x13c>)
c0dece4c:	2a0e      	cmp	r2, #14
c0dece4e:	d800      	bhi.n	c0dece52 <ux_layout_paging_prepro_common+0x12a>
c0dece50:	1c89      	adds	r1, r1, #2
c0dece52:	22c4      	movs	r2, #196	; 0xc4
c0dece54:	5281      	strh	r1, [r0, r2]
c0dece56:	4648      	mov	r0, r9
c0dece58:	19c0      	adds	r0, r0, r7
c0dece5a:	30ac      	adds	r0, #172	; 0xac
}
c0dece5c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
c0dece5e:	46c0      	nop			; (mov r8, r8)
c0dece60:	00000330 	.word	0x00000330
c0dece64:	ffff8008 	.word	0xffff8008
c0dece68:	00000f4b 	.word	0x00000f4b
c0dece6c:	00001109 	.word	0x00001109
c0dece70:	000014ad 	.word	0x000014ad
c0dece74:	0000101e 	.word	0x0000101e

c0dece78 <ux_layout_paging_button_callback_common>:
static unsigned int ux_layout_paging_button_callback_common(unsigned int button_mask, unsigned int button_mask_counter, ux_layout_paging_redisplay_t redisplay) {
c0dece78:	b510      	push	{r4, lr}
c0dece7a:	4a1c      	ldr	r2, [pc, #112]	; (c0deceec <ux_layout_paging_button_callback_common+0x74>)
  switch(button_mask) {
c0dece7c:	4290      	cmp	r0, r2
c0dece7e:	d00f      	beq.n	c0decea0 <ux_layout_paging_button_callback_common+0x28>
c0dece80:	4a1b      	ldr	r2, [pc, #108]	; (c0decef0 <ux_layout_paging_button_callback_common+0x78>)
c0dece82:	4290      	cmp	r0, r2
c0dece84:	d01b      	beq.n	c0decebe <ux_layout_paging_button_callback_common+0x46>
c0dece86:	4a1b      	ldr	r2, [pc, #108]	; (c0decef4 <ux_layout_paging_button_callback_common+0x7c>)
c0dece88:	4290      	cmp	r0, r2
c0dece8a:	d117      	bne.n	c0decebc <ux_layout_paging_button_callback_common+0x44>
  if (G_ux.layout_paging.current == 0) {
c0dece8c:	481a      	ldr	r0, [pc, #104]	; (c0decef8 <ux_layout_paging_button_callback_common+0x80>)
c0dece8e:	464a      	mov	r2, r9
c0dece90:	1812      	adds	r2, r2, r0
c0dece92:	6892      	ldr	r2, [r2, #8]
c0dece94:	2a00      	cmp	r2, #0
c0dece96:	d025      	beq.n	c0decee4 <ux_layout_paging_button_callback_common+0x6c>
    G_ux.layout_paging.current--;
c0dece98:	464b      	mov	r3, r9
c0dece9a:	181c      	adds	r4, r3, r0
c0dece9c:	1e52      	subs	r2, r2, #1
c0dece9e:	e01c      	b.n	c0deceda <ux_layout_paging_button_callback_common+0x62>
      if (G_ux.layout_paging.count == 0 
c0decea0:	4815      	ldr	r0, [pc, #84]	; (c0decef8 <ux_layout_paging_button_callback_common+0x80>)
c0decea2:	4649      	mov	r1, r9
c0decea4:	1809      	adds	r1, r1, r0
c0decea6:	68c9      	ldr	r1, [r1, #12]
        || G_ux.layout_paging.count-1 == G_ux.layout_paging.current) {
c0decea8:	2900      	cmp	r1, #0
c0deceaa:	d005      	beq.n	c0deceb8 <ux_layout_paging_button_callback_common+0x40>
c0deceac:	464a      	mov	r2, r9
c0deceae:	1810      	adds	r0, r2, r0
c0deceb0:	6880      	ldr	r0, [r0, #8]
c0deceb2:	1e49      	subs	r1, r1, #1
      if (G_ux.layout_paging.count == 0 
c0deceb4:	4281      	cmp	r1, r0
c0deceb6:	d101      	bne.n	c0decebc <ux_layout_paging_button_callback_common+0x44>
        ux_flow_validate();
c0deceb8:	f7ff fcfe 	bl	c0dec8b8 <ux_flow_validate>
c0decebc:	bd10      	pop	{r4, pc}
  if (G_ux.layout_paging.current == G_ux.layout_paging.count-1) {
c0decebe:	480e      	ldr	r0, [pc, #56]	; (c0decef8 <ux_layout_paging_button_callback_common+0x80>)
c0decec0:	464a      	mov	r2, r9
c0decec2:	1813      	adds	r3, r2, r0
c0decec4:	689a      	ldr	r2, [r3, #8]
c0decec6:	68db      	ldr	r3, [r3, #12]
c0decec8:	1e5b      	subs	r3, r3, #1
c0dececa:	429a      	cmp	r2, r3
c0dececc:	d102      	bne.n	c0deced4 <ux_layout_paging_button_callback_common+0x5c>
    ux_flow_next();
c0decece:	f7ff fc73 	bl	c0dec7b8 <ux_flow_next>
c0deced2:	bd10      	pop	{r4, pc}
    G_ux.layout_paging.current++;
c0deced4:	464b      	mov	r3, r9
c0deced6:	181c      	adds	r4, r3, r0
c0deced8:	1c52      	adds	r2, r2, #1
c0deceda:	60a2      	str	r2, [r4, #8]
c0decedc:	5c18      	ldrb	r0, [r3, r0]
c0decede:	1e40      	subs	r0, r0, #1
c0decee0:	4788      	blx	r1
c0decee2:	bd10      	pop	{r4, pc}
    ux_flow_prev();
c0decee4:	f7ff fc6e 	bl	c0dec7c4 <ux_flow_prev>
c0decee8:	bd10      	pop	{r4, pc}
c0deceea:	46c0      	nop			; (mov r8, r8)
c0deceec:	80000003 	.word	0x80000003
c0decef0:	80000002 	.word	0x80000002
c0decef4:	80000001 	.word	0x80000001
c0decef8:	00000330 	.word	0x00000330

c0decefc <ux_layout_paging_compute>:
// return the number of pages to be displayed when current page to show is -1
unsigned int ux_layout_paging_compute(const char* text_to_split, 
                                      unsigned int page_to_display,
                                      ux_layout_paging_state_t* paging_state,
                                      bagl_font_id_e font
                                      ) {
c0decefc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0decefe:	b08b      	sub	sp, #44	; 0x2c
c0decf00:	9308      	str	r3, [sp, #32]
c0decf02:	4617      	mov	r7, r2
c0decf04:	460e      	mov	r6, r1
c0decf06:	4605      	mov	r5, r0
#ifndef HAVE_FONTS
  UNUSED(font);
#endif

  // reset length and offset of lines
  memset(paging_state->offsets, 0, sizeof(paging_state->offsets));
c0decf08:	4610      	mov	r0, r2
c0decf0a:	300a      	adds	r0, #10
c0decf0c:	210c      	movs	r1, #12
  memset(paging_state->lengths, 0, sizeof(paging_state->lengths));
c0decf0e:	f000 fc81 	bl	c0ded814 <__aeabi_memclr>

  // a page has been asked, but no page exists
  if (page_to_display >= paging_state->count && page_to_display != -1UL) {
c0decf12:	1c70      	adds	r0, r6, #1
c0decf14:	9004      	str	r0, [sp, #16]
c0decf16:	d004      	beq.n	c0decf22 <ux_layout_paging_compute+0x26>
c0decf18:	6878      	ldr	r0, [r7, #4]
c0decf1a:	42b0      	cmp	r0, r6
c0decf1c:	d801      	bhi.n	c0decf22 <ux_layout_paging_compute+0x26>
c0decf1e:	2000      	movs	r0, #0
c0decf20:	e08a      	b.n	c0ded038 <ux_layout_paging_compute+0x13c>
  }

  // compute offset/length of text of each line for the current page
  unsigned int page = 0;
  unsigned int line = 0;
  const char* start = (text_to_split ? STRPIC(text_to_split) : G_ux.externalText);
c0decf22:	2d00      	cmp	r5, #0
c0decf24:	d004      	beq.n	c0decf30 <ux_layout_paging_compute+0x34>
c0decf26:	4628      	mov	r0, r5
c0decf28:	f7fb f98c 	bl	c0de8244 <pic>
c0decf2c:	4605      	mov	r5, r0
c0decf2e:	e005      	b.n	c0decf3c <ux_layout_paging_compute+0x40>
c0decf30:	4842      	ldr	r0, [pc, #264]	; (c0ded03c <ux_layout_paging_compute+0x140>)
c0decf32:	4649      	mov	r1, r9
c0decf34:	1808      	adds	r0, r1, r0
c0decf36:	2111      	movs	r1, #17
c0decf38:	0109      	lsls	r1, r1, #4
c0decf3a:	5845      	ldr	r5, [r0, r1]
  const char* start2 = start;
  const char* end = start + strlen(start);
c0decf3c:	4628      	mov	r0, r5
c0decf3e:	f000 fe6f 	bl	c0dedc20 <strlen>
c0decf42:	1828      	adds	r0, r5, r0
c0decf44:	900a      	str	r0, [sp, #40]	; 0x28
c0decf46:	2000      	movs	r0, #0
  const char* start = (text_to_split ? STRPIC(text_to_split) : G_ux.externalText);
c0decf48:	462a      	mov	r2, r5
c0decf4a:	9006      	str	r0, [sp, #24]
  unsigned int page = 0;
c0decf4c:	9005      	str	r0, [sp, #20]
c0decf4e:	a801      	add	r0, sp, #4
c0decf50:	c0e0      	stmia	r0!, {r5, r6, r7}
  while (start < end) {
c0decf52:	980a      	ldr	r0, [sp, #40]	; 0x28
c0decf54:	4282      	cmp	r2, r0
c0decf56:	d26b      	bcs.n	c0ded030 <ux_layout_paging_compute+0x134>
c0decf58:	2600      	movs	r6, #0
c0decf5a:	4635      	mov	r5, r6
c0decf5c:	9207      	str	r2, [sp, #28]
c0decf5e:	9209      	str	r2, [sp, #36]	; 0x24
    unsigned int len = 0;
    unsigned int linew = 0; 
    const char* last_word_delim = start;
    // not reached end of content
    while (start + len < end
c0decf60:	1997      	adds	r7, r2, r6
c0decf62:	980a      	ldr	r0, [sp, #40]	; 0x28
c0decf64:	4287      	cmp	r7, r0
c0decf66:	d217      	bcs.n	c0decf98 <ux_layout_paging_compute+0x9c>
c0decf68:	2d72      	cmp	r5, #114	; 0x72
c0decf6a:	d815      	bhi.n	c0decf98 <ux_layout_paging_compute+0x9c>
c0decf6c:	2100      	movs	r1, #0
      // avoid display buffer overflow for each line
      // && len < sizeof(G_ux.string_buffer)-1
      ) {
      // compute new line length
#ifdef HAVE_FONTS
      linew = bagl_compute_line_width(font, 0, start, len+1, BAGL_ENCODING_LATIN1);
c0decf6e:	9100      	str	r1, [sp, #0]
c0decf70:	1c74      	adds	r4, r6, #1
c0decf72:	b2e3      	uxtb	r3, r4
c0decf74:	9808      	ldr	r0, [sp, #32]
c0decf76:	f7f3 fb49 	bl	c0de060c <bagl_compute_line_width>
#else // HAVE_FONTS
      linew = se_compute_line_width_light(start, len + 1, G_ux.layout_paging.format);
#endif //HAVE_FONTS
      //if (start[len] )
      if (linew > PIXEL_PER_LINE) {
c0decf7a:	2872      	cmp	r0, #114	; 0x72
c0decf7c:	d80e      	bhi.n	c0decf9c <ux_layout_paging_compute+0xa0>
c0decf7e:	4605      	mov	r5, r0
        // we got a full line
        break;
      }
      unsigned char c = start[len];
c0decf80:	783e      	ldrb	r6, [r7, #0]
      if (is_word_delim(c)) {
c0decf82:	4630      	mov	r0, r6
c0decf84:	f000 f85c 	bl	c0ded040 <is_word_delim>
c0decf88:	2800      	cmp	r0, #0
c0decf8a:	d000      	beq.n	c0decf8e <ux_layout_paging_compute+0x92>
c0decf8c:	9707      	str	r7, [sp, #28]
c0decf8e:	2e0a      	cmp	r6, #10
c0decf90:	4626      	mov	r6, r4
c0decf92:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0decf94:	d1e4      	bne.n	c0decf60 <ux_layout_paging_compute+0x64>
c0decf96:	e003      	b.n	c0decfa0 <ux_layout_paging_compute+0xa4>
c0decf98:	4634      	mov	r4, r6
c0decf9a:	e001      	b.n	c0decfa0 <ux_layout_paging_compute+0xa4>
c0decf9c:	4634      	mov	r4, r6
c0decf9e:	9a09      	ldr	r2, [sp, #36]	; 0x24
        break;
      }
    }

    // if not splitting line onto a word delimiter, then cut at the previous word_delim, adjust len accordingly (and a wor delim has been found already)
    if (start + len < end && last_word_delim != start && len) {
c0decfa0:	1915      	adds	r5, r2, r4
c0decfa2:	980a      	ldr	r0, [sp, #40]	; 0x28
c0decfa4:	4285      	cmp	r5, r0
c0decfa6:	d20e      	bcs.n	c0decfc6 <ux_layout_paging_compute+0xca>
c0decfa8:	2c00      	cmp	r4, #0
c0decfaa:	9e03      	ldr	r6, [sp, #12]
c0decfac:	9f02      	ldr	r7, [sp, #8]
c0decfae:	d00c      	beq.n	c0decfca <ux_layout_paging_compute+0xce>
c0decfb0:	9807      	ldr	r0, [sp, #28]
c0decfb2:	4290      	cmp	r0, r2
c0decfb4:	d009      	beq.n	c0decfca <ux_layout_paging_compute+0xce>
      // if line split within a word
      if ((!is_word_delim(start[len-1]) && !is_word_delim(start[len]))) {
c0decfb6:	1e68      	subs	r0, r5, #1
c0decfb8:	7800      	ldrb	r0, [r0, #0]
c0decfba:	f000 f841 	bl	c0ded040 <is_word_delim>
c0decfbe:	2800      	cmp	r0, #0
c0decfc0:	d02d      	beq.n	c0ded01e <ux_layout_paging_compute+0x122>
c0decfc2:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0decfc4:	e001      	b.n	c0decfca <ux_layout_paging_compute+0xce>
c0decfc6:	9e03      	ldr	r6, [sp, #12]
c0decfc8:	9f02      	ldr	r7, [sp, #8]
        len = last_word_delim - start;
      }
    }

    // fill up the paging structure
    if (page_to_display != -1UL && page_to_display == page && page_to_display < paging_state->count) {
c0decfca:	9804      	ldr	r0, [sp, #16]
c0decfcc:	2800      	cmp	r0, #0
c0decfce:	9d01      	ldr	r5, [sp, #4]
c0decfd0:	d00d      	beq.n	c0decfee <ux_layout_paging_compute+0xf2>
c0decfd2:	9805      	ldr	r0, [sp, #20]
c0decfd4:	42b8      	cmp	r0, r7
c0decfd6:	d10a      	bne.n	c0decfee <ux_layout_paging_compute+0xf2>
c0decfd8:	6870      	ldr	r0, [r6, #4]
c0decfda:	42b8      	cmp	r0, r7
c0decfdc:	d907      	bls.n	c0decfee <ux_layout_paging_compute+0xf2>
c0decfde:	9b06      	ldr	r3, [sp, #24]
      paging_state->offsets[line] = start - start2;
c0decfe0:	0058      	lsls	r0, r3, #1
c0decfe2:	1830      	adds	r0, r6, r0
      paging_state->lengths[line] = len;
c0decfe4:	8204      	strh	r4, [r0, #16]
      paging_state->offsets[line] = start - start2;
c0decfe6:	1b51      	subs	r1, r2, r5
c0decfe8:	8141      	strh	r1, [r0, #10]

      // won't compute all pages, we reached the one to display
#if UX_LAYOUT_PAGING_LINE_COUNT > 1
      if (line >= UX_LAYOUT_PAGING_LINE_COUNT-1) 
c0decfea:	2b01      	cmp	r3, #1
c0decfec:	d823      	bhi.n	c0ded036 <ux_layout_paging_compute+0x13a>

    // prepare for next line
    start += len;

    // skip to next line/page
    line++;
c0decfee:	9806      	ldr	r0, [sp, #24]
c0decff0:	1c40      	adds	r0, r0, #1
c0decff2:	2201      	movs	r2, #1
c0decff4:	2100      	movs	r1, #0
    if (
#if UX_LAYOUT_PAGING_LINE_COUNT > 1
      line >= UX_LAYOUT_PAGING_LINE_COUNT && 
c0decff6:	9106      	str	r1, [sp, #24]
c0decff8:	2802      	cmp	r0, #2
c0decffa:	4611      	mov	r1, r2
c0decffc:	d800      	bhi.n	c0ded000 <ux_layout_paging_compute+0x104>
c0decffe:	9906      	ldr	r1, [sp, #24]
c0ded000:	9e09      	ldr	r6, [sp, #36]	; 0x24
    start += len;
c0ded002:	1936      	adds	r6, r6, r4
#endif // UX_LAYOUT_PAGING_LINE_COUNT
      start < end) {
c0ded004:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0ded006:	4634      	mov	r4, r6
c0ded008:	429e      	cmp	r6, r3
c0ded00a:	d300      	bcc.n	c0ded00e <ux_layout_paging_compute+0x112>
c0ded00c:	9a06      	ldr	r2, [sp, #24]
      line >= UX_LAYOUT_PAGING_LINE_COUNT && 
c0ded00e:	4011      	ands	r1, r2
c0ded010:	d100      	bne.n	c0ded014 <ux_layout_paging_compute+0x118>
c0ded012:	9006      	str	r0, [sp, #24]
c0ded014:	9805      	ldr	r0, [sp, #20]
c0ded016:	1840      	adds	r0, r0, r1
c0ded018:	9005      	str	r0, [sp, #20]
c0ded01a:	4622      	mov	r2, r4
c0ded01c:	e799      	b.n	c0decf52 <ux_layout_paging_compute+0x56>
      if ((!is_word_delim(start[len-1]) && !is_word_delim(start[len]))) {
c0ded01e:	7828      	ldrb	r0, [r5, #0]
c0ded020:	f000 f80e 	bl	c0ded040 <is_word_delim>
c0ded024:	2800      	cmp	r0, #0
c0ded026:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0ded028:	d1cf      	bne.n	c0decfca <ux_layout_paging_compute+0xce>
        len = last_word_delim - start;
c0ded02a:	9807      	ldr	r0, [sp, #28]
c0ded02c:	1a84      	subs	r4, r0, r2
c0ded02e:	e7cc      	b.n	c0decfca <ux_layout_paging_compute+0xce>
      line = 0;
    }
  }

  // return total number of page detected
  return page+1;
c0ded030:	9805      	ldr	r0, [sp, #20]
c0ded032:	1c40      	adds	r0, r0, #1
c0ded034:	e000      	b.n	c0ded038 <ux_layout_paging_compute+0x13c>
c0ded036:	2001      	movs	r0, #1
}
c0ded038:	b00b      	add	sp, #44	; 0x2c
c0ded03a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0ded03c:	00000330 	.word	0x00000330

c0ded040 <is_word_delim>:
static unsigned int is_word_delim(unsigned char c) {
c0ded040:	4601      	mov	r1, r0
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0ded042:	4602      	mov	r2, r0
c0ded044:	3a09      	subs	r2, #9
c0ded046:	2001      	movs	r0, #1
c0ded048:	2a02      	cmp	r2, #2
c0ded04a:	d303      	bcc.n	c0ded054 <is_word_delim+0x14>
c0ded04c:	2920      	cmp	r1, #32
c0ded04e:	d001      	beq.n	c0ded054 <is_word_delim+0x14>
c0ded050:	292d      	cmp	r1, #45	; 0x2d
c0ded052:	d100      	bne.n	c0ded056 <is_word_delim+0x16>
c0ded054:	4770      	bx	lr
c0ded056:	395f      	subs	r1, #95	; 0x5f
c0ded058:	4248      	negs	r0, r1
c0ded05a:	4148      	adcs	r0, r1
c0ded05c:	4770      	bx	lr
c0ded05e:	d4d4      	bmi.n	c0ded00a <ux_layout_paging_compute+0x10e>

c0ded060 <ux_layout_pb_prepro>:
#else
  #error "BAGL_WIDTH/BAGL_HEIGHT not defined"
#endif
};

const bagl_element_t* ux_layout_pb_prepro(const bagl_element_t* element) {
c0ded060:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0ded062:	4605      	mov	r5, r0
  // don't display if null
  const ux_layout_pb_params_t* params = (const ux_layout_pb_params_t*)ux_stack_get_current_step_params();

	// copy element before any mod
	memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0ded064:	4f15      	ldr	r7, [pc, #84]	; (c0ded0bc <ux_layout_pb_prepro+0x5c>)
c0ded066:	4648      	mov	r0, r9
c0ded068:	19c6      	adds	r6, r0, r7
c0ded06a:	36ac      	adds	r6, #172	; 0xac
  const ux_layout_pb_params_t* params = (const ux_layout_pb_params_t*)ux_stack_get_current_step_params();
c0ded06c:	f7ff fd04 	bl	c0deca78 <ux_stack_get_current_step_params>
c0ded070:	4604      	mov	r4, r0
c0ded072:	2220      	movs	r2, #32
	memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0ded074:	4630      	mov	r0, r6
c0ded076:	4629      	mov	r1, r5
c0ded078:	f000 fbd6 	bl	c0ded828 <__aeabi_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0ded07c:	7868      	ldrb	r0, [r5, #1]
c0ded07e:	2811      	cmp	r0, #17
c0ded080:	d008      	beq.n	c0ded094 <ux_layout_pb_prepro+0x34>
c0ded082:	2802      	cmp	r0, #2
c0ded084:	d00a      	beq.n	c0ded09c <ux_layout_pb_prepro+0x3c>
c0ded086:	2810      	cmp	r0, #16
c0ded088:	d00e      	beq.n	c0ded0a8 <ux_layout_pb_prepro+0x48>
c0ded08a:	2801      	cmp	r0, #1
c0ded08c:	d111      	bne.n	c0ded0b2 <ux_layout_pb_prepro+0x52>
  	case 0x01:
  		if (ux_flow_is_first()) {
c0ded08e:	f7ff facf 	bl	c0dec630 <ux_flow_is_first>
c0ded092:	e005      	b.n	c0ded0a0 <ux_layout_pb_prepro+0x40>
    case 0x10:
  		G_ux.tmp_element.text = (const char*)params->icon;
      break;

    case 0x11:
  		G_ux.tmp_element.text = params->line1;
c0ded094:	4648      	mov	r0, r9
c0ded096:	19c0      	adds	r0, r0, r7
c0ded098:	6861      	ldr	r1, [r4, #4]
c0ded09a:	e008      	b.n	c0ded0ae <ux_layout_pb_prepro+0x4e>
  		if (ux_flow_is_last()) {
c0ded09c:	f7ff fb06 	bl	c0dec6ac <ux_flow_is_last>
c0ded0a0:	2800      	cmp	r0, #0
c0ded0a2:	d006      	beq.n	c0ded0b2 <ux_layout_pb_prepro+0x52>
c0ded0a4:	2000      	movs	r0, #0
      break;
  }
  return &G_ux.tmp_element;
}
c0ded0a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  		G_ux.tmp_element.text = (const char*)params->icon;
c0ded0a8:	4648      	mov	r0, r9
c0ded0aa:	19c0      	adds	r0, r0, r7
c0ded0ac:	6821      	ldr	r1, [r4, #0]
c0ded0ae:	22c8      	movs	r2, #200	; 0xc8
c0ded0b0:	5081      	str	r1, [r0, r2]
c0ded0b2:	4648      	mov	r0, r9
c0ded0b4:	19c0      	adds	r0, r0, r7
c0ded0b6:	30ac      	adds	r0, #172	; 0xac
}
c0ded0b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0ded0ba:	46c0      	nop			; (mov r8, r8)
c0ded0bc:	00000330 	.word	0x00000330

c0ded0c0 <ux_layout_pb_init>:

void ux_layout_pb_init(unsigned int stack_slot) {
c0ded0c0:	b510      	push	{r4, lr}
c0ded0c2:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0ded0c4:	f000 f932 	bl	c0ded32c <ux_stack_init>
c0ded0c8:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pb_elements;
c0ded0ca:	4360      	muls	r0, r4
c0ded0cc:	490c      	ldr	r1, [pc, #48]	; (c0ded100 <ux_layout_pb_init+0x40>)
c0ded0ce:	464a      	mov	r2, r9
c0ded0d0:	1851      	adds	r1, r2, r1
c0ded0d2:	1808      	adds	r0, r1, r0
c0ded0d4:	21d4      	movs	r1, #212	; 0xd4
c0ded0d6:	2205      	movs	r2, #5
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pb_elements);
c0ded0d8:	5442      	strb	r2, [r0, r1]
c0ded0da:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pb_elements;
c0ded0dc:	4a09      	ldr	r2, [pc, #36]	; (c0ded104 <ux_layout_pb_init+0x44>)
c0ded0de:	447a      	add	r2, pc
c0ded0e0:	5042      	str	r2, [r0, r1]
c0ded0e2:	21e0      	movs	r1, #224	; 0xe0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pb_prepro;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0ded0e4:	4a08      	ldr	r2, [pc, #32]	; (c0ded108 <ux_layout_pb_init+0x48>)
c0ded0e6:	447a      	add	r2, pc
c0ded0e8:	5042      	str	r2, [r0, r1]
c0ded0ea:	21dc      	movs	r1, #220	; 0xdc
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pb_prepro;
c0ded0ec:	4a07      	ldr	r2, [pc, #28]	; (c0ded10c <ux_layout_pb_init+0x4c>)
c0ded0ee:	447a      	add	r2, pc
c0ded0f0:	5042      	str	r2, [r0, r1]
c0ded0f2:	21cd      	movs	r1, #205	; 0xcd
c0ded0f4:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0ded0f6:	5442      	strb	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0ded0f8:	4620      	mov	r0, r4
c0ded0fa:	f000 f8e9 	bl	c0ded2d0 <ux_stack_display>
}
c0ded0fe:	bd10      	pop	{r4, pc}
c0ded100:	00000330 	.word	0x00000330
c0ded104:	000041ee 	.word	0x000041ee
c0ded108:	fffff91f 	.word	0xfffff91f
c0ded10c:	ffffff6f 	.word	0xffffff6f

c0ded110 <ux_layout_pbb_prepro>:
#else
  #error "BAGL_WIDTH/BAGL_HEIGHT not defined"
#endif
};

const bagl_element_t* ux_layout_pbb_prepro(const bagl_element_t* element) {
c0ded110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0ded112:	4605      	mov	r5, r0
  // don't display if null
  const ux_layout_icon_strings_params_t* params = (const ux_layout_icon_strings_params_t*)ux_stack_get_current_step_params();

	// ocpy element before any mod
	memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0ded114:	4f18      	ldr	r7, [pc, #96]	; (c0ded178 <ux_layout_pbb_prepro+0x68>)
c0ded116:	4648      	mov	r0, r9
c0ded118:	19c6      	adds	r6, r0, r7
c0ded11a:	36ac      	adds	r6, #172	; 0xac
  const ux_layout_icon_strings_params_t* params = (const ux_layout_icon_strings_params_t*)ux_stack_get_current_step_params();
c0ded11c:	f7ff fcac 	bl	c0deca78 <ux_stack_get_current_step_params>
c0ded120:	4604      	mov	r4, r0
c0ded122:	2220      	movs	r2, #32
	memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0ded124:	4630      	mov	r0, r6
c0ded126:	4629      	mov	r1, r5
c0ded128:	f000 fb7e 	bl	c0ded828 <__aeabi_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0ded12c:	7868      	ldrb	r0, [r5, #1]
c0ded12e:	4601      	mov	r1, r0
c0ded130:	3910      	subs	r1, #16
c0ded132:	2902      	cmp	r1, #2
c0ded134:	d308      	bcc.n	c0ded148 <ux_layout_pbb_prepro+0x38>
c0ded136:	280f      	cmp	r0, #15
c0ded138:	d00f      	beq.n	c0ded15a <ux_layout_pbb_prepro+0x4a>
c0ded13a:	2802      	cmp	r0, #2
c0ded13c:	d016      	beq.n	c0ded16c <ux_layout_pbb_prepro+0x5c>
c0ded13e:	2801      	cmp	r0, #1
c0ded140:	d110      	bne.n	c0ded164 <ux_layout_pbb_prepro+0x54>
  	case 0x01:
  		if (ux_flow_is_first()) {
c0ded142:	f7ff fa75 	bl	c0dec630 <ux_flow_is_first>
c0ded146:	e013      	b.n	c0ded170 <ux_layout_pbb_prepro+0x60>
  		G_ux.tmp_element.text = (const char*)params->icon;
      break;

    case 0x10:
    case 0x11:
      G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
c0ded148:	4648      	mov	r0, r9
c0ded14a:	19c0      	adds	r0, r0, r7
c0ded14c:	21ad      	movs	r1, #173	; 0xad
c0ded14e:	5c41      	ldrb	r1, [r0, r1]
c0ded150:	0709      	lsls	r1, r1, #28
c0ded152:	0e89      	lsrs	r1, r1, #26
c0ded154:	1861      	adds	r1, r4, r1
c0ded156:	6849      	ldr	r1, [r1, #4]
c0ded158:	e002      	b.n	c0ded160 <ux_layout_pbb_prepro+0x50>
  		G_ux.tmp_element.text = (const char*)params->icon;
c0ded15a:	4648      	mov	r0, r9
c0ded15c:	19c0      	adds	r0, r0, r7
c0ded15e:	6821      	ldr	r1, [r4, #0]
c0ded160:	22c8      	movs	r2, #200	; 0xc8
c0ded162:	5081      	str	r1, [r0, r2]
c0ded164:	4648      	mov	r0, r9
c0ded166:	19c0      	adds	r0, r0, r7
c0ded168:	30ac      	adds	r0, #172	; 0xac
      break;

  }
  return &G_ux.tmp_element;
}
c0ded16a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  		if (ux_flow_is_last()) {
c0ded16c:	f7ff fa9e 	bl	c0dec6ac <ux_flow_is_last>
c0ded170:	2800      	cmp	r0, #0
c0ded172:	d0f7      	beq.n	c0ded164 <ux_layout_pbb_prepro+0x54>
c0ded174:	2000      	movs	r0, #0
}
c0ded176:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0ded178:	00000330 	.word	0x00000330

c0ded17c <ux_layout_pbb_init_common>:


void ux_layout_pbb_init_common(unsigned int stack_slot) {
c0ded17c:	b510      	push	{r4, lr}
c0ded17e:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0ded180:	f000 f8d4 	bl	c0ded32c <ux_stack_init>
c0ded184:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0ded186:	4360      	muls	r0, r4
c0ded188:	4909      	ldr	r1, [pc, #36]	; (c0ded1b0 <ux_layout_pbb_init_common+0x34>)
c0ded18a:	464a      	mov	r2, r9
c0ded18c:	1851      	adds	r1, r2, r1
c0ded18e:	1808      	adds	r0, r1, r0
c0ded190:	21d4      	movs	r1, #212	; 0xd4
c0ded192:	2206      	movs	r2, #6
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pbb_elements);
c0ded194:	5442      	strb	r2, [r0, r1]
c0ded196:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0ded198:	4a06      	ldr	r2, [pc, #24]	; (c0ded1b4 <ux_layout_pbb_init_common+0x38>)
c0ded19a:	447a      	add	r2, pc
c0ded19c:	5042      	str	r2, [r0, r1]
c0ded19e:	21e0      	movs	r1, #224	; 0xe0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0ded1a0:	4a05      	ldr	r2, [pc, #20]	; (c0ded1b8 <ux_layout_pbb_init_common+0x3c>)
c0ded1a2:	447a      	add	r2, pc
c0ded1a4:	5042      	str	r2, [r0, r1]
c0ded1a6:	21cd      	movs	r1, #205	; 0xcd
c0ded1a8:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0ded1aa:	5442      	strb	r2, [r0, r1]
}
c0ded1ac:	bd10      	pop	{r4, pc}
c0ded1ae:	46c0      	nop			; (mov r8, r8)
c0ded1b0:	00000330 	.word	0x00000330
c0ded1b4:	000041d2 	.word	0x000041d2
c0ded1b8:	fffff863 	.word	0xfffff863

c0ded1bc <ux_layout_pbb_init>:

void ux_layout_pbb_init(unsigned int stack_slot) {
c0ded1bc:	b510      	push	{r4, lr}
c0ded1be:	4604      	mov	r4, r0
  ux_layout_pbb_init_common(stack_slot);
c0ded1c0:	f7ff ffdc 	bl	c0ded17c <ux_layout_pbb_init_common>
c0ded1c4:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pbb_prepro;
c0ded1c6:	4360      	muls	r0, r4
c0ded1c8:	4905      	ldr	r1, [pc, #20]	; (c0ded1e0 <ux_layout_pbb_init+0x24>)
c0ded1ca:	464a      	mov	r2, r9
c0ded1cc:	1851      	adds	r1, r2, r1
c0ded1ce:	1808      	adds	r0, r1, r0
c0ded1d0:	21dc      	movs	r1, #220	; 0xdc
c0ded1d2:	4a04      	ldr	r2, [pc, #16]	; (c0ded1e4 <ux_layout_pbb_init+0x28>)
c0ded1d4:	447a      	add	r2, pc
c0ded1d6:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0ded1d8:	4620      	mov	r0, r4
c0ded1da:	f000 f879 	bl	c0ded2d0 <ux_stack_display>
}
c0ded1de:	bd10      	pop	{r4, pc}
c0ded1e0:	00000330 	.word	0x00000330
c0ded1e4:	ffffff39 	.word	0xffffff39

c0ded1e8 <ux_layout_pnn_prepro>:

/*********************************************************************************
 * 4 text lines
 */

const bagl_element_t* ux_layout_pnn_prepro(const bagl_element_t* element) {
c0ded1e8:	b580      	push	{r7, lr}
  const bagl_element_t* e = ux_layout_pbb_prepro(element);
c0ded1ea:	f7ff ff91 	bl	c0ded110 <ux_layout_pbb_prepro>
  if (e && G_ux.tmp_element.component.userid >= 0x10) {
c0ded1ee:	2800      	cmp	r0, #0
c0ded1f0:	d00b      	beq.n	c0ded20a <ux_layout_pnn_prepro+0x22>
c0ded1f2:	4906      	ldr	r1, [pc, #24]	; (c0ded20c <ux_layout_pnn_prepro+0x24>)
c0ded1f4:	464a      	mov	r2, r9
c0ded1f6:	1852      	adds	r2, r2, r1
c0ded1f8:	23ad      	movs	r3, #173	; 0xad
c0ded1fa:	5cd2      	ldrb	r2, [r2, r3]
c0ded1fc:	2a10      	cmp	r2, #16
c0ded1fe:	d304      	bcc.n	c0ded20a <ux_layout_pnn_prepro+0x22>
    // The centering depends on the screensize.
#if (BAGL_WIDTH==128 && BAGL_HEIGHT==64)
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0ded200:	464a      	mov	r2, r9
c0ded202:	1851      	adds	r1, r2, r1
c0ded204:	22c4      	movs	r2, #196	; 0xc4
c0ded206:	4b02      	ldr	r3, [pc, #8]	; (c0ded210 <ux_layout_pnn_prepro+0x28>)
c0ded208:	528b      	strh	r3, [r1, r2]
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px;
#else
  #error "BAGL_WIDTH/BAGL_HEIGHT not defined"
#endif
  }
  return e;
c0ded20a:	bd80      	pop	{r7, pc}
c0ded20c:	00000330 	.word	0x00000330
c0ded210:	0000800a 	.word	0x0000800a

c0ded214 <ux_layout_pnn_init>:
}

void ux_layout_pnn_init(unsigned int stack_slot) { 
c0ded214:	b510      	push	{r4, lr}
c0ded216:	4604      	mov	r4, r0
  ux_layout_pbb_init_common(stack_slot);
c0ded218:	f7ff ffb0 	bl	c0ded17c <ux_layout_pbb_init_common>
c0ded21c:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pnn_prepro;
c0ded21e:	4360      	muls	r0, r4
c0ded220:	4905      	ldr	r1, [pc, #20]	; (c0ded238 <ux_layout_pnn_init+0x24>)
c0ded222:	464a      	mov	r2, r9
c0ded224:	1851      	adds	r1, r2, r1
c0ded226:	1808      	adds	r0, r1, r0
c0ded228:	21dc      	movs	r1, #220	; 0xdc
c0ded22a:	4a04      	ldr	r2, [pc, #16]	; (c0ded23c <ux_layout_pnn_init+0x28>)
c0ded22c:	447a      	add	r2, pc
c0ded22e:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0ded230:	4620      	mov	r0, r4
c0ded232:	f000 f84d 	bl	c0ded2d0 <ux_stack_display>
}
c0ded236:	bd10      	pop	{r4, pc}
c0ded238:	00000330 	.word	0x00000330
c0ded23c:	ffffffb9 	.word	0xffffffb9

c0ded240 <ux_layout_strings_prepro>:
    G_ux.stack[stack_slot].ticker_value = ms;
    G_ux.stack[stack_slot].ticker_interval = ms; // restart
  }
}

const bagl_element_t* ux_layout_strings_prepro(const bagl_element_t* element) {
c0ded240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0ded242:	4605      	mov	r5, r0
  // don't display if null
  const ux_layout_strings_params_t* params = (const ux_layout_strings_params_t*)ux_stack_get_current_step_params();
  // ocpy element before any mod
  memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0ded244:	4f15      	ldr	r7, [pc, #84]	; (c0ded29c <ux_layout_strings_prepro+0x5c>)
c0ded246:	4648      	mov	r0, r9
c0ded248:	19c6      	adds	r6, r0, r7
c0ded24a:	36ac      	adds	r6, #172	; 0xac
  const ux_layout_strings_params_t* params = (const ux_layout_strings_params_t*)ux_stack_get_current_step_params();
c0ded24c:	f7ff fc14 	bl	c0deca78 <ux_stack_get_current_step_params>
c0ded250:	4604      	mov	r4, r0
c0ded252:	2220      	movs	r2, #32
  memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0ded254:	4630      	mov	r0, r6
c0ded256:	4629      	mov	r1, r5
c0ded258:	f000 fae6 	bl	c0ded828 <__aeabi_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0ded25c:	7868      	ldrb	r0, [r5, #1]
c0ded25e:	2802      	cmp	r0, #2
c0ded260:	d004      	beq.n	c0ded26c <ux_layout_strings_prepro+0x2c>
c0ded262:	2801      	cmp	r0, #1
c0ded264:	d108      	bne.n	c0ded278 <ux_layout_strings_prepro+0x38>
    case 0x01:
      if (ux_flow_is_first()) {
c0ded266:	f7ff f9e3 	bl	c0dec630 <ux_flow_is_first>
c0ded26a:	e001      	b.n	c0ded270 <ux_layout_strings_prepro+0x30>
        return NULL;
      }
      break;

    case 0x02:
      if (ux_flow_is_last()) {
c0ded26c:	f7ff fa1e 	bl	c0dec6ac <ux_flow_is_last>
c0ded270:	2800      	cmp	r0, #0
c0ded272:	d00f      	beq.n	c0ded294 <ux_layout_strings_prepro+0x54>
c0ded274:	2000      	movs	r0, #0
        G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
      }
      break;
  }
  return &G_ux.tmp_element;
}
c0ded276:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (G_ux.tmp_element.component.userid&0xF0) {
c0ded278:	4648      	mov	r0, r9
c0ded27a:	19c0      	adds	r0, r0, r7
c0ded27c:	21ad      	movs	r1, #173	; 0xad
c0ded27e:	5c40      	ldrb	r0, [r0, r1]
c0ded280:	0601      	lsls	r1, r0, #24
c0ded282:	0f09      	lsrs	r1, r1, #28
c0ded284:	d006      	beq.n	c0ded294 <ux_layout_strings_prepro+0x54>
        G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
c0ded286:	4649      	mov	r1, r9
c0ded288:	19c9      	adds	r1, r1, r7
c0ded28a:	0700      	lsls	r0, r0, #28
c0ded28c:	0e80      	lsrs	r0, r0, #26
c0ded28e:	5820      	ldr	r0, [r4, r0]
c0ded290:	22c8      	movs	r2, #200	; 0xc8
c0ded292:	5088      	str	r0, [r1, r2]
c0ded294:	4648      	mov	r0, r9
c0ded296:	19c0      	adds	r0, r0, r7
c0ded298:	30ac      	adds	r0, #172	; 0xac
}
c0ded29a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0ded29c:	00000330 	.word	0x00000330

c0ded2a0 <ux_stack_push>:
  }

  return 0;
}

unsigned int ux_stack_push(void) {
c0ded2a0:	b570      	push	{r4, r5, r6, lr}
  // only push if an available slot exists
  if (G_ux.stack_count < ARRAYLEN(G_ux.stack)) {
c0ded2a2:	4c0a      	ldr	r4, [pc, #40]	; (c0ded2cc <ux_stack_push+0x2c>)
c0ded2a4:	4648      	mov	r0, r9
c0ded2a6:	5d00      	ldrb	r0, [r0, r4]
c0ded2a8:	2800      	cmp	r0, #0
c0ded2aa:	d10c      	bne.n	c0ded2c6 <ux_stack_push+0x26>
    memset(&G_ux.stack[G_ux.stack_count], 0, sizeof(G_ux.stack[0]));
c0ded2ac:	464d      	mov	r5, r9
c0ded2ae:	192e      	adds	r6, r5, r4
c0ded2b0:	4630      	mov	r0, r6
c0ded2b2:	30cc      	adds	r0, #204	; 0xcc
c0ded2b4:	2124      	movs	r1, #36	; 0x24
c0ded2b6:	f000 faad 	bl	c0ded814 <__aeabi_memclr>
c0ded2ba:	2001      	movs	r0, #1
#ifdef HAVE_UX_FLOW
    memset(&G_ux.flow_stack[G_ux.stack_count], 0, sizeof(G_ux.flow_stack[0]));
#endif // HAVE_UX_FLOW
    G_ux.stack_count++;
c0ded2bc:	5528      	strb	r0, [r5, r4]
c0ded2be:	2100      	movs	r1, #0
    memset(&G_ux.flow_stack[G_ux.stack_count], 0, sizeof(G_ux.flow_stack[0]));
c0ded2c0:	6231      	str	r1, [r6, #32]
c0ded2c2:	6271      	str	r1, [r6, #36]	; 0x24
c0ded2c4:	62b1      	str	r1, [r6, #40]	; 0x28
  }
  // return the stack top index
  return G_ux.stack_count - 1;
c0ded2c6:	1e40      	subs	r0, r0, #1
c0ded2c8:	bd70      	pop	{r4, r5, r6, pc}
c0ded2ca:	46c0      	nop			; (mov r8, r8)
c0ded2cc:	00000330 	.word	0x00000330

c0ded2d0 <ux_stack_display>:
}
#endif // UX_STACK_SLOT_ARRAY_COUNT == 1
#endif // HAVE_SE_SCREEN

// common code for all screens
void ux_stack_display(unsigned int stack_slot) {
c0ded2d0:	b510      	push	{r4, lr}
  // don't display any elements of a previous screen replacement
  if (G_ux.stack_count > 0 && stack_slot + 1 == G_ux.stack_count) {
c0ded2d2:	4915      	ldr	r1, [pc, #84]	; (c0ded328 <ux_stack_display+0x58>)
c0ded2d4:	464a      	mov	r2, r9
c0ded2d6:	5c52      	ldrb	r2, [r2, r1]
c0ded2d8:	2a00      	cmp	r2, #0
c0ded2da:	d011      	beq.n	c0ded300 <ux_stack_display+0x30>
c0ded2dc:	1c43      	adds	r3, r0, #1
c0ded2de:	4293      	cmp	r3, r2
c0ded2e0:	d10e      	bne.n	c0ded300 <ux_stack_display+0x30>
c0ded2e2:	2224      	movs	r2, #36	; 0x24
    io_seproxyhal_init_ux();
    // at worse a redisplay of the current screen has been requested, ensure to redraw it correctly
    G_ux.stack[stack_slot].element_index = 0;
c0ded2e4:	4342      	muls	r2, r0
c0ded2e6:	4648      	mov	r0, r9
c0ded2e8:	1840      	adds	r0, r0, r1
c0ded2ea:	1884      	adds	r4, r0, r2
    io_seproxyhal_init_ux();
c0ded2ec:	f7fa fa1c 	bl	c0de7728 <io_seproxyhal_init_ux>
c0ded2f0:	20ce      	movs	r0, #206	; 0xce
c0ded2f2:	2100      	movs	r1, #0
    G_ux.stack[stack_slot].element_index = 0;
c0ded2f4:	5221      	strh	r1, [r4, r0]
c0ded2f6:	34cc      	adds	r4, #204	; 0xcc
#ifdef HAVE_SE_SCREEN
    ux_stack_display_elements(&G_ux.stack[stack_slot]); // on balenos, no need to wait for the display processed event
c0ded2f8:	4620      	mov	r0, r4
c0ded2fa:	f000 f847 	bl	c0ded38c <ux_stack_display_elements>
    if (G_ux.exit_code == BOLOS_UX_OK) {
      G_ux.exit_code = BOLOS_UX_REDRAW;
    }
  }
  // else don't draw (in stack insertion)
}
c0ded2fe:	bd10      	pop	{r4, pc}
c0ded300:	2300      	movs	r3, #0
c0ded302:	43db      	mvns	r3, r3
  else if (stack_slot == -1UL || G_ux.stack_count == 0) {
c0ded304:	1ac0      	subs	r0, r0, r3
c0ded306:	1e43      	subs	r3, r0, #1
c0ded308:	4198      	sbcs	r0, r3
  if (G_ux.stack_count > 0 && stack_slot + 1 == G_ux.stack_count) {
c0ded30a:	1e53      	subs	r3, r2, #1
c0ded30c:	419a      	sbcs	r2, r3
  else if (stack_slot == -1UL || G_ux.stack_count == 0) {
c0ded30e:	4210      	tst	r0, r2
c0ded310:	d108      	bne.n	c0ded324 <ux_stack_display+0x54>
c0ded312:	4648      	mov	r0, r9
c0ded314:	1840      	adds	r0, r0, r1
c0ded316:	7840      	ldrb	r0, [r0, #1]
c0ded318:	28aa      	cmp	r0, #170	; 0xaa
c0ded31a:	d103      	bne.n	c0ded324 <ux_stack_display+0x54>
      G_ux.exit_code = BOLOS_UX_REDRAW;
c0ded31c:	4648      	mov	r0, r9
c0ded31e:	1840      	adds	r0, r0, r1
c0ded320:	2169      	movs	r1, #105	; 0x69
c0ded322:	7041      	strb	r1, [r0, #1]
}
c0ded324:	bd10      	pop	{r4, pc}
c0ded326:	46c0      	nop			; (mov r8, r8)
c0ded328:	00000330 	.word	0x00000330

c0ded32c <ux_stack_init>:
void ux_stack_init(unsigned int stack_slot) {
c0ded32c:	b510      	push	{r4, lr}
c0ded32e:	4604      	mov	r4, r0
  io_seproxyhal_init_ux(); // glitch upon ux_stack_display for a button being pressed in a previous screen
c0ded330:	f7fa f9fa 	bl	c0de7728 <io_seproxyhal_init_ux>
  if (stack_slot < UX_STACK_SLOT_COUNT) {
c0ded334:	2c00      	cmp	r4, #0
c0ded336:	d000      	beq.n	c0ded33a <ux_stack_init+0xe>
}
c0ded338:	bd10      	pop	{r4, pc}
    G_ux.stack[stack_slot].exit_code_after_elements_displayed = BOLOS_UX_CONTINUE;
c0ded33a:	4804      	ldr	r0, [pc, #16]	; (c0ded34c <ux_stack_init+0x20>)
c0ded33c:	4649      	mov	r1, r9
c0ded33e:	1808      	adds	r0, r1, r0
c0ded340:	30cc      	adds	r0, #204	; 0xcc
c0ded342:	2124      	movs	r1, #36	; 0x24
c0ded344:	f000 fa66 	bl	c0ded814 <__aeabi_memclr>
}
c0ded348:	bd10      	pop	{r4, pc}
c0ded34a:	46c0      	nop			; (mov r8, r8)
c0ded34c:	00000330 	.word	0x00000330

c0ded350 <ux_stack_display_element_callback>:
const bagl_element_t *ux_stack_display_element_callback(const bagl_element_t *element) {
c0ded350:	b510      	push	{r4, lr}
c0ded352:	4604      	mov	r4, r0
  if (G_ux.stack_count) {
c0ded354:	490c      	ldr	r1, [pc, #48]	; (c0ded388 <ux_stack_display_element_callback+0x38>)
c0ded356:	4648      	mov	r0, r9
c0ded358:	5c40      	ldrb	r0, [r0, r1]
c0ded35a:	2800      	cmp	r0, #0
c0ded35c:	d011      	beq.n	c0ded382 <ux_stack_display_element_callback+0x32>
    if (G_ux.stack[G_ux.stack_count - 1].screen_before_element_display_callback) {
c0ded35e:	464a      	mov	r2, r9
c0ded360:	1851      	adds	r1, r2, r1
c0ded362:	2224      	movs	r2, #36	; 0x24
c0ded364:	4342      	muls	r2, r0
c0ded366:	1850      	adds	r0, r2, r1
c0ded368:	21b8      	movs	r1, #184	; 0xb8
c0ded36a:	5841      	ldr	r1, [r0, r1]
c0ded36c:	2900      	cmp	r1, #0
c0ded36e:	d008      	beq.n	c0ded382 <ux_stack_display_element_callback+0x32>
      el = G_ux.stack[G_ux.stack_count - 1].screen_before_element_display_callback(element);
c0ded370:	4620      	mov	r0, r4
c0ded372:	4788      	blx	r1
      if (!el) {
c0ded374:	2800      	cmp	r0, #0
c0ded376:	d003      	beq.n	c0ded380 <ux_stack_display_element_callback+0x30>
c0ded378:	2801      	cmp	r0, #1
c0ded37a:	d002      	beq.n	c0ded382 <ux_stack_display_element_callback+0x32>
c0ded37c:	4604      	mov	r4, r0
c0ded37e:	e000      	b.n	c0ded382 <ux_stack_display_element_callback+0x32>
c0ded380:	2400      	movs	r4, #0
}
c0ded382:	4620      	mov	r0, r4
c0ded384:	bd10      	pop	{r4, pc}
c0ded386:	46c0      	nop			; (mov r8, r8)
c0ded388:	00000330 	.word	0x00000330

c0ded38c <ux_stack_display_elements>:
void ux_stack_display_elements(ux_stack_slot_t *slot) {
c0ded38c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
c0ded38e:	4604      	mov	r4, r0
  if ((os_perso_isonboarded() != BOLOS_UX_OK || os_global_pin_is_validated() == BOLOS_UX_OK))
c0ded390:	f7fb ff24 	bl	c0de91dc <os_perso_isonboarded>
c0ded394:	28aa      	cmp	r0, #170	; 0xaa
c0ded396:	d103      	bne.n	c0ded3a0 <ux_stack_display_elements+0x14>
c0ded398:	f7fb ff48 	bl	c0de922c <os_global_pin_is_validated>
c0ded39c:	28aa      	cmp	r0, #170	; 0xaa
c0ded39e:	d146      	bne.n	c0ded42e <ux_stack_display_elements+0xa2>
c0ded3a0:	2001      	movs	r0, #1
c0ded3a2:	2100      	movs	r1, #0
c0ded3a4:	9100      	str	r1, [sp, #0]
    for (i = 0; i < UX_STACK_SLOT_ARRAY_COUNT && i < slot->element_arrays_count; i++) {
c0ded3a6:	07c0      	lsls	r0, r0, #31
c0ded3a8:	d02b      	beq.n	c0ded402 <ux_stack_display_elements+0x76>
c0ded3aa:	8860      	ldrh	r0, [r4, #2]
c0ded3ac:	7861      	ldrb	r1, [r4, #1]
c0ded3ae:	2900      	cmp	r1, #0
c0ded3b0:	d028      	beq.n	c0ded404 <ux_stack_display_elements+0x78>
c0ded3b2:	9a00      	ldr	r2, [sp, #0]
      elem_idx = slot->element_index - total_element_count;
c0ded3b4:	1a86      	subs	r6, r0, r2
      while (elem_idx < slot->element_arrays[i].element_array_count) {
c0ded3b6:	0151      	lsls	r1, r2, #5
c0ded3b8:	0140      	lsls	r0, r0, #5
c0ded3ba:	1a47      	subs	r7, r0, r1
      total_element_count += slot->element_arrays[i].element_array_count;
c0ded3bc:	7a20      	ldrb	r0, [r4, #8]
c0ded3be:	1812      	adds	r2, r2, r0
c0ded3c0:	9200      	str	r2, [sp, #0]
      while (elem_idx < slot->element_arrays[i].element_array_count) {
c0ded3c2:	b2c0      	uxtb	r0, r0
c0ded3c4:	4286      	cmp	r6, r0
c0ded3c6:	d21a      	bcs.n	c0ded3fe <ux_stack_display_elements+0x72>
        slot->element_index++;
c0ded3c8:	8860      	ldrh	r0, [r4, #2]
c0ded3ca:	1c40      	adds	r0, r0, #1
c0ded3cc:	8060      	strh	r0, [r4, #2]
        element = &slot->element_arrays[i].element_array[elem_idx];
c0ded3ce:	6860      	ldr	r0, [r4, #4]
        el      = ux_stack_display_element_callback(element);
c0ded3d0:	19c5      	adds	r5, r0, r7
c0ded3d2:	4628      	mov	r0, r5
c0ded3d4:	f7ff ffbc 	bl	c0ded350 <ux_stack_display_element_callback>
        if (!el) {
c0ded3d8:	2800      	cmp	r0, #0
c0ded3da:	d006      	beq.n	c0ded3ea <ux_stack_display_elements+0x5e>
c0ded3dc:	2801      	cmp	r0, #1
c0ded3de:	d000      	beq.n	c0ded3e2 <ux_stack_display_elements+0x56>
c0ded3e0:	4605      	mov	r5, r0
          io_seproxyhal_display(element);
c0ded3e2:	4628      	mov	r0, r5
c0ded3e4:	f7f9 fc2e 	bl	c0de6c44 <io_seproxyhal_display>
c0ded3e8:	e005      	b.n	c0ded3f6 <ux_stack_display_elements+0x6a>
              G_ux.exit_code != BOLOS_UX_CONTINUE) {
c0ded3ea:	4648      	mov	r0, r9
c0ded3ec:	4913      	ldr	r1, [pc, #76]	; (c0ded43c <ux_stack_display_elements+0xb0>)
c0ded3ee:	1840      	adds	r0, r0, r1
c0ded3f0:	7840      	ldrb	r0, [r0, #1]
c0ded3f2:	2800      	cmp	r0, #0
c0ded3f4:	d11b      	bne.n	c0ded42e <ux_stack_display_elements+0xa2>
c0ded3f6:	3720      	adds	r7, #32
      while (elem_idx < slot->element_arrays[i].element_array_count) {
c0ded3f8:	7a20      	ldrb	r0, [r4, #8]
        elem_idx++;
c0ded3fa:	1c76      	adds	r6, r6, #1
c0ded3fc:	e7e1      	b.n	c0ded3c2 <ux_stack_display_elements+0x36>
c0ded3fe:	2000      	movs	r0, #0
c0ded400:	e7d1      	b.n	c0ded3a6 <ux_stack_display_elements+0x1a>
c0ded402:	8860      	ldrh	r0, [r4, #2]
    if (slot->element_index == total_element_count) {
c0ded404:	9900      	ldr	r1, [sp, #0]
c0ded406:	4281      	cmp	r1, r0
c0ded408:	d111      	bne.n	c0ded42e <ux_stack_display_elements+0xa2>
      screen_update();
c0ded40a:	f7fb ffbb 	bl	c0de9384 <screen_update>
      slot->element_index++;
c0ded40e:	8860      	ldrh	r0, [r4, #2]
c0ded410:	1c40      	adds	r0, r0, #1
c0ded412:	8060      	strh	r0, [r4, #2]
      if (slot->displayed_callback) {
c0ded414:	68e1      	ldr	r1, [r4, #12]
c0ded416:	2900      	cmp	r1, #0
c0ded418:	d004      	beq.n	c0ded424 <ux_stack_display_elements+0x98>
c0ded41a:	2500      	movs	r5, #0
        if (!slot->displayed_callback(0)) {
c0ded41c:	4628      	mov	r0, r5
c0ded41e:	4788      	blx	r1
c0ded420:	2800      	cmp	r0, #0
c0ded422:	d005      	beq.n	c0ded430 <ux_stack_display_elements+0xa4>
      G_ux.exit_code = slot->exit_code_after_elements_displayed;
c0ded424:	4648      	mov	r0, r9
c0ded426:	4905      	ldr	r1, [pc, #20]	; (c0ded43c <ux_stack_display_elements+0xb0>)
c0ded428:	1840      	adds	r0, r0, r1
c0ded42a:	7821      	ldrb	r1, [r4, #0]
c0ded42c:	7041      	strb	r1, [r0, #1]
}
c0ded42e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          slot->element_index = 0;
c0ded430:	8065      	strh	r5, [r4, #2]
          G_ux.exit_code      = BOLOS_UX_CONTINUE;
c0ded432:	4648      	mov	r0, r9
c0ded434:	4901      	ldr	r1, [pc, #4]	; (c0ded43c <ux_stack_display_elements+0xb0>)
c0ded436:	1840      	adds	r0, r0, r1
c0ded438:	7045      	strb	r5, [r0, #1]
}
c0ded43a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
c0ded43c:	00000330 	.word	0x00000330

c0ded440 <__udivsi3>:
c0ded440:	2200      	movs	r2, #0
c0ded442:	0843      	lsrs	r3, r0, #1
c0ded444:	428b      	cmp	r3, r1
c0ded446:	d374      	bcc.n	c0ded532 <__udivsi3+0xf2>
c0ded448:	0903      	lsrs	r3, r0, #4
c0ded44a:	428b      	cmp	r3, r1
c0ded44c:	d35f      	bcc.n	c0ded50e <__udivsi3+0xce>
c0ded44e:	0a03      	lsrs	r3, r0, #8
c0ded450:	428b      	cmp	r3, r1
c0ded452:	d344      	bcc.n	c0ded4de <__udivsi3+0x9e>
c0ded454:	0b03      	lsrs	r3, r0, #12
c0ded456:	428b      	cmp	r3, r1
c0ded458:	d328      	bcc.n	c0ded4ac <__udivsi3+0x6c>
c0ded45a:	0c03      	lsrs	r3, r0, #16
c0ded45c:	428b      	cmp	r3, r1
c0ded45e:	d30d      	bcc.n	c0ded47c <__udivsi3+0x3c>
c0ded460:	22ff      	movs	r2, #255	; 0xff
c0ded462:	0209      	lsls	r1, r1, #8
c0ded464:	ba12      	rev	r2, r2
c0ded466:	0c03      	lsrs	r3, r0, #16
c0ded468:	428b      	cmp	r3, r1
c0ded46a:	d302      	bcc.n	c0ded472 <__udivsi3+0x32>
c0ded46c:	1212      	asrs	r2, r2, #8
c0ded46e:	0209      	lsls	r1, r1, #8
c0ded470:	d065      	beq.n	c0ded53e <__udivsi3+0xfe>
c0ded472:	0b03      	lsrs	r3, r0, #12
c0ded474:	428b      	cmp	r3, r1
c0ded476:	d319      	bcc.n	c0ded4ac <__udivsi3+0x6c>
c0ded478:	e000      	b.n	c0ded47c <__udivsi3+0x3c>
c0ded47a:	0a09      	lsrs	r1, r1, #8
c0ded47c:	0bc3      	lsrs	r3, r0, #15
c0ded47e:	428b      	cmp	r3, r1
c0ded480:	d301      	bcc.n	c0ded486 <__udivsi3+0x46>
c0ded482:	03cb      	lsls	r3, r1, #15
c0ded484:	1ac0      	subs	r0, r0, r3
c0ded486:	4152      	adcs	r2, r2
c0ded488:	0b83      	lsrs	r3, r0, #14
c0ded48a:	428b      	cmp	r3, r1
c0ded48c:	d301      	bcc.n	c0ded492 <__udivsi3+0x52>
c0ded48e:	038b      	lsls	r3, r1, #14
c0ded490:	1ac0      	subs	r0, r0, r3
c0ded492:	4152      	adcs	r2, r2
c0ded494:	0b43      	lsrs	r3, r0, #13
c0ded496:	428b      	cmp	r3, r1
c0ded498:	d301      	bcc.n	c0ded49e <__udivsi3+0x5e>
c0ded49a:	034b      	lsls	r3, r1, #13
c0ded49c:	1ac0      	subs	r0, r0, r3
c0ded49e:	4152      	adcs	r2, r2
c0ded4a0:	0b03      	lsrs	r3, r0, #12
c0ded4a2:	428b      	cmp	r3, r1
c0ded4a4:	d301      	bcc.n	c0ded4aa <__udivsi3+0x6a>
c0ded4a6:	030b      	lsls	r3, r1, #12
c0ded4a8:	1ac0      	subs	r0, r0, r3
c0ded4aa:	4152      	adcs	r2, r2
c0ded4ac:	0ac3      	lsrs	r3, r0, #11
c0ded4ae:	428b      	cmp	r3, r1
c0ded4b0:	d301      	bcc.n	c0ded4b6 <__udivsi3+0x76>
c0ded4b2:	02cb      	lsls	r3, r1, #11
c0ded4b4:	1ac0      	subs	r0, r0, r3
c0ded4b6:	4152      	adcs	r2, r2
c0ded4b8:	0a83      	lsrs	r3, r0, #10
c0ded4ba:	428b      	cmp	r3, r1
c0ded4bc:	d301      	bcc.n	c0ded4c2 <__udivsi3+0x82>
c0ded4be:	028b      	lsls	r3, r1, #10
c0ded4c0:	1ac0      	subs	r0, r0, r3
c0ded4c2:	4152      	adcs	r2, r2
c0ded4c4:	0a43      	lsrs	r3, r0, #9
c0ded4c6:	428b      	cmp	r3, r1
c0ded4c8:	d301      	bcc.n	c0ded4ce <__udivsi3+0x8e>
c0ded4ca:	024b      	lsls	r3, r1, #9
c0ded4cc:	1ac0      	subs	r0, r0, r3
c0ded4ce:	4152      	adcs	r2, r2
c0ded4d0:	0a03      	lsrs	r3, r0, #8
c0ded4d2:	428b      	cmp	r3, r1
c0ded4d4:	d301      	bcc.n	c0ded4da <__udivsi3+0x9a>
c0ded4d6:	020b      	lsls	r3, r1, #8
c0ded4d8:	1ac0      	subs	r0, r0, r3
c0ded4da:	4152      	adcs	r2, r2
c0ded4dc:	d2cd      	bcs.n	c0ded47a <__udivsi3+0x3a>
c0ded4de:	09c3      	lsrs	r3, r0, #7
c0ded4e0:	428b      	cmp	r3, r1
c0ded4e2:	d301      	bcc.n	c0ded4e8 <__udivsi3+0xa8>
c0ded4e4:	01cb      	lsls	r3, r1, #7
c0ded4e6:	1ac0      	subs	r0, r0, r3
c0ded4e8:	4152      	adcs	r2, r2
c0ded4ea:	0983      	lsrs	r3, r0, #6
c0ded4ec:	428b      	cmp	r3, r1
c0ded4ee:	d301      	bcc.n	c0ded4f4 <__udivsi3+0xb4>
c0ded4f0:	018b      	lsls	r3, r1, #6
c0ded4f2:	1ac0      	subs	r0, r0, r3
c0ded4f4:	4152      	adcs	r2, r2
c0ded4f6:	0943      	lsrs	r3, r0, #5
c0ded4f8:	428b      	cmp	r3, r1
c0ded4fa:	d301      	bcc.n	c0ded500 <__udivsi3+0xc0>
c0ded4fc:	014b      	lsls	r3, r1, #5
c0ded4fe:	1ac0      	subs	r0, r0, r3
c0ded500:	4152      	adcs	r2, r2
c0ded502:	0903      	lsrs	r3, r0, #4
c0ded504:	428b      	cmp	r3, r1
c0ded506:	d301      	bcc.n	c0ded50c <__udivsi3+0xcc>
c0ded508:	010b      	lsls	r3, r1, #4
c0ded50a:	1ac0      	subs	r0, r0, r3
c0ded50c:	4152      	adcs	r2, r2
c0ded50e:	08c3      	lsrs	r3, r0, #3
c0ded510:	428b      	cmp	r3, r1
c0ded512:	d301      	bcc.n	c0ded518 <__udivsi3+0xd8>
c0ded514:	00cb      	lsls	r3, r1, #3
c0ded516:	1ac0      	subs	r0, r0, r3
c0ded518:	4152      	adcs	r2, r2
c0ded51a:	0883      	lsrs	r3, r0, #2
c0ded51c:	428b      	cmp	r3, r1
c0ded51e:	d301      	bcc.n	c0ded524 <__udivsi3+0xe4>
c0ded520:	008b      	lsls	r3, r1, #2
c0ded522:	1ac0      	subs	r0, r0, r3
c0ded524:	4152      	adcs	r2, r2
c0ded526:	0843      	lsrs	r3, r0, #1
c0ded528:	428b      	cmp	r3, r1
c0ded52a:	d301      	bcc.n	c0ded530 <__udivsi3+0xf0>
c0ded52c:	004b      	lsls	r3, r1, #1
c0ded52e:	1ac0      	subs	r0, r0, r3
c0ded530:	4152      	adcs	r2, r2
c0ded532:	1a41      	subs	r1, r0, r1
c0ded534:	d200      	bcs.n	c0ded538 <__udivsi3+0xf8>
c0ded536:	4601      	mov	r1, r0
c0ded538:	4152      	adcs	r2, r2
c0ded53a:	4610      	mov	r0, r2
c0ded53c:	4770      	bx	lr
c0ded53e:	e7ff      	b.n	c0ded540 <__udivsi3+0x100>
c0ded540:	b501      	push	{r0, lr}
c0ded542:	2000      	movs	r0, #0
c0ded544:	f000 f806 	bl	c0ded554 <__aeabi_idiv0>
c0ded548:	bd02      	pop	{r1, pc}
c0ded54a:	46c0      	nop			; (mov r8, r8)

c0ded54c <__aeabi_uidivmod>:
c0ded54c:	2900      	cmp	r1, #0
c0ded54e:	d0f7      	beq.n	c0ded540 <__udivsi3+0x100>
c0ded550:	e776      	b.n	c0ded440 <__udivsi3>
c0ded552:	4770      	bx	lr

c0ded554 <__aeabi_idiv0>:
c0ded554:	4770      	bx	lr
c0ded556:	46c0      	nop			; (mov r8, r8)

c0ded558 <__aeabi_llsr>:
c0ded558:	40d0      	lsrs	r0, r2
c0ded55a:	1c0b      	adds	r3, r1, #0
c0ded55c:	40d1      	lsrs	r1, r2
c0ded55e:	469c      	mov	ip, r3
c0ded560:	3a20      	subs	r2, #32
c0ded562:	40d3      	lsrs	r3, r2
c0ded564:	4318      	orrs	r0, r3
c0ded566:	4252      	negs	r2, r2
c0ded568:	4663      	mov	r3, ip
c0ded56a:	4093      	lsls	r3, r2
c0ded56c:	4318      	orrs	r0, r3
c0ded56e:	4770      	bx	lr

c0ded570 <__aeabi_llsl>:
c0ded570:	4091      	lsls	r1, r2
c0ded572:	1c03      	adds	r3, r0, #0
c0ded574:	4090      	lsls	r0, r2
c0ded576:	469c      	mov	ip, r3
c0ded578:	3a20      	subs	r2, #32
c0ded57a:	4093      	lsls	r3, r2
c0ded57c:	4319      	orrs	r1, r3
c0ded57e:	4252      	negs	r2, r2
c0ded580:	4663      	mov	r3, ip
c0ded582:	40d3      	lsrs	r3, r2
c0ded584:	4319      	orrs	r1, r3
c0ded586:	4770      	bx	lr

c0ded588 <__aeabi_uldivmod>:
c0ded588:	2b00      	cmp	r3, #0
c0ded58a:	d111      	bne.n	c0ded5b0 <__aeabi_uldivmod+0x28>
c0ded58c:	2a00      	cmp	r2, #0
c0ded58e:	d10f      	bne.n	c0ded5b0 <__aeabi_uldivmod+0x28>
c0ded590:	2900      	cmp	r1, #0
c0ded592:	d100      	bne.n	c0ded596 <__aeabi_uldivmod+0xe>
c0ded594:	2800      	cmp	r0, #0
c0ded596:	d002      	beq.n	c0ded59e <__aeabi_uldivmod+0x16>
c0ded598:	2100      	movs	r1, #0
c0ded59a:	43c9      	mvns	r1, r1
c0ded59c:	1c08      	adds	r0, r1, #0
c0ded59e:	b407      	push	{r0, r1, r2}
c0ded5a0:	4802      	ldr	r0, [pc, #8]	; (c0ded5ac <__aeabi_uldivmod+0x24>)
c0ded5a2:	a102      	add	r1, pc, #8	; (adr r1, c0ded5ac <__aeabi_uldivmod+0x24>)
c0ded5a4:	1840      	adds	r0, r0, r1
c0ded5a6:	9002      	str	r0, [sp, #8]
c0ded5a8:	bd03      	pop	{r0, r1, pc}
c0ded5aa:	46c0      	nop			; (mov r8, r8)
c0ded5ac:	ffffffa9 	.word	0xffffffa9
c0ded5b0:	b403      	push	{r0, r1}
c0ded5b2:	4668      	mov	r0, sp
c0ded5b4:	b501      	push	{r0, lr}
c0ded5b6:	9802      	ldr	r0, [sp, #8]
c0ded5b8:	f000 f830 	bl	c0ded61c <__udivmoddi4>
c0ded5bc:	9b01      	ldr	r3, [sp, #4]
c0ded5be:	469e      	mov	lr, r3
c0ded5c0:	b002      	add	sp, #8
c0ded5c2:	bc0c      	pop	{r2, r3}
c0ded5c4:	4770      	bx	lr
c0ded5c6:	46c0      	nop			; (mov r8, r8)

c0ded5c8 <__aeabi_lmul>:
c0ded5c8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0ded5ca:	46ce      	mov	lr, r9
c0ded5cc:	4647      	mov	r7, r8
c0ded5ce:	0415      	lsls	r5, r2, #16
c0ded5d0:	0c2d      	lsrs	r5, r5, #16
c0ded5d2:	002e      	movs	r6, r5
c0ded5d4:	b580      	push	{r7, lr}
c0ded5d6:	0407      	lsls	r7, r0, #16
c0ded5d8:	0c14      	lsrs	r4, r2, #16
c0ded5da:	0c3f      	lsrs	r7, r7, #16
c0ded5dc:	4699      	mov	r9, r3
c0ded5de:	0c03      	lsrs	r3, r0, #16
c0ded5e0:	437e      	muls	r6, r7
c0ded5e2:	435d      	muls	r5, r3
c0ded5e4:	4367      	muls	r7, r4
c0ded5e6:	4363      	muls	r3, r4
c0ded5e8:	197f      	adds	r7, r7, r5
c0ded5ea:	0c34      	lsrs	r4, r6, #16
c0ded5ec:	19e4      	adds	r4, r4, r7
c0ded5ee:	469c      	mov	ip, r3
c0ded5f0:	42a5      	cmp	r5, r4
c0ded5f2:	d903      	bls.n	c0ded5fc <__aeabi_lmul+0x34>
c0ded5f4:	2380      	movs	r3, #128	; 0x80
c0ded5f6:	025b      	lsls	r3, r3, #9
c0ded5f8:	4698      	mov	r8, r3
c0ded5fa:	44c4      	add	ip, r8
c0ded5fc:	464b      	mov	r3, r9
c0ded5fe:	4343      	muls	r3, r0
c0ded600:	4351      	muls	r1, r2
c0ded602:	0c25      	lsrs	r5, r4, #16
c0ded604:	0436      	lsls	r6, r6, #16
c0ded606:	4465      	add	r5, ip
c0ded608:	0c36      	lsrs	r6, r6, #16
c0ded60a:	0424      	lsls	r4, r4, #16
c0ded60c:	19a4      	adds	r4, r4, r6
c0ded60e:	195b      	adds	r3, r3, r5
c0ded610:	1859      	adds	r1, r3, r1
c0ded612:	0020      	movs	r0, r4
c0ded614:	bc0c      	pop	{r2, r3}
c0ded616:	4690      	mov	r8, r2
c0ded618:	4699      	mov	r9, r3
c0ded61a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0ded61c <__udivmoddi4>:
c0ded61c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0ded61e:	4657      	mov	r7, sl
c0ded620:	464e      	mov	r6, r9
c0ded622:	4645      	mov	r5, r8
c0ded624:	46de      	mov	lr, fp
c0ded626:	b5e0      	push	{r5, r6, r7, lr}
c0ded628:	0004      	movs	r4, r0
c0ded62a:	b083      	sub	sp, #12
c0ded62c:	000d      	movs	r5, r1
c0ded62e:	4692      	mov	sl, r2
c0ded630:	4699      	mov	r9, r3
c0ded632:	428b      	cmp	r3, r1
c0ded634:	d830      	bhi.n	c0ded698 <__udivmoddi4+0x7c>
c0ded636:	d02d      	beq.n	c0ded694 <__udivmoddi4+0x78>
c0ded638:	4649      	mov	r1, r9
c0ded63a:	4650      	mov	r0, sl
c0ded63c:	f000 f8c0 	bl	c0ded7c0 <__clzdi2>
c0ded640:	0029      	movs	r1, r5
c0ded642:	0006      	movs	r6, r0
c0ded644:	0020      	movs	r0, r4
c0ded646:	f000 f8bb 	bl	c0ded7c0 <__clzdi2>
c0ded64a:	1a33      	subs	r3, r6, r0
c0ded64c:	4698      	mov	r8, r3
c0ded64e:	3b20      	subs	r3, #32
c0ded650:	469b      	mov	fp, r3
c0ded652:	d433      	bmi.n	c0ded6bc <__udivmoddi4+0xa0>
c0ded654:	465a      	mov	r2, fp
c0ded656:	4653      	mov	r3, sl
c0ded658:	4093      	lsls	r3, r2
c0ded65a:	4642      	mov	r2, r8
c0ded65c:	001f      	movs	r7, r3
c0ded65e:	4653      	mov	r3, sl
c0ded660:	4093      	lsls	r3, r2
c0ded662:	001e      	movs	r6, r3
c0ded664:	42af      	cmp	r7, r5
c0ded666:	d83a      	bhi.n	c0ded6de <__udivmoddi4+0xc2>
c0ded668:	42af      	cmp	r7, r5
c0ded66a:	d100      	bne.n	c0ded66e <__udivmoddi4+0x52>
c0ded66c:	e07b      	b.n	c0ded766 <__udivmoddi4+0x14a>
c0ded66e:	465b      	mov	r3, fp
c0ded670:	1ba4      	subs	r4, r4, r6
c0ded672:	41bd      	sbcs	r5, r7
c0ded674:	2b00      	cmp	r3, #0
c0ded676:	da00      	bge.n	c0ded67a <__udivmoddi4+0x5e>
c0ded678:	e078      	b.n	c0ded76c <__udivmoddi4+0x150>
c0ded67a:	2200      	movs	r2, #0
c0ded67c:	2300      	movs	r3, #0
c0ded67e:	9200      	str	r2, [sp, #0]
c0ded680:	9301      	str	r3, [sp, #4]
c0ded682:	2301      	movs	r3, #1
c0ded684:	465a      	mov	r2, fp
c0ded686:	4093      	lsls	r3, r2
c0ded688:	9301      	str	r3, [sp, #4]
c0ded68a:	2301      	movs	r3, #1
c0ded68c:	4642      	mov	r2, r8
c0ded68e:	4093      	lsls	r3, r2
c0ded690:	9300      	str	r3, [sp, #0]
c0ded692:	e028      	b.n	c0ded6e6 <__udivmoddi4+0xca>
c0ded694:	4282      	cmp	r2, r0
c0ded696:	d9cf      	bls.n	c0ded638 <__udivmoddi4+0x1c>
c0ded698:	2200      	movs	r2, #0
c0ded69a:	2300      	movs	r3, #0
c0ded69c:	9200      	str	r2, [sp, #0]
c0ded69e:	9301      	str	r3, [sp, #4]
c0ded6a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
c0ded6a2:	2b00      	cmp	r3, #0
c0ded6a4:	d001      	beq.n	c0ded6aa <__udivmoddi4+0x8e>
c0ded6a6:	601c      	str	r4, [r3, #0]
c0ded6a8:	605d      	str	r5, [r3, #4]
c0ded6aa:	9800      	ldr	r0, [sp, #0]
c0ded6ac:	9901      	ldr	r1, [sp, #4]
c0ded6ae:	b003      	add	sp, #12
c0ded6b0:	bc3c      	pop	{r2, r3, r4, r5}
c0ded6b2:	4690      	mov	r8, r2
c0ded6b4:	4699      	mov	r9, r3
c0ded6b6:	46a2      	mov	sl, r4
c0ded6b8:	46ab      	mov	fp, r5
c0ded6ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0ded6bc:	4642      	mov	r2, r8
c0ded6be:	2320      	movs	r3, #32
c0ded6c0:	1a9b      	subs	r3, r3, r2
c0ded6c2:	4652      	mov	r2, sl
c0ded6c4:	40da      	lsrs	r2, r3
c0ded6c6:	4641      	mov	r1, r8
c0ded6c8:	0013      	movs	r3, r2
c0ded6ca:	464a      	mov	r2, r9
c0ded6cc:	408a      	lsls	r2, r1
c0ded6ce:	0017      	movs	r7, r2
c0ded6d0:	4642      	mov	r2, r8
c0ded6d2:	431f      	orrs	r7, r3
c0ded6d4:	4653      	mov	r3, sl
c0ded6d6:	4093      	lsls	r3, r2
c0ded6d8:	001e      	movs	r6, r3
c0ded6da:	42af      	cmp	r7, r5
c0ded6dc:	d9c4      	bls.n	c0ded668 <__udivmoddi4+0x4c>
c0ded6de:	2200      	movs	r2, #0
c0ded6e0:	2300      	movs	r3, #0
c0ded6e2:	9200      	str	r2, [sp, #0]
c0ded6e4:	9301      	str	r3, [sp, #4]
c0ded6e6:	4643      	mov	r3, r8
c0ded6e8:	2b00      	cmp	r3, #0
c0ded6ea:	d0d9      	beq.n	c0ded6a0 <__udivmoddi4+0x84>
c0ded6ec:	07fb      	lsls	r3, r7, #31
c0ded6ee:	469c      	mov	ip, r3
c0ded6f0:	4661      	mov	r1, ip
c0ded6f2:	0872      	lsrs	r2, r6, #1
c0ded6f4:	430a      	orrs	r2, r1
c0ded6f6:	087b      	lsrs	r3, r7, #1
c0ded6f8:	4646      	mov	r6, r8
c0ded6fa:	e00e      	b.n	c0ded71a <__udivmoddi4+0xfe>
c0ded6fc:	42ab      	cmp	r3, r5
c0ded6fe:	d101      	bne.n	c0ded704 <__udivmoddi4+0xe8>
c0ded700:	42a2      	cmp	r2, r4
c0ded702:	d80c      	bhi.n	c0ded71e <__udivmoddi4+0x102>
c0ded704:	1aa4      	subs	r4, r4, r2
c0ded706:	419d      	sbcs	r5, r3
c0ded708:	2001      	movs	r0, #1
c0ded70a:	1924      	adds	r4, r4, r4
c0ded70c:	416d      	adcs	r5, r5
c0ded70e:	2100      	movs	r1, #0
c0ded710:	3e01      	subs	r6, #1
c0ded712:	1824      	adds	r4, r4, r0
c0ded714:	414d      	adcs	r5, r1
c0ded716:	2e00      	cmp	r6, #0
c0ded718:	d006      	beq.n	c0ded728 <__udivmoddi4+0x10c>
c0ded71a:	42ab      	cmp	r3, r5
c0ded71c:	d9ee      	bls.n	c0ded6fc <__udivmoddi4+0xe0>
c0ded71e:	3e01      	subs	r6, #1
c0ded720:	1924      	adds	r4, r4, r4
c0ded722:	416d      	adcs	r5, r5
c0ded724:	2e00      	cmp	r6, #0
c0ded726:	d1f8      	bne.n	c0ded71a <__udivmoddi4+0xfe>
c0ded728:	9800      	ldr	r0, [sp, #0]
c0ded72a:	9901      	ldr	r1, [sp, #4]
c0ded72c:	465b      	mov	r3, fp
c0ded72e:	1900      	adds	r0, r0, r4
c0ded730:	4169      	adcs	r1, r5
c0ded732:	2b00      	cmp	r3, #0
c0ded734:	db25      	blt.n	c0ded782 <__udivmoddi4+0x166>
c0ded736:	002b      	movs	r3, r5
c0ded738:	465a      	mov	r2, fp
c0ded73a:	4644      	mov	r4, r8
c0ded73c:	40d3      	lsrs	r3, r2
c0ded73e:	002a      	movs	r2, r5
c0ded740:	40e2      	lsrs	r2, r4
c0ded742:	001c      	movs	r4, r3
c0ded744:	465b      	mov	r3, fp
c0ded746:	0015      	movs	r5, r2
c0ded748:	2b00      	cmp	r3, #0
c0ded74a:	db2b      	blt.n	c0ded7a4 <__udivmoddi4+0x188>
c0ded74c:	0026      	movs	r6, r4
c0ded74e:	465f      	mov	r7, fp
c0ded750:	40be      	lsls	r6, r7
c0ded752:	0033      	movs	r3, r6
c0ded754:	0026      	movs	r6, r4
c0ded756:	4647      	mov	r7, r8
c0ded758:	40be      	lsls	r6, r7
c0ded75a:	0032      	movs	r2, r6
c0ded75c:	1a80      	subs	r0, r0, r2
c0ded75e:	4199      	sbcs	r1, r3
c0ded760:	9000      	str	r0, [sp, #0]
c0ded762:	9101      	str	r1, [sp, #4]
c0ded764:	e79c      	b.n	c0ded6a0 <__udivmoddi4+0x84>
c0ded766:	42a3      	cmp	r3, r4
c0ded768:	d8b9      	bhi.n	c0ded6de <__udivmoddi4+0xc2>
c0ded76a:	e780      	b.n	c0ded66e <__udivmoddi4+0x52>
c0ded76c:	4642      	mov	r2, r8
c0ded76e:	2320      	movs	r3, #32
c0ded770:	2100      	movs	r1, #0
c0ded772:	1a9b      	subs	r3, r3, r2
c0ded774:	2200      	movs	r2, #0
c0ded776:	9100      	str	r1, [sp, #0]
c0ded778:	9201      	str	r2, [sp, #4]
c0ded77a:	2201      	movs	r2, #1
c0ded77c:	40da      	lsrs	r2, r3
c0ded77e:	9201      	str	r2, [sp, #4]
c0ded780:	e783      	b.n	c0ded68a <__udivmoddi4+0x6e>
c0ded782:	4642      	mov	r2, r8
c0ded784:	2320      	movs	r3, #32
c0ded786:	1a9b      	subs	r3, r3, r2
c0ded788:	002a      	movs	r2, r5
c0ded78a:	4646      	mov	r6, r8
c0ded78c:	409a      	lsls	r2, r3
c0ded78e:	0023      	movs	r3, r4
c0ded790:	40f3      	lsrs	r3, r6
c0ded792:	4644      	mov	r4, r8
c0ded794:	4313      	orrs	r3, r2
c0ded796:	002a      	movs	r2, r5
c0ded798:	40e2      	lsrs	r2, r4
c0ded79a:	001c      	movs	r4, r3
c0ded79c:	465b      	mov	r3, fp
c0ded79e:	0015      	movs	r5, r2
c0ded7a0:	2b00      	cmp	r3, #0
c0ded7a2:	dad3      	bge.n	c0ded74c <__udivmoddi4+0x130>
c0ded7a4:	2320      	movs	r3, #32
c0ded7a6:	4642      	mov	r2, r8
c0ded7a8:	0026      	movs	r6, r4
c0ded7aa:	1a9b      	subs	r3, r3, r2
c0ded7ac:	40de      	lsrs	r6, r3
c0ded7ae:	002f      	movs	r7, r5
c0ded7b0:	46b4      	mov	ip, r6
c0ded7b2:	4646      	mov	r6, r8
c0ded7b4:	40b7      	lsls	r7, r6
c0ded7b6:	4666      	mov	r6, ip
c0ded7b8:	003b      	movs	r3, r7
c0ded7ba:	4333      	orrs	r3, r6
c0ded7bc:	e7ca      	b.n	c0ded754 <__udivmoddi4+0x138>
c0ded7be:	46c0      	nop			; (mov r8, r8)

c0ded7c0 <__clzdi2>:
c0ded7c0:	b510      	push	{r4, lr}
c0ded7c2:	2900      	cmp	r1, #0
c0ded7c4:	d103      	bne.n	c0ded7ce <__clzdi2+0xe>
c0ded7c6:	f000 f807 	bl	c0ded7d8 <__clzsi2>
c0ded7ca:	3020      	adds	r0, #32
c0ded7cc:	e002      	b.n	c0ded7d4 <__clzdi2+0x14>
c0ded7ce:	1c08      	adds	r0, r1, #0
c0ded7d0:	f000 f802 	bl	c0ded7d8 <__clzsi2>
c0ded7d4:	bd10      	pop	{r4, pc}
c0ded7d6:	46c0      	nop			; (mov r8, r8)

c0ded7d8 <__clzsi2>:
c0ded7d8:	211c      	movs	r1, #28
c0ded7da:	2301      	movs	r3, #1
c0ded7dc:	041b      	lsls	r3, r3, #16
c0ded7de:	4298      	cmp	r0, r3
c0ded7e0:	d301      	bcc.n	c0ded7e6 <__clzsi2+0xe>
c0ded7e2:	0c00      	lsrs	r0, r0, #16
c0ded7e4:	3910      	subs	r1, #16
c0ded7e6:	0a1b      	lsrs	r3, r3, #8
c0ded7e8:	4298      	cmp	r0, r3
c0ded7ea:	d301      	bcc.n	c0ded7f0 <__clzsi2+0x18>
c0ded7ec:	0a00      	lsrs	r0, r0, #8
c0ded7ee:	3908      	subs	r1, #8
c0ded7f0:	091b      	lsrs	r3, r3, #4
c0ded7f2:	4298      	cmp	r0, r3
c0ded7f4:	d301      	bcc.n	c0ded7fa <__clzsi2+0x22>
c0ded7f6:	0900      	lsrs	r0, r0, #4
c0ded7f8:	3904      	subs	r1, #4
c0ded7fa:	a202      	add	r2, pc, #8	; (adr r2, c0ded804 <__clzsi2+0x2c>)
c0ded7fc:	5c10      	ldrb	r0, [r2, r0]
c0ded7fe:	1840      	adds	r0, r0, r1
c0ded800:	4770      	bx	lr
c0ded802:	46c0      	nop			; (mov r8, r8)
c0ded804:	02020304 	.word	0x02020304
c0ded808:	01010101 	.word	0x01010101
	...

c0ded814 <__aeabi_memclr>:
c0ded814:	b510      	push	{r4, lr}
c0ded816:	2200      	movs	r2, #0
c0ded818:	f000 f80a 	bl	c0ded830 <__aeabi_memset>
c0ded81c:	bd10      	pop	{r4, pc}
c0ded81e:	46c0      	nop			; (mov r8, r8)

c0ded820 <__aeabi_memcpy>:
c0ded820:	b510      	push	{r4, lr}
c0ded822:	f000 f83f 	bl	c0ded8a4 <memcpy>
c0ded826:	bd10      	pop	{r4, pc}

c0ded828 <__aeabi_memmove>:
c0ded828:	b510      	push	{r4, lr}
c0ded82a:	f000 f88f 	bl	c0ded94c <memmove>
c0ded82e:	bd10      	pop	{r4, pc}

c0ded830 <__aeabi_memset>:
c0ded830:	0013      	movs	r3, r2
c0ded832:	b510      	push	{r4, lr}
c0ded834:	000a      	movs	r2, r1
c0ded836:	0019      	movs	r1, r3
c0ded838:	f000 f8e6 	bl	c0deda08 <memset>
c0ded83c:	bd10      	pop	{r4, pc}
c0ded83e:	46c0      	nop			; (mov r8, r8)

c0ded840 <explicit_bzero>:
c0ded840:	b510      	push	{r4, lr}
c0ded842:	f000 f801 	bl	c0ded848 <bzero>
c0ded846:	bd10      	pop	{r4, pc}

c0ded848 <bzero>:
c0ded848:	b510      	push	{r4, lr}
c0ded84a:	000a      	movs	r2, r1
c0ded84c:	2100      	movs	r1, #0
c0ded84e:	f000 f8db 	bl	c0deda08 <memset>
c0ded852:	bd10      	pop	{r4, pc}

c0ded854 <memcmp>:
c0ded854:	b530      	push	{r4, r5, lr}
c0ded856:	2a03      	cmp	r2, #3
c0ded858:	d90c      	bls.n	c0ded874 <memcmp+0x20>
c0ded85a:	0003      	movs	r3, r0
c0ded85c:	430b      	orrs	r3, r1
c0ded85e:	079b      	lsls	r3, r3, #30
c0ded860:	d11c      	bne.n	c0ded89c <memcmp+0x48>
c0ded862:	6803      	ldr	r3, [r0, #0]
c0ded864:	680c      	ldr	r4, [r1, #0]
c0ded866:	42a3      	cmp	r3, r4
c0ded868:	d118      	bne.n	c0ded89c <memcmp+0x48>
c0ded86a:	3a04      	subs	r2, #4
c0ded86c:	3004      	adds	r0, #4
c0ded86e:	3104      	adds	r1, #4
c0ded870:	2a03      	cmp	r2, #3
c0ded872:	d8f6      	bhi.n	c0ded862 <memcmp+0xe>
c0ded874:	1e55      	subs	r5, r2, #1
c0ded876:	2a00      	cmp	r2, #0
c0ded878:	d00e      	beq.n	c0ded898 <memcmp+0x44>
c0ded87a:	7802      	ldrb	r2, [r0, #0]
c0ded87c:	780c      	ldrb	r4, [r1, #0]
c0ded87e:	4294      	cmp	r4, r2
c0ded880:	d10e      	bne.n	c0ded8a0 <memcmp+0x4c>
c0ded882:	3501      	adds	r5, #1
c0ded884:	2301      	movs	r3, #1
c0ded886:	3901      	subs	r1, #1
c0ded888:	e004      	b.n	c0ded894 <memcmp+0x40>
c0ded88a:	5cc2      	ldrb	r2, [r0, r3]
c0ded88c:	3301      	adds	r3, #1
c0ded88e:	5ccc      	ldrb	r4, [r1, r3]
c0ded890:	42a2      	cmp	r2, r4
c0ded892:	d105      	bne.n	c0ded8a0 <memcmp+0x4c>
c0ded894:	42ab      	cmp	r3, r5
c0ded896:	d1f8      	bne.n	c0ded88a <memcmp+0x36>
c0ded898:	2000      	movs	r0, #0
c0ded89a:	bd30      	pop	{r4, r5, pc}
c0ded89c:	1e55      	subs	r5, r2, #1
c0ded89e:	e7ec      	b.n	c0ded87a <memcmp+0x26>
c0ded8a0:	1b10      	subs	r0, r2, r4
c0ded8a2:	e7fa      	b.n	c0ded89a <memcmp+0x46>

c0ded8a4 <memcpy>:
c0ded8a4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0ded8a6:	46c6      	mov	lr, r8
c0ded8a8:	b500      	push	{lr}
c0ded8aa:	2a0f      	cmp	r2, #15
c0ded8ac:	d943      	bls.n	c0ded936 <memcpy+0x92>
c0ded8ae:	000b      	movs	r3, r1
c0ded8b0:	2603      	movs	r6, #3
c0ded8b2:	4303      	orrs	r3, r0
c0ded8b4:	401e      	ands	r6, r3
c0ded8b6:	000c      	movs	r4, r1
c0ded8b8:	0003      	movs	r3, r0
c0ded8ba:	2e00      	cmp	r6, #0
c0ded8bc:	d140      	bne.n	c0ded940 <memcpy+0x9c>
c0ded8be:	0015      	movs	r5, r2
c0ded8c0:	3d10      	subs	r5, #16
c0ded8c2:	092d      	lsrs	r5, r5, #4
c0ded8c4:	46ac      	mov	ip, r5
c0ded8c6:	012d      	lsls	r5, r5, #4
c0ded8c8:	46a8      	mov	r8, r5
c0ded8ca:	4480      	add	r8, r0
c0ded8cc:	e000      	b.n	c0ded8d0 <memcpy+0x2c>
c0ded8ce:	003b      	movs	r3, r7
c0ded8d0:	6867      	ldr	r7, [r4, #4]
c0ded8d2:	6825      	ldr	r5, [r4, #0]
c0ded8d4:	605f      	str	r7, [r3, #4]
c0ded8d6:	68e7      	ldr	r7, [r4, #12]
c0ded8d8:	601d      	str	r5, [r3, #0]
c0ded8da:	60df      	str	r7, [r3, #12]
c0ded8dc:	001f      	movs	r7, r3
c0ded8de:	68a5      	ldr	r5, [r4, #8]
c0ded8e0:	3710      	adds	r7, #16
c0ded8e2:	609d      	str	r5, [r3, #8]
c0ded8e4:	3410      	adds	r4, #16
c0ded8e6:	4543      	cmp	r3, r8
c0ded8e8:	d1f1      	bne.n	c0ded8ce <memcpy+0x2a>
c0ded8ea:	4665      	mov	r5, ip
c0ded8ec:	230f      	movs	r3, #15
c0ded8ee:	240c      	movs	r4, #12
c0ded8f0:	3501      	adds	r5, #1
c0ded8f2:	012d      	lsls	r5, r5, #4
c0ded8f4:	1949      	adds	r1, r1, r5
c0ded8f6:	4013      	ands	r3, r2
c0ded8f8:	1945      	adds	r5, r0, r5
c0ded8fa:	4214      	tst	r4, r2
c0ded8fc:	d023      	beq.n	c0ded946 <memcpy+0xa2>
c0ded8fe:	598c      	ldr	r4, [r1, r6]
c0ded900:	51ac      	str	r4, [r5, r6]
c0ded902:	3604      	adds	r6, #4
c0ded904:	1b9c      	subs	r4, r3, r6
c0ded906:	2c03      	cmp	r4, #3
c0ded908:	d8f9      	bhi.n	c0ded8fe <memcpy+0x5a>
c0ded90a:	2403      	movs	r4, #3
c0ded90c:	3b04      	subs	r3, #4
c0ded90e:	089b      	lsrs	r3, r3, #2
c0ded910:	3301      	adds	r3, #1
c0ded912:	009b      	lsls	r3, r3, #2
c0ded914:	4022      	ands	r2, r4
c0ded916:	18ed      	adds	r5, r5, r3
c0ded918:	18c9      	adds	r1, r1, r3
c0ded91a:	1e56      	subs	r6, r2, #1
c0ded91c:	2a00      	cmp	r2, #0
c0ded91e:	d007      	beq.n	c0ded930 <memcpy+0x8c>
c0ded920:	2300      	movs	r3, #0
c0ded922:	e000      	b.n	c0ded926 <memcpy+0x82>
c0ded924:	0023      	movs	r3, r4
c0ded926:	5cca      	ldrb	r2, [r1, r3]
c0ded928:	1c5c      	adds	r4, r3, #1
c0ded92a:	54ea      	strb	r2, [r5, r3]
c0ded92c:	429e      	cmp	r6, r3
c0ded92e:	d1f9      	bne.n	c0ded924 <memcpy+0x80>
c0ded930:	bc04      	pop	{r2}
c0ded932:	4690      	mov	r8, r2
c0ded934:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0ded936:	0005      	movs	r5, r0
c0ded938:	1e56      	subs	r6, r2, #1
c0ded93a:	2a00      	cmp	r2, #0
c0ded93c:	d1f0      	bne.n	c0ded920 <memcpy+0x7c>
c0ded93e:	e7f7      	b.n	c0ded930 <memcpy+0x8c>
c0ded940:	1e56      	subs	r6, r2, #1
c0ded942:	0005      	movs	r5, r0
c0ded944:	e7ec      	b.n	c0ded920 <memcpy+0x7c>
c0ded946:	001a      	movs	r2, r3
c0ded948:	e7f6      	b.n	c0ded938 <memcpy+0x94>
c0ded94a:	46c0      	nop			; (mov r8, r8)

c0ded94c <memmove>:
c0ded94c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0ded94e:	46c6      	mov	lr, r8
c0ded950:	b500      	push	{lr}
c0ded952:	4288      	cmp	r0, r1
c0ded954:	d90c      	bls.n	c0ded970 <memmove+0x24>
c0ded956:	188b      	adds	r3, r1, r2
c0ded958:	4298      	cmp	r0, r3
c0ded95a:	d209      	bcs.n	c0ded970 <memmove+0x24>
c0ded95c:	1e53      	subs	r3, r2, #1
c0ded95e:	2a00      	cmp	r2, #0
c0ded960:	d003      	beq.n	c0ded96a <memmove+0x1e>
c0ded962:	5cca      	ldrb	r2, [r1, r3]
c0ded964:	54c2      	strb	r2, [r0, r3]
c0ded966:	3b01      	subs	r3, #1
c0ded968:	d2fb      	bcs.n	c0ded962 <memmove+0x16>
c0ded96a:	bc04      	pop	{r2}
c0ded96c:	4690      	mov	r8, r2
c0ded96e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0ded970:	2a0f      	cmp	r2, #15
c0ded972:	d80c      	bhi.n	c0ded98e <memmove+0x42>
c0ded974:	0005      	movs	r5, r0
c0ded976:	1e56      	subs	r6, r2, #1
c0ded978:	2a00      	cmp	r2, #0
c0ded97a:	d0f6      	beq.n	c0ded96a <memmove+0x1e>
c0ded97c:	2300      	movs	r3, #0
c0ded97e:	e000      	b.n	c0ded982 <memmove+0x36>
c0ded980:	0023      	movs	r3, r4
c0ded982:	5cca      	ldrb	r2, [r1, r3]
c0ded984:	1c5c      	adds	r4, r3, #1
c0ded986:	54ea      	strb	r2, [r5, r3]
c0ded988:	429e      	cmp	r6, r3
c0ded98a:	d1f9      	bne.n	c0ded980 <memmove+0x34>
c0ded98c:	e7ed      	b.n	c0ded96a <memmove+0x1e>
c0ded98e:	000b      	movs	r3, r1
c0ded990:	2603      	movs	r6, #3
c0ded992:	4303      	orrs	r3, r0
c0ded994:	401e      	ands	r6, r3
c0ded996:	000c      	movs	r4, r1
c0ded998:	0003      	movs	r3, r0
c0ded99a:	2e00      	cmp	r6, #0
c0ded99c:	d12e      	bne.n	c0ded9fc <memmove+0xb0>
c0ded99e:	0015      	movs	r5, r2
c0ded9a0:	3d10      	subs	r5, #16
c0ded9a2:	092d      	lsrs	r5, r5, #4
c0ded9a4:	46ac      	mov	ip, r5
c0ded9a6:	012d      	lsls	r5, r5, #4
c0ded9a8:	46a8      	mov	r8, r5
c0ded9aa:	4480      	add	r8, r0
c0ded9ac:	e000      	b.n	c0ded9b0 <memmove+0x64>
c0ded9ae:	002b      	movs	r3, r5
c0ded9b0:	001d      	movs	r5, r3
c0ded9b2:	6827      	ldr	r7, [r4, #0]
c0ded9b4:	3510      	adds	r5, #16
c0ded9b6:	601f      	str	r7, [r3, #0]
c0ded9b8:	6867      	ldr	r7, [r4, #4]
c0ded9ba:	605f      	str	r7, [r3, #4]
c0ded9bc:	68a7      	ldr	r7, [r4, #8]
c0ded9be:	609f      	str	r7, [r3, #8]
c0ded9c0:	68e7      	ldr	r7, [r4, #12]
c0ded9c2:	3410      	adds	r4, #16
c0ded9c4:	60df      	str	r7, [r3, #12]
c0ded9c6:	4543      	cmp	r3, r8
c0ded9c8:	d1f1      	bne.n	c0ded9ae <memmove+0x62>
c0ded9ca:	4665      	mov	r5, ip
c0ded9cc:	230f      	movs	r3, #15
c0ded9ce:	240c      	movs	r4, #12
c0ded9d0:	3501      	adds	r5, #1
c0ded9d2:	012d      	lsls	r5, r5, #4
c0ded9d4:	1949      	adds	r1, r1, r5
c0ded9d6:	4013      	ands	r3, r2
c0ded9d8:	1945      	adds	r5, r0, r5
c0ded9da:	4214      	tst	r4, r2
c0ded9dc:	d011      	beq.n	c0deda02 <memmove+0xb6>
c0ded9de:	598c      	ldr	r4, [r1, r6]
c0ded9e0:	51ac      	str	r4, [r5, r6]
c0ded9e2:	3604      	adds	r6, #4
c0ded9e4:	1b9c      	subs	r4, r3, r6
c0ded9e6:	2c03      	cmp	r4, #3
c0ded9e8:	d8f9      	bhi.n	c0ded9de <memmove+0x92>
c0ded9ea:	2403      	movs	r4, #3
c0ded9ec:	3b04      	subs	r3, #4
c0ded9ee:	089b      	lsrs	r3, r3, #2
c0ded9f0:	3301      	adds	r3, #1
c0ded9f2:	009b      	lsls	r3, r3, #2
c0ded9f4:	18ed      	adds	r5, r5, r3
c0ded9f6:	18c9      	adds	r1, r1, r3
c0ded9f8:	4022      	ands	r2, r4
c0ded9fa:	e7bc      	b.n	c0ded976 <memmove+0x2a>
c0ded9fc:	1e56      	subs	r6, r2, #1
c0ded9fe:	0005      	movs	r5, r0
c0deda00:	e7bc      	b.n	c0ded97c <memmove+0x30>
c0deda02:	001a      	movs	r2, r3
c0deda04:	e7b7      	b.n	c0ded976 <memmove+0x2a>
c0deda06:	46c0      	nop			; (mov r8, r8)

c0deda08 <memset>:
c0deda08:	b5f0      	push	{r4, r5, r6, r7, lr}
c0deda0a:	0005      	movs	r5, r0
c0deda0c:	0783      	lsls	r3, r0, #30
c0deda0e:	d04a      	beq.n	c0dedaa6 <memset+0x9e>
c0deda10:	1e54      	subs	r4, r2, #1
c0deda12:	2a00      	cmp	r2, #0
c0deda14:	d044      	beq.n	c0dedaa0 <memset+0x98>
c0deda16:	b2ce      	uxtb	r6, r1
c0deda18:	0003      	movs	r3, r0
c0deda1a:	2203      	movs	r2, #3
c0deda1c:	e002      	b.n	c0deda24 <memset+0x1c>
c0deda1e:	3501      	adds	r5, #1
c0deda20:	3c01      	subs	r4, #1
c0deda22:	d33d      	bcc.n	c0dedaa0 <memset+0x98>
c0deda24:	3301      	adds	r3, #1
c0deda26:	702e      	strb	r6, [r5, #0]
c0deda28:	4213      	tst	r3, r2
c0deda2a:	d1f8      	bne.n	c0deda1e <memset+0x16>
c0deda2c:	2c03      	cmp	r4, #3
c0deda2e:	d92f      	bls.n	c0deda90 <memset+0x88>
c0deda30:	22ff      	movs	r2, #255	; 0xff
c0deda32:	400a      	ands	r2, r1
c0deda34:	0215      	lsls	r5, r2, #8
c0deda36:	4315      	orrs	r5, r2
c0deda38:	042a      	lsls	r2, r5, #16
c0deda3a:	4315      	orrs	r5, r2
c0deda3c:	2c0f      	cmp	r4, #15
c0deda3e:	d935      	bls.n	c0dedaac <memset+0xa4>
c0deda40:	0027      	movs	r7, r4
c0deda42:	3f10      	subs	r7, #16
c0deda44:	093f      	lsrs	r7, r7, #4
c0deda46:	013e      	lsls	r6, r7, #4
c0deda48:	46b4      	mov	ip, r6
c0deda4a:	001e      	movs	r6, r3
c0deda4c:	001a      	movs	r2, r3
c0deda4e:	3610      	adds	r6, #16
c0deda50:	4466      	add	r6, ip
c0deda52:	6015      	str	r5, [r2, #0]
c0deda54:	6055      	str	r5, [r2, #4]
c0deda56:	6095      	str	r5, [r2, #8]
c0deda58:	60d5      	str	r5, [r2, #12]
c0deda5a:	3210      	adds	r2, #16
c0deda5c:	42b2      	cmp	r2, r6
c0deda5e:	d1f8      	bne.n	c0deda52 <memset+0x4a>
c0deda60:	260f      	movs	r6, #15
c0deda62:	220c      	movs	r2, #12
c0deda64:	3701      	adds	r7, #1
c0deda66:	013f      	lsls	r7, r7, #4
c0deda68:	4026      	ands	r6, r4
c0deda6a:	19db      	adds	r3, r3, r7
c0deda6c:	0037      	movs	r7, r6
c0deda6e:	4222      	tst	r2, r4
c0deda70:	d017      	beq.n	c0dedaa2 <memset+0x9a>
c0deda72:	1f3e      	subs	r6, r7, #4
c0deda74:	08b6      	lsrs	r6, r6, #2
c0deda76:	00b4      	lsls	r4, r6, #2
c0deda78:	46a4      	mov	ip, r4
c0deda7a:	001a      	movs	r2, r3
c0deda7c:	1d1c      	adds	r4, r3, #4
c0deda7e:	4464      	add	r4, ip
c0deda80:	c220      	stmia	r2!, {r5}
c0deda82:	42a2      	cmp	r2, r4
c0deda84:	d1fc      	bne.n	c0deda80 <memset+0x78>
c0deda86:	2403      	movs	r4, #3
c0deda88:	3601      	adds	r6, #1
c0deda8a:	00b6      	lsls	r6, r6, #2
c0deda8c:	199b      	adds	r3, r3, r6
c0deda8e:	403c      	ands	r4, r7
c0deda90:	2c00      	cmp	r4, #0
c0deda92:	d005      	beq.n	c0dedaa0 <memset+0x98>
c0deda94:	b2c9      	uxtb	r1, r1
c0deda96:	191c      	adds	r4, r3, r4
c0deda98:	7019      	strb	r1, [r3, #0]
c0deda9a:	3301      	adds	r3, #1
c0deda9c:	429c      	cmp	r4, r3
c0deda9e:	d1fb      	bne.n	c0deda98 <memset+0x90>
c0dedaa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dedaa2:	0034      	movs	r4, r6
c0dedaa4:	e7f4      	b.n	c0deda90 <memset+0x88>
c0dedaa6:	0014      	movs	r4, r2
c0dedaa8:	0003      	movs	r3, r0
c0dedaaa:	e7bf      	b.n	c0deda2c <memset+0x24>
c0dedaac:	0027      	movs	r7, r4
c0dedaae:	e7e0      	b.n	c0deda72 <memset+0x6a>

c0dedab0 <setjmp>:
c0dedab0:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
c0dedab2:	4641      	mov	r1, r8
c0dedab4:	464a      	mov	r2, r9
c0dedab6:	4653      	mov	r3, sl
c0dedab8:	465c      	mov	r4, fp
c0dedaba:	466d      	mov	r5, sp
c0dedabc:	4676      	mov	r6, lr
c0dedabe:	c07e      	stmia	r0!, {r1, r2, r3, r4, r5, r6}
c0dedac0:	3828      	subs	r0, #40	; 0x28
c0dedac2:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0dedac4:	2000      	movs	r0, #0
c0dedac6:	4770      	bx	lr

c0dedac8 <longjmp>:
c0dedac8:	3010      	adds	r0, #16
c0dedaca:	c87c      	ldmia	r0!, {r2, r3, r4, r5, r6}
c0dedacc:	4690      	mov	r8, r2
c0dedace:	4699      	mov	r9, r3
c0dedad0:	46a2      	mov	sl, r4
c0dedad2:	46ab      	mov	fp, r5
c0dedad4:	46b5      	mov	sp, r6
c0dedad6:	c808      	ldmia	r0!, {r3}
c0dedad8:	3828      	subs	r0, #40	; 0x28
c0dedada:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0dedadc:	1c08      	adds	r0, r1, #0
c0dedade:	d100      	bne.n	c0dedae2 <longjmp+0x1a>
c0dedae0:	2001      	movs	r0, #1
c0dedae2:	4718      	bx	r3

c0dedae4 <strcmp>:
c0dedae4:	4602      	mov	r2, r0
c0dedae6:	b570      	push	{r4, r5, r6, lr}
c0dedae8:	430a      	orrs	r2, r1
c0dedaea:	0792      	lsls	r2, r2, #30
c0dedaec:	d12a      	bne.n	c0dedb44 <strcmp+0x60>
c0dedaee:	4d1e      	ldr	r5, [pc, #120]	; (c0dedb68 <strcmp+0x84>)
c0dedaf0:	01ee      	lsls	r6, r5, #7
c0dedaf2:	c804      	ldmia	r0!, {r2}
c0dedaf4:	c908      	ldmia	r1!, {r3}
c0dedaf6:	1b54      	subs	r4, r2, r5
c0dedaf8:	4394      	bics	r4, r2
c0dedafa:	4034      	ands	r4, r6
c0dedafc:	d017      	beq.n	c0dedb2e <strcmp+0x4a>
c0dedafe:	b2d0      	uxtb	r0, r2
c0dedb00:	b2d9      	uxtb	r1, r3
c0dedb02:	1a40      	subs	r0, r0, r1
c0dedb04:	0621      	lsls	r1, r4, #24
c0dedb06:	4301      	orrs	r1, r0
c0dedb08:	d110      	bne.n	c0dedb2c <strcmp+0x48>
c0dedb0a:	b290      	uxth	r0, r2
c0dedb0c:	b299      	uxth	r1, r3
c0dedb0e:	1a40      	subs	r0, r0, r1
c0dedb10:	0421      	lsls	r1, r4, #16
c0dedb12:	4301      	orrs	r1, r0
c0dedb14:	d10a      	bne.n	c0dedb2c <strcmp+0x48>
c0dedb16:	0210      	lsls	r0, r2, #8
c0dedb18:	0219      	lsls	r1, r3, #8
c0dedb1a:	0a00      	lsrs	r0, r0, #8
c0dedb1c:	0a09      	lsrs	r1, r1, #8
c0dedb1e:	1a40      	subs	r0, r0, r1
c0dedb20:	0221      	lsls	r1, r4, #8
c0dedb22:	4301      	orrs	r1, r0
c0dedb24:	d102      	bne.n	c0dedb2c <strcmp+0x48>
c0dedb26:	0e10      	lsrs	r0, r2, #24
c0dedb28:	0e19      	lsrs	r1, r3, #24
c0dedb2a:	1a40      	subs	r0, r0, r1
c0dedb2c:	bd70      	pop	{r4, r5, r6, pc}
c0dedb2e:	429a      	cmp	r2, r3
c0dedb30:	d0df      	beq.n	c0dedaf2 <strcmp+0xe>
c0dedb32:	ba10      	rev	r0, r2
c0dedb34:	ba19      	rev	r1, r3
c0dedb36:	4288      	cmp	r0, r1
c0dedb38:	d901      	bls.n	c0dedb3e <strcmp+0x5a>
c0dedb3a:	2001      	movs	r0, #1
c0dedb3c:	bd70      	pop	{r4, r5, r6, pc}
c0dedb3e:	2000      	movs	r0, #0
c0dedb40:	43c0      	mvns	r0, r0
c0dedb42:	bd70      	pop	{r4, r5, r6, pc}
c0dedb44:	7802      	ldrb	r2, [r0, #0]
c0dedb46:	780b      	ldrb	r3, [r1, #0]
c0dedb48:	3001      	adds	r0, #1
c0dedb4a:	3101      	adds	r1, #1
c0dedb4c:	2a00      	cmp	r2, #0
c0dedb4e:	d009      	beq.n	c0dedb64 <strcmp+0x80>
c0dedb50:	429a      	cmp	r2, r3
c0dedb52:	d107      	bne.n	c0dedb64 <strcmp+0x80>
c0dedb54:	7802      	ldrb	r2, [r0, #0]
c0dedb56:	780b      	ldrb	r3, [r1, #0]
c0dedb58:	3001      	adds	r0, #1
c0dedb5a:	3101      	adds	r1, #1
c0dedb5c:	2a00      	cmp	r2, #0
c0dedb5e:	d001      	beq.n	c0dedb64 <strcmp+0x80>
c0dedb60:	429a      	cmp	r2, r3
c0dedb62:	d0ef      	beq.n	c0dedb44 <strcmp+0x60>
c0dedb64:	1ad0      	subs	r0, r2, r3
c0dedb66:	bd70      	pop	{r4, r5, r6, pc}
c0dedb68:	01010101 	.word	0x01010101

c0dedb6c <strlcat>:
c0dedb6c:	b570      	push	{r4, r5, r6, lr}
c0dedb6e:	2a00      	cmp	r2, #0
c0dedb70:	d02a      	beq.n	c0dedbc8 <strlcat+0x5c>
c0dedb72:	7803      	ldrb	r3, [r0, #0]
c0dedb74:	2b00      	cmp	r3, #0
c0dedb76:	d029      	beq.n	c0dedbcc <strlcat+0x60>
c0dedb78:	1884      	adds	r4, r0, r2
c0dedb7a:	0003      	movs	r3, r0
c0dedb7c:	e002      	b.n	c0dedb84 <strlcat+0x18>
c0dedb7e:	781d      	ldrb	r5, [r3, #0]
c0dedb80:	2d00      	cmp	r5, #0
c0dedb82:	d018      	beq.n	c0dedbb6 <strlcat+0x4a>
c0dedb84:	3301      	adds	r3, #1
c0dedb86:	42a3      	cmp	r3, r4
c0dedb88:	d1f9      	bne.n	c0dedb7e <strlcat+0x12>
c0dedb8a:	1a26      	subs	r6, r4, r0
c0dedb8c:	1b92      	subs	r2, r2, r6
c0dedb8e:	d016      	beq.n	c0dedbbe <strlcat+0x52>
c0dedb90:	780d      	ldrb	r5, [r1, #0]
c0dedb92:	000b      	movs	r3, r1
c0dedb94:	2d00      	cmp	r5, #0
c0dedb96:	d00a      	beq.n	c0dedbae <strlcat+0x42>
c0dedb98:	2a01      	cmp	r2, #1
c0dedb9a:	d002      	beq.n	c0dedba2 <strlcat+0x36>
c0dedb9c:	7025      	strb	r5, [r4, #0]
c0dedb9e:	3a01      	subs	r2, #1
c0dedba0:	3401      	adds	r4, #1
c0dedba2:	3301      	adds	r3, #1
c0dedba4:	781d      	ldrb	r5, [r3, #0]
c0dedba6:	2d00      	cmp	r5, #0
c0dedba8:	d1f6      	bne.n	c0dedb98 <strlcat+0x2c>
c0dedbaa:	1a5b      	subs	r3, r3, r1
c0dedbac:	18f6      	adds	r6, r6, r3
c0dedbae:	2300      	movs	r3, #0
c0dedbb0:	7023      	strb	r3, [r4, #0]
c0dedbb2:	0030      	movs	r0, r6
c0dedbb4:	bd70      	pop	{r4, r5, r6, pc}
c0dedbb6:	001c      	movs	r4, r3
c0dedbb8:	1a26      	subs	r6, r4, r0
c0dedbba:	1b92      	subs	r2, r2, r6
c0dedbbc:	d1e8      	bne.n	c0dedb90 <strlcat+0x24>
c0dedbbe:	0008      	movs	r0, r1
c0dedbc0:	f000 f82e 	bl	c0dedc20 <strlen>
c0dedbc4:	1836      	adds	r6, r6, r0
c0dedbc6:	e7f4      	b.n	c0dedbb2 <strlcat+0x46>
c0dedbc8:	2600      	movs	r6, #0
c0dedbca:	e7f8      	b.n	c0dedbbe <strlcat+0x52>
c0dedbcc:	0004      	movs	r4, r0
c0dedbce:	2600      	movs	r6, #0
c0dedbd0:	e7de      	b.n	c0dedb90 <strlcat+0x24>
c0dedbd2:	46c0      	nop			; (mov r8, r8)

c0dedbd4 <strlcpy>:
c0dedbd4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0dedbd6:	2a00      	cmp	r2, #0
c0dedbd8:	d013      	beq.n	c0dedc02 <strlcpy+0x2e>
c0dedbda:	3a01      	subs	r2, #1
c0dedbdc:	2a00      	cmp	r2, #0
c0dedbde:	d019      	beq.n	c0dedc14 <strlcpy+0x40>
c0dedbe0:	2300      	movs	r3, #0
c0dedbe2:	1c4f      	adds	r7, r1, #1
c0dedbe4:	1c46      	adds	r6, r0, #1
c0dedbe6:	e002      	b.n	c0dedbee <strlcpy+0x1a>
c0dedbe8:	3301      	adds	r3, #1
c0dedbea:	429a      	cmp	r2, r3
c0dedbec:	d016      	beq.n	c0dedc1c <strlcpy+0x48>
c0dedbee:	18f5      	adds	r5, r6, r3
c0dedbf0:	46ac      	mov	ip, r5
c0dedbf2:	5ccd      	ldrb	r5, [r1, r3]
c0dedbf4:	18fc      	adds	r4, r7, r3
c0dedbf6:	54c5      	strb	r5, [r0, r3]
c0dedbf8:	2d00      	cmp	r5, #0
c0dedbfa:	d1f5      	bne.n	c0dedbe8 <strlcpy+0x14>
c0dedbfc:	1a60      	subs	r0, r4, r1
c0dedbfe:	3801      	subs	r0, #1
c0dedc00:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0dedc02:	000c      	movs	r4, r1
c0dedc04:	0023      	movs	r3, r4
c0dedc06:	3301      	adds	r3, #1
c0dedc08:	1e5a      	subs	r2, r3, #1
c0dedc0a:	7812      	ldrb	r2, [r2, #0]
c0dedc0c:	001c      	movs	r4, r3
c0dedc0e:	2a00      	cmp	r2, #0
c0dedc10:	d1f9      	bne.n	c0dedc06 <strlcpy+0x32>
c0dedc12:	e7f3      	b.n	c0dedbfc <strlcpy+0x28>
c0dedc14:	000c      	movs	r4, r1
c0dedc16:	2300      	movs	r3, #0
c0dedc18:	7003      	strb	r3, [r0, #0]
c0dedc1a:	e7f3      	b.n	c0dedc04 <strlcpy+0x30>
c0dedc1c:	4660      	mov	r0, ip
c0dedc1e:	e7fa      	b.n	c0dedc16 <strlcpy+0x42>

c0dedc20 <strlen>:
c0dedc20:	b510      	push	{r4, lr}
c0dedc22:	0783      	lsls	r3, r0, #30
c0dedc24:	d027      	beq.n	c0dedc76 <strlen+0x56>
c0dedc26:	7803      	ldrb	r3, [r0, #0]
c0dedc28:	2b00      	cmp	r3, #0
c0dedc2a:	d026      	beq.n	c0dedc7a <strlen+0x5a>
c0dedc2c:	0003      	movs	r3, r0
c0dedc2e:	2103      	movs	r1, #3
c0dedc30:	e002      	b.n	c0dedc38 <strlen+0x18>
c0dedc32:	781a      	ldrb	r2, [r3, #0]
c0dedc34:	2a00      	cmp	r2, #0
c0dedc36:	d01c      	beq.n	c0dedc72 <strlen+0x52>
c0dedc38:	3301      	adds	r3, #1
c0dedc3a:	420b      	tst	r3, r1
c0dedc3c:	d1f9      	bne.n	c0dedc32 <strlen+0x12>
c0dedc3e:	6819      	ldr	r1, [r3, #0]
c0dedc40:	4a0f      	ldr	r2, [pc, #60]	; (c0dedc80 <strlen+0x60>)
c0dedc42:	4c10      	ldr	r4, [pc, #64]	; (c0dedc84 <strlen+0x64>)
c0dedc44:	188a      	adds	r2, r1, r2
c0dedc46:	438a      	bics	r2, r1
c0dedc48:	4222      	tst	r2, r4
c0dedc4a:	d10f      	bne.n	c0dedc6c <strlen+0x4c>
c0dedc4c:	3304      	adds	r3, #4
c0dedc4e:	6819      	ldr	r1, [r3, #0]
c0dedc50:	4a0b      	ldr	r2, [pc, #44]	; (c0dedc80 <strlen+0x60>)
c0dedc52:	188a      	adds	r2, r1, r2
c0dedc54:	438a      	bics	r2, r1
c0dedc56:	4222      	tst	r2, r4
c0dedc58:	d108      	bne.n	c0dedc6c <strlen+0x4c>
c0dedc5a:	3304      	adds	r3, #4
c0dedc5c:	6819      	ldr	r1, [r3, #0]
c0dedc5e:	4a08      	ldr	r2, [pc, #32]	; (c0dedc80 <strlen+0x60>)
c0dedc60:	188a      	adds	r2, r1, r2
c0dedc62:	438a      	bics	r2, r1
c0dedc64:	4222      	tst	r2, r4
c0dedc66:	d0f1      	beq.n	c0dedc4c <strlen+0x2c>
c0dedc68:	e000      	b.n	c0dedc6c <strlen+0x4c>
c0dedc6a:	3301      	adds	r3, #1
c0dedc6c:	781a      	ldrb	r2, [r3, #0]
c0dedc6e:	2a00      	cmp	r2, #0
c0dedc70:	d1fb      	bne.n	c0dedc6a <strlen+0x4a>
c0dedc72:	1a18      	subs	r0, r3, r0
c0dedc74:	bd10      	pop	{r4, pc}
c0dedc76:	0003      	movs	r3, r0
c0dedc78:	e7e1      	b.n	c0dedc3e <strlen+0x1e>
c0dedc7a:	2000      	movs	r0, #0
c0dedc7c:	e7fa      	b.n	c0dedc74 <strlen+0x54>
c0dedc7e:	46c0      	nop			; (mov r8, r8)
c0dedc80:	fefefeff 	.word	0xfefefeff
c0dedc84:	80808080 	.word	0x80808080

c0dedc88 <strncmp>:
c0dedc88:	b530      	push	{r4, r5, lr}
c0dedc8a:	2a00      	cmp	r2, #0
c0dedc8c:	d039      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedc8e:	0003      	movs	r3, r0
c0dedc90:	430b      	orrs	r3, r1
c0dedc92:	079b      	lsls	r3, r3, #30
c0dedc94:	d11f      	bne.n	c0dedcd6 <strncmp+0x4e>
c0dedc96:	2a03      	cmp	r2, #3
c0dedc98:	d91d      	bls.n	c0dedcd6 <strncmp+0x4e>
c0dedc9a:	6803      	ldr	r3, [r0, #0]
c0dedc9c:	680c      	ldr	r4, [r1, #0]
c0dedc9e:	42a3      	cmp	r3, r4
c0dedca0:	d131      	bne.n	c0dedd06 <strncmp+0x7e>
c0dedca2:	3a04      	subs	r2, #4
c0dedca4:	2a00      	cmp	r2, #0
c0dedca6:	d02c      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedca8:	4c1a      	ldr	r4, [pc, #104]	; (c0dedd14 <strncmp+0x8c>)
c0dedcaa:	4d1b      	ldr	r5, [pc, #108]	; (c0dedd18 <strncmp+0x90>)
c0dedcac:	191c      	adds	r4, r3, r4
c0dedcae:	439c      	bics	r4, r3
c0dedcb0:	422c      	tst	r4, r5
c0dedcb2:	d00c      	beq.n	c0dedcce <strncmp+0x46>
c0dedcb4:	e025      	b.n	c0dedd02 <strncmp+0x7a>
c0dedcb6:	6803      	ldr	r3, [r0, #0]
c0dedcb8:	680c      	ldr	r4, [r1, #0]
c0dedcba:	42a3      	cmp	r3, r4
c0dedcbc:	d123      	bne.n	c0dedd06 <strncmp+0x7e>
c0dedcbe:	3a04      	subs	r2, #4
c0dedcc0:	2a00      	cmp	r2, #0
c0dedcc2:	d01e      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedcc4:	4c13      	ldr	r4, [pc, #76]	; (c0dedd14 <strncmp+0x8c>)
c0dedcc6:	191c      	adds	r4, r3, r4
c0dedcc8:	439c      	bics	r4, r3
c0dedcca:	422c      	tst	r4, r5
c0dedccc:	d119      	bne.n	c0dedd02 <strncmp+0x7a>
c0dedcce:	3004      	adds	r0, #4
c0dedcd0:	3104      	adds	r1, #4
c0dedcd2:	2a03      	cmp	r2, #3
c0dedcd4:	d8ef      	bhi.n	c0dedcb6 <strncmp+0x2e>
c0dedcd6:	7804      	ldrb	r4, [r0, #0]
c0dedcd8:	780d      	ldrb	r5, [r1, #0]
c0dedcda:	3a01      	subs	r2, #1
c0dedcdc:	42a5      	cmp	r5, r4
c0dedcde:	d10e      	bne.n	c0dedcfe <strncmp+0x76>
c0dedce0:	2a00      	cmp	r2, #0
c0dedce2:	d00e      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedce4:	2c00      	cmp	r4, #0
c0dedce6:	d00c      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedce8:	2301      	movs	r3, #1
c0dedcea:	e004      	b.n	c0dedcf6 <strncmp+0x6e>
c0dedcec:	429a      	cmp	r2, r3
c0dedcee:	d008      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedcf0:	3301      	adds	r3, #1
c0dedcf2:	2c00      	cmp	r4, #0
c0dedcf4:	d005      	beq.n	c0dedd02 <strncmp+0x7a>
c0dedcf6:	5cc4      	ldrb	r4, [r0, r3]
c0dedcf8:	5ccd      	ldrb	r5, [r1, r3]
c0dedcfa:	42ac      	cmp	r4, r5
c0dedcfc:	d0f6      	beq.n	c0dedcec <strncmp+0x64>
c0dedcfe:	1b60      	subs	r0, r4, r5
c0dedd00:	e000      	b.n	c0dedd04 <strncmp+0x7c>
c0dedd02:	2000      	movs	r0, #0
c0dedd04:	bd30      	pop	{r4, r5, pc}
c0dedd06:	7804      	ldrb	r4, [r0, #0]
c0dedd08:	780d      	ldrb	r5, [r1, #0]
c0dedd0a:	3a01      	subs	r2, #1
c0dedd0c:	42a5      	cmp	r5, r4
c0dedd0e:	d0e9      	beq.n	c0dedce4 <strncmp+0x5c>
c0dedd10:	1b60      	subs	r0, r4, r5
c0dedd12:	e7f7      	b.n	c0dedd04 <strncmp+0x7c>
c0dedd14:	fefefeff 	.word	0xfefefeff
c0dedd18:	80808080 	.word	0x80808080

c0dedd1c <strnlen>:
c0dedd1c:	b510      	push	{r4, lr}
c0dedd1e:	2900      	cmp	r1, #0
c0dedd20:	d00b      	beq.n	c0dedd3a <strnlen+0x1e>
c0dedd22:	7803      	ldrb	r3, [r0, #0]
c0dedd24:	2b00      	cmp	r3, #0
c0dedd26:	d00c      	beq.n	c0dedd42 <strnlen+0x26>
c0dedd28:	1844      	adds	r4, r0, r1
c0dedd2a:	0003      	movs	r3, r0
c0dedd2c:	e002      	b.n	c0dedd34 <strnlen+0x18>
c0dedd2e:	781a      	ldrb	r2, [r3, #0]
c0dedd30:	2a00      	cmp	r2, #0
c0dedd32:	d004      	beq.n	c0dedd3e <strnlen+0x22>
c0dedd34:	3301      	adds	r3, #1
c0dedd36:	42a3      	cmp	r3, r4
c0dedd38:	d1f9      	bne.n	c0dedd2e <strnlen+0x12>
c0dedd3a:	0008      	movs	r0, r1
c0dedd3c:	bd10      	pop	{r4, pc}
c0dedd3e:	1a19      	subs	r1, r3, r0
c0dedd40:	e7fb      	b.n	c0dedd3a <strnlen+0x1e>
c0dedd42:	2100      	movs	r1, #0
c0dedd44:	e7f9      	b.n	c0dedd3a <strnlen+0x1e>
c0dedd46:	46c0      	nop			; (mov r8, r8)
c0dedd48:	6425      	str	r5, [r4, #64]	; 0x40
c0dedd4a:	4100      	asrs	r0, r0
c0dedd4c:	7070      	strb	r0, [r6, #1]
c0dedd4e:	6f72      	ldr	r2, [r6, #116]	; 0x74
c0dedd50:	6576      	str	r6, [r6, #84]	; 0x54
c0dedd52:	2500      	movs	r5, #0
c0dedd54:	3630      	adds	r6, #48	; 0x30
c0dedd56:	0064      	lsls	r4, r4, #1
c0dedd58:	6564      	str	r4, [r4, #84]	; 0x54
c0dedd5a:	6174      	str	r4, [r6, #20]
c0dedd5c:	6c69      	ldr	r1, [r5, #68]	; 0x44
c0dedd5e:	0073      	lsls	r3, r6, #1
c0dedd60:	6944      	ldr	r4, [r0, #20]
c0dedd62:	7073      	strb	r3, [r6, #1]
c0dedd64:	616c      	str	r4, [r5, #20]
c0dedd66:	2079      	movs	r0, #121	; 0x79
c0dedd68:	6361      	str	r1, [r4, #52]	; 0x34
c0dedd6a:	6f63      	ldr	r3, [r4, #116]	; 0x74
c0dedd6c:	6e75      	ldr	r5, [r6, #100]	; 0x64
c0dedd6e:	2074      	movs	r0, #116	; 0x74
c0dedd70:	6f6e      	ldr	r6, [r5, #116]	; 0x74
c0dedd72:	636e      	str	r6, [r5, #52]	; 0x34
c0dedd74:	0065      	lsls	r5, r4, #1
c0dedd76:	724f      	strb	r7, [r1, #9]
c0dedd78:	6361      	str	r1, [r4, #52]	; 0x34
c0dedd7a:	656c      	str	r4, [r5, #84]	; 0x54
c0dedd7c:	2500      	movs	r5, #0
c0dedd7e:	2073      	movs	r0, #115	; 0x73
c0dedd80:	2528      	movs	r5, #40	; 0x28
c0dedd82:	2f64      	cmp	r7, #100	; 0x64
c0dedd84:	6425      	str	r5, [r4, #64]	; 0x40
c0dedd86:	0029      	movs	r1, r5
c0dedd88:	614d      	str	r5, [r1, #20]
c0dedd8a:	7473      	strb	r3, [r6, #17]
c0dedd8c:	7265      	strb	r5, [r4, #9]
c0dedd8e:	4120      	asrs	r0, r4
c0dedd90:	6363      	str	r3, [r4, #52]	; 0x34
c0dedd92:	756f      	strb	r7, [r5, #21]
c0dedd94:	746e      	strb	r6, [r5, #17]
c0dedd96:	6200      	str	r0, [r0, #32]
c0dedd98:	696c      	ldr	r4, [r5, #20]
c0dedd9a:	646e      	str	r6, [r5, #68]	; 0x44
c0dedd9c:	7320      	strb	r0, [r4, #12]
c0dedd9e:	6769      	str	r1, [r5, #116]	; 0x74
c0dedda0:	696e      	ldr	r6, [r5, #20]
c0dedda2:	676e      	str	r6, [r5, #116]	; 0x74
c0dedda4:	4400      	add	r0, r0
c0dedda6:	7369      	strb	r1, [r5, #13]
c0dedda8:	6c70      	ldr	r0, [r6, #68]	; 0x44
c0deddaa:	7961      	ldrb	r1, [r4, #5]
c0deddac:	6320      	str	r0, [r4, #48]	; 0x30
c0deddae:	6e6f      	ldr	r7, [r5, #100]	; 0x64
c0deddb0:	7274      	strb	r4, [r6, #9]
c0deddb2:	6361      	str	r1, [r4, #52]	; 0x34
c0deddb4:	2074      	movs	r0, #116	; 0x74
c0deddb6:	6164      	str	r4, [r4, #20]
c0deddb8:	6174      	str	r4, [r6, #20]
c0deddba:	4d00      	ldr	r5, [pc, #0]	; (c0deddbc <strnlen+0xa0>)
c0deddbc:	7369      	strb	r1, [r5, #13]
c0deddbe:	6973      	ldr	r3, [r6, #20]
c0deddc0:	676e      	str	r6, [r5, #116]	; 0x74
c0deddc2:	6f20      	ldr	r0, [r4, #112]	; 0x70
c0deddc4:	6172      	str	r2, [r6, #20]
c0deddc6:	6c63      	ldr	r3, [r4, #68]	; 0x44
c0deddc8:	2065      	movs	r0, #101	; 0x65
c0deddca:	6164      	str	r4, [r4, #20]
c0deddcc:	6174      	str	r4, [r6, #20]
c0deddce:	4100      	asrs	r0, r0
c0deddd0:	6c6c      	ldr	r4, [r5, #68]	; 0x44
c0deddd2:	776f      	strb	r7, [r5, #29]
c0deddd4:	6e61      	ldr	r1, [r4, #100]	; 0x64
c0deddd6:	6563      	str	r3, [r4, #84]	; 0x54
c0deddd8:	4e00      	ldr	r6, [pc, #0]	; (c0dedddc <strnlen+0xc0>)
c0deddda:	5446      	strb	r6, [r0, r1]
c0dedddc:	4320      	orrs	r0, r4
c0deddde:	6e6f      	ldr	r7, [r5, #100]	; 0x64
c0dedde0:	7274      	strb	r4, [r6, #9]
c0dedde2:	6361      	str	r1, [r4, #52]	; 0x34
c0dedde4:	0074      	lsls	r4, r6, #1
c0dedde6:	6544      	str	r4, [r0, #84]	; 0x54
c0dedde8:	7562      	strb	r2, [r4, #21]
c0deddea:	2067      	movs	r0, #103	; 0x67
c0deddec:	6164      	str	r4, [r4, #20]
c0deddee:	6174      	str	r4, [r6, #20]
c0deddf0:	6500      	str	r0, [r0, #80]	; 0x50
c0deddf2:	616e      	str	r6, [r5, #20]
c0deddf4:	6c62      	ldr	r2, [r4, #68]	; 0x44
c0deddf6:	6465      	str	r5, [r4, #68]	; 0x44
c0deddf8:	6920      	ldr	r0, [r4, #16]
c0deddfa:	206e      	movs	r0, #110	; 0x6e
c0deddfc:	6553      	str	r3, [r2, #84]	; 0x54
c0deddfe:	7474      	strb	r4, [r6, #17]
c0dede00:	6e69      	ldr	r1, [r5, #100]	; 0x64
c0dede02:	7367      	strb	r7, [r4, #13]
c0dede04:	6100      	str	r0, [r0, #16]
c0dede06:	646e      	str	r6, [r5, #68]	; 0x44
c0dede08:	7320      	strb	r0, [r4, #12]
c0dede0a:	6e65      	ldr	r5, [r4, #100]	; 0x64
c0dede0c:	0064      	lsls	r4, r4, #1
c0dede0e:	7453      	strb	r3, [r2, #17]
c0dede10:	7261      	strb	r1, [r4, #9]
c0dede12:	206b      	movs	r0, #107	; 0x6b
c0dede14:	654b      	str	r3, [r1, #84]	; 0x54
c0dede16:	0079      	lsls	r1, r7, #1
c0dede18:	2e25      	cmp	r6, #37	; 0x25
c0dede1a:	732a      	strb	r2, [r5, #12]
c0dede1c:	2500      	movs	r5, #0
c0dede1e:	0075      	lsls	r5, r6, #1
c0dede20:	6552      	str	r2, [r2, #84]	; 0x54
c0dede22:	656a      	str	r2, [r5, #84]	; 0x54
c0dede24:	7463      	strb	r3, [r4, #17]
c0dede26:	5300      	strh	r0, [r0, r4]
c0dede28:	6769      	str	r1, [r5, #116]	; 0x74
c0dede2a:	696e      	ldr	r6, [r5, #20]
c0dede2c:	676e      	str	r6, [r5, #116]	; 0x74
c0dede2e:	5300      	strh	r0, [r0, r4]
c0dede30:	6174      	str	r4, [r6, #20]
c0dede32:	6b72      	ldr	r2, [r6, #52]	; 0x34
c0dede34:	6b20      	ldr	r0, [r4, #48]	; 0x30
c0dede36:	7965      	ldrb	r5, [r4, #5]
c0dede38:	5000      	str	r0, [r0, r0]
c0dede3a:	6961      	ldr	r1, [r4, #20]
c0dede3c:	0072      	lsls	r2, r6, #1
c0dede3e:	6148      	str	r0, [r1, #20]
c0dede40:	6873      	ldr	r3, [r6, #4]
c0dede42:	4500      	cmp	r0, r0
c0dede44:	4352      	muls	r2, r2
c0dede46:	3237      	adds	r2, #55	; 0x37
c0dede48:	0031      	movs	r1, r6
c0dede4a:	5245      	strh	r5, [r0, r1]
c0dede4c:	3143      	adds	r1, #67	; 0x43
c0dede4e:	3531      	adds	r5, #49	; 0x31
c0dede50:	0035      	movs	r5, r6
c0dede52:	6552      	str	r2, [r2, #84]	; 0x54
c0dede54:	6c63      	ldr	r3, [r4, #68]	; 0x44
c0dede56:	6961      	ldr	r1, [r4, #20]
c0dede58:	206d      	movs	r0, #109	; 0x6d
c0dede5a:	6544      	str	r4, [r0, #84]	; 0x54
c0dede5c:	6f70      	ldr	r0, [r6, #116]	; 0x74
c0dede5e:	6973      	ldr	r3, [r6, #20]
c0dede60:	0074      	lsls	r4, r6, #1
c0dede62:	6f54      	ldr	r4, [r2, #116]	; 0x74
c0dede64:	4520      	cmp	r0, r4
c0dede66:	4854      	ldr	r0, [pc, #336]	; (c0dedfb8 <strnlen+0x29c>)
c0dede68:	4120      	asrs	r0, r4
c0dede6a:	6464      	str	r4, [r4, #68]	; 0x44
c0dede6c:	6572      	str	r2, [r6, #84]	; 0x54
c0dede6e:	7373      	strb	r3, [r6, #13]
c0dede70:	4e00      	ldr	r6, [pc, #0]	; (c0dede74 <strnlen+0x158>)
c0dede72:	544f      	strb	r7, [r1, r1]
c0dede74:	4520      	cmp	r0, r4
c0dede76:	616e      	str	r6, [r5, #20]
c0dede78:	6c62      	ldr	r2, [r4, #68]	; 0x44
c0dede7a:	6465      	str	r5, [r4, #68]	; 0x44
c0dede7c:	4100      	asrs	r0, r0
c0dede7e:	6f6d      	ldr	r5, [r5, #116]	; 0x74
c0dede80:	6e75      	ldr	r5, [r6, #100]	; 0x64
c0dede82:	0074      	lsls	r4, r6, #1
c0dede84:	6f54      	ldr	r4, [r2, #116]	; 0x74
c0dede86:	4d20      	ldr	r5, [pc, #128]	; (c0dedf08 <strnlen+0x1ec>)
c0dede88:	6e61      	ldr	r1, [r4, #100]	; 0x64
c0dede8a:	6761      	str	r1, [r4, #116]	; 0x74
c0dede8c:	2065      	movs	r0, #101	; 0x65
c0dede8e:	4c41      	ldr	r4, [pc, #260]	; (c0dedf94 <strnlen+0x278>)
c0dede90:	004c      	lsls	r4, r1, #1
c0dede92:	6156      	str	r6, [r2, #20]
c0dede94:	696c      	ldr	r4, [r5, #20]
c0dede96:	6164      	str	r4, [r4, #20]
c0dede98:	6f74      	ldr	r4, [r6, #116]	; 0x74
c0dede9a:	0072      	lsls	r2, r6, #1
c0dede9c:	4f4e      	ldr	r7, [pc, #312]	; (c0dedfd8 <strnlen+0x2bc>)
c0dede9e:	2054      	movs	r0, #84	; 0x54
c0dedea0:	6944      	ldr	r4, [r0, #20]
c0dedea2:	7073      	strb	r3, [r6, #1]
c0dedea4:	616c      	str	r4, [r5, #20]
c0dedea6:	6579      	str	r1, [r7, #84]	; 0x54
c0dedea8:	0064      	lsls	r4, r4, #1
c0dedeaa:	7974      	ldrb	r4, [r6, #5]
c0dedeac:	6570      	str	r0, [r6, #84]	; 0x54
c0dedeae:	2064      	movs	r0, #100	; 0x64
c0dedeb0:	656d      	str	r5, [r5, #84]	; 0x54
c0dedeb2:	7373      	strb	r3, [r6, #13]
c0dedeb4:	6761      	str	r1, [r4, #116]	; 0x74
c0dedeb6:	0065      	lsls	r5, r4, #1
c0dedeb8:	0020      	movs	r0, r4
c0dedeba:	7246      	strb	r6, [r0, #9]
c0dedebc:	6d6f      	ldr	r7, [r5, #84]	; 0x54
c0dedebe:	4120      	asrs	r0, r4
c0dedec0:	6363      	str	r3, [r4, #52]	; 0x34
c0dedec2:	756f      	strb	r7, [r5, #21]
c0dedec4:	746e      	strb	r6, [r5, #17]
c0dedec6:	2500      	movs	r5, #0
c0dedec8:	0073      	lsls	r3, r6, #1
c0dedeca:	6f54      	ldr	r4, [r2, #116]	; 0x74
c0dedecc:	5400      	strb	r0, [r0, r0]
c0dedece:	206f      	movs	r0, #111	; 0x6f
c0deded0:	614d      	str	r5, [r1, #20]
c0deded2:	616e      	str	r6, [r5, #20]
c0deded4:	6567      	str	r7, [r4, #84]	; 0x54
c0deded6:	5920      	ldr	r0, [r4, r4]
c0deded8:	756f      	strb	r7, [r5, #21]
c0dededa:	0072      	lsls	r2, r6, #1
c0dededc:	5445      	strb	r5, [r0, r1]
c0dedede:	3248      	adds	r2, #72	; 0x48
c0dedee0:	6d00      	ldr	r0, [r0, #80]	; 0x50
c0dedee2:	7365      	strb	r5, [r4, #13]
c0dedee4:	6173      	str	r3, [r6, #20]
c0dedee6:	6567      	str	r7, [r4, #84]	; 0x54
c0dedee8:	5300      	strh	r0, [r0, r4]
c0dedeea:	6c65      	ldr	r5, [r4, #68]	; 0x44
c0dedeec:	2066      	movs	r0, #102	; 0x66
c0dedeee:	7254      	strb	r4, [r2, #9]
c0dedef0:	6e61      	ldr	r1, [r4, #100]	; 0x64
c0dedef2:	6673      	str	r3, [r6, #100]	; 0x64
c0dedef4:	7265      	strb	r5, [r4, #9]
c0dedef6:	2500      	movs	r5, #0
c0dedef8:	2073      	movs	r0, #115	; 0x73
c0dedefa:	7266      	strb	r6, [r4, #9]
c0dedefc:	6d6f      	ldr	r7, [r5, #84]	; 0x54
c0dedefe:	2520      	movs	r5, #32
c0dedf00:	2064      	movs	r0, #100	; 0x64
c0dedf02:	464e      	mov	r6, r9
c0dedf04:	2054      	movs	r0, #84	; 0x54
c0dedf06:	4449      	add	r1, r9
c0dedf08:	0073      	lsls	r3, r6, #1
c0dedf0a:	6f54      	ldr	r4, [r2, #116]	; 0x74
c0dedf0c:	656b      	str	r3, [r5, #84]	; 0x54
c0dedf0e:	206e      	movs	r0, #110	; 0x6e
c0dedf10:	6341      	str	r1, [r0, #52]	; 0x34
c0dedf12:	6f63      	ldr	r3, [r4, #116]	; 0x74
c0dedf14:	6e75      	ldr	r5, [r6, #100]	; 0x64
c0dedf16:	0074      	lsls	r4, r6, #1
c0dedf18:	6e45      	ldr	r5, [r0, #100]	; 0x64
c0dedf1a:	6261      	str	r1, [r4, #36]	; 0x24
c0dedf1c:	656c      	str	r4, [r5, #84]	; 0x54
c0dedf1e:	0064      	lsls	r4, r4, #1
c0dedf20:	7550      	strb	r0, [r2, #21]
c0dedf22:	6c62      	ldr	r2, [r4, #68]	; 0x44
c0dedf24:	6369      	str	r1, [r5, #52]	; 0x34
c0dedf26:	4b20      	ldr	r3, [pc, #128]	; (c0dedfa8 <strnlen+0x28c>)
c0dedf28:	7965      	ldrb	r5, [r4, #5]
c0dedf2a:	4d00      	ldr	r5, [pc, #0]	; (c0dedf2c <strnlen+0x210>)
c0dedf2c:	7861      	ldrb	r1, [r4, #1]
c0dedf2e:	4620      	mov	r0, r4
c0dedf30:	6565      	str	r5, [r4, #84]	; 0x54
c0dedf32:	0073      	lsls	r3, r6, #1
c0dedf34:	6341      	str	r1, [r0, #52]	; 0x34
c0dedf36:	6563      	str	r3, [r4, #84]	; 0x54
c0dedf38:	7470      	strb	r0, [r6, #17]
c0dedf3a:	5400      	strb	r0, [r0, r0]
c0dedf3c:	746f      	strb	r7, [r5, #17]
c0dedf3e:	6c61      	ldr	r1, [r4, #68]	; 0x44
c0dedf40:	5120      	str	r0, [r4, r4]
c0dedf42:	6175      	str	r5, [r6, #20]
c0dedf44:	746e      	strb	r6, [r5, #17]
c0dedf46:	7469      	strb	r1, [r5, #17]
c0dedf48:	0079      	lsls	r1, r7, #1
c0dedf4a:	3077      	adds	r0, #119	; 0x77
c0dedf4c:	0077      	lsls	r7, r6, #1
c0dedf4e:	6556      	str	r6, [r2, #84]	; 0x54
c0dedf50:	6972      	ldr	r2, [r6, #20]
c0dedf52:	7966      	ldrb	r6, [r4, #5]
c0dedf54:	4400      	add	r0, r0
c0dedf56:	6d6f      	ldr	r7, [r5, #84]	; 0x54
c0dedf58:	6961      	ldr	r1, [r4, #20]
c0dedf5a:	206e      	movs	r0, #110	; 0x6e
c0dedf5c:	6168      	str	r0, [r5, #20]
c0dedf5e:	6873      	ldr	r3, [r6, #4]
c0dedf60:	4300      	orrs	r0, r0
c0dedf62:	6e6f      	ldr	r7, [r5, #100]	; 0x64
c0dedf64:	2e64      	cmp	r6, #100	; 0x64
c0dedf66:	4120      	asrs	r0, r4
c0dedf68:	6464      	str	r4, [r4, #68]	; 0x44
c0dedf6a:	6572      	str	r2, [r6, #84]	; 0x54
c0dedf6c:	7373      	strb	r3, [r6, #13]
c0dedf6e:	5200      	strh	r0, [r0, r0]
c0dedf70:	6465      	str	r5, [r4, #68]	; 0x44
c0dedf72:	6565      	str	r5, [r4, #84]	; 0x54
c0dedf74:	006d      	lsls	r5, r5, #1
c0dedf76:	464e      	mov	r6, r9
c0dedf78:	0054      	lsls	r4, r2, #1
c0dedf7a:	4e55      	ldr	r6, [pc, #340]	; (c0dee0d0 <strnlen+0x3b4>)
c0dedf7c:	4e4b      	ldr	r6, [pc, #300]	; (c0dee0ac <strnlen+0x390>)
c0dedf7e:	574f      	ldrsb	r7, [r1, r5]
c0dedf80:	004e      	lsls	r6, r1, #1
c0dedf82:	7345      	strb	r5, [r0, #13]
c0dedf84:	6163      	str	r3, [r4, #20]
c0dedf86:	6570      	str	r0, [r6, #84]	; 0x54
c0dedf88:	5400      	strb	r0, [r0, r0]
c0dedf8a:	6b6f      	ldr	r7, [r5, #52]	; 0x34
c0dedf8c:	6e65      	ldr	r5, [r4, #100]	; 0x64
c0dedf8e:	4449      	add	r1, r9
c0dedf90:	5300      	strh	r0, [r0, r4]
c0dedf92:	7465      	strb	r5, [r4, #17]
c0dedf94:	6974      	ldr	r4, [r6, #20]
c0dedf96:	676e      	str	r6, [r5, #116]	; 0x74
c0dedf98:	0073      	lsls	r3, r6, #1
c0dedf9a:	6e45      	ldr	r5, [r0, #100]	; 0x64
c0dedf9c:	6261      	str	r1, [r4, #36]	; 0x24
c0dedf9e:	656c      	str	r4, [r5, #84]	; 0x54
c0dedfa0:	7420      	strb	r0, [r4, #16]
c0dedfa2:	6172      	str	r2, [r6, #20]
c0dedfa4:	736e      	strb	r6, [r5, #13]
c0dedfa6:	6361      	str	r1, [r4, #52]	; 0x34
c0dedfa8:	6974      	ldr	r4, [r6, #20]
c0dedfaa:	6e6f      	ldr	r7, [r5, #100]	; 0x64
c0dedfac:	4300      	orrs	r0, r0
c0dedfae:	6c6f      	ldr	r7, [r5, #68]	; 0x44
c0dedfb0:	656c      	str	r4, [r5, #84]	; 0x54
c0dedfb2:	7463      	strb	r3, [r4, #17]
c0dedfb4:	6f69      	ldr	r1, [r5, #116]	; 0x74
c0dedfb6:	206e      	movs	r0, #110	; 0x6e
c0dedfb8:	614e      	str	r6, [r1, #20]
c0dedfba:	656d      	str	r5, [r5, #84]	; 0x54
c0dedfbc:	5500      	strb	r0, [r0, r4]
c0dedfbe:	6c6e      	ldr	r6, [r5, #68]	; 0x44
c0dedfc0:	6d69      	ldr	r1, [r5, #84]	; 0x54
c0dedfc2:	7469      	strb	r1, [r5, #17]
c0dedfc4:	6465      	str	r5, [r4, #68]	; 0x44
c0dedfc6:	0020      	movs	r0, r4
c0dedfc8:	6f43      	ldr	r3, [r0, #116]	; 0x74
c0dedfca:	746e      	strb	r6, [r5, #17]
c0dedfcc:	6172      	str	r2, [r6, #20]
c0dedfce:	7463      	strb	r3, [r4, #17]
c0dedfd0:	4e20      	ldr	r6, [pc, #128]	; (c0dee054 <strnlen+0x338>)
c0dedfd2:	6d61      	ldr	r1, [r4, #84]	; 0x54
c0dedfd4:	0065      	lsls	r5, r4, #1
c0dedfd6:	7341      	strb	r1, [r0, #13]
c0dedfd8:	6573      	str	r3, [r6, #84]	; 0x54
c0dedfda:	2074      	movs	r0, #116	; 0x74
c0dedfdc:	6f43      	ldr	r3, [r0, #116]	; 0x74
c0dedfde:	746e      	strb	r6, [r5, #17]
c0dedfe0:	6172      	str	r2, [r6, #20]
c0dedfe2:	7463      	strb	r3, [r4, #17]
c0dedfe4:	5300      	strh	r0, [r0, r4]
c0dedfe6:	6174      	str	r4, [r6, #20]
c0dedfe8:	6b72      	ldr	r2, [r6, #52]	; 0x34
c0dedfea:	5320      	strh	r0, [r4, r4]
c0dedfec:	6769      	str	r1, [r5, #116]	; 0x74
c0dedfee:	006e      	lsls	r6, r5, #1
c0dedff0:	7954      	ldrb	r4, [r2, #5]
c0dedff2:	6570      	str	r0, [r6, #84]	; 0x54
c0dedff4:	4300      	orrs	r0, r0
c0dedff6:	6e6f      	ldr	r7, [r5, #100]	; 0x64
c0dedff8:	7274      	strb	r4, [r6, #9]
c0dedffa:	6361      	str	r1, [r4, #52]	; 0x34
c0dedffc:	0074      	lsls	r4, r6, #1
c0dedffe:	7546      	strb	r6, [r0, #21]
c0dee000:	6c6c      	ldr	r4, [r5, #68]	; 0x44
c0dee002:	5720      	ldrsb	r0, [r4, r4]
c0dee004:	7469      	strb	r1, [r5, #17]
c0dee006:	6468      	str	r0, [r5, #68]	; 0x44
c0dee008:	6172      	str	r2, [r6, #20]
c0dee00a:	6177      	str	r7, [r6, #20]
c0dee00c:	006c      	lsls	r4, r5, #1
c0dee00e:	6556      	str	r6, [r2, #84]	; 0x54
c0dee010:	7372      	strb	r2, [r6, #13]
c0dee012:	6f69      	ldr	r1, [r5, #116]	; 0x74
c0dee014:	006e      	lsls	r6, r5, #1
c0dee016:	6c42      	ldr	r2, [r0, #68]	; 0x44
c0dee018:	6e69      	ldr	r1, [r5, #100]	; 0x64
c0dee01a:	2064      	movs	r0, #100	; 0x64
c0dee01c:	6973      	ldr	r3, [r6, #20]
c0dee01e:	6e67      	ldr	r7, [r4, #100]	; 0x64
c0dee020:	6e69      	ldr	r1, [r5, #100]	; 0x64
c0dee022:	2067      	movs	r0, #103	; 0x67
c0dee024:	756d      	strb	r5, [r5, #21]
c0dee026:	7473      	strb	r3, [r6, #17]
c0dee028:	6220      	str	r0, [r4, #32]
c0dee02a:	0065      	lsls	r5, r4, #1
c0dee02c:	6c42      	ldr	r2, [r0, #68]	; 0x44
c0dee02e:	6e69      	ldr	r1, [r5, #100]	; 0x64
c0dee030:	0064      	lsls	r4, r4, #1
c0dee032:	6143      	str	r3, [r0, #20]
c0dee034:	636e      	str	r6, [r5, #52]	; 0x34
c0dee036:	6c65      	ldr	r5, [r4, #68]	; 0x44
c0dee038:	4e00      	ldr	r6, [pc, #0]	; (c0dee03c <strnlen+0x320>)
c0dee03a:	7465      	strb	r5, [r4, #17]
c0dee03c:	6f77      	ldr	r7, [r6, #116]	; 0x74
c0dee03e:	6b72      	ldr	r2, [r6, #52]	; 0x34
c0dee040:	4f00      	ldr	r7, [pc, #0]	; (c0dee044 <strnlen+0x328>)
c0dee042:	6172      	str	r2, [r6, #20]
c0dee044:	6c63      	ldr	r3, [r4, #68]	; 0x44
c0dee046:	2065      	movs	r0, #101	; 0x65
c0dee048:	6144      	str	r4, [r0, #20]
c0dee04a:	6174      	str	r4, [r6, #20]
c0dee04c:	3000      	adds	r0, #0
c0dee04e:	4600      	mov	r0, r0
c0dee050:	6572      	str	r2, [r6, #84]	; 0x54
c0dee052:	7a65      	ldrb	r5, [r4, #9]
c0dee054:	0065      	lsls	r5, r4, #1
c0dee056:	7570      	strb	r0, [r6, #21]
c0dee058:	6c62      	ldr	r2, [r4, #68]	; 0x44
c0dee05a:	6369      	str	r1, [r5, #52]	; 0x34
c0dee05c:	6b20      	ldr	r0, [r4, #48]	; 0x30
c0dee05e:	7965      	ldrb	r5, [r4, #5]
c0dee060:	5000      	str	r0, [r0, r0]
c0dee062:	6f72      	ldr	r2, [r6, #116]	; 0x74
c0dee064:	6976      	ldr	r6, [r6, #20]
c0dee066:	6564      	str	r4, [r4, #84]	; 0x54
c0dee068:	7020      	strb	r0, [r4, #0]
c0dee06a:	6275      	str	r5, [r6, #36]	; 0x24
c0dee06c:	696c      	ldr	r4, [r5, #20]
c0dee06e:	0063      	lsls	r3, r4, #1
c0dee070:	6553      	str	r3, [r2, #84]	; 0x54
c0dee072:	656c      	str	r4, [r5, #84]	; 0x54
c0dee074:	7463      	strb	r3, [r4, #17]
c0dee076:	726f      	strb	r7, [r5, #9]
c0dee078:	4300      	orrs	r0, r0
c0dee07a:	6d6f      	ldr	r7, [r5, #84]	; 0x54
c0dee07c:	6f70      	ldr	r0, [r6, #116]	; 0x74
c0dee07e:	6e75      	ldr	r5, [r6, #100]	; 0x64
c0dee080:	2064      	movs	r0, #100	; 0x64
c0dee082:	5600      	ldrsb	r0, [r0, r0]
c0dee084:	7265      	strb	r5, [r4, #9]
c0dee086:	6669      	str	r1, [r5, #100]	; 0x64
c0dee088:	2079      	movs	r0, #121	; 0x79
c0dee08a:	7345      	strb	r5, [r0, #13]
c0dee08c:	6163      	str	r3, [r4, #20]
c0dee08e:	6570      	str	r0, [r6, #84]	; 0x54
c0dee090:	4600      	mov	r0, r0
c0dee092:	6f72      	ldr	r2, [r6, #116]	; 0x74
c0dee094:	206d      	movs	r0, #109	; 0x6d
c0dee096:	5445      	strb	r5, [r0, r1]
c0dee098:	2048      	movs	r0, #72	; 0x48
c0dee09a:	6441      	str	r1, [r0, #68]	; 0x44
c0dee09c:	7264      	strb	r4, [r4, #9]
c0dee09e:	7365      	strb	r5, [r4, #13]
c0dee0a0:	0073      	lsls	r3, r6, #1
c0dee0a2:	6944      	ldr	r4, [r0, #20]
c0dee0a4:	7073      	strb	r3, [r6, #1]
c0dee0a6:	616c      	str	r4, [r5, #20]
c0dee0a8:	6579      	str	r1, [r7, #84]	; 0x54
c0dee0aa:	0064      	lsls	r4, r4, #1
c0dee0ac:	6973      	ldr	r3, [r6, #20]
c0dee0ae:	6e67      	ldr	r7, [r4, #100]	; 0x64
c0dee0b0:	7461      	strb	r1, [r4, #17]
c0dee0b2:	7275      	strb	r5, [r6, #9]
c0dee0b4:	0065      	lsls	r5, r4, #1
c0dee0b6:	6553      	str	r3, [r2, #84]	; 0x54
c0dee0b8:	666c      	str	r4, [r5, #100]	; 0x64
c0dee0ba:	2500      	movs	r5, #0
c0dee0bc:	3230      	adds	r2, #48	; 0x30
c0dee0be:	0058      	lsls	r0, r3, #1
c0dee0c0:	4120      	asrs	r0, r4
c0dee0c2:	7373      	strb	r3, [r6, #13]
c0dee0c4:	7465      	strb	r5, [r4, #17]
c0dee0c6:	0073      	lsls	r3, r6, #1
c0dee0c8:	6552      	str	r2, [r2, #84]	; 0x54
c0dee0ca:	6967      	ldr	r7, [r4, #20]
c0dee0cc:	7473      	strb	r3, [r6, #17]
c0dee0ce:	7265      	strb	r5, [r4, #9]
c0dee0d0:	5300      	strh	r0, [r0, r4]
c0dee0d2:	6174      	str	r4, [r6, #20]
c0dee0d4:	6b72      	ldr	r2, [r6, #52]	; 0x34
c0dee0d6:	6177      	str	r7, [r6, #20]
c0dee0d8:	6572      	str	r2, [r6, #84]	; 0x54
c0dee0da:	3000      	adds	r0, #0
c0dee0dc:	2578      	movs	r5, #120	; 0x78
c0dee0de:	2a2e      	cmp	r2, #46	; 0x2e
c0dee0e0:	0048      	lsls	r0, r1, #1

c0dee0e2 <HEXDIGITS>:
c0dee0e2:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef
c0dee0f2:	4500 5252 524f 4200 696c 646e 7320 6769     .ERROR.Blind sig
c0dee102:	696e 676e 3000 0078 6150 6172 656d 6574     ning.0x.Paramete
c0dee112:	0072 2e2e 002e 7551 6e61 6974 7974 5700     r.....Quantity.W
c0dee122:	7469 6468 6172 6177 206c 6f54 5600 7265     ithdrawal To.Ver
c0dee132:	6669 2079 5445 3248 5000 6f72 6976 6564     ify ETH2.Provide
c0dee142:	7020 6972 6176 7963 2500 2a2e 0048 6552      privacy.%.*H.Re
c0dee152:	7571 7269 2065 724f 6361 656c 4200 7461     quire Oracle.Bat
c0dee162:	6863 5420 6172 736e 6566 0072 614e 6f6e     ch Transfer.Nano
c0dee172:	5820 5700 7469 6468 6172 6177 006c 2e31      X.Withdrawal.1.
c0dee182:	2e39 3931 7400 6172 736e 6361 6974 6e6f     9.19.transaction
c0dee192:	6420 7461 0061 7254 6e61 6673 7265 4100      data.Transfer.A
c0dee1a2:	6464 6572 7373 4600 6569 646c 2520 0064     ddress.Field %d.
c0dee1b2:	7551 7469 4200 6361 006b 6f43 646e 7469     Quit.Back.Condit
c0dee1c2:	6f69 616e 006c 464e 2054 6441 7264 7365     ional.NFT Addres
c0dee1d2:	0073 6f54 656b 206e 7953 626d 6c6f 4100     s.Token Symbol.A
c0dee1e2:	7070 696c 6163 6974 6e6f 6100 6464 6572     pplication.addre
c0dee1f2:	7373 4d00 7365 6173 6567 7300 6c65 6365     ss.Message.selec
c0dee202:	6f74 0072 6544 6576 7372 4669 0069 6e69     tor.DeversiFi.in
c0dee212:	7420 6172 736e 6361 6974 6e6f 0073 7270      transactions.pr
c0dee222:	7669 6361 2079 656b 0079 6552 6976 7765     ivacy key.Review
c0dee232:	4c00 6d69 7469 4f00 6472 7265 4c00 6e65     .Limit.Order.Len
c0dee242:	0064 464e 2054 4449 4e00 6e6f 6563 5400     d.NFT ID.Nonce.T
c0dee252:	6172 6964 676e 4300 6e6f 2e64 4620 6361     rading.Cond. Fac
c0dee262:	0074 4400 7065 736f 7469 5300 6769 006e     t..Deposit.Sign.
c0dee272:	7274 6e61 6173 7463 6f69 006e 6e55 6173     transaction.Unsa
c0dee282:	6566 4300 6e61 6563 206c 6544 6f70 6973     fe.Cancel Deposi
c0dee292:	0074 6552 6967 7473 7265 4426 7065 736f     t.Register&Depos
c0dee2a2:	7469 6900 2073 6572 6461 0079 654b 0079     it.is ready.Key.
c0dee2b2:	654d 7373 6761 2065 6168 6873 4100 6c6c     Message hash.All
c0dee2c2:	776f 7300 6365 6572 2074 656b 0079 6553     ow.secret key.Se
c0dee2d2:	6c6c 4200 7975 2500 2f64 6425 3000 2578     ll.Buy.%d/%d.0x%
c0dee2e2:	2a2e 0073 6552 6f76 656b                     .*s.Revoke.

c0dee2ed <bitmapOPEN_SANS_EXTRABOLD_11PX>:
c0dee2ed:	0000 0000 b000 c36d 0006 2d80 0049 0000     ......m....-I...
c0dee2fd:	0000 0000 c912 f94f 244b 0012 0000 b788     ......O.K$......
c0dee30d:	0e2c a687 021f 0000 b138 0ac6 f9fb 358d     ,.......8......5
c0dee31d:	c8d6 0001 0000 7800 b0d8 c1c1 3ddb be7b     .......x.....={.
c0dee32d:	0001 0000 04b0 0000 4000 3366 6633 2004     .........@f33f. 
c0dee33d:	cc66 66cc 0002 fed3 079e 0000 0000 c000     f..f............
c0dee34d:	3f30 00c3 0000 0000 c000 001a 0000 0ff0     0?..............
c0dee35d:	0000 0000 06c0 0000 c623 118c 0003 0000     ........#.......
c0dee36d:	663c 6666 6666 3c66 0000 0000 79c6 8618     <ffffff<.....y..
c0dee37d:	1861 0000 8e00 060d 70c3 3e18 0000 0000     a........p.>....
c0dee38d:	0c0f 81c6 60c1 001e 0000 3000 3838 3434     .....`.....08844
c0dee39d:	307e 0030 0000 6780 1e18 6186 001e 0000     ~00....g...a....
c0dee3ad:	0c38 3e04 6666 3c66 0000 0000 0c1f c306     8..>fff<........
c0dee3bd:	3060 000c 0000 3c00 6666 663c 6666 003c     `0.....<ff<fff<.
c0dee3cd:	0000 3c00 6666 7c66 3060 001c 0000 6c00     ...<fff|`0.....l
c0dee3dd:	06c0 0000 c06c 001a 6000 8666 1861 0000     ....l....`f.a...
c0dee3ed:	0000 3f00 03f0 0000 0000 c30c 3330 0003     ...?........03..
c0dee3fd:	c000 6183 018e 0618 0000 e000 98c3 5bdd     ...a...........[
c0dee40d:	bd2f 7ef6 e006 0007 0000 3c18 7e3c 7e66     /..~.......<<~f~
c0dee41d:	c3e7 0000 0000 cd9f b1e6 6cd9 003e 0000     ...........l>...
c0dee42d:	9e00 60c1 1830 3c0c 0000 0000 663e 6666     ...`0..<....>fff
c0dee43d:	6666 3e66 0000 8000 1867 619e 1e18 0000     fff>....g..a....
c0dee44d:	6f80 9e18 1861 0006 0000 067c 7606 6666     .o..a.....|..vff
c0dee45d:	7c66 0000 0000 6666 7e66 6666 6666 0000     f|....fff~ffff..
c0dee46d:	6000 6666 0666 8000 c631 6318 b18c 0003     .`fff...1..c....
c0dee47d:	66e6 1e36 363e e666 0000 8000 1861 6186     .f6.>6f.....a..a
c0dee48d:	3e18 0000 7000 e39c e7bc ef3d cd59 766e     .>...p....=.Y.nv
c0dee49d:	0003 0000 0000 399c e6f3 9ecd 733d 00e6     .......9....=s..
c0dee4ad:	0000 0000 18f8 6633 98cc 6331 007c 0000     ......3f..1c|...
c0dee4bd:	0000 cd9f f366 0c19 0006 0000 f800 3318     ....f..........3
c0dee4cd:	cc66 3198 7c63 00c0 0003 1e00 3636 1e36     f..1c|......666.
c0dee4dd:	3636 0066 0000 6f00 0e18 e787 001e c000     66f....o........
c0dee4ed:	30cf c30c 0c30 0000 6600 6666 6666 6666     .0..0....fffffff
c0dee4fd:	003c 0000 3cc0 b3cf 79e7 000c 0000 b398     <....<...y......
c0dee50d:	ecdd 3566 71ab 3b87 00d8 0000 0000 c300     ..f5.q.;........
c0dee51d:	3c66 3c3c 663c 00c3 0000 b180 c6cd 60c1     f<<<<f.........`
c0dee52d:	1830 0000 8000 0c3f 6187 0c38 007f 0000     0.....?..a8.....
c0dee53d:	1bc0 8c63 c631 0078 0860 1863 1843 0000     ..c.1.x.`.c.C...
c0dee54d:	31e0 18c6 8c63 003d 0600 23c3 0199 0000     .1..c.=....#....
	...
c0dee565:	0000 03f0 0c0c 0000 0000 0000 0000 0000     ................
c0dee575:	c000 f303 66cd 003e 0000 8300 67c1 dbb3     .....f>......g..
c0dee585:	3e6d 0000 0000 f000 71c6 3c18 0000 1800     m>.......q.<....
c0dee595:	678c ddbb 3c6c 0000 0000 8000 fe67 0c1f     .g..l<......g...
c0dee5a5:	003c 0000 6700 867c 1861 0006 0000 c000     <....g|.a.......
c0dee5b5:	b36f 0c79 f1be 07d8 8300 67c1 d9b3 366c     o.y........g..l6
c0dee5c5:	0000 6000 6660 0666 8000 c601 6318 318c     ...``ff......c.1
c0dee5d5:	0003 c183 f3e6 6c78 0076 0000 6660 6666     ......xlv...`fff
c0dee5e5:	0006 0000 8000 b676 66d9 6d9b 01b6 0000     ......v..f.m....
c0dee5f5:	0000 4000 b367 6cd9 0036 0000 0000 6380     ...@g..l6......c
c0dee605:	dfbb 1c6d 0000 0000 c000 b367 6ddb 833e     ..m.......g..m>.
c0dee615:	00c1 0000 67c0 ddbb 3e6c 0c18 0006 ed00     .....g..l>......
c0dee625:	318d 0006 0000 7800 c786 1ec3 0000 9800     .1.....x........
c0dee635:	8c6f 1c31 0000 0000 66c0 d9b3 2e6c 0000     o.1......f..l...
c0dee645:	0000 6000 b36c 38d9 001c 0000 0000 c000     ...`l..8........
c0dee655:	b6cc e7f9 331f 00cc 0000 0000 e000 e36e     .....3........n.
c0dee665:	6c70 0077 0000 0000 6c60 d1b3 1c38 c306     plw.....`l..8...
c0dee675:	0000 fc00 c318 3f18 0000 3380 cec6 8c61     .......?...3..a.
c0dee685:	0071 c300 0c30 30c3 c30c e030 6318 3738     q...0..0..0..c87
c0dee695:	1cc6 0000 0000 0f6f 0000 0000 2780 9249     ......o......'I.
c0dee6a5:	4924 001e                                    $I...

c0dee6aa <charactersOPEN_SANS_EXTRABOLD_11PX>:
c0dee6aa:	0503 0000 0503 0005 0906 000a 0b07 0013     ................
c0dee6ba:	0906 001e 0f0a 0027 0e09 0036 0503 0044     ......'...6...D.
c0dee6ca:	0604 0049 0604 004f 0906 0055 0906 005e     ..I...O...U...^.
c0dee6da:	0503 0067 0604 006c 0503 0072 0805 0077     ..g...l...r...w.
c0dee6ea:	0c08 007f 0906 008b 0b07 0094 0b07 009f     ................
c0dee6fa:	0c08 00aa 0906 00b6 0c08 00bf 0b07 00cb     ................
c0dee70a:	0c08 00d6 0c08 00e2 0503 00ee 0503 00f3     ................
c0dee71a:	0805 00f8 0906 0100 0805 0109 0906 0111     ................
c0dee72a:	0f0a 011a 0c08 0129 0b07 0135 0b07 0140     ......)...5...@.
c0dee73a:	0c08 014b 0906 0157 0906 0160 0c08 0169     ..K...W...`...i.
c0dee74a:	0c08 0175 0604 0181 0805 0187 0c08 018f     ..u.............
c0dee75a:	0906 019b 110b 01a4 0e09 01b5 0e09 01c3     ................
c0dee76a:	0b07 01d1 0e09 01dc 0c08 01ea 0906 01f6     ................
c0dee77a:	0906 01ff 0c08 0208 0906 0214 110b 021d     ................
c0dee78a:	0c08 022e 0b07 023a 0b07 0245 0805 0250     ......:...E...P.
c0dee79a:	0805 0258 0805 0260 0b07 0268 0906 0273     ..X...`...h...s.
c0dee7aa:	0b07 027c 0b07 0287 0b07 0292 0906 029d     ..|.............
c0dee7ba:	0b07 02a6 0b07 02b1 0906 02bc 0b07 02c5     ................
c0dee7ca:	0b07 02d0 0604 02db 0805 02e1 0b07 02e9     ................
c0dee7da:	0604 02f4 0f0a 02fa 0b07 0309 0b07 0314     ................
c0dee7ea:	0b07 031f 0b07 032a 0805 0335 0906 033d     ......*...5...=.
c0dee7fa:	0805 0346 0b07 034e 0b07 0359 0f0a 0364     ..F...N...Y...d.
c0dee80a:	0b07 0373 0b07 037e 0906 0389 0805 0392     ..s...~.........
c0dee81a:	0906 039a 0805 03a3 0906 03ab 0906 03b4     ................
c0dee82a:	d4d4                                        ..

c0dee82c <fontOPEN_SANS_EXTRABOLD_11PX>:
c0dee82c:	0008 0000 0c01 0009 0020 007f e6aa c0de     ........ .......
c0dee83c:	e2ed c0de                                   ....

c0dee840 <bitmapOPEN_SANS_LIGHT_16PX>:
	...
c0dee848:	9000 4924 2402 0000 2480 1249 0000 0000     ..$I.$...$I.....
c0dee858:	0000 0000 0000 4000 0902 8822 8ff8 1204     .......@..".....
c0dee868:	11ff 0441 2409 0000 0000 0000 0000 e020     ..A..$........ .
c0dee878:	20a1 0241 1c05 2070 9241 03c2 0002 0000     . A...p A.......
c0dee888:	0000 8000 4841 8904 0920 8124 6194 204a     ....AH.. .$..aJ 
c0dee898:	2409 2441 8488 0060 0000 0000 0000 0000     .$A$..`.........
c0dee8a8:	c000 1101 4088 1404 8060 4244 9412 0c40     .....@..`.DB..@.
c0dee8b8:	27c3 0000 0000 0000 9000 0024 0000 0000     .'........$.....
c0dee8c8:	2440 2222 2222 4422 2000 4442 4444 4444     @$"""""D. BDDDDD
c0dee8d8:	0022 2010 f040 0287 1105 0000 0000 0000     ".. @...........
	...
c0dee8f0:	0000 0080 8201 083f 2010 0000 0000 0000     ......?.. ......
	...
c0dee908:	0524 0000 0000 0000 000e 0000 0000 0000     $...............
c0dee918:	0000 0000 0660 0000 2200 0884 4421 1108     ....`...."..!D..
c0dee928:	0000 0000 7000 1110 4824 2090 8241 0904     .....p..$H. A...
c0dee938:	8222 0003 0000 0000 0000 6020 00a0 0201     "......... `....
c0dee948:	0804 2010 8040 0100 0000 0000 0000 7800     ... @..........x
c0dee958:	0108 0402 1008 1010 1010 e010 000f 0000     ................
c0dee968:	0000 0000 0878 0401 0c04 200f 0080 0201     ....x...... ....
c0dee978:	03e2 0000 0000 0000 0000 3004 0140 4809     ...........0@..H
c0dee988:	8220 8410 1ff0 0020 0801 0000 0000 0000      ..... .........
c0dee998:	0000 10f8 4020 8040 600f 0080 1201 03c2     .... @@..`......
c0dee9a8:	0000 0000 0000 e000 2030 4020 1e80 8243     ........0  @..C.
c0dee9b8:	0904 8422 0007 0000 0000 0000 01fc 0202     ..".............
c0dee9c8:	0804 1008 2010 4040 0080 0000 0000 0000     ..... @@........
c0dee9d8:	7000 1110 8824 0e08 8222 0904 c412 0007     .p..$...".......
c0dee9e8:	0000 0000 0000 0878 2411 9048 5e30 0080     ......x..$H.0^..
c0dee9f8:	0101 01c3 0000 0000 0000 0000 0066 6000     ............f..`
c0deea08:	0006 0000 6600 0000 2220 0000 0000 0000     .....f.. "......
c0deea18:	0604 0183 600c 0100 0000 0000 0000 0000     .....`..........
c0deea28:	0000 0000 0000 1fc0 0000 00fe 0000 0000     ................
	...
c0deea40:	1000 00c0 3006 0c18 0004 0000 0000 0000     .....0..........
c0deea50:	0000 0000 080f 0204 1041 0204 4080 0000     ........A....@..
c0deea60:	0000 0000 f800 4180 2010 93c4 2488 4921     .......A. ...$!I
c0deea70:	1248 c492 ee24 0008 0004 0002 001f 0000     H...$...........
c0deea80:	0000 0000 00c0 0c03 2048 0481 fc21 2408     ........H ..!..$
c0deea90:	4090 0201 0000 0000 0000 f000 0841 0441     .@..........A.A.
c0deeaa0:	c211 2107 1104 1044 7c21 0000 0000 0000     ...!..D.!|......
c0deeab0:	0000 87c0 0100 0802 8020 0200 4008 0200     ........ ....@..
c0deeac0:	01f0 0000 0000 0000 e000 2103 4208 0220     ...........!.B .
c0deead0:	8811 0440 1022 0841 07c1 0000 0000 0000     ..@.".A.........
c0deeae0:	0000 11f8 4020 0080 023f 0804 2010 0fc0     .... @..?.... ..
c0deeaf0:	0000 0000 0000 fc00 0404 0404 fc04 0404     ................
c0deeb00:	0404 0004 0000 0000 0000 083f 0040 2002     ..........?.@.. 
c0deeb10:	0200 7c20 2402 0440 4084 03f0 0000 0000     .. |.$@..@......
c0deeb20:	0000 0000 2040 4204 0420 2042 43fc 0420     ....@ .B .B .C .
c0deeb30:	2042 4204 0420 0002 0000 0000 0000 4440     B .B .........@D
c0deeb40:	4444 4444 0004 0000 0204 4081 1020 0408     DDDD.......@ ...
c0deeb50:	8102 2040 000c 0000 1208 4222 0282 0a03     ..@ ......"B....
c0deeb60:	8824 2110 1044 0000 0000 0000 0400 0404     $..!D...........
c0deeb70:	0404 0404 0404 0404 00fc 0000 0000 0000     ................
c0deeb80:	4201 30c0 0c30 850c a142 2850 0924 4249     .B.00...B.P($.IB
c0deeb90:	108c 0423 0008 0000 0000 0000 0000 4000     ..#............@
c0deeba0:	0c20 20c2 4214 2421 2442 4244 0428 3043      .. .B!$B$DB(.C0
c0deebb0:	0204 0000 0000 0000 0000 0f00 4108 0220     .............A .
c0deebc0:	4024 2402 0240 4024 8204 f010 0000 0000     $@.$@.$@........
c0deebd0:	0000 0000 f800 2210 8844 2110 043e 1008     ......."D..!>...
c0deebe0:	4020 0000 0000 0000 0000 0f00 4108 0220      @...........A .
c0deebf0:	4024 2402 0240 4024 8204 f010 0800 0100     $@.$@.$@........
c0deec00:	0030 0000 f000 0841 0441 4411 1f08 1044     0.....A.A..D..D.
c0deec10:	0841 0441 0001 0000 0000 0000 08f8 2012     A.A............ 
c0deec20:	0040 3007 0080 0201 07e4 0000 0000 0000     @..0............
c0deec30:	3f80 8102 2040 0810 0204 0081 0000 0000     .?..@ ..........
c0deec40:	4000 0420 2042 4204 0420 2042 4204 0420     .@ .B .B .B .B .
c0deec50:	1082 00f0 0000 0000 0000 0000 0602 2414     ...............$
c0deec60:	1048 2211 5044 80a0 0100 0000 0000 0000     H.."DP..........
c0deec70:	4000 2830 090c 2243 4891 9244 2490 0a14     .@0(..C".HD..$..
c0deec80:	8285 6061 0818 0004 0000 0000 0000 0000     ..a`............
c0deec90:	0400 2209 0482 0405 2814 1088 1411 0010     ...".....(......
c0deeca0:	0000 0000 0000 4281 2442 1824 1018 1010     .......BB$$.....
c0deecb0:	1010 0000 0000 0000 01fc 0202 0404 0804     ................
c0deecc0:	0808 1010 0fe0 0000 0000 0000 0bc0 8421     ..............!.
c0deecd0:	4210 2108 f084 0000 0820 0821 0421 0421     .B.!.... .!.!.!.
c0deece0:	0001 0000 21e0 1084 0842 8421 7a10 0000     .....!..B.!..z..
c0deecf0:	2000 40a0 8441 2088 0041 0000 0000 0000     . .@A.. A.......
	...
c0deed10:	fc00 0001 0800 8020 0000 0000 0000 0000     ...... .........
	...
c0deed2c:	0000 403c 4040 427c 6242 005c 0000 0000     ..<@@@|BBb\.....
c0deed3c:	0802 8020 7a00 2218 4090 0902 9024 7a21     .. ..z.".@..$.!z
	...
c0deed54:	0000 7800 0204 0202 0202 7804 0000 0000     ...x.......x....
c0deed64:	0000 0401 4010 1178 9026 0240 2409 6110     .....@x.&.@..$.a
c0deed74:	0178 0000 0000 0000 0000 0000 8380 2088     x.............. 
c0deed84:	fe41 0804 8420 0007 0000 0000 3800 1041     A... ........8A.
c0deed94:	411f 0410 1041 0004 0000 0000 0000 fc00     .A..A...........
c0deeda4:	4222 2242 043c 7c02 8142 3e43 0200 0804     "BB"<..|B.C>....
c0deedb4:	a010 88c3 4120 0482 1209 0824 0000 0000     .... A....$.....
c0deedc4:	0000 0200 2220 2222 0002 0000 0010 2108     .... """.......!
c0deedd4:	1084 0842 0721 0200 0202 4202 1222 0a0a     ..B.!......B"...
c0deede4:	2216 8242 0000 0000 4400 4444 4444 0444     ."B......DDDDDD.
	...
c0deedfc:	3a00 3187 0822 4209 9082 2420 0908 8242     .:.1"..B.. $..B.
c0deee0c:	0010 0000 0000 0000 0000 0000 0000 c3a0     ................
c0deee1c:	2088 8241 0904 2412 0008 0000 0000 0000     . A....$........
c0deee2c:	0000 8000 8883 4120 0482 2209 0382 0000     ...... A..."....
	...
c0deee44:	7a00 2218 4090 0902 9024 7a21 2008 0080     .z.".@..$.!z. ..
c0deee54:	0002 0000 0000 0000 1178 9026 0240 2409     ........x.&.@..$
c0deee64:	6110 0178 1004 0040 0001 0000 ba00 0821     .ax...@.......!.
c0deee74:	2082 0208 0000 0000 0000 c000 0813 180c     . ..............
c0deee84:	0810 01e4 0000 0000 0000 84f1 4210 c108     .............B..
c0deee94:	0001 0000 0000 0000 4820 2090 8241 0904     ........ H. A...
c0deeea4:	c622 000b 0000 0000 0000 0000 0c10 448a     "..............D
c0deeeb4:	0a22 8285 0000 0000 0000 0000 0000 6100     "..............a
c0deeec4:	4628 2462 9249 2944 830c 0810 0001 0000     (Fb$I.D)........
	...
c0deeedc:	4242 1824 1818 4224 0042 0000 0000 0000     BB$...$BB.......
c0deeeec:	1000 8a0c 2244 850a 4082 0810 0003 0000     ....D"...@......
c0deeefc:	e000 4103 0820 4102 03e0 0000 0000 4600     ...A ..A.......F
c0deef0c:	0410 1041 4103 0410 6041 0000 2010 8040     ..A..A..A`... @.
c0deef1c:	0100 0402 1008 4020 0080 0201 0804 0010     ...... @........
c0deef2c:	8000 2041 8208 3020 2082 4208 0018 0000     ..A .. 0. .B....
c0deef3c:	0000 0000 8000 7803 0000 0000 0000 0000     .......x........
c0deef4c:	0000 0000 0000 0fc0 8421 4210 2108 1084     ........!..B.!..
c0deef5c:	0842 fc21 0000 0000 0000 d400               B.!.........

c0deef68 <charactersOPEN_SANS_LIGHT_16PX>:
c0deef68:	0904 0000 0703 0009 0e06 0010 170a 001e     ................
c0deef78:	1509 0035 1e0d 004a 190b 0068 0703 0081     ..5...J...h.....
c0deef88:	0904 0088 0904 0091 1509 009a 1509 00af     ................
c0deef98:	0703 00c4 0c05 00cb 0904 00d7 0c05 00e0     ................
c0deefa8:	1509 00ec 1509 0101 1509 0116 1509 012b     ..............+.
c0deefb8:	190b 0140 1509 0159 1509 016e 1509 0183     ..@...Y...n.....
c0deefc8:	1509 0198 1509 01ad 0904 01c2 0904 01cb     ................
c0deefd8:	1509 01d4 1509 01e9 1509 01fe 1007 0213     ................
c0deefe8:	200e 0223 170a 0243 170a 025a 170a 0271     . #...C...Z...q.
c0deeff8:	190b 0288 1509 02a1 1208 02b6 1b0c 02c8     ................
c0def008:	1b0c 02e3 0904 02fe 1007 0307 1509 0317     ................
c0def018:	1208 032c 200e 033e 1b0c 035e 1b0c 0379     ..,.. >...^...y.
c0def028:	1509 0394 1b0c 03a9 170a 03c4 1509 03db     ................
c0def038:	1007 03f0 1b0c 0400 1509 041b 200e 0430     ............. 0.
c0def048:	1509 0450 1208 0465 1509 0477 0c05 048c     ..P...e...w.....
c0def058:	0c05 0498 0c05 04a4 1509 04b0 1007 04c5     ................
c0def068:	1509 04d5 1208 04ea 170a 04fc 1208 0513     ................
c0def078:	170a 0525 1509 053c 0e06 0551 1208 055f     ..%...<...Q..._.
c0def088:	1509 0571 0904 0586 0c05 058f 1208 059b     ..q.............
c0def098:	0904 05ad 200e 05b6 1509 05d6 1509 05eb     ..... ..........
c0def0a8:	170a 0600 170a 0617 0e06 062e 1007 063c     ..............<.
c0def0b8:	0c05 064c 1509 0658 1007 066d 1b0c 067d     ..L...X...m...}.
c0def0c8:	1208 0698 1007 06aa 1007 06ba 0e06 06ca     ................
c0def0d8:	1509 06d8 0e06 06ed 1509 06fb 170a 0710     ................

c0def0e8 <fontOPEN_SANS_LIGHT_16PX>:
c0def0e8:	0009 0000 1201 000d 0020 007f ef68 c0de     ........ ...h...
c0def0f8:	e840 c0de                                   @...

c0def0fc <bitmapOPEN_SANS_REGULAR_11PX>:
c0def0fc:	0000 0000 9000 0924 0002 0660 0000 0000     ......$...`.....
c0def10c:	1000 4fc9 fca1 0224 0000 0000 29e0 830a     ...O..$......)..
c0def11c:	1e61 0000 8c00 50a8 cda1 2a16 c454 0000     a......P...*T...
c0def12c:	0000 1c00 1212 4a0c 2252 005e 0000 0028     .......JR"^...(.
c0def13c:	9000 2494 0092 4490 9292 0000 fc41 048c     ...$...D....A...
c0def14c:	0000 0000 0000 c800 008f 0000 0000 0000     ................
c0def15c:	0052 0000 0600 0000 0000 0200 8000 2444     R.............D$
c0def16c:	0122 0000 4923 2492 0c49 0000 a300 0820     "...#I.$I..... .
c0def17c:	2082 0008 8000 4103 4210 1e08 0000 0380     . .....A.B......
c0def18c:	0c41 4104 000e 0000 3020 2428 7e24 2020     A..A.... 0($$~  
c0def19c:	0000 8000 0827 041e 0e41 0000 2700 9e08     ....'...A....'..
c0def1ac:	4924 000c 8000 4107 4208 0410 0000 2300     $I.....A.B.....#
c0def1bc:	8c49 4924 000c 0000 4923 0792 0e41 0000     I.$I....#I..A...
c0def1cc:	0400 0200 0000 0004 0052 0000 8621 4081     ........R...!..@
c0def1dc:	0000 0000 0000 e01e 0001 0000 2000 1810     ............. ..
c0def1ec:	0846 0000 c000 8841 0108 0004 0000 43e0     F.....A........C
c0def1fc:	5c90 294a 94a5 027e 01f0 0000 0400 4285     .\J)..~........B
c0def20c:	f911 4144 0000 0000 489f 11e4 4489 003e     ..DA.....H...D>.
c0def21c:	0000 9e00 2041 0810 3c0c 0000 0000 423e     ....A ...<....>B
c0def22c:	4242 4242 3e42 0000 8000 0827 209e 1e08     BBBBB>....'.. ..
c0def23c:	0000 2f80 8208 082f 0002 0000 027c 0202     .../../.....|...
c0def24c:	4262 7c42 0000 0000 4242 7e42 4242 4242     bBB|....BBB~BBBB
c0def25c:	0000 9000 4924 0002 4440 4444 0344 9100     ....$I..@DDDD...
c0def26c:	6144 4850 4244 0000 8000 0820 2082 3e08     DaPHDB.... .. .>
c0def27c:	0000 1800 9866 4a61 2529 4c93 0132 0000     ....f.aJ)%.L2...
c0def28c:	0000 4642 4a4a 5252 4262 0000 0000 08f8     ..BFJJRRbB......
c0def29c:	2412 9048 4120 007c 0000 0000 488f f224     .$H. A|......H$.
c0def2ac:	0408 0002 0000 f800 1208 4824 2090 7c41     ..........$H. A|
c0def2bc:	0040 0001 8f00 2448 48f2 2244 0000 0000     @.....H$.HD"....
c0def2cc:	0827 0606 0e41 0000 1f00 8102 2040 0810     '...A.......@ ..
c0def2dc:	0000 0000 4242 4242 4242 3c42 0000 8000     ....BBBBBBB<....
c0def2ec:	48a0 a224 2850 0008 0000 c400 9328 4a4c     .H$.P(......(.LJ
c0def2fc:	a529 2114 0084 0000 4000 3128 230c 2149     )..!.....@(1.#I!
c0def30c:	0000 2840 0c49 2082 0008 8000 2107 2108     ..@(I.. .....!.!
c0def31c:	1e08 0000 22e0 2222 0e22 2210 4442 0008     ....."""".."BD..
c0def32c:	4470 4444 0744 c300 5248 0008 0000 0000     pDDDD...HR......
c0def33c:	0000 0000 7c00 0400 0002 0000 0000 0000     .....|..........
c0def34c:	0000 9078 4927 001e 0000 c081 1223 4489     ..x.'I......#..D
c0def35c:	001e 0000 0000 842e 1c10 0000 1000 2788     ...............'
c0def36c:	8912 3c44 0000 0000 7000 2792 1c08 0000     ..D<.....p.'....
c0def37c:	8980 8427 0210 0000 0000 92f8 08e4 185e     ..'...........^.
c0def38c:	007a c081 1223 4489 0022 0000 2410 0249     z...#..D"....$I.
c0def39c:	4000 4440 4444 8074 4820 a18a 1248 0000     .@@DDDt. H..H...
c0def3ac:	2490 0249 0000 0000 7780 8922 9224 2248     .$I......w".$.H"
c0def3bc:	0001 0000 0000 23c0 8912 2244 0000 0000     .......#..D"....
c0def3cc:	8000 1223 4489 001c 0000 0000 23c0 8912     ..#..D.......#..
c0def3dc:	1e44 4081 0000 8000 1227 4489 103c 0408     D..@....'..D<...
c0def3ec:	e000 2222 0002 0000 0c27 0e82 0000 f200     ..""....'.......
c0def3fc:	2222 000e 0000 2440 8912 3e44 0000 0000     ""....@$..D>....
c0def40c:	8400 2492 0c31 0000 0000 8800 4aa8 2a95     ...$1........J.*
c0def41c:	4422 0000 0000 0000 1248 48c3 0012 0000     "D......H..H....
c0def42c:	8400 2492 0c31 0c41 8000 088f 1f11 0000     ...$1.A.........
c0def43c:	44c0 4224 0c44 8200 0820 2082 8208 3020     .D$BD... .. .. 0
c0def44c:	4222 2224 0003 0000 0606 0000 0000 9f00     "B$"............
c0def45c:	2448 8912 3e44 0000 d400                    H$..D>....

c0def466 <charactersOPEN_SANS_REGULAR_11PX>:
c0def466:	0503 0000 0503 0005 0604 000a 0b07 0010     ................
c0def476:	0906 001b 0e09 0024 0c08 0032 0302 003e     ......$...2...>.
c0def486:	0503 0041 0503 0046 0906 004b 0906 0054     ..A...F...K...T.
c0def496:	0503 005d 0604 0062 0503 0068 0604 006d     ..]...b...h...m.
c0def4a6:	0906 0073 0906 007c 0906 0085 0906 008e     ..s...|.........
c0def4b6:	0c08 0097 0906 00a3 0906 00ac 0906 00b5     ................
c0def4c6:	0906 00be 0906 00c7 0503 00d0 0503 00d5     ................
c0def4d6:	0906 00da 0906 00e3 0906 00ec 0805 00f5     ................
c0def4e6:	0f0a 00fd 0b07 010c 0b07 0117 0b07 0122     ..............".
c0def4f6:	0c08 012d 0906 0139 0906 0142 0c08 014b     ..-...9...B...K.
c0def506:	0c08 0157 0503 0163 0604 0168 0b07 016e     ..W...c...h...n.
c0def516:	0906 0179 0f0a 0182 0c08 0191 0e09 019d     ..y.............
c0def526:	0b07 01ab 0e09 01b6 0b07 01c4 0906 01cf     ................
c0def536:	0b07 01d8 0c08 01e3 0b07 01ef 0f0a 01fa     ................
c0def546:	0906 0209 0906 0212 0906 021b 0604 0224     ..............$.
c0def556:	0604 022a 0604 0230 0906 0236 0805 023f     ..*...0...6...?.
c0def566:	0906 0247 0906 0250 0b07 0259 0805 0264     ..G...P...Y...d.
c0def576:	0b07 026c 0906 0277 0805 0280 0906 0288     ..l...w.........
c0def586:	0b07 0291 0503 029c 0604 02a1 0906 02a7     ................
c0def596:	0503 02b0 0f0a 02b5 0b07 02c4 0b07 02cf     ................
c0def5a6:	0b07 02da 0b07 02e5 0604 02f0 0805 02f6     ................
c0def5b6:	0604 02fe 0b07 0304 0906 030f 0e09 0318     ................
c0def5c6:	0906 0326 0906 032f 0805 0338 0604 0340     ..&.../...8...@.
c0def5d6:	0906 0346 0604 034f 0906 0355 0b07 035e     ..F...O...U...^.
c0def5e6:	d4d4                                        ..

c0def5e8 <fontOPEN_SANS_REGULAR_11PX>:
c0def5e8:	000a 0000 0c01 0009 0020 007f f466 c0de     ........ ...f...
c0def5f8:	f0fc c0de                                   ....

c0def5fc <C_bagl_fonts>:
c0def5fc:	e82c c0de f0e8 c0de f5e8 c0de               ,...........

c0def608 <C_bagl_fonts_count>:
c0def608:	0003 0000                                   ....

c0def60c <BLS12_381_FIELD_MODULUS>:
c0def60c:	011a ea11 7f39 9ae6 1b4b b6a7 4b43 d7ac     ....9...K...CK..
c0def61c:	7764 844b 85f3 bf12 3067 a0d2 b0f6 24f6     dwK.....g0.....$
c0def62c:	ab1e feff 53b1 ffff feb9 ffff ffff abaa     .....S..........

c0def63c <LEDGER_NFT_METADATA_PUBLIC_KEY>:
c0def63c:	9804 a68d 46b2 8ef2 c177 b6ba cb75 272a     .....F..w...u.*'
c0def64c:	f744 cef5 6ac5 e0e6 2332 7b33 9457 6acd     D....j..2#3{W..j
c0def65c:	7de0 b348 b90d b4cc 5a0f a102 3a1a 9db9     .}H......Z...:..
c0def66c:	595f 3d5a a050 30e1 fd23 950d 9287 97d7     _YZ=P..0#.......
c0def67c:	                                             .

c0def67d <LEDGER_SIGNATURE_PUBLIC_KEY>:
c0def67d:	5e04 106c c120 c44d 4264 89fe 7cf9 680b     .^l. .M.dB...|.h
c0def68d:	b1cd 7659 24dc 4cf2 6e31 307b 4efe c78c     ..Yv.$.L1n{0.N..
c0def69d:	146b 1589 210c 4e51 44bf f50f a5de 3d39     k....!QN.D....9=
c0def6ad:	de83 5853 09cd ce8f d08f 1df8 94aa 9197     ..SX............
c0def6bd:	                                             .

c0def6be <LEDGER_SIGNATURE_PUBLIC_KEY>:
c0def6be:	5e04 106c c120 c44d 4264 89fe 7cf9 680b     .^l. .M.dB...|.h
c0def6ce:	b1cd 7659 24dc 4cf2 6e31 307b 4efe c78c     ..Yv.$.L1n{0.N..
c0def6de:	146b 1589 210c 4e51 44bf f50f a5de 3d39     k....!QN.D....9=
c0def6ee:	de83 5853 09cd ce8f d08f 1df8 94aa 9197     ..SX............
c0def6fe:	                                             .

c0def6ff <LEDGER_NFT_SELECTOR_PUBLIC_KEY>:
c0def6ff:	d804 6e62 9e01 3e55 6919 f156 4d17 b8cd     ..bn..U>.iV..M..
c0def70f:	1c9a c4da 9093 bc08 7779 6d33 2478 e3ee     ........yw3mx$..
c0def71f:	62a2 1a24 7362 3b52 b809 ced0 390d 60e8     .b$.bsR;.....9.`
c0def72f:	4dc9 5302 db58 25dc c792 48c6 390d bbce     .M.SX..%...H.9..
c0def73f:	                                             .

c0def740 <SIGN_MAGIC>:
c0def740:	4519 6874 7265 7565 206d 6953 6e67 6465     .Ethereum Signed
c0def750:	4d20 7365 6173 6567 0a3a                      Message:..

c0def75b <UNDERLYING_ASSET_DECIMALS>:
c0def75b:	4463 4941 0000 0000 0000 0000 4312 5445     cDAI.........CET
c0def76b:	0048 0000 0000 0000 1200 5543 4453 0043     H.........CUSDC.
c0def77b:	0000 0000 0000 4306 525a 0058 0000 0000     .......CZRX.....
c0def78b:	0000 1200 5543 4453 0054 0000 0000 0000     ....CUSDT.......
c0def79b:	4306 5442 0043 0000 0000 0000 0800 4243     .CBTC.........CB
c0def7ab:	5441 0000 0000 0000 0000 4312 4552 0050     AT.........CREP.
c0def7bb:	0000 0000 0000 1200 5363 4941 0000 0000     ........cSAI....
c0def7cb:	0000 0000                                    .....

c0def7d0 <MINTABLE_ERC721_SELECTOR>:
c0def7d0:	b8b8 7266                                   ..fr

c0def7d4 <MINTABLE_ERC20_SELECTOR>:
c0def7d4:	6468 2d6e                                   hdn-

c0def7d8 <COMPOUND_EXPECTED_DATA_SIZE>:
c0def7d8:	2424 0424                                   $$$.

c0def7dc <ERC20_SELECTOR>:
c0def7dc:	72f4 b061                                   .ra.

c0def7e0 <ERC721_SELECTOR>:
c0def7e0:	5702 9217                                   .W..

c0def7e4 <ERC1155_APPROVE_FOR_ALL_SELECTOR>:
c0def7e4:	2ca2 65b4                                   .,.e

c0def7e8 <ERC1155_SAFE_TRANSFER_SELECTOR>:
c0def7e8:	42f2 2a43                                   .BC*

c0def7ec <ERC1155_SAFE_BATCH_TRANSFER>:
c0def7ec:	b22e d6c2                                   ....

c0def7f0 <ERC1155_SELECTORS>:
c0def7f0:	f7e4 c0de f7e8 c0de f7ec c0de               ............

c0def7fc <CONTRACTS>:
c0def7fc:	6f43 706d 756f 646e 4420 4941 0000 5d00     Compound DAI...]
c0def80c:	533a 4d6e bd6d 1461 1ecc 35ad 7b77 94ab     :SnMm.a....5w{..
c0def81c:	368e 4343 6d6f 6f70 6e75 2064 5445 0048     .6CCompound ETH.
c0def82c:	0000 dc4d 192d 4839 6d92 f902 feb1 1d9e     ..M.-.9H.m......
c0def83c:	07aa 2718 d50e 6f43 706d 756f 646e 5520     ...'..Compound U
c0def84c:	4453 0043 3900 39aa 21c0 badf fae8 45c5     SDC..9.9.!.....E
c0def85c:	6693 ac93 7d91 755e 4363 6d6f 6f70 6e75     .f...}^ucCompoun
c0def86c:	2064 525a 0058 0000 31b3 5d9f bc18 840d     d ZRX....1.]....
c0def87c:	1bdd 2548 dedc 5f5d 6672 07d4 6f43 706d     ..H%..]_rf..Comp
c0def88c:	756f 646e 5520 4453 0054 f600 c350 8dd8     ound USDT...P...
c0def89c:	db12 5b85 f78b 1bd1 c5e6 4e5a dc07 43c9     ...[......ZN...C
c0def8ac:	6d6f 6f70 6e75 2064 4257 4354 0000 1bc1     ompound WBTC....
c0def8bc:	6812 a3c1 e584 485c 39c2 8d1d 0248 a364     .h....\H.9..H.d.
c0def8cc:	f4a7 6f43 706d 756f 646e 4220 5441 0000     ..Compound BAT..
c0def8dc:	6c00 6b8c e702 beb2 d414 60fa df22 d7d6     .l.k.......`"...
c0def8ec:	2159 0ed9 434e 6d6f 6f70 6e75 2064 4552     Y!..NCompound RE
c0def8fc:	0050 0000 8015 ee79 fc67 f5e2 7284 65a9     P.....y.g....r.e
c0def90c:	a784 7a3c acb9 c195 6f43 706d 756f 646e     ..<z....Compound
c0def91c:	5320 4941 0000 f500 e5dc 8272 84a5 74d2      SAI......r....t
c0def92c:	af6f 9315 12d3 ca1f 44c4 43dc 6d6f 6f70     o........D.Compo
c0def93c:	6e75 2064 4e55 0049 0000 a135 0080 0d23     und UNI...5...#.
c0def94c:	75a7 c2ca 7348 0fd0 5bf8 decc 50d5 6150     .u..Hs...[...PPa
c0def95c:	6172 7773 7061 0000 0000 0000 1b00 35d4     raswap.........5
c0def96c:	c0f3 b654 01e9 b1b7 a008 76ab c817 6708     ..T........v...g
c0def97c:	4c7b 6469 006f 0000 0000 0000 0000 0000     {Lido...........
c0def98c:	397f 81c5 95f5 3cb5 b15c d09b f8b3 6cda     .9.....<\......l
c0def99c:	5e93 a02c 7257 7061 6570 2064 7473 5445     .^,.Wrapped stET
c0def9ac:	0048 ae00 b97a 2065 3ade e518 11e1 eab5     H...z.e .:......
c0def9bc:	09ab 1253 fed7                               ..S....

c0def9c3 <ERC721_APPROVE_SELECTOR>:
c0def9c3:	5e09 b3a7                                   .^..

c0def9c7 <ERC721_APPROVE_FOR_ALL_SELECTOR>:
c0def9c7:	2ca2 65b4                                   .,.e

c0def9cb <ERC721_TRANSFER_SELECTOR>:
c0def9cb:	b823 dd72                                   #.r.

c0def9cf <ERC721_SAFE_TRANSFER_SELECTOR>:
c0def9cf:	8442 0e2e                                   B...

c0def9d3 <ERC721_SAFE_TRANSFER_DATA_SELECTOR>:
c0def9d3:	8db8 de4f                                    ..O..

c0def9d8 <ERC721_SELECTORS>:
c0def9d8:	f9c3 c0de f9c7 c0de f9cb c0de f9cf c0de     ................
c0def9e8:	f9d3 c0de                                   ....

c0def9ec <deposit_contract_address>:
c0def9ec:	0000 0000 9a21 40b5 6c35 83bb be9c 3005     ....!..@5l.....0
c0def9fc:	773d fa05                                   =w..

c0defa00 <ERC20_TRANSFER_SELECTOR>:
c0defa00:	05a9 bb9c                                   ....

c0defa04 <ERC20_APPROVE_SELECTOR>:
c0defa04:	5e09 b3a7                                   .^..

c0defa08 <ERC20_SELECTORS>:
c0defa08:	fa00 c0de fa04 c0de                         ........

c0defa10 <COMPOUND_REDEEM_UNDERLYING_SELECTOR>:
c0defa10:	2a85 e312                                   .*..

c0defa14 <COMPOUND_REDEEM_SELECTOR>:
c0defa14:	00db 756a                                   ..ju

c0defa18 <COMPOUND_MINT_SELECTOR>:
c0defa18:	71a0 682d                                   .q-h

c0defa1c <CETH_MINT_SELECTOR>:
c0defa1c:	4912 8bc5                                   .I..

c0defa20 <COMPOUND_SELECTORS>:
c0defa20:	fa10 c0de fa14 c0de fa18 c0de fa1c c0de     ................

c0defa30 <ETH2_DEPOSIT_SELECTOR>:
c0defa30:	8922 1851                                   ".Q.

c0defa34 <ETH2_SELECTORS>:
c0defa34:	fa30 c0de                                   0...

c0defa38 <STARKWARE_REGISTER_ID>:
c0defa38:	24dd d414                                   .$..

c0defa3c <STARKWARE_DEPOSIT_TOKEN_ID>:
c0defa3c:	0525 d9c3                                   %...

c0defa40 <STARKWARE_DEPOSIT_ETH_ID>:
c0defa40:	ae00 8aef                                   ....

c0defa44 <STARKWARE_DEPOSIT_CANCEL_ID>:
c0defa44:	f77d 04dc                                   }...

c0defa48 <STARKWARE_DEPOSIT_RECLAIM_ID>:
c0defa48:	87ae 1638                                   ..8.

c0defa4c <STARKWARE_WITHDRAW_ID>:
c0defa4c:	1a44 703e                                   D.>p

c0defa50 <STARKWARE_FULL_WITHDRAWAL_ID>:
c0defa50:	33a9 c410                                   .3..

c0defa54 <STARKWARE_FREEZE_ID>:
c0defa54:	c193 66e4                                   ...f

c0defa58 <STARKWARE_ESCAPE_ID>:
c0defa58:	3a9e c4da                                   .:..

c0defa5c <STARKWARE_VERIFY_ESCAPE_ID>:
c0defa5c:	d52d 0630                                   -.0.

c0defa60 <STARKWARE_WITHDRAW_TO_ID>:
c0defa60:	cd14 e470                                   ..p.

c0defa64 <STARKWARE_DEPOSIT_NFT_ID>:
c0defa64:	1cae e6dd                                   ....

c0defa68 <STARKWARE_DEPOSIT_NFT_RECLAIM_ID>:
c0defa68:	b0fc 2258                                   ..X"

c0defa6c <STARKWARE_WITHDRAW_AND_MINT_ID>:
c0defa6c:	14d9 b743                                   ..C.

c0defa70 <STARKWARE_WITHDRAW_NFT_ID>:
c0defa70:	9b01 7a41                                   ..Az

c0defa74 <STARKWARE_WITHDRAW_NFT_TO_ID>:
c0defa74:	efeb d00f                                   ....

c0defa78 <STARKWARE_REGISTER_AND_DEPOSIT_TOKEN_ID>:
c0defa78:	8210 cf08                                   ....

c0defa7c <STARKWARE_REGISTER_AND_DEPOSIT_ETH_ID>:
c0defa7c:	78a7 c3c0                                   .x..

c0defa80 <STARKWARE_PROXY_DEPOSIT_TOKEN_ID>:
c0defa80:	cadc 24d5                                   ...$

c0defa84 <STARKWARE_PROXY_DEPOSIT_ETH_ID>:
c0defa84:	e56c 57d9                                   l..W

c0defa88 <STARKWARE_SELECTORS>:
c0defa88:	fa38 c0de fa3c c0de fa40 c0de fa44 c0de     8...<...@...D...
c0defa98:	fa48 c0de fa4c c0de fa50 c0de fa54 c0de     H...L...P...T...
c0defaa8:	fa58 c0de fa5c c0de fa60 c0de fa64 c0de     X...\...`...d...
c0defab8:	fa68 c0de fa6c c0de fa70 c0de fa74 c0de     h...l...p...t...
c0defac8:	fa78 c0de fa7c c0de fa80 c0de fa84 c0de     x...|...........

c0defad8 <INTERNAL_ETH_PLUGINS>:
c0defad8:	3619 c0de fa08 c0de 2d02 7265 3263 0030     .6.......-erc20.
c0defae8:	0000 0000 3649 c0de 0000 0000 fa20 c0de     ....I6...... ...
c0defaf8:	2d04 6d63 6470 0000 0000 0000 2ddd c0de     .-cmpd.......-..
c0defb08:	0000 0000 fa34 c0de 2d01 7465 3268 0000     ....4....-eth2..
c0defb18:	0000 0000 3c15 c0de 0000 0000 fa88 c0de     .....<..........
c0defb28:	2d14 7473 6b72 0000 0000 0000 8b81 c0de     .-strk..........
	...

c0defb50 <C_icon_back_x_colors>:
c0defb50:	0000 0000 ffff 00ff                         ........

c0defb58 <C_icon_back_x_bitmap>:
c0defb58:	0000 0000 800c 7003 0e00 ffc0 3ff0 0038     .......p.....?8.
c0defb68:	001c 000e 0003 0000 d400 d4d4               ............

c0defb74 <C_icon_back_x>:
c0defb74:	000e 0000 000e 0000 0001 0000 fb50 c0de     ............P...
c0defb84:	fb58 c0de                                   X...

c0defb88 <C_icon_certificate_colors>:
c0defb88:	0000 0000 ffff 00ff                         ........

c0defb90 <C_icon_certificate_bitmap>:
c0defb90:	0000 c1fe 30ff ec30 030d dec3 3030 0dec     .....00.....00..
c0defba0:	c303 f0c0 f83f 0007 d400 d4d4               ....?.......

c0defbac <C_icon_certificate>:
c0defbac:	000e 0000 000e 0000 0001 0000 fb88 c0de     ................
c0defbbc:	fb90 c0de                                   ....

c0defbc0 <C_icon_crossmark_colors>:
c0defbc0:	0000 0000 ffff 00ff                         ........

c0defbc8 <C_icon_crossmark_bitmap>:
c0defbc8:	8000 e601 71c0 3838 fc07 1e00 0780 03f0     .....q88........
c0defbd8:	c1ce 38e1 0670 0018 d400 d4d4               ...8p.......

c0defbe4 <C_icon_crossmark>:
c0defbe4:	000e 0000 000e 0000 0001 0000 fbc0 c0de     ................
c0defbf4:	fbc8 c0de                                   ....

c0defbf8 <C_icon_dashboard_x_colors>:
c0defbf8:	0000 0000 ffff 00ff                         ........

c0defc00 <C_icon_dashboard_x_bitmap>:
c0defc00:	0000 0000 800c f007 fe03 ffc1 3ff0 03f0     .............?..
c0defc10:	00cc c033 000c 0000 d400 d4d4               ..3.........

c0defc1c <C_icon_dashboard_x>:
c0defc1c:	000e 0000 000e 0000 0001 0000 fbf8 c0de     ................
c0defc2c:	fc00 c0de                                   ....

c0defc30 <C_icon_eye_colors>:
c0defc30:	0000 0000 ffff 00ff                         ........

c0defc38 <C_icon_eye_bitmap>:
c0defc38:	0000 0000 e01e 1c1f 030e 8c63 6319 0c0c     ..........c..c..
c0defc48:	8387 807f 0007 0000 d400 d4d4               ............

c0defc54 <C_icon_eye>:
c0defc54:	000e 0000 000e 0000 0001 0000 fc30 c0de     ............0...
c0defc64:	fc38 c0de                                   8...

c0defc68 <C_icon_left_colors>:
c0defc68:	0000 0000 ffff 00ff                         ........

c0defc70 <C_icon_left_bitmap>:
c0defc70:	1248 0842                                   H.B.

c0defc74 <C_icon_left>:
c0defc74:	0004 0000 0007 0000 0001 0000 fc68 c0de     ............h...
c0defc84:	fc70 c0de                                   p...

c0defc88 <C_icon_right_colors>:
c0defc88:	0000 0000 ffff 00ff                         ........

c0defc90 <C_icon_right_bitmap>:
c0defc90:	8421 0124                                   !.$.

c0defc94 <C_icon_right>:
c0defc94:	0004 0000 0007 0000 0001 0000 fc88 c0de     ................
c0defca4:	fc90 c0de                                   ....

c0defca8 <C_icon_validate_14_colors>:
c0defca8:	0000 0000 ffff 00ff                         ........

c0defcb0 <C_icon_validate_14_bitmap>:
c0defcb0:	0000 0000 0000 00c0 0038 e067 1c38 039c     ........8.g.8...
c0defcc0:	007e 800f 0001 0000 d400 d4d4               ~...........

c0defccc <C_icon_validate_14>:
c0defccc:	000e 0000 000e 0000 0001 0000 fca8 c0de     ................
c0defcdc:	fcb0 c0de                                   ....

c0defce0 <C_icon_warning_colors>:
c0defce0:	0000 0000 ffff 00ff                         ........

c0defce8 <C_icon_warning_bitmap>:
c0defce8:	0000 0030 800c 2007 cc01 3300 1ce0 0738     ..0.... ...3..8.
c0defcf8:	c3ff f8f3 fe7c 001f d400 d4d4               ....|.......

c0defd04 <C_icon_warning>:
c0defd04:	000e 0000 000e 0000 0001 0000 fce0 c0de     ................
c0defd14:	fce8 c0de                                   ....

c0defd18 <service_uuid>:
c0defd18:	6572 6467 4c65 0000 0004 2c97 3400 13d6     regdeL.....,.4..

c0defd28 <charUuidTX>:
c0defd28:	6572 6467 4c65 0001 0004 2c97 3400 13d6     regdeL.....,.4..

c0defd38 <charUuidRX>:
c0defd38:	6572 6467 4c65 0002 0004 2c97 3400 13d6     regdeL.....,.4..
c0defd48:	6f43 746e 6172 7463 d400 d4d4               Contract....

c0defd54 <U_os_perso_seed_cookie>:
c0defd54:	ba5e da7a 51c5 c1a5                         ^.z..Q..

c0defd5c <seph_io_general_status>:
c0defd5c:	0060 0002                                    `....

c0defd61 <seph_io_mcu_protect>:
c0defd61:	0031 0201                                   1...

c0defd65 <g_pcHex>:
c0defd65:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef

c0defd75 <g_pcHex_cap>:
c0defd75:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF

c0defd85 <STARK_DERIVE_BIAS>:
c0defd85:	00f8 0000 0000 0e02 ffff ffff ffff f7ff     ................
c0defd95:	a138 4b3b 0e92 1194 6dae f4a5 030b b158     8.;K.....m....X.

c0defda5 <C_cx_Stark256_n>:
c0defda5:	0008 0000 0000 1000 ffff ffff ffff ffff     ................
c0defdb5:	81b7 6d12 e7ca 32b2 661e 41a2 c6ad 2f4d     ...m...2.f.A..M/

c0defdc5 <PEDERSEN_POINTS>:
c0defdc5:	0204 2834 cb7d feaf 967f 749c 5586 a9fc     ..4(}......t.U..
c0defdd5:	8fe5 12a8 6d0b eb56 100c d180 5779 e4eb     .....mV.....yW..
c0defde5:	037b 56b0 00f1 6ff9 1eb2 9588 d427 4e1f     {..V...o....'..N
c0defdf5:	9439 3501 7add 946c 6ecc 26d0 e88e 569e     9..5.zl..n.&...V
c0defe05:	0415 fa04 f356 c876 b33d 9d3f 26ab 5556     ....V.v.=.?..&VU
c0defe15:	338f 0999 c19e 5ede 1830 a6b7 2d93 8aba     .3.....^0....-..
c0defe25:	78a3 fa03 8409 31c9 e3c9 1381 c0e0 7ee4     .x.....1.......~
c0defe35:	0144 2756 f961 7a2a b423 6851 e8f4 f50f     D.V'a.*z#.Qh....
c0defe45:	4db5 0404 4cba 66c1 8dbe 76ec 1049 5bf7     .M...L.f...vI..[
c0defe55:	f745 404b 90c6 47c7 e909 3a0f 72a3 bdf0     E.K@...G...:.r..
c0defe65:	692d 0097 3040 f51c 75c1 4b1f 1e97 c446     -i..@0...u.K..F.
c0defe75:	e8ed ca5f c5c5 5c9a aee5 487c 1f15 b227     .._....\..|H..'.
c0defe85:	214b 049c 4305 dc02 e6b0 1ccc 446e a8cc     K!...C......nD..
c0defe95:	1af6 bb63 a62c 4850 3fd5 25b3 6fd3 2cf1     ..c.,.PH.?.%.o.,
c0defea5:	a549 0282 b701 3e7b d137 0435 48b3 6204     I.....{>7.5..H.b
c0defeb5:	d868 25ae 98ce 78ad 253c 1a56 9d87 77cc     h..%...x<%V....w
c0defec5:	9ce9 2624 d4d4                               ..$&...

c0defecc <PEDERSEN_SHIFT>:
c0defecc:	0404 e39e a8eb 60c1 0007 1bee eb87 9f59     .......`......Y.
c0defedc:	7116 0b6b 2210 7794 5533 de1f 5040 68ca     .qk..".w3U..@P.h
c0defeec:	0304 0cca 4bfe c63b f3dd d446 069d 0eea     .....K;...F.....
c0defefc:	4ed3 1062 c062 56e0 d0c1 5d40 6e26 2610     .Nb.b..V..@]&n.&
c0deff0c:	                                             .

c0deff0d <ETH_SELECTOR>:
c0deff0d:	2283 f2ff                                   ."..

c0deff11 <MINTABLE_ASSET_ID_PREFIX>:
c0deff11:	494d 544e 4241 454c 003a                    MINTABLE:.

c0deff1b <DEVERSIFI_CONTRACT>:
c0deff1b:	5d02 0422 ac5d b0ea 153b 3180 b7ec d0d9     .]".]...;..1....
c0deff2b:	ad6f 6024 7d9b f0e1 0442 29ef 9d22 e784     o.$`.}..B..)"...
c0deff3b:	c2c0 21d1 286c 5a64                          ...!l(dZ.

c0deff44 <STARKWARE_EXPECTED_DATA_SIZE>:
c0deff44:	8400 6464 4464 4444 0084 8464 0084 8464     ..dddDDD..d...d.
c0deff54:	0000 64c4                                   ...d

c0deff58 <STARKWARE_NUM_SCREENS>:
c0deff58:	0403 0304 0403 0303 0104 0504 0305 0505     ................
c0deff68:	0505 0404                                   ....

c0deff6c <SW_INTERNAL>:
c0deff6c:	006f                                        o.

c0deff6e <SW_BUSY>:
c0deff6e:	0190                                        ..

c0deff70 <SW_WRONG_LENGTH>:
c0deff70:	0067                                        g.

c0deff72 <SW_PROOF_OF_PRESENCE_REQUIRED>:
c0deff72:	8569                                        i.

c0deff74 <.L.str>:
c0deff74:	d0f1 0000 0000                              ......

c0deff7a <SW_BAD_KEY_HANDLE>:
c0deff7a:	806a                                        j.

c0deff7c <U2F_VERSION>:
c0deff7c:	3255 5f46 3256 0090                         U2F_V2..

c0deff84 <INFO>:
c0deff84:	0901 0090                                   ....

c0deff88 <SW_UNKNOWN_CLASS>:
c0deff88:	006e                                        n.

c0deff8a <SW_UNKNOWN_INSTRUCTION>:
c0deff8a:	006d                                        m.

c0deff8c <EIP_712_MAGIC>:
c0deff8c:	0119 d4d4                                   ....

c0deff90 <ux_idle_flow_1_step_val>:
c0deff90:	e1e1 c0de e2a5 c0de                         ........

c0deff98 <ux_idle_flow_1_step>:
c0deff98:	cba1 c0de ff90 c0de 0000 0000 0000 0000     ................

c0deffa8 <ux_idle_flow_2_step_val>:
c0deffa8:	e00e c0de e180 c0de                         ........

c0deffb0 <ux_idle_flow_2_step>:
c0deffb0:	caf9 c0de ffa8 c0de 0000 0000 0000 0000     ................

c0deffc0 <ux_idle_flow_3_step_validate_step>:
c0deffc0:	a3c1 c0de 0000 0000 0000 0000 0000 0000     ................

c0deffd0 <ux_idle_flow_3_step_validate>:
c0deffd0:	ffc0 c0de ffff ffff                         ........

c0deffd8 <ux_idle_flow_3_step_val>:
c0deffd8:	fc54 c0de df91 c0de                         T.......

c0deffe0 <ux_idle_flow_3_step>:
c0deffe0:	d0c1 c0de ffd8 c0de ffd0 c0de 0000 0000     ................

c0defff0 <ux_idle_flow_4_step_validate_step>:
c0defff0:	a491 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0000 <ux_idle_flow_4_step_validate>:
c0df0000:	fff0 c0de ffff ffff                         ........

c0df0008 <ux_idle_flow_4_step_val>:
c0df0008:	fc1c c0de e1b2 c0de                         ........

c0df0010 <ux_idle_flow_4_step>:
c0df0010:	d0c1 c0de 0008 c0df 0000 c0df 0000 0000     ................

c0df0020 <ux_idle_flow>:
c0df0020:	ff98 c0de ffb0 c0de ffe0 c0de 0010 c0df     ................
c0df0030:	fffd ffff ffff ffff                         ........

c0df0038 <ux_settings_flow_1_step_validate_step>:
c0df0038:	a497 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0048 <ux_settings_flow_1_step_validate>:
c0df0048:	0038 c0df ffff ffff                         8.......

c0df0050 <ux_settings_flow_1_step_val>:
c0df0050:	e0f9 c0de df9a c0de dd97 c0de 06ba da7a     ..............z.

c0df0060 <ux_settings_flow_1_step>:
c0df0060:	cb25 c0de 0050 c0df 0048 c0df 0000 0000     %...P...H.......

c0df0070 <ux_settings_flow_2_step_validate_step>:
c0df0070:	a4d9 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0080 <ux_settings_flow_2_step_validate>:
c0df0080:	0070 c0df ffff ffff                         p.......

c0df0088 <ux_settings_flow_2_step_val>:
c0df0088:	dde6 c0de dda5 c0de dd58 c0de 06c6 da7a     ........X.....z.

c0df0098 <ux_settings_flow_2_step>:
c0df0098:	cb25 c0de 0088 c0df 0080 c0df 0000 0000     %...............

c0df00a8 <ux_settings_flow_3_step_validate_step>:
c0df00a8:	a519 c0de 0000 0000 0000 0000 0000 0000     ................

c0df00b8 <ux_settings_flow_3_step_validate>:
c0df00b8:	00a8 c0df ffff ffff                         ........

c0df00c0 <ux_settings_flow_3_step_val>:
c0df00c0:	e24b c0de dd60 c0de e210 c0de 06d4 da7a     K...`.........z.

c0df00d0 <ux_settings_flow_3_step>:
c0df00d0:	cb25 c0de 00c0 c0df 00b8 c0df 0000 0000     %...............

c0df00e0 <ux_settings_flow_4_step_validate_step>:
c0df00e0:	a559 c0de 0000 0000 0000 0000 0000 0000     Y...............

c0df00f0 <ux_settings_flow_4_step_validate>:
c0df00f0:	00e0 c0df ffff ffff                         ........

c0df00f8 <ux_settings_flow_4_step_val>:
c0df00f8:	dd76 c0de e150 c0de e187 c0de 06e2 da7a     v...P.........z.

c0df0108 <ux_settings_flow_4_step>:
c0df0108:	cb25 c0de 00f8 c0df 00f0 c0df 0000 0000     %...............

c0df0118 <ux_settings_flow_5_step_validate_step>:
c0df0118:	a599 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0128 <ux_settings_flow_5_step_validate>:
c0df0128:	0118 c0df ffff ffff                         ........

c0df0130 <ux_settings_flow_5_step_val>:
c0df0130:	fb74 c0de e1b7 c0de                         t.......

c0df0138 <ux_settings_flow_5_step>:
c0df0138:	d0c1 c0de 0130 c0df 0128 c0df 0000 0000     ....0...(.......

c0df0148 <ux_settings_flow>:
c0df0148:	0060 c0df 0098 c0df 00d0 c0df 0108 c0df     `...............
c0df0158:	0138 c0df ffff ffff                         8.......

c0df0160 <ux_warning_contract_data_step_validate_step>:
c0df0160:	a5a1 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0170 <ux_warning_contract_data_step_validate>:
c0df0170:	0160 c0df ffff ffff                         `.......

c0df0178 <ux_warning_contract_data_step_val>:
c0df0178:	fbe4 c0de e016 c0de ddf1 c0de               ............

c0df0184 <ux_warning_contract_data_step>:
c0df0184:	d215 c0de 0178 c0df 0170 c0df 0000 0000     ....x...p.......

c0df0194 <ux_warning_oracle_data_step_validate_step>:
c0df0194:	a5a9 c0de 0000 0000 0000 0000 0000 0000     ................

c0df01a4 <ux_warning_oracle_data_step_validate>:
c0df01a4:	0194 c0df ffff ffff                         ........

c0df01ac <ux_warning_oracle_data_step_val>:
c0df01ac:	fbe4 c0de ddbb c0de 0000 0000               ............

c0df01b8 <ux_warning_oracle_data_step>:
c0df01b8:	d215 c0de 01ac c0df 01a4 c0df 0000 0000     ................

c0df01c8 <ux_warning_contract_data_flow>:
c0df01c8:	0184 c0df ffff ffff                         ........

c0df01d0 <ux_warning_oracle_data_flow>:
c0df01d0:	01b8 c0df ffff ffff                         ........

c0df01d8 <ux_display_public_eth2_flow_1_step_val>:
c0df01d8:	fc54 c0de e12f c0de e056 c0de               T.../...V...

c0df01e4 <ux_display_public_eth2_flow_1_step>:
c0df01e4:	d215 c0de 01d8 c0df 0000 0000 0000 0000     ................

c0df01f4 <ux_display_public_eth2_flow_2_step_val>:
c0df01f4:	df20 c0de 06ba da7a                          .....z.

c0df01fc <ux_display_public_eth2_flow_2_step>:
c0df01fc:	a5dd c0de 01f4 c0df 0000 0000 0000 0000     ................

c0df020c <ux_display_public_eth2_flow_3_step_validate_step>:
c0df020c:	a5ed c0de 0000 0000 0000 0000 0000 0000     ................

c0df021c <ux_display_public_eth2_flow_3_step_validate>:
c0df021c:	020c c0df ffff ffff                         ........

c0df0224 <ux_display_public_eth2_flow_3_step_val>:
c0df0224:	fccc c0de dd4b c0de                         ....K...

c0df022c <ux_display_public_eth2_flow_3_step>:
c0df022c:	d0c1 c0de 0224 c0df 021c c0df 0000 0000     ....$...........

c0df023c <ux_display_public_eth2_flow_4_step_validate_step>:
c0df023c:	a5f7 c0de 0000 0000 0000 0000 0000 0000     ................

c0df024c <ux_display_public_eth2_flow_4_step_validate>:
c0df024c:	023c c0df ffff ffff                         <.......

c0df0254 <ux_display_public_eth2_flow_4_step_val>:
c0df0254:	fbe4 c0de de20 c0de                         .... ...

c0df025c <ux_display_public_eth2_flow_4_step>:
c0df025c:	d0c1 c0de 0254 c0df 024c c0df 0000 0000     ....T...L.......

c0df026c <ux_display_public_eth2_flow>:
c0df026c:	01e4 c0df 01fc c0df 022c c0df 025c c0df     ........,...\...
c0df027c:	ffff ffff                                   ....

c0df0280 <ux_display_public_flow_1_step_val>:
c0df0280:	fc54 c0de df4e c0de e1ed c0de               T...N.......

c0df028c <ux_display_public_flow_1_step>:
c0df028c:	d215 c0de 0280 c0df 0000 0000 0000 0000     ................

c0df029c <ux_display_public_flow_2_step_val>:
c0df029c:	e1a1 c0de 06ba da7a                         ......z.

c0df02a4 <ux_display_public_flow_2_step>:
c0df02a4:	cd0d c0de 029c c0df 0000 0000 0000 0000     ................

c0df02b4 <ux_display_public_flow_3_step_validate_step>:
c0df02b4:	a601 c0de 0000 0000 0000 0000 0000 0000     ................

c0df02c4 <ux_display_public_flow_3_step_validate>:
c0df02c4:	02b4 c0df ffff ffff                         ........

c0df02cc <ux_display_public_flow_3_step_val>:
c0df02cc:	fccc c0de dd4b c0de                         ....K...

c0df02d4 <ux_display_public_flow_3_step>:
c0df02d4:	d0c1 c0de 02cc c0df 02c4 c0df 0000 0000     ................

c0df02e4 <ux_display_public_flow_4_step_validate_step>:
c0df02e4:	a60b c0de 0000 0000 0000 0000 0000 0000     ................

c0df02f4 <ux_display_public_flow_4_step_validate>:
c0df02f4:	02e4 c0df ffff ffff                         ........

c0df02fc <ux_display_public_flow_4_step_val>:
c0df02fc:	fbe4 c0de de20 c0de                         .... ...

c0df0304 <ux_display_public_flow_4_step>:
c0df0304:	d0c1 c0de 02fc c0df 02f4 c0df 0000 0000     ................

c0df0314 <ux_display_public_flow>:
c0df0314:	028c c0df 02a4 c0df 02d4 c0df 0304 c0df     ................
c0df0324:	ffff ffff                                   ....

c0df0328 <ux_display_privacy_public_key_flow_1_step_val>:
c0df0328:	fc54 c0de e061 c0de e220 c0de               T...a... ...

c0df0334 <ux_display_privacy_public_key_flow_1_step>:
c0df0334:	d215 c0de 0328 c0df 0000 0000 0000 0000     ....(...........

c0df0344 <ux_display_privacy_public_key_flow_2_step_val>:
c0df0344:	e1a1 c0de 06ba da7a                         ......z.

c0df034c <ux_display_privacy_public_key_flow_2_step>:
c0df034c:	cd0d c0de 0344 c0df 0000 0000 0000 0000     ....D...........

c0df035c <ux_display_privacy_public_key_flow_3_step_val>:
c0df035c:	e2ae c0de 06ef da7a                         ......z.

c0df0364 <ux_display_privacy_public_key_flow_3_step>:
c0df0364:	cd0d c0de 035c c0df 0000 0000 0000 0000     ....\...........

c0df0374 <ux_display_privacy_public_key_flow_4_step_validate_step>:
c0df0374:	a615 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0384 <ux_display_privacy_public_key_flow_4_step_validate>:
c0df0384:	0374 c0df ffff ffff                         t.......

c0df038c <ux_display_privacy_public_key_flow_4_step_val>:
c0df038c:	fccc c0de dd4b c0de                         ....K...

c0df0394 <ux_display_privacy_public_key_flow_4_step>:
c0df0394:	d0c1 c0de 038c c0df 0384 c0df 0000 0000     ................

c0df03a4 <ux_display_privacy_public_key_flow_5_step_validate_step>:
c0df03a4:	a61f c0de 0000 0000 0000 0000 0000 0000     ................

c0df03b4 <ux_display_privacy_public_key_flow_5_step_validate>:
c0df03b4:	03a4 c0df ffff ffff                         ........

c0df03bc <ux_display_privacy_public_key_flow_5_step_val>:
c0df03bc:	fbe4 c0de de20 c0de                         .... ...

c0df03c4 <ux_display_privacy_public_key_flow_5_step>:
c0df03c4:	d0c1 c0de 03bc c0df 03b4 c0df 0000 0000     ................

c0df03d4 <ux_display_privacy_shared_secret_flow_1_step_val>:
c0df03d4:	fc54 c0de e13b c0de e2c5 c0de               T...;.......

c0df03e0 <ux_display_privacy_shared_secret_flow_1_step>:
c0df03e0:	d215 c0de 03d4 c0df 0000 0000 0000 0000     ................

c0df03f0 <ux_display_privacy_public_key_flow>:
c0df03f0:	0334 c0df 034c c0df 0364 c0df 0394 c0df     4...L...d.......
c0df0400:	03c4 c0df ffff ffff                         ........

c0df0408 <ux_display_privacy_shared_secret_flow>:
c0df0408:	03e0 c0df 034c c0df 0364 c0df 0394 c0df     ....L...d.......
c0df0418:	03c4 c0df ffff ffff                         ........

c0df0420 <ux_sign_flow_1_step_val>:
c0df0420:	fbac c0de e26d c0de dee1 c0de               ....m.......

c0df042c <ux_sign_flow_1_step>:
c0df042c:	d215 c0de 0420 c0df 0000 0000 0000 0000     .... ...........

c0df043c <ux_sign_flow_2_step_val>:
c0df043c:	e1f5 c0de 06ba da7a                         ......z.

c0df0444 <ux_sign_flow_2_step>:
c0df0444:	cd0d c0de 043c c0df 0000 0000 0000 0000     ....<...........

c0df0454 <ux_sign_flow_3_step_validate_step>:
c0df0454:	a629 c0de 0000 0000 0000 0000 0000 0000     )...............

c0df0464 <ux_sign_flow_3_step_validate>:
c0df0464:	0454 c0df ffff ffff                         T.......

c0df046c <ux_sign_flow_3_step_val>:
c0df046c:	fccc c0de e26d c0de dee1 c0de               ....m.......

c0df0478 <ux_sign_flow_3_step>:
c0df0478:	d1bd c0de 046c c0df 0464 c0df 0000 0000     ....l...d.......

c0df0488 <ux_sign_flow_4_step_validate_step>:
c0df0488:	a633 c0de 0000 0000 0000 0000 0000 0000     3...............

c0df0498 <ux_sign_flow_4_step_validate>:
c0df0498:	0488 c0df ffff ffff                         ........

c0df04a0 <ux_sign_flow_4_step_val>:
c0df04a0:	fbe4 c0de e032 c0de e0ac c0de               ....2.......

c0df04ac <ux_sign_flow_4_step>:
c0df04ac:	d1bd c0de 04a0 c0df 0498 c0df 0000 0000     ................

c0df04bc <ux_sign_flow>:
c0df04bc:	042c c0df 0444 c0df 0478 c0df 04ac c0df     ,...D...x.......
c0df04cc:	ffff ffff                                   ....

c0df04d0 <ux_sign_712_v0_flow_1_step_val>:
c0df04d0:	fbac c0de e26d c0de deaa c0de               ....m.......

c0df04dc <ux_sign_712_v0_flow_1_step>:
c0df04dc:	d215 c0de 04d0 c0df 0000 0000 0000 0000     ................

c0df04ec <ux_sign_712_v0_flow_2_step_val>:
c0df04ec:	df55 c0de 06ba da7a                         U.....z.

c0df04f4 <ux_sign_712_v0_flow_2_step>:
c0df04f4:	a695 c0de 04ec c0df 0000 0000 0000 0000     ................

c0df0504 <ux_sign_712_v0_flow_3_step_val>:
c0df0504:	e2b2 c0de 06ba da7a                         ......z.

c0df050c <ux_sign_712_v0_flow_3_step>:
c0df050c:	a6a5 c0de 0504 c0df 0000 0000 0000 0000     ................

c0df051c <ux_sign_712_v0_flow_4_step_validate_step>:
c0df051c:	a6b5 c0de 0000 0000 0000 0000 0000 0000     ................

c0df052c <ux_sign_712_v0_flow_4_step_validate>:
c0df052c:	051c c0df ffff ffff                         ........

c0df0534 <ux_sign_712_v0_flow_4_step_val>:
c0df0534:	fccc c0de e26d c0de dee1 c0de               ....m.......

c0df0540 <ux_sign_712_v0_flow_4_step>:
c0df0540:	d1bd c0de 0534 c0df 052c c0df 0000 0000     ....4...,.......

c0df0550 <ux_sign_712_v0_flow_5_step_validate_step>:
c0df0550:	a6bf c0de 0000 0000 0000 0000 0000 0000     ................

c0df0560 <ux_sign_712_v0_flow_5_step_validate>:
c0df0560:	0550 c0df ffff ffff                         P.......

c0df0568 <ux_sign_712_v0_flow_5_step_val>:
c0df0568:	fbe4 c0de e032 c0de e0ac c0de               ....2.......

c0df0574 <ux_sign_712_v0_flow_5_step>:
c0df0574:	d1bd c0de 0568 c0df 0560 c0df 0000 0000     ....h...`.......

c0df0584 <ux_sign_712_v0_flow>:
c0df0584:	04dc c0df 04f4 c0df 050c c0df 0540 c0df     ............@...
c0df0594:	0574 c0df ffff ffff                         t.......

c0df059c <ux_confirm_selector_flow_1_step_val>:
c0df059c:	fc54 c0de df4e c0de e1fd c0de               T...N.......

c0df05a8 <ux_confirm_selector_flow_1_step>:
c0df05a8:	d215 c0de 059c c0df 0000 0000 0000 0000     ................

c0df05b8 <ux_confirm_selector_flow_2_step_val>:
c0df05b8:	e070 c0de 06ba da7a                         p.....z.

c0df05c0 <ux_confirm_selector_flow_2_step>:
c0df05c0:	caf9 c0de 05b8 c0df 0000 0000 0000 0000     ................

c0df05d0 <ux_confirm_selector_flow_3_step_validate_step>:
c0df05d0:	a6c9 c0de 0000 0000 0000 0000 0000 0000     ................

c0df05e0 <ux_confirm_selector_flow_3_step_validate>:
c0df05e0:	05d0 c0df ffff ffff                         ........

c0df05e8 <ux_confirm_selector_flow_3_step_val>:
c0df05e8:	fccc c0de dd4b c0de                         ....K...

c0df05f0 <ux_confirm_selector_flow_3_step>:
c0df05f0:	d0c1 c0de 05e8 c0df 05e0 c0df 0000 0000     ................

c0df0600 <ux_confirm_selector_flow_4_step_validate_step>:
c0df0600:	a6d3 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0610 <ux_confirm_selector_flow_4_step_validate>:
c0df0610:	0600 c0df ffff ffff                         ........

c0df0618 <ux_confirm_selector_flow_4_step_val>:
c0df0618:	fbe4 c0de de20 c0de                         .... ...

c0df0620 <ux_confirm_selector_flow_4_step>:
c0df0620:	d0c1 c0de 0618 c0df 0610 c0df 0000 0000     ................

c0df0630 <ux_confirm_selector_flow>:
c0df0630:	05a8 c0df 05c0 c0df 05f0 c0df 0620 c0df     ............ ...
c0df0640:	ffff ffff                                   ....

c0df0644 <ux_confirm_parameter_flow_1_step_val>:
c0df0644:	fc54 c0de df4e c0de 07ba da7a               T...N.....z.

c0df0650 <ux_confirm_parameter_flow_1_step>:
c0df0650:	d215 c0de 0644 c0df 0000 0000 0000 0000     ....D...........

c0df0660 <ux_confirm_parameter_flow_2_step_val>:
c0df0660:	e10a c0de 06ba da7a                         ......z.

c0df0668 <ux_confirm_parameter_flow_2_step>:
c0df0668:	cd0d c0de 0660 c0df 0000 0000 0000 0000     ....`...........

c0df0678 <ux_confirm_parameter_flow_3_step_validate_step>:
c0df0678:	a6dd c0de 0000 0000 0000 0000 0000 0000     ................

c0df0688 <ux_confirm_parameter_flow_3_step_validate>:
c0df0688:	0678 c0df ffff ffff                         x.......

c0df0690 <ux_confirm_parameter_flow_3_step_val>:
c0df0690:	fccc c0de dd4b c0de                         ....K...

c0df0698 <ux_confirm_parameter_flow_3_step>:
c0df0698:	d0c1 c0de 0690 c0df 0688 c0df 0000 0000     ................

c0df06a8 <ux_confirm_parameter_flow_4_step_validate_step>:
c0df06a8:	a6e7 c0de 0000 0000 0000 0000 0000 0000     ................

c0df06b8 <ux_confirm_parameter_flow_4_step_validate>:
c0df06b8:	06a8 c0df ffff ffff                         ........

c0df06c0 <ux_confirm_parameter_flow_4_step_val>:
c0df06c0:	fbe4 c0de de20 c0de                         .... ...

c0df06c8 <ux_confirm_parameter_flow_4_step>:
c0df06c8:	d0c1 c0de 06c0 c0df 06b8 c0df 0000 0000     ................

c0df06d8 <ux_confirm_parameter_flow>:
c0df06d8:	0650 c0df 0668 c0df 0698 c0df 06c8 c0df     P...h...........
c0df06e8:	ffff ffff                                   ....

c0df06ec <ux_approval_review_step_val>:
c0df06ec:	fc54 c0de e22c c0de e272 c0de               T...,...r...

c0df06f8 <ux_approval_review_step>:
c0df06f8:	d215 c0de 06ec c0df 0000 0000 0000 0000     ................

c0df0708 <ux_approval_amount_step_val>:
c0df0708:	de7d c0de 06ef da7a                         }.....z.

c0df0710 <ux_approval_amount_step>:
c0df0710:	cd0d c0de 0708 c0df 0000 0000 0000 0000     ................

c0df0720 <ux_approval_address_step_val>:
c0df0720:	e1a1 c0de 06ba da7a                         ......z.

c0df0728 <ux_approval_address_step>:
c0df0728:	cd0d c0de 0720 c0df 0000 0000 0000 0000     .... ...........

c0df0738 <ux_plugin_approval_id_step_val>:
c0df0738:	06ba da7a 06ef da7a                         ..z...z.

c0df0740 <ux_plugin_approval_id_step>:
c0df0740:	a6f1 c0de 0738 c0df 0000 0000 0000 0000     ....8...........

c0df0750 <ux_plugin_approval_before_step>:
c0df0750:	a701 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0760 <ux_plugin_approval_display_step_val>:
c0df0760:	06ba da7a 06ef da7a                         ..z...z.

c0df0768 <ux_plugin_approval_display_step>:
c0df0768:	cd0d c0de 0760 c0df 0000 0000 0000 0000     ....`...........

c0df0778 <ux_plugin_approval_after_step>:
c0df0778:	a70b c0de 0000 0000 0000 0000 0000 0000     ................

c0df0788 <ux_approval_fees_step_val>:
c0df0788:	df2b c0de 073e da7a                         +...>.z.

c0df0790 <ux_approval_fees_step>:
c0df0790:	cd0d c0de 0788 c0df 0000 0000 0000 0000     ................

c0df07a0 <ux_approval_network_step_val>:
c0df07a0:	e039 c0de 07c9 da7a                         9.....z.

c0df07a8 <ux_approval_network_step>:
c0df07a8:	cd0d c0de 07a0 c0df 0000 0000 0000 0000     ................

c0df07b8 <ux_approval_accept_step_validate_step>:
c0df07b8:	a715 c0de 0000 0000 0000 0000 0000 0000     ................

c0df07c8 <ux_approval_accept_step_validate>:
c0df07c8:	07b8 c0df ffff ffff                         ........

c0df07d0 <ux_approval_accept_step_val>:
c0df07d0:	fccc c0de df34 c0de de05 c0de               ....4.......

c0df07dc <ux_approval_accept_step>:
c0df07dc:	d1bd c0de 07d0 c0df 07c8 c0df 0000 0000     ................

c0df07ec <ux_approval_reject_step_validate_step>:
c0df07ec:	a71f c0de 0000 0000 0000 0000 0000 0000     ................

c0df07fc <ux_approval_reject_step_validate>:
c0df07fc:	07ec c0df ffff ffff                         ........

c0df0804 <ux_approval_reject_step_val>:
c0df0804:	fbe4 c0de de20 c0de                         .... ...

c0df080c <ux_approval_reject_step>:
c0df080c:	d0c1 c0de 0804 c0df 07fc c0df 0000 0000     ................

c0df081c <ux_approval_nonce_step_val>:
c0df081c:	e24b c0de 0770 da7a                         K...p.z.

c0df0824 <ux_approval_nonce_step>:
c0df0824:	cd0d c0de 081c c0df 0000 0000 0000 0000     ................

c0df0834 <ux_approval_blind_signing_warning_step_val>:
c0df0834:	fd04 c0de e02c c0de de27 c0de               ....,...'...

c0df0840 <ux_approval_blind_signing_warning_step>:
c0df0840:	d1bd c0de 0834 c0df 0000 0000 0000 0000     ....4...........

c0df0850 <ux_approval_oracle_data_val>:
c0df0850:	e041 c0de 0778 da7a                         A...x.z.

c0df0858 <ux_approval_oracle_data>:
c0df0858:	cd0d c0de 0850 c0df 0000 0000 0000 0000     ....P...........

c0df0868 <ux_display_stark_public_flow_1_step_val>:
c0df0868:	fc54 c0de df4e c0de de2f c0de               T...N.../...

c0df0874 <ux_display_stark_public_flow_1_step>:
c0df0874:	d215 c0de 0868 c0df 0000 0000 0000 0000     ....h...........

c0df0884 <ux_display_stark_public_flow_2_step_val>:
c0df0884:	de0e c0de 06ba da7a                         ......z.

c0df088c <ux_display_stark_public_flow_2_step>:
c0df088c:	cd0d c0de 0884 c0df 0000 0000 0000 0000     ................

c0df089c <ux_display_stark_public_flow_3_step_validate_step>:
c0df089c:	a881 c0de 0000 0000 0000 0000 0000 0000     ................

c0df08ac <ux_display_stark_public_flow_3_step_validate>:
c0df08ac:	089c c0df ffff ffff                         ........

c0df08b4 <ux_display_stark_public_flow_3_step_val>:
c0df08b4:	fccc c0de dd4b c0de                         ....K...

c0df08bc <ux_display_stark_public_flow_3_step>:
c0df08bc:	d0c1 c0de 08b4 c0df 08ac c0df 0000 0000     ................

c0df08cc <ux_display_stark_public_flow_4_step_validate_step>:
c0df08cc:	a88b c0de 0000 0000 0000 0000 0000 0000     ................

c0df08dc <ux_display_stark_public_flow_4_step_validate>:
c0df08dc:	08cc c0df ffff ffff                         ........

c0df08e4 <ux_display_stark_public_flow_4_step_val>:
c0df08e4:	fbe4 c0de de20 c0de                         .... ...

c0df08ec <ux_display_stark_public_flow_4_step>:
c0df08ec:	d0c1 c0de 08e4 c0df 08dc c0df 0000 0000     ................

c0df08fc <ux_display_stark_public_flow>:
c0df08fc:	0874 c0df 088c c0df 08bc c0df 08ec c0df     t...............
c0df090c:	ffff ffff                                   ....

c0df0910 <ux_stark_limit_order_1_step_val>:
c0df0910:	fc54 c0de e22c c0de e272 c0de               T...,...r...

c0df091c <ux_stark_limit_order_1_step>:
c0df091c:	d215 c0de 0910 c0df 0000 0000 0000 0000     ................

c0df092c <ux_stark_limit_order_2_step_val>:
c0df092c:	e233 c0de e239 c0de                         3...9...

c0df0934 <ux_stark_limit_order_2_step>:
c0df0934:	cd0d c0de 092c c0df 0000 0000 0000 0000     ....,...........

c0df0944 <ux_stark_limit_order_3_step_val>:
c0df0944:	e251 c0de de39 c0de                         Q...9...

c0df094c <ux_stark_limit_order_3_step>:
c0df094c:	cd0d c0de 0944 c0df 0000 0000 0000 0000     ....D...........

c0df095c <ux_stark_limit_order_4_step_val>:
c0df095c:	e2d0 c0de 06ef da7a                         ......z.

c0df0964 <ux_stark_limit_order_4_step>:
c0df0964:	cd0d c0de 095c c0df 0000 0000 0000 0000     ....\...........

c0df0974 <ux_stark_limit_order_5_step_val>:
c0df0974:	e2d5 c0de 073e da7a                         ....>.z.

c0df097c <ux_stark_limit_order_5_step>:
c0df097c:	cd0d c0de 0974 c0df 0000 0000 0000 0000     ....t...........

c0df098c <ux_stark_limit_order_6_step_val>:
c0df098c:	df0a c0de 06ba da7a                         ......z.

c0df0994 <ux_stark_limit_order_6_step>:
c0df0994:	cd0d c0de 098c c0df 0000 0000 0000 0000     ................

c0df09a4 <ux_stark_limit_order_7_step_validate_step>:
c0df09a4:	a8ed c0de 0000 0000 0000 0000 0000 0000     ................

c0df09b4 <ux_stark_limit_order_7_step_validate>:
c0df09b4:	09a4 c0df ffff ffff                         ........

c0df09bc <ux_stark_limit_order_7_step_val>:
c0df09bc:	fccc c0de df34 c0de de05 c0de               ....4.......

c0df09c8 <ux_stark_limit_order_7_step>:
c0df09c8:	d1bd c0de 09bc c0df 09b4 c0df 0000 0000     ................

c0df09d8 <ux_stark_limit_order_8_step_validate_step>:
c0df09d8:	a8f7 c0de 0000 0000 0000 0000 0000 0000     ................

c0df09e8 <ux_stark_limit_order_8_step_validate>:
c0df09e8:	09d8 c0df ffff ffff                         ........

c0df09f0 <ux_stark_limit_order_8_step_val>:
c0df09f0:	fbe4 c0de de20 c0de                         .... ...

c0df09f8 <ux_stark_limit_order_8_step>:
c0df09f8:	d0c1 c0de 09f0 c0df 09e8 c0df 0000 0000     ................

c0df0a08 <ux_stark_limit_order_flow>:
c0df0a08:	091c c0df 0934 c0df 094c c0df 0964 c0df     ....4...L...d...
c0df0a18:	097c c0df 0994 c0df 09c8 c0df 09f8 c0df     |...............
c0df0a28:	ffff ffff                                   ....

c0df0a2c <ux_stark_transfer_1_step_val>:
c0df0a2c:	fc54 c0de e22c c0de e272 c0de               T...,...r...

c0df0a38 <ux_stark_transfer_1_step>:
c0df0a38:	d215 c0de 0a2c c0df 0000 0000 0000 0000     ....,...........

c0df0a48 <ux_stark_transfer_2_step_val>:
c0df0a48:	e198 c0de deb8 c0de                         ........

c0df0a50 <ux_stark_transfer_2_step>:
c0df0a50:	cd0d c0de 0a48 c0df 0000 0000 0000 0000     ....H...........

c0df0a60 <ux_stark_self_transfer_2_step_val>:
c0df0a60:	e0b6 c0de e198 c0de                         ........

c0df0a68 <ux_stark_self_transfer_2_step>:
c0df0a68:	cd0d c0de 0a60 c0df 0000 0000 0000 0000     ....`...........

c0df0a78 <ux_stark_conditional_transfer_2_step_val>:
c0df0a78:	e1bc c0de e198 c0de                         ........

c0df0a80 <ux_stark_conditional_transfer_2_step>:
c0df0a80:	cd0d c0de 0a78 c0df 0000 0000 0000 0000     ....x...........

c0df0a90 <ux_stark_self_conditional_transfer_2_step_val>:
c0df0a90:	e1bc c0de dee9 c0de                         ........

c0df0a98 <ux_stark_self_conditional_transfer_2_step>:
c0df0a98:	cd0d c0de 0a90 c0df 0000 0000 0000 0000     ................

c0df0aa8 <ux_stark_transfer_3_step_val>:
c0df0aa8:	de7d c0de 026c da7a                         }...l.z.

c0df0ab0 <ux_stark_transfer_3_step>:
c0df0ab0:	cd0d c0de 0aa8 c0df 0000 0000 0000 0000     ................

c0df0ac0 <ux_stark_transfer_4_step_val>:
c0df0ac0:	dd88 c0de 06ba da7a                         ......z.

c0df0ac8 <ux_stark_transfer_4_step>:
c0df0ac8:	cd0d c0de 0ac0 c0df 0000 0000 0000 0000     ................

c0df0ad8 <ux_stark_transfer_5_step_val>:
c0df0ad8:	df0a c0de 07ba da7a                         ......z.

c0df0ae0 <ux_stark_transfer_5_step>:
c0df0ae0:	cd0d c0de 0ad8 c0df 0000 0000 0000 0000     ................

c0df0af0 <ux_stark_transfer_6_step_validate_step>:
c0df0af0:	a901 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0b00 <ux_stark_transfer_6_step_validate>:
c0df0b00:	0af0 c0df ffff ffff                         ........

c0df0b08 <ux_stark_transfer_6_step_val>:
c0df0b08:	fccc c0de df34 c0de de05 c0de               ....4.......

c0df0b14 <ux_stark_transfer_6_step>:
c0df0b14:	d1bd c0de 0b08 c0df 0b00 c0df 0000 0000     ................

c0df0b24 <ux_stark_transfer_7_step_validate_step>:
c0df0b24:	a90b c0de 0000 0000 0000 0000 0000 0000     ................

c0df0b34 <ux_stark_transfer_7_step_validate>:
c0df0b34:	0b24 c0df ffff ffff                         $.......

c0df0b3c <ux_stark_transfer_7_step_val>:
c0df0b3c:	fbe4 c0de de20 c0de                         .... ...

c0df0b44 <ux_stark_transfer_7_step>:
c0df0b44:	d0c1 c0de 0b3c c0df 0b34 c0df 0000 0000     ....<...4.......

c0df0b54 <ux_stark_conditional_transfer_4_step_val>:
c0df0b54:	dd88 c0de 06ba da7a                         ......z.

c0df0b5c <ux_stark_conditional_transfer_4_step>:
c0df0b5c:	a915 c0de 0b54 c0df 0000 0000 0000 0000     ....T...........

c0df0b6c <ux_stark_conditional_transfer_8_step_val>:
c0df0b6c:	df61 c0de 06ba da7a                         a.....z.

c0df0b74 <ux_stark_conditional_transfer_8_step>:
c0df0b74:	a925 c0de 0b6c c0df 0000 0000 0000 0000     %...l...........

c0df0b84 <ux_stark_conditional_transfer_9_step_val>:
c0df0b84:	e259 c0de 06ba da7a                         Y.....z.

c0df0b8c <ux_stark_conditional_transfer_9_step>:
c0df0b8c:	a965 c0de 0b84 c0df 0000 0000 0000 0000     e...............

c0df0b9c <ux_stark_transfer_flow>:
c0df0b9c:	0a38 c0df 0a50 c0df 0ab0 c0df 0ac8 c0df     8...P...........
c0df0bac:	0ae0 c0df 0b14 c0df 0b44 c0df ffff ffff     ........D.......

c0df0bbc <ux_stark_self_transfer_flow>:
c0df0bbc:	0a38 c0df 0a68 c0df 0ab0 c0df 0ae0 c0df     8...h...........
c0df0bcc:	0b14 c0df 0b44 c0df ffff ffff               ....D.......

c0df0bd8 <ux_stark_transfer_conditional_flow>:
c0df0bd8:	0a38 c0df 0a80 c0df 0ab0 c0df 0b5c c0df     8...........\...
c0df0be8:	0ae0 c0df 0b74 c0df 0b8c c0df 0b14 c0df     ....t...........
c0df0bf8:	0b44 c0df ffff ffff                         D.......

c0df0c00 <ux_stark_self_transfer_conditional_flow>:
c0df0c00:	0a38 c0df 0a98 c0df 0ab0 c0df 0ae0 c0df     8...............
c0df0c10:	0b74 c0df 0b8c c0df 0b14 c0df 0b44 c0df     t...........D...
c0df0c20:	ffff ffff                                   ....

c0df0c24 <ux_stark_unsafe_sign_1_step_val>:
c0df0c24:	fd04 c0de e27e c0de dfe5 c0de               ....~.......

c0df0c30 <ux_stark_unsafe_sign_1_step>:
c0df0c30:	d215 c0de 0c24 c0df 0000 0000 0000 0000     ....$...........

c0df0c40 <ux_stark_unsafe_sign_2_step_val>:
c0df0c40:	deba c0de 06ba da7a                         ......z.

c0df0c48 <ux_stark_unsafe_sign_2_step>:
c0df0c48:	a9cd c0de 0c40 c0df 0000 0000 0000 0000     ....@...........

c0df0c58 <ux_stark_unsafe_sign_3_step_val>:
c0df0c58:	de3e c0de 06ba da7a                         >.....z.

c0df0c60 <ux_stark_unsafe_sign_3_step>:
c0df0c60:	a9dd c0de 0c58 c0df 0000 0000 0000 0000     ....X...........

c0df0c70 <ux_stark_unsafe_sign_4_step_validate_step>:
c0df0c70:	a9ed c0de 0000 0000 0000 0000 0000 0000     ................

c0df0c80 <ux_stark_unsafe_sign_4_step_validate>:
c0df0c80:	0c70 c0df ffff ffff                         p.......

c0df0c88 <ux_stark_unsafe_sign_4_step_val>:
c0df0c88:	fccc c0de df34 c0de de05 c0de               ....4.......

c0df0c94 <ux_stark_unsafe_sign_4_step>:
c0df0c94:	d1bd c0de 0c88 c0df 0c80 c0df 0000 0000     ................

c0df0ca4 <ux_stark_unsafe_sign_5_step_validate_step>:
c0df0ca4:	a9f7 c0de 0000 0000 0000 0000 0000 0000     ................

c0df0cb4 <ux_stark_unsafe_sign_5_step_validate>:
c0df0cb4:	0ca4 c0df ffff ffff                         ........

c0df0cbc <ux_stark_unsafe_sign_5_step_val>:
c0df0cbc:	fbe4 c0de de20 c0de                         .... ...

c0df0cc4 <ux_stark_unsafe_sign_5_step>:
c0df0cc4:	d0c1 c0de 0cbc c0df 0cb4 c0df 0000 0000     ................

c0df0cd4 <ux_stark_unsafe_sign_flow>:
c0df0cd4:	0c30 c0df 0c48 c0df 0c60 c0df 0c94 c0df     0...H...`.......
c0df0ce4:	0cc4 c0df ffff ffff                         ........

c0df0cec <USBD_HID_Desc_fido>:
c0df0cec:	2109 0111 0121 2222 d400 d4d4               .!..!.""....

c0df0cf8 <USBD_HID_Desc>:
c0df0cf8:	2109 0111 0100 2222                          .!...."".

c0df0d01 <HID_ReportDesc_fido>:
c0df0d01:	d006 09f1 a101 0901 1503 2600 00ff 0875     ...........&..u.
c0df0d11:	4095 0881 0409 0015 ff26 7500 9508 9140     .@......&..u..@.
c0df0d21:	c008                                        ..

c0df0d23 <HID_ReportDesc>:
c0df0d23:	a006 09ff a101 0901 1503 2600 00ff 0875     ...........&..u.
c0df0d33:	4095 0881 0409 0015 ff26 7500 9508 9140     .@......&..u..@.
c0df0d43:	c008                                        ..

c0df0d45 <C_usb_bos>:
c0df0d45:	0f05 0039 1802 0510 3800 08b6 a934 a009     ..9......8..4...
c0df0d55:	8b47 a0fd 8876 b615 0065 1e01 1c00 0510     G...v...e.......
c0df0d65:	df00 dd60 89d8 c745 9c4c 65d2 9e9d 8a64     ..`...E.L..e..d.
c0df0d75:	009f 0300 b206 7700 d400                     .......w...

c0df0d80 <HID_Desc>:
c0df0d80:	c1cd c0de c1dd c0de c1ed c0de c1fd c0de     ................
c0df0d90:	c20d c0de c21d c0de c22d c0de c23d c0de     ........-...=...

c0df0da0 <C_winusb_string_descriptor>:
c0df0da0:	0312 004d 0053 0046 0054 0031 0030 0030     ..M.S.F.T.1.0.0.
c0df0db0:	0077                                        w.

c0df0db2 <C_winusb_guid>:
c0df0db2:	0092 0000 0100 0005 0001 0088 0000 0007     ................
c0df0dc2:	0000 002a 0044 0065 0076 0069 0063 0065     ..*.D.e.v.i.c.e.
c0df0dd2:	0049 006e 0074 0065 0072 0066 0061 0063     I.n.t.e.r.f.a.c.
c0df0de2:	0065 0047 0055 0049 0044 0073 0000 0050     e.G.U.I.D.s...P.
c0df0df2:	0000 007b 0031 0033 0064 0036 0033 0034     ..{.1.3.d.6.3.4.
c0df0e02:	0030 0030 002d 0032 0043 0039 0037 002d     0.0.-.2.C.9.7.-.
c0df0e12:	0030 0030 0030 0034 002d 0030 0030 0030     0.0.0.4.-.0.0.0.
c0df0e22:	0030 002d 0034 0063 0036 0035 0036 0034     0.-.4.c.6.5.6.4.
c0df0e32:	0036 0037 0036 0035 0037 0032 007d 0000     6.7.6.5.7.2.}...
	...

c0df0e44 <C_winusb_request_descriptor>:
c0df0e44:	000a 0000 0000 0603 00b2 0008 0001 0000     ................
c0df0e54:	00a8 0008 0002 0002 00a0 0014 0003 4957     ..............WI
c0df0e64:	554e 4253 0000 0000 0000 0000 0000 0084     NUSB............
c0df0e74:	0004 0007 002a 0044 0065 0076 0069 0063     ....*.D.e.v.i.c.
c0df0e84:	0065 0049 006e 0074 0065 0072 0066 0061     e.I.n.t.e.r.f.a.
c0df0e94:	0063 0065 0047 0055 0049 0044 0073 0000     c.e.G.U.I.D.s...
c0df0ea4:	0050 007b 0043 0045 0038 0030 0039 0032     P.{.C.E.8.0.9.2.
c0df0eb4:	0036 0034 002d 0034 0042 0032 0034 002d     6.4.-.4.B.2.4.-.
c0df0ec4:	0034 0045 0038 0031 002d 0041 0038 0042     4.E.8.1.-.A.8.B.
c0df0ed4:	0032 002d 0035 0037 0045 0044 0030 0031     2.-.5.7.E.D.0.1.
c0df0ee4:	0044 0035 0038 0030 0045 0031 007d 0000     D.5.8.0.E.1.}...
c0df0ef4:	0000 d4d4                                   ....

c0df0ef8 <USBD_HID>:
c0df0ef8:	bf71 c0de bf9f c0de bee1 c0de 0000 0000     q...............
c0df0f08:	0000 0000 c0c1 c0de c0d9 c0de 0000 0000     ................
	...
c0df0f20:	c375 c0de c375 c0de c375 c0de c385 c0de     u...u...u.......

c0df0f30 <USBD_U2F>:
c0df0f30:	c045 c0de bf9f c0de bee1 c0de 0000 0000     E...............
c0df0f40:	0000 0000 c075 c0de c091 c0de 0000 0000     ....u...........
	...
c0df0f58:	c375 c0de c375 c0de c375 c0de c385 c0de     u...u...u.......

c0df0f68 <USBD_WEBUSB>:
c0df0f68:	c12d c0de c159 c0de c15d c0de 0000 0000     -...Y...].......
c0df0f78:	0000 0000 c161 c0de c179 c0de 0000 0000     ....a...y.......
	...
c0df0f90:	c375 c0de c375 c0de c375 c0de c385 c0de     u...u...u.......

c0df0fa0 <USBD_DeviceDesc>:
c0df0fa0:	0112 0210 0000 4000 2c97 4015 0201 0201     .......@.,.@....
c0df0fb0:	0103                                        ..

c0df0fb2 <USBD_LangIDDesc>:
c0df0fb2:	0304 0409                                   ....

c0df0fb6 <USBD_MANUFACTURER_STRING>:
c0df0fb6:	030e 004c 0065 0064 0067 0065 0072          ..L.e.d.g.e.r.

c0df0fc4 <USBD_PRODUCT_FS_STRING>:
c0df0fc4:	030e 004e 0061 006e 006f 0020 0058          ..N.a.n.o. .X.

c0df0fd2 <USB_SERIAL_STRING>:
c0df0fd2:	030a 0030 0030 0030 0031                    ..0.0.0.1.

c0df0fdc <C_winusb_wcid>:
c0df0fdc:	0028 0000 0100 0004 0001 0000 0000 0000     (...............
c0df0fec:	0102 4957 554e 4253 0000 0000 0000 0000     ..WINUSB........
	...

c0df1004 <USBD_CfgDesc>:
c0df1004:	0209 0060 0103 c002 0932 0004 0200 0003     ..`.....2.......
c0df1014:	0200 2109 0111 0100 2222 0700 8205 4003     ...!...."".....@
c0df1024:	0100 0507 0302 0040 0901 0104 0200 0103     ......@.........
c0df1034:	0201 2109 0111 0121 2222 0700 8105 4003     ...!..!."".....@
c0df1044:	0100 0507 0301 0040 0901 0204 0200 ffff     ......@.........
c0df1054:	02ff 0507 0383 0040 0701 0305 4003 0100     ......@......@..

c0df1064 <USBD_DeviceQualifierDesc>:
c0df1064:	060a 0200 0000 4000 0001 d4d4               .......@....

c0df1070 <ux_layout_bb_elements>:
c0df1070:	0003 0000 0000 0080 0040 0000 0001 0000     ........@.......
c0df1080:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0df1090:	0105 0002 001c 0004 0007 0000 0000 0000     ................
c0df10a0:	ffff 00ff 0000 0000 0000 0000 fc74 c0de     ............t...
c0df10b0:	0205 007a 001c 0004 0007 0000 0000 0000     ..z.............
c0df10c0:	ffff 00ff 0000 0000 0000 0000 fc94 c0de     ................
c0df10d0:	1007 0006 001d 0074 0020 0000 0000 0000     ......t. .......
c0df10e0:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0df10f0:	1107 0006 002b 0074 0020 0000 0000 0000     ....+.t. .......
c0df1100:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................

c0df1110 <ux_layout_bnnn_elements>:
c0df1110:	0003 0000 0000 0080 0040 0000 0001 0000     ........@.......
c0df1120:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0df1130:	0105 0002 001c 0004 0007 0000 0000 0000     ................
c0df1140:	ffff 00ff 0000 0000 0000 0000 fc74 c0de     ............t...
c0df1150:	0205 007a 001c 0004 0007 0000 0000 0000     ..z.............
c0df1160:	ffff 00ff 0000 0000 0000 0000 fc94 c0de     ................
c0df1170:	1007 0006 000f 0074 0020 0000 0000 0000     ......t. .......
c0df1180:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0df1190:	1107 0006 001d 0074 0020 0000 0000 0000     ......t. .......
c0df11a0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0df11b0:	1207 0006 002b 0074 0020 0000 0000 0000     ....+.t. .......
c0df11c0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0df11d0:	1307 0006 0039 0074 0020 0000 0000 0000     ....9.t. .......
c0df11e0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................

c0df11f0 <ux_layout_paging_elements>:
c0df11f0:	0003 0000 0000 0080 0040 0000 0001 0000     ........@.......
c0df1200:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0df1210:	0105 0002 001c 0004 0007 0000 0000 0000     ................
c0df1220:	ffff 00ff 0000 0000 0000 0000 fc74 c0de     ............t...
c0df1230:	0205 007a 001c 0004 0007 0000 0000 0000     ..z.............
c0df1240:	ffff 00ff 0000 0000 0000 0000 fc94 c0de     ................
c0df1250:	1007 0000 000f 0080 000c 0000 0000 0000     ................
c0df1260:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0df1270:	1107 0007 001d 0072 000c 0000 0000 0000     ......r.........
c0df1280:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0df1290:	1207 0007 002b 0072 000c 0000 0000 0000     ....+.r.........
c0df12a0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0df12b0:	1307 0007 0039 0072 000c 0000 0000 0000     ....9.r.........
c0df12c0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................

c0df12d0 <ux_layout_pb_elements>:
c0df12d0:	0003 0000 0000 0080 0040 0000 0001 0000     ........@.......
c0df12e0:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0df12f0:	0105 0002 001c 0004 0007 0000 0000 0000     ................
c0df1300:	ffff 00ff 0000 0000 0000 0000 fc74 c0de     ............t...
c0df1310:	0205 007a 001c 0004 0007 0000 0000 0000     ..z.............
c0df1320:	ffff 00ff 0000 0000 0000 0000 fc94 c0de     ................
c0df1330:	1005 0039 0011 000e 000e 0000 0000 0000     ..9.............
c0df1340:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0df1350:	1107 0000 002c 0080 0020 0000 0000 0000     ....,... .......
c0df1360:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................

c0df1370 <ux_layout_pbb_elements>:
c0df1370:	0003 0000 0000 0080 0040 0000 0001 0000     ........@.......
c0df1380:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0df1390:	0105 0002 001c 0004 0007 0000 0000 0000     ................
c0df13a0:	ffff 00ff 0000 0000 0000 0000 fc74 c0de     ............t...
c0df13b0:	0205 007a 001c 0004 0007 0000 0000 0000     ..z.............
c0df13c0:	ffff 00ff 0000 0000 0000 0000 fc94 c0de     ................
c0df13d0:	0f05 0039 000a 000e 000e 0000 0000 0000     ..9.............
c0df13e0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0df13f0:	1007 0006 0025 0074 0020 0000 0000 0000     ....%.t. .......
c0df1400:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0df1410:	1107 0006 0033 0074 0020 0000 0000 0000     ....3.t. .......
c0df1420:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................

c0df1430 <NETWORK_MAPPING>:
c0df1430:	7445 6568 6572 6d75 0000 0000 0000 0000     Ethereum........
c0df1440:	5445 2048 0000 0000 0001 0000 0000 0000     ETH ............
c0df1450:	6f52 7370 6574 006e 0000 0000 0000 0000     Ropsten.........
c0df1460:	5445 2048 0000 0000 0003 0000 0000 0000     ETH ............
c0df1470:	6952 6b6e 6265 0079 0000 0000 0000 0000     Rinkeby.........
c0df1480:	5445 2048 0000 0000 0004 0000 0000 0000     ETH ............
c0df1490:	6f47 7265 696c 0000 0000 0000 0000 0000     Goerli..........
c0df14a0:	5445 2048 0000 0000 0005 0000 0000 0000     ETH ............
c0df14b0:	704f 6974 696d 6d73 0000 0000 0000 0000     Optimism........
c0df14c0:	5445 2048 0000 0000 000a 0000 0000 0000     ETH ............
c0df14d0:	6f4b 6176 006e 0000 0000 0000 0000 0000     Kovan...........
c0df14e0:	5445 2048 0000 0000 002a 0000 0000 0000     ETH ....*.......
c0df14f0:	5342 0043 0000 0000 0000 0000 0000 0000     BSC.............
c0df1500:	4e42 2042 0000 0000 0038 0000 0000 0000     BNB ....8.......
c0df1510:	4478 6961 0000 0000 0000 0000 0000 0000     xDai............
c0df1520:	4478 4941 0020 0000 0064 0000 0000 0000     xDAI ...d.......
c0df1530:	6f50 796c 6f67 006e 0000 0000 0000 0000     Polygon.........
c0df1540:	414d 4954 2043 0000 0089 0000 0000 0000     MATIC ..........
c0df1550:	6146 746e 6d6f 0000 0000 0000 0000 0000     Fantom..........
c0df1560:	5446 204d 0000 0000 00fa 0000 0000 0000     FTM ............
c0df1570:	7241 6962 7274 6d75 0000 0000 0000 0000     Arbitrum........
c0df1580:	4541 4854 0020 0000 a4b1 0000 0000 0000     AETH ...........
c0df1590:	6543 6f6c 0000 0000 0000 0000 0000 0000     Celo............
c0df15a0:	4543 4f4c 0020 0000 a4ec 0000 0000 0000     CELO ...........
c0df15b0:	7641 6c61 6e61 6863 0065 0000 0000 0000     Avalanche.......
c0df15c0:	5641 5841 0020 0000 a86a 0000 0000 0000     AVAX ...j.......
c0df15d0:	6543 6f6c 4120 666c 6a61 726f 7365 0000     Celo Alfajores..
c0df15e0:	4361 4c45 204f 0000 aef3 0000 0000 0000     aCELO ..........
c0df15f0:	6543 6f6c 4220 6b61 616c 6176 0000 0000     Celo Baklava....
c0df1600:	4362 4c45 204f 0000 f370 0000 0000 0000     bCELO ..p.......
c0df1610:	6150 6d6c 4e20 7465 6f77 6b72 0000 0000     Palm Network....
c0df1620:	4150 4d4c 0020 0000 308d a15c 0002 0000     PALM ....0\.....
c0df1630:	7543 6562 0000 0000 0000 0000 0000 0000     Cube............
c0df1640:	5543 4542 0020 0000 071a 0000 0000 0000     CUBE ...........
c0df1650:	6853 6469 6e65 0000 0000 0000 0000 0000     Shiden..........
c0df1660:	4453 204e 0000 0000 0150 0000 0000 0000     SDN ....P.......
c0df1670:	7341 6174 0072 0000 0000 0000 0000 0000     Astar...........
c0df1680:	5341 5254 0020 0000 0250 0000 0000 0000     ASTR ...P.......

c0df1690 <NFT_ASSET_ID_PREFIX>:
c0df1690:	464e 3a54 d400 d4d4                         NFT:....

c0df1698 <_etext>:
c0df1698:	d4d4      	bmi.n	c0df1644 <NETWORK_MAPPING+0x214>
c0df169a:	d4d4      	bmi.n	c0df1646 <NETWORK_MAPPING+0x216>
c0df169c:	d4d4      	bmi.n	c0df1648 <NETWORK_MAPPING+0x218>
c0df169e:	d4d4      	bmi.n	c0df164a <NETWORK_MAPPING+0x21a>
c0df16a0:	d4d4      	bmi.n	c0df164c <NETWORK_MAPPING+0x21c>
c0df16a2:	d4d4      	bmi.n	c0df164e <NETWORK_MAPPING+0x21e>
c0df16a4:	d4d4      	bmi.n	c0df1650 <NETWORK_MAPPING+0x220>
c0df16a6:	d4d4      	bmi.n	c0df1652 <NETWORK_MAPPING+0x222>
c0df16a8:	d4d4      	bmi.n	c0df1654 <NETWORK_MAPPING+0x224>
c0df16aa:	d4d4      	bmi.n	c0df1656 <NETWORK_MAPPING+0x226>
c0df16ac:	d4d4      	bmi.n	c0df1658 <NETWORK_MAPPING+0x228>
c0df16ae:	d4d4      	bmi.n	c0df165a <NETWORK_MAPPING+0x22a>
c0df16b0:	d4d4      	bmi.n	c0df165c <NETWORK_MAPPING+0x22c>
c0df16b2:	d4d4      	bmi.n	c0df165e <NETWORK_MAPPING+0x22e>
c0df16b4:	d4d4      	bmi.n	c0df1660 <NETWORK_MAPPING+0x230>
c0df16b6:	d4d4      	bmi.n	c0df1662 <NETWORK_MAPPING+0x232>
c0df16b8:	d4d4      	bmi.n	c0df1664 <NETWORK_MAPPING+0x234>
c0df16ba:	d4d4      	bmi.n	c0df1666 <NETWORK_MAPPING+0x236>
c0df16bc:	d4d4      	bmi.n	c0df1668 <NETWORK_MAPPING+0x238>
c0df16be:	d4d4      	bmi.n	c0df166a <NETWORK_MAPPING+0x23a>
c0df16c0:	d4d4      	bmi.n	c0df166c <NETWORK_MAPPING+0x23c>
c0df16c2:	d4d4      	bmi.n	c0df166e <NETWORK_MAPPING+0x23e>
c0df16c4:	d4d4      	bmi.n	c0df1670 <NETWORK_MAPPING+0x240>
c0df16c6:	d4d4      	bmi.n	c0df1672 <NETWORK_MAPPING+0x242>
c0df16c8:	d4d4      	bmi.n	c0df1674 <NETWORK_MAPPING+0x244>
c0df16ca:	d4d4      	bmi.n	c0df1676 <NETWORK_MAPPING+0x246>
c0df16cc:	d4d4      	bmi.n	c0df1678 <NETWORK_MAPPING+0x248>
c0df16ce:	d4d4      	bmi.n	c0df167a <NETWORK_MAPPING+0x24a>
c0df16d0:	d4d4      	bmi.n	c0df167c <NETWORK_MAPPING+0x24c>
c0df16d2:	d4d4      	bmi.n	c0df167e <NETWORK_MAPPING+0x24e>
c0df16d4:	d4d4      	bmi.n	c0df1680 <NETWORK_MAPPING+0x250>
c0df16d6:	d4d4      	bmi.n	c0df1682 <NETWORK_MAPPING+0x252>
c0df16d8:	d4d4      	bmi.n	c0df1684 <NETWORK_MAPPING+0x254>
c0df16da:	d4d4      	bmi.n	c0df1686 <NETWORK_MAPPING+0x256>
c0df16dc:	d4d4      	bmi.n	c0df1688 <NETWORK_MAPPING+0x258>
c0df16de:	d4d4      	bmi.n	c0df168a <NETWORK_MAPPING+0x25a>
c0df16e0:	d4d4      	bmi.n	c0df168c <NETWORK_MAPPING+0x25c>
c0df16e2:	d4d4      	bmi.n	c0df168e <NETWORK_MAPPING+0x25e>
c0df16e4:	d4d4      	bmi.n	c0df1690 <NFT_ASSET_ID_PREFIX>
c0df16e6:	d4d4      	bmi.n	c0df1692 <NFT_ASSET_ID_PREFIX+0x2>
c0df16e8:	d4d4      	bmi.n	c0df1694 <NFT_ASSET_ID_PREFIX+0x4>
c0df16ea:	d4d4      	bmi.n	c0df1696 <NFT_ASSET_ID_PREFIX+0x6>
c0df16ec:	d4d4      	bmi.n	c0df1698 <_etext>
c0df16ee:	d4d4      	bmi.n	c0df169a <_etext+0x2>
c0df16f0:	d4d4      	bmi.n	c0df169c <_etext+0x4>
c0df16f2:	d4d4      	bmi.n	c0df169e <_etext+0x6>
c0df16f4:	d4d4      	bmi.n	c0df16a0 <_etext+0x8>
c0df16f6:	d4d4      	bmi.n	c0df16a2 <_etext+0xa>
c0df16f8:	d4d4      	bmi.n	c0df16a4 <_etext+0xc>
c0df16fa:	d4d4      	bmi.n	c0df16a6 <_etext+0xe>
c0df16fc:	d4d4      	bmi.n	c0df16a8 <_etext+0x10>
c0df16fe:	d4d4      	bmi.n	c0df16aa <_etext+0x12>

c0df1700 <N_storage_real>:
c0df1700:	0000 0000 d400 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1710:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1720:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1730:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1740:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1750:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1760:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1770:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1780:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df1790:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df17a0:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df17b0:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df17c0:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df17d0:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df17e0:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
c0df17f0:	d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4 d4d4     ................
